\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}

\pagestyle{fancy}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Learn Regex The Easy Way}
    
           \vspace{0.5cm}
           A Guide To Learning Regular Expressions
            
                
           \vspace{1.5cm}
    
           A Document By: \\
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{./figures/RegEx-Logo.png}
           \bigbreak \noindent 
            June 29, 2023 \\ 
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak \bigbreak \noindent
    \unsect{Introduction}
    Regular expressions are powerful tools for pattern matching and text manipulation. They provide a concise and flexible way to describe and search for patterns in strings.
    \bigbreak \noindent 
    A regular expression, often abbreviated as regex, is a sequence of characters that defines a search pattern. This pattern can be used to match, locate, or replace specific portions of text.
    \bigbreak \noindent 
    Regular expressions are widely used in various programming languages, text editors, and command-line tools. They are particularly useful for tasks such as data validation, parsing, and data extraction.
    \bigbreak \noindent 
    The syntax and features of regular expressions may vary slightly between different programming languages and implementations. However, the core concepts remain the same.
    \bigbreak \noindent 
    With regular expressions, you can match literal characters, define character classes to match sets of characters, specify repetition with quantifiers, and use metacharacters for more complex pattern matching. You can also use anchors to match positions within a string, escape sequences to match special characters, and grouping and capturing to extract specific parts of the matched text.
    \bigbreak \noindent 
    Regular expressions support advanced features such as alternation to match multiple alternatives, backreferences to refer to previously matched content, and lookarounds for lookahead and lookbehind assertions.
    \bigbreak \noindent 
    It is important to note that regular expressions can be quite powerful but also complex. Constructing and debugging complex regular expressions may require practice and careful consideration. It's recommended to break down complex patterns into smaller components and test them incrementally.
    \bigbreak \noindent 
    In this document, we will explore the key concepts and syntax of regular expressions, providing examples and practical tips to help you understand and effectively use regular expressions in your projects.
    \bigbreak \noindent 
    Now let's dive into the world of regular expressions and discover their immense potential for pattern matching and text manipulation.

    \pagebreak \bigbreak \noindent
    \unsect{Literal Characters}
    In regular expressions, literal characters are the simplest form of pattern matching. They represent exact characters that you want to match in the target string.
    \bigbreak \noindent 
    For example, the regular expression `cat` will match the exact sequence of characters "cat" in a string. The letters 'c', 'a', and 't' are treated as literal characters and must appear in that exact order for a match to occur.
    \bigbreak \noindent 
    It's important to note that literal characters are case-sensitive by default. So, the regular expression `cat` will not match the string "Cat" or "CAT", but it will match "cat" exactly.
    \bigbreak \noindent 
    If you need case-insensitive matching, you can specify a modifier flag. In many programming languages, the `i` flag is commonly used to enable case-insensitive matching. For example, the regular expression `/cat/i` would match "cat", "Cat", "CAT", or any other combination of upper and lowercase letters.
    \bigbreak \noindent 
    Literal characters can include alphabetic letters, digits, and various special characters. However, some characters have special meanings in regular expressions, such as metacharacters. To match these special characters as literal characters, you need to escape them using a backslash (\textbackslash).
    \bigbreak \noindent 
    For instance, to match a literal dot (.), you would use the regular expression \textbackslash. The backslash escapes the special meaning of the dot and treats it as a literal character.
    \bigbreak \noindent 
    In summary, literal characters in regular expressions match the exact sequence of characters you specify. They provide a simple and straightforward way to search for specific strings or patterns in your target text.

    \pagebreak
    \bigbreak
    \noindent

    \unsect{Metacharacters}
    Metacharacters in regular expressions are special characters that have predefined meanings and provide powerful pattern matching capabilities. They allow you to express more complex search patterns beyond literal characters.
    \bigbreak \noindent 
    Metacharacters can be combined and used in various combinations to create more complex patterns. It's important to note that some metacharacters may have different meanings or require escaping depending on the programming language or regex engine you are using.
    \bigbreak \noindent 
    Understanding and properly utilizing metacharacters can greatly enhance the power and flexibility of your regular expressions, enabling you to match and manipulate patterns in your target text more effectively.
    \bigbreak \noindent 
    \subsection{Single Characters}
    \bigbreak \noindent 
    Here are the commonly used single character metacharacters:
    \begin{itemize}
        \item \textbf{. (Dot)}: Matches any character except a newline. It can be used to represent any character in a pattern.
        \item \textbackslash{\textbf{w}} Match any single alphanumeric character: 0-9, a-z, A-Z, and \_ (underscore).
        \item \textbackslash{\textbf{d}} To match any single digit.
        \item \textbackslash{\textbf{s}} Match any single whitespace character.
    \end{itemize}
    \bigbreak \noindent 
    \nt{The uppercase version performs the opposite action compared to its lowercase counterpart}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{\textbackslash t} Matches a tab character
        \item \textbf{\textbackslash n} Matches a newline character
        \item \textbf{\textbackslash r} Matches a carriage return character
    \end{itemize}
    \bigbreak \noindent 
    These are just a few examples of the most common escape sequences in regex. There are additional escape sequences available to represent other special characters or character classes. Using escape sequences, you can match specific characters or character patterns in your regular expressions.

    \pagebreak \bigbreak \noindent
    \subsection{Quantifiers}
    Here are the commonly used quantifiers:
    \begin{itemize}
        \item \textbf{* (Asterisk)}: Matches zero or more occurrences of the preceding element. For example, the pattern `ab*` would match "a", "ab", "abb", "abbb", and so on.
        \item \textbf{+ (Plus)}: Matches one or more occurrences of the preceding element. The pattern `ab+` would match "ab", "abb", "abbb", and so on, but not "a".
        \item \textbf{? (Question Mark)}: Matches zero or one occurrence of the preceding element. For example, the pattern `ab$?$` would match "a" or "ab".
        \item \textbf{| (Pipe)}: Acts as an OR operator and matches either the pattern on the left or the pattern on the right. For instance, the pattern `a|b` would match either "a" or "b".
        \item \textbf{() (Parentheses)}: Creates a group that allows you to apply quantifiers and modifiers to multiple characters. It also enables capturing of matched content for later use.
        \item \textbf{[] (Square Brackets)}: Defines a character class, allowing you to specify a set of characters to match. For example, the pattern `[abc]` would match either "a", "b", or "c".
        \item \textbf{\textbackslash (Backslash)}: Escapes special characters, allowing you to match them as literal characters. For instance, to match a literal asterisk, you would use `\*`.
        \item \textbf{\{ n \}}: (Matches exactly n times)
        \item \textbf{\{ n ,\}}: (Matches at least n times)
        \item \textbf{\{ n , m\}}: (Matches from n to m times)
    \end{itemize}

    \pagebreak \bigbreak \noindent
    \subsection{Anchors (Position)}
    \bigbreak \noindent 
    Here are the commonly used position metacharacters:
    \begin{itemize}
        \item \textbf{\textsuperscript{$\wedge$}:} Beginning (Goes in the beginning of the expression)
        \item \textbf{\$:} End (Goes at the end of the expression)
        \item \textbf{\textbackslash b:} Word boundry
        \item \textbf{\textbackslash B:} Non-Word boundry
    \end{itemize}
    \bigbreak \noindent 
    Word Boundry Example:
    \bigbreak \noindent 
    Let's say we want to find all occurrences of the word "apple" in a given text, but we only want to match it as a whole word and not as part of another word. We can use the word boundary \textbackslash b to achieve this.
    \begin{center}
        \textbackslash bapple\textbackslash b
    \end{center}

    \bigbreak \noindent 
    Non-Word Boundry Example:
    \bigbreak \noindent 
    Let's say we want to find all occurrences of the word "apple" in a given text, but we only want to match it as a non whole word and find where it appears in other words, for example the word \textbf{pineapple}. We can use the non-word boundary \textbackslash b to achieve this.
    \begin{center}
        \textbackslash Bapple\textbackslash B
    \end{center}

    

    \pagebreak
    \bigbreak
    \noindent

    \unsect{Character Classes}
    Character classes in regular expressions allow you to specify a set of characters to match at a particular position in the target string. They provide a convenient way to define patterns for matching specific types of characters.
    \bigbreak \noindent 
    To define a character class, you enclose the desired characters within square brackets \([ ]\). The character class will match any single character that matches one of the characters within the brackets.
    \bigbreak \noindent 
    Here are some examples of character classes:
    \begin{itemize}
        \item \textbf{[abc]}: Matches either 'a', 'b', or 'c'. It will match any one of these characters at the specified position.
        \item \textbf{[0-9]}: Matches any digit from 0 to 9. It will match any single digit character.
        \item \textbf{[a-z]}: Matches any lowercase letter from 'a' to 'z'. It will match any single lowercase letter.
        \item \textbf{[A-Z]}: Matches any uppercase letter from 'A' to 'Z'. It will match any single uppercase letter.
        \item \textbf{[0-9a-f]}: Matches any hexadecimal digit. It will match any single digit from 0 to 9 or any lowercase letter from 'a' to 'f'.
        \item \textbf{[\textsuperscript{$\wedge$}0-9]}: The caret symbol (\textsuperscript{$\wedge$}) at the beginning of the character class negates the match. It matches any character that is not a digit. In this example, it will match any non-digit character.
    \end{itemize}
    Character classes can also include special character ranges, such as `\textbackslash w` for word characters (letters, digits, and underscore) or `\textbackslash s` for whitespace characters (spaces, tabs, newlines, etc.). These shorthand character classes provide a convenient way to match commonly used character sets.
    \bigbreak \noindent 
    You can use metacharacters within character classes as well, but they may have different meanings. For example, the hyphen (-) has a special meaning within a character class as a range indicator. To match a literal hyphen, you can either escape it with a backslash (\textbackslash -) or place it as the first or last character within the brackets.
    \bigbreak \noindent 
    Character classes provide a flexible way to define patterns for matching specific types of characters in your target text. By combining character classes with other regular expression constructs, you can create powerful and precise matching patterns.

    \pagebreak
    \bigbreak
    \noindent


    \unsect{Escaping}
    \bigbreak \noindent 
    In regular expressions (regex), escape sequences are used to represent special characters or sequences of characters that have a predefined meaning. They allow you to match characters that would otherwise be interpreted as special regex syntax. Escape sequences in regex are represented by a backslash (\) followed by a specific character. 
    \bigbreak \noindent 
    Here are some common escape sequences in regex:
    \begin{itemize}
        \item \textbackslash . The backslash followed by a period (\textbackslash .) matches a literal period character. The period character has a special meaning in regex, as it matches any character except a newline. By using the escape sequence \textbackslash . you can match a literal period.
        \item \textbackslash \textbackslash \  The backslash followed by another backslash (\textbackslash \textbackslash) matches a literal backslash character. Since the backslash is used as the escape character in regex, you need to escape it with another backslash to match a literal backslash.
    \end{itemize}
    \pagebreak
    \bigbreak
    \noindent

    \unsect{Grouping and Capturing}
    \bigbreak \noindent 
    As seen briefly in the quantifiers section, Grouping and capturing are features in regular expressions that allow you to group parts of a pattern together and capture the matched content for later use.
    \bigbreak \noindent 
    \textbf{Grouping:}
    \begin{itemize}
        \item Grouping is denoted by placing the desired pattern inside parentheses ( ). It allows you to create subexpressions within a larger regex pattern.
        \item By grouping parts of a pattern, you can apply quantifiers or modifiers to the entire group, treating it as a single unit.
        \item Grouping is useful for establishing precedence, defining alternations, or applying repetition to specific sections of a pattern.
    \end{itemize}
    \bigbreak \noindent 
    For example, the regex (ab)+ matches one or more occurrences of the sequence "ab". The parentheses group the characters "ab" together, and the + quantifier applies to the entire group.

    \bigbreak \noindent 
    \textbf{Capturing}
    \begin{itemize}
        \item Capturing is the process of extracting the matched content of a specific group within a regex pattern.
        \item When a pattern contains capturing groups, the substrings that match those groups are saved in memory for later use.
        \item Each capturing group is assigned a number, starting from 1, based on the order of the opening parentheses from left to right.
    \end{itemize}
    \bigbreak \noindent 
    For example, consider the regex pattern \texttt{(ab)+(\textbackslash d+)}. It contains two capturing groups: \texttt{(ab)} and \texttt{(\textbackslash d+)}. If the input string is "abab123", the first capturing group captures "ab" and the second capturing group captures "123".
    \bigbreak \noindent 
    Captured content can be referenced in a variety of ways, such as:
    \begin{itemize}
        \item By using backreferences like \texttt{\textbackslash 1}, \texttt{\textbackslash 2}, etc., to refer to the captured content later within the same regex pattern.
        \item By using programming language-specific methods or functions to access the captured content programmatically.
    \end{itemize}
    \bigbreak \noindent 
    \nt{Grouping and capturing are powerful features in regular expressions that allow you to create more complex patterns and extract specific parts of matched content for further processing or analysis.}


    \pagebreak
    \bigbreak
    \noindent

    \unsect{Alternation}
    In regular expressions (regex), alternation allows you to specify multiple alternatives for matching. It allows you to create a pattern that matches one of several choices. Alternation is denoted by the pipe character (|), which acts as a logical OR operator within the regex pattern.
    \bigbreak \noindent 
    Here's how alternation works in regex:
    \bigbreak \noindent 
    \textbf{Basic Alternation:}
    \begin{itemize}
        \item The basic syntax for alternation is choice1|choice2, where choice1 and choice2 represent the alternative patterns you want to match.
        \item When the regex engine encounters the alternation, it tries to match the pattern on the left side of the | first. If it doesn't match, it tries to match the pattern on the right side.
        \item The alternation continues until a match is found or all alternatives have been exhausted.
    \end{itemize}
    \bigbreak \noindent 
    For example, the regex \textbf{apple\texttt{|}banana} matches either the word \textbf{"apple"} or the word \textbf{"banana".} If the input string is "I like bananas", it would match the word "banana".

    \bigbreak \noindent 
    \textbf{Grouping Alternatives:}
    \begin{itemize}
        \item You can use parentheses to group alternatives together and create more complex alternation patterns.
        \item For example, the regex (apple|banana)( pie)? matches either "apple" or "banana" followed by an optional " pie" string. It would match "apple", "apple pie", "banana", or "banana pie".
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Additional Alternation:}
    \begin{itemize}
        \item Alternation can be combined with other regex constructs, such as character classes, quantifiers, or capturing groups.
        \item For example, the regex (apple|banana)[s|es] matches either "apple" or "banana" followed by an "s" or "es". It would match "apples", "bananas", "apple", or "banana".
    \end{itemize}
    \bigbreak \noindent 
    \nt{Alternation is a useful feature in regex when you want to match different options or choices within a pattern. It allows you to specify multiple alternatives and flexibly match different variations of input.}


    \pagebreak
    \bigbreak
    \noindent

    \unsect{Backreferences}
    n regular expressions (regex), backreferences are a feature that allows you to refer to previously matched content within the same pattern. They are used to match repeated or duplicated patterns. Backreferences are denoted by the backslash followed by a number (\textbackslash 1, \textbackslash 2, etc.) corresponding to the capturing group you want to reference.
    \bigbreak \noindent 
    Here's how backreferences work in regex:

    \bigbreak \noindent 
    \textbf{Capturing Groups:}
    \begin{itemize}
        \item First, you need to create capturing groups by enclosing a pattern in parentheses.
        \item When a regex pattern contains capturing groups, the substrings that match those groups are saved in memory for later use.
        \item Each capturing group is assigned a number, starting from 1, based on the order of the opening parentheses from left to right.
    \end{itemize}
    \textbf{Backreferencing}:
    \begin{itemize}
        \item Once you have capturing groups, you can use backreferences to refer to the matched content of those groups later in the pattern.
        \item The backreference \textbackslash 1 refers to the content matched by the first capturing group, \textbackslash 2 refers to the content matched by the second capturing group, and so on.
    \end{itemize}
    For example, consider the regex pattern (ab)+\textbackslash 1. It contains a capturing group (ab) followed by the backreference \textbackslash 1. This pattern matches repetitions of the sequence "ab". The backreference \textbackslash 1 ensures that the repeated sequence matches the exact content captured by the first group.

    \bigbreak \noindent 
    \nt{Backreferences are specific to the current pattern and \textbf{cannot} reference content captured in previous or subsequent patterns.}
    \bigbreak \noindent 

    \bigbreak \noindent 
    \textbf{Backreferencing Example (neovim)}
    \bigbreak \noindent 
    To swap the order of \textit{firstname, lastname}, we can do something like:
    \begin{center}
        :\%s/\textbackslash(\textbackslash w\textbackslash +\textbackslash ), \textbackslash(\textbackslash w\textbackslash +\textbackslash )/\textbackslash 2, \textbackslash 1/g
    \end{center}
    Which will turn:
    \begin{center}
        nate, warner
    \end{center}
    Into:
    \begin{center}
        warner, nate
    \end{center}



    \pagebreak
    \bigbreak
    \noindent

    \unsect{Lookarounds (Generic)}
    \bigbreak \noindent 
    Lookarounds are a powerful feature in regular expressions (regex) that allow you to define conditions around a pattern without including the condition itself in the match. Lookarounds assert whether a certain pattern is present or absent at a particular position in the input string, without actually including that pattern in the match. There are two types of lookarounds: positive lookaheads and negative lookaheads, as well as positive lookbehinds and negative lookbehinds. Let's explore each of them:
    \bigbreak \noindent 
    \textbf{Positive Lookahead (?=):}
    \begin{itemize}
        \item Positive lookaheads are denoted by (?=...).
        \item They assert that the pattern inside the lookahead must be present immediately ahead of the current position in the input string, but it is not included in the match.
        \item For example, the regex pattern foo(?=bar) matches the substring "foo" only if it is followed by the substring "bar".
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Negative Lookahead (?!)}:

    \begin{itemize}
        \item Negative lookaheads are denoted by (?!...).
        \item They assert that the pattern inside the lookahead must not be present immediately ahead of the current position in the input string.
        \item For example, the regex pattern foo(?!bar) matches the substring "foo" only if it is not followed by the substring "bar".
    \end{itemize}

    \bigbreak \noindent     
    \textbf{Positive Lookbehind (?<=)}:
    \begin{itemize}
        \item Positive lookbehinds are denoted by (?<=...).
        \item They assert that the pattern inside the lookbehind must be present immediately before the current position in the input string, but it is not included in the match.
        \item Positive lookbehinds are only supported in some regex engines, and the length of the lookbehind must be fixed (no variable length).
        \item For example, the regex pattern (?<=foo)bar matches the substring "bar" only if it is preceded by the substring "foo".
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Negative Lookbehind (?<!)}:
    \begin{itemize}
        \item Negative lookbehinds are denoted by (?<!...).
        \item They assert that the pattern inside the lookbehind must not be present immediately before the current position in the input string.
        \item Negative lookbehinds are only supported in some regex engines, and the length of the lookbehind must be fixed (no variable length).
        \item For example, the regex pattern (?<!foo)bar matches the substring "bar" only if it is not preceded by the substring "foo".
    \end{itemize}

    \bigbreak \noindent 
    \nt{Above is the syntax that is used by the python module \textit{re} \\ It's important to note that the availability and syntax of lookarounds may vary between different regex engines.}

    \pagebreak \bigbreak \noindent
    \unsect{Neovim lookarounds}
    \bigbreak \noindent 
    The syntax for lookarounds in the neovim regex engine is a bit different so let's take a look at them as well.
    \bigbreak \noindent 
    In Neovim regex, lookarounds are denoted by specific symbols (\textbackslash ze, \textbackslash @!, \textbackslash @<=, \textbackslash @<!) placed at specific positions within the regex pattern. They allow you to define conditions around a pattern without including the condition itself in the match.  

    \bigbreak \noindent 
    \textbf{Positive Lookahead}:
    \begin{itemize}
        \item \textbf{Syntax:} \textit{capture}\textbackslash ze\textit{stipulation}
        \item \textbf{Example:} /foo\textbackslash ze bar will match "foo" but only if it comes before the word "bar"
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Negative Lookahead}:
    \begin{itemize}
        \item \textbf{Syntax:} \textit{\textbackslash(capture\textbackslash )}\textbackslash(stipulation\textbackslash)\textbackslash @!
        \item \textbf{Example:} /foo\textbackslash(bar\textbackslash)\textbackslash @! will match "foo" but only if the word "bar" does not come after it
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Positive Lookbehind}:
    \begin{itemize}
        \item \textbf{Syntax:} \textbackslash(\textit{stipulation}\textbackslash)\textbackslash @<=\textbackslash(\textit{capture}\textbackslash)
        \item \textbf{Example:} /\textbackslash(bar\textbackslash)\textbackslash @<=foo will match "foo" but only if the word "bar" comes before it
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Negative Lookbehind}:
    \begin{itemize}
        \item \textbf{Syntax}: \textbackslash(\textbackslash @<!lookbehind-pattern\textbackslash)pattern
        \item \textbackslash @<! is placed before the initial pattern and indicates that the lookbehind-pattern should not be present immediately before the current position.
        \item lookbehind-pattern is the pattern that should not be present for a match to occur.
        \item The content matched by pattern is included in the match result.
        \item \textbf{Syntax:} \textbackslash(\textit{stipulation}\textbackslash)\textbackslash @<!\textbackslash(\textit{capture}\textbackslash)
        \item \textbf{Example:} /\textbackslash(bar\textbackslash)\textbackslash @<!foo will match foo but only if the word "bar" does not come before it
    \end{itemize}




    \pagebreak
    \bigbreak
    \noindent

    \unsect{Greedy and Lazy Matching}
    Greedy and lazy matching refer to the behavior of quantifiers in regular expressions.
    \bigbreak \noindent 
    By default, quantifiers in regular expressions are greedy, meaning they match as much as possible while still allowing the overall pattern to match. This behavior is often intuitive because it tries to find the longest possible match.
    \bigbreak \noindent 
    For example, consider the regular expression pattern a.*b applied to the input string abcabcab. The .* quantifier means "match any character (except newline) zero or more times." In a greedy match, it will match as much as possible, resulting in the longest match: abcabcab.
    \bigbreak \noindent 
    However, there are cases where you might want to perform a more conservative or minimal match, where the quantifier matches as little as possible. This is known as lazy or non-greedy matching.
    \bigbreak \noindent 
    To perform a lazy match, you can use the ? modifier after a greedy quantifier. It instructs the quantifier to match as little as possible while still allowing the overall pattern to match.
    \bigbreak \noindent 
    For example, if we modify the previous pattern to a.*?b and apply it to the same input string, the .*? quantifier will match as few characters as possible before encountering the subsequent b. It will result in the shortest match: ab.
    \bigbreak \noindent 
    Lazy matching is useful in scenarios where you want to capture the smallest possible substring that satisfies the pattern.
    \bigbreak \noindent 
    \nt{It's important to note that lazy matching applies to quantifiers such as *, +, ?, and {}. Without the ? modifier, these quantifiers are greedy by default. }
    \bigbreak \noindent 
    \subsection{Lazy matching in neovim}
    \bigbreak \noindent 
    In Neovim (and Vim) regex, lazy quantifiers like .*? in PCRE — are written differently because Vim’s regex engine is not Perl-compatible.
    \bigbreak \noindent 
    In Vim/Neovim, the lazy quantifiers have their own symbol / notation, which are summarized in the following table
    \bigbreak \noindent 
    \begin{center}
        \begin{tabular}{p{4cm}|p{4cm}}
            Greedy	&Lazy \\
            \hline \\[0.01cm]
            *&	\textbackslash \{-\} [2ex] \\[2ex]
            \textbackslashh +	&\textbackslash \{-1,\} \\[2ex]
            \textbackslash\{n,m\}	&\textbackslash \{n,m\}- 
        \end{tabular}
    \end{center}

    \unsect{Flags}
    \bigbreak \noindent 
    In regular expressions (regex),flags are used to modify the behavior of the pattern matching. They are typically specified as options or additional characters added to the regex pattern itself. Here's an explanation of flags:

    \bigbreak \noindent 
    \textbf{Commonly Used Flags}
    \begin{itemize}
        \item g: Global matching. Finds all matches in the input string, rather than stopping after the first match.
        \item i: Case-insensitive matching. The pattern matches regardless of letter case.
        \item m: Multiline mode. Allows the \textsuperscript{$\wedge$} and \$ anchors to match the start and end of each line within a multiline input string.
        \item s: Single-line mode. The dot (.) matches any character, including newline characters.
        \item x: Verbose mode. Allows the use of whitespace and comments within the pattern for improved readability.
    \end{itemize}

    \bigbreak \noindent 
    
    \nt{Neovim has an additional flag \textit{/c}, which stands for \textit{confirm} and has you enter Y/N for each search and replace match}

    \pagebreak \bigbreak \noindent
    \unsect{Bonus: Neovim Multiline Support}
    \bigbreak \noindent 
    Consider the scenario:
    \begin{minted}{python}
1 foomane
2 barmane
    \end{minted}
    \bigbreak \noindent 
    And I want to swap the order. That is, "barmane" on line 1, and "foomane" on line 2. Our pattern would look something like:
    \begin{minted}{python}
    %s/foomane\s*\n\s*barmane
    \end{minted}
    \bigbreak \noindent 
    Which would produce:
    \begin{minted}{python}
1 barmane
2 foomane
    \end{minted}
    So you can infer that the syntax to start matching on the next line is:
    \begin{minted}{python}
    pattern\s*\n\s*pattern
    \end{minted}
    And the syntax for adding newlines while replacing is:
    \begin{minted}{python}
\r
    \end{minted}




    
\end{document}
