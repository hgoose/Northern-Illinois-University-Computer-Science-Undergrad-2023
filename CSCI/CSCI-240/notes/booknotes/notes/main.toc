\contentsline {section}{\numberline {1}The C++ Language}{13}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Key Features}{13}{subsection.0.1.1}%
\contentsline {section}{\numberline {2}The Compiler}{15}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Preprocessing}{15}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Lexical Analysis}{15}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Syntax Analysis}{15}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Semantic Analysis}{15}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Intermediate Code Generation}{15}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Code Optimization}{16}{subsection.0.2.6}%
\contentsline {subsection}{\numberline {2.7}Code Generation}{16}{subsection.0.2.7}%
\contentsline {subsection}{\numberline {2.8}Assembling}{16}{subsection.0.2.8}%
\contentsline {subsection}{\numberline {2.9}Linking}{16}{subsection.0.2.9}%
\contentsline {subsection}{\numberline {2.10}Complier Options}{16}{subsection.0.2.10}%
\contentsline {subsection}{\numberline {2.11}Header Files}{17}{subsection.0.2.11}%
\contentsline {section}{\numberline {3}Preliminaries: A Quick Tour of C++ Fundamentals}{18}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Boilerplate}{18}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}The main function}{18}{subsection.0.3.2}%
\contentsline {subsection}{\numberline {3.3}Comments}{19}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Data Types, Modifiers, Qualifiers, Inference}{20}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}Creating strings without the STL}{22}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}Retrieve size}{23}{subsection.0.3.6}%
\contentsline {subsection}{\numberline {3.7}Retrieve type}{23}{subsection.0.3.7}%
\contentsline {subsection}{\numberline {3.8}Exponential Notation}{24}{subsection.0.3.8}%
\contentsline {subsection}{\numberline {3.9}Type Conversion}{24}{subsection.0.3.9}%
\contentsline {subsection}{\numberline {3.10}Integer Division}{25}{subsection.0.3.10}%
\contentsline {subsection}{\numberline {3.11}Overflow/Underflow}{25}{subsection.0.3.11}%
\contentsline {subsection}{\numberline {3.12}Type Casting}{25}{subsection.0.3.12}%
\contentsline {subsection}{\numberline {3.13}C-style Casts}{26}{subsection.0.3.13}%
\contentsline {subsection}{\numberline {3.14}The Using Directive}{27}{subsection.0.3.14}%
\contentsline {subsection}{\numberline {3.15}Variable Declaration}{28}{subsection.0.3.15}%
\contentsline {subsection}{\numberline {3.16}Multiple Declaration}{28}{subsection.0.3.16}%
\contentsline {subsection}{\numberline {3.17}Initialization}{28}{subsection.0.3.17}%
\contentsline {subsection}{\numberline {3.18}Multiple Initialization}{28}{subsection.0.3.18}%
\contentsline {subsection}{\numberline {3.19}Direct Initialization}{29}{subsection.0.3.19}%
\contentsline {subsection}{\numberline {3.20}List Initialization}{29}{subsection.0.3.20}%
\contentsline {subsection}{\numberline {3.21}Copy Initialization}{29}{subsection.0.3.21}%
\contentsline {subsection}{\numberline {3.22}Assignment}{29}{subsection.0.3.22}%
\contentsline {subsection}{\numberline {3.23}Multiple Assignment}{30}{subsection.0.3.23}%
\contentsline {section}{\numberline {4}Symbols}{31}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Parentheses}{31}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Brackets}{31}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Braces}{31}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Angle Brackets}{31}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Semi Colon}{31}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Colon}{31}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}Comma}{32}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}Ellipsis}{32}{subsection.0.4.8}%
\contentsline {subsection}{\numberline {4.9}Hash}{32}{subsection.0.4.9}%
\contentsline {section}{\numberline {5}Preprocessor Directives}{33}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}\#include}{33}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}\#define}{33}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}\#undef}{33}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}\#ifdef, \#ifndef, \#else, \#elif, \#endif}{33}{subsection.0.5.4}%
\contentsline {subsection}{\numberline {5.5}\#if}{34}{subsection.0.5.5}%
\contentsline {subsection}{\numberline {5.6}\#pragma}{34}{subsection.0.5.6}%
\contentsline {subsection}{\numberline {5.7}\#error}{34}{subsection.0.5.7}%
\contentsline {subsection}{\numberline {5.8}\#line}{34}{subsection.0.5.8}%
\contentsline {section}{\numberline {6}Input/Output}{35}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}iostream}{35}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Output}{35}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Input}{35}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}IO Manipulators}{37}{subsection.0.6.4}%
\contentsline {subsection}{\numberline {6.5}std::setiosflags}{39}{subsection.0.6.5}%
\contentsline {subsection}{\numberline {6.6}Escape Sequences}{39}{subsection.0.6.6}%
\contentsline {subsection}{\numberline {6.7}User Input With Strings}{40}{subsection.0.6.7}%
\contentsline {subsection}{\numberline {6.8}User input with characters}{41}{subsection.0.6.8}%
\contentsline {subsection}{\numberline {6.9}Mixing cin and cin.get}{41}{subsection.0.6.9}%
\contentsline {section}{\numberline {7}Operators}{42}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Arithmetic Operators}{42}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Relational Operators}{42}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}Logical Operators}{42}{subsection.0.7.3}%
\contentsline {subsection}{\numberline {7.4}Bitwise Operators}{42}{subsection.0.7.4}%
\contentsline {subsection}{\numberline {7.5}Assignment Operators}{42}{subsection.0.7.5}%
\contentsline {subsection}{\numberline {7.6}Increment and Decrement Operators}{42}{subsection.0.7.6}%
\contentsline {subsection}{\numberline {7.7}Pointers and References}{42}{subsection.0.7.7}%
\contentsline {subsection}{\numberline {7.8}Scope Resolution Operator}{42}{subsection.0.7.8}%
\contentsline {section}{\numberline {8}Random Numbers}{44}{section.0.8}%
\contentsline {section}{\numberline {9}Conditionals (Decision Structure)}{45}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Decision Structure Flowchart}{46}{subsection.0.9.1}%
\contentsline {subsection}{\numberline {9.2}The Conditional Operator (Ternary)}{46}{subsection.0.9.2}%
\contentsline {subsection}{\numberline {9.3}Switch}{47}{subsection.0.9.3}%
\contentsline {section}{\numberline {10}The While Loop}{48}{section.0.10}%
\contentsline {section}{\numberline {11}The Do-While Loop}{49}{section.0.11}%
\contentsline {section}{\numberline {12}The for loop}{50}{section.0.12}%
\contentsline {section}{\numberline {13}Using Files for Data Storage}{51}{section.0.13}%
\contentsline {subsection}{\numberline {13.1}File Access Methods}{51}{subsection.0.13.1}%
\contentsline {subsection}{\numberline {13.2}Setting up a program for file input/output}{51}{subsection.0.13.2}%
\contentsline {subsection}{\numberline {13.3}File Stream Objects}{51}{subsection.0.13.3}%
\contentsline {subsection}{\numberline {13.4}Creating a file object and opening a file}{52}{subsection.0.13.4}%
\contentsline {subsection}{\numberline {13.5}Closing a file}{53}{subsection.0.13.5}%
\contentsline {subsection}{\numberline {13.6}Reading from a file with an unknown number of lines}{54}{subsection.0.13.6}%
\contentsline {subsection}{\numberline {13.7}Testing for file open errors}{54}{subsection.0.13.7}%
\contentsline {section}{\numberline {14}rvalues and lvalues}{55}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}rvalue (right value):}{55}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}lvalue}{55}{subsection.0.14.2}%
\contentsline {section}{\numberline {15}Breaking and Continuing a loop}{56}{section.0.15}%
\contentsline {section}{\numberline {16}Functions}{57}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Function prototypes (function declarations)}{57}{subsection.0.16.1}%
\contentsline {subsection}{\numberline {16.2}Static locals}{58}{subsection.0.16.2}%
\contentsline {subsection}{\numberline {16.3}PREREQ - Reference variables}{58}{subsection.0.16.3}%
\contentsline {subsection}{\numberline {16.4}Using reference variables as parameters}{59}{subsection.0.16.4}%
\contentsline {subsection}{\numberline {16.5}Overloading Functions}{60}{subsection.0.16.5}%
\contentsline {subsection}{\numberline {16.6}The exit() function}{60}{subsection.0.16.6}%
\contentsline {subsection}{\numberline {16.7}Stubs and Drivers}{61}{subsection.0.16.7}%
\contentsline {section}{\numberline {17}Arrays and Vectors}{62}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Arrays}{62}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Partial array initialization}{62}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}Implicit array sizing}{62}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}Bound violation}{62}{subsection.0.17.4}%
\contentsline {subsection}{\numberline {17.5}The range based for loop}{63}{subsection.0.17.5}%
\contentsline {subsection}{\numberline {17.6}Modifying an array with a range-based for loop}{63}{subsection.0.17.6}%
\contentsline {subsection}{\numberline {17.7}Thou shall not assign}{63}{subsection.0.17.7}%
\contentsline {subsection}{\numberline {17.8}Getting the size of an array}{64}{subsection.0.17.8}%
\contentsline {subsection}{\numberline {17.9}Arrays as function arguments}{64}{subsection.0.17.9}%
\contentsline {subsection}{\numberline {17.10}2D array (matrix)}{66}{subsection.0.17.10}%
\contentsline {subsection}{\numberline {17.11}Passing a matrix to a function}{67}{subsection.0.17.11}%
\contentsline {subsection}{\numberline {17.12}The STL Vector}{68}{subsection.0.17.12}%
\contentsline {subsection}{\numberline {17.13}Defining a vector}{68}{subsection.0.17.13}%
\contentsline {subsection}{\numberline {17.14}Get index position of elements}{68}{subsection.0.17.14}%
\contentsline {subsection}{\numberline {17.15}Adding to a vector}{69}{subsection.0.17.15}%
\contentsline {subsection}{\numberline {17.16}Getting the size of a vector}{69}{subsection.0.17.16}%
\contentsline {subsection}{\numberline {17.17}Removing last element of a vector}{69}{subsection.0.17.17}%
\contentsline {subsection}{\numberline {17.18}Removing elements of a vector }{69}{subsection.0.17.18}%
\contentsline {subsection}{\numberline {17.19}Clearing a vector}{70}{subsection.0.17.19}%
\contentsline {subsection}{\numberline {17.20}Detecting an Empty vector}{70}{subsection.0.17.20}%
\contentsline {subsection}{\numberline {17.21}Resizing a vector}{70}{subsection.0.17.21}%
\contentsline {subsection}{\numberline {17.22}Swapping Vectors}{70}{subsection.0.17.22}%
\contentsline {section}{\numberline {18}Searching and Sorting Arrays}{71}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}The linear search}{71}{subsection.0.18.1}%
\contentsline {subsection}{\numberline {18.2}The binary search}{72}{subsection.0.18.2}%
\contentsline {subsection}{\numberline {18.3}Bubble Sort}{73}{subsection.0.18.3}%
\contentsline {subsection}{\numberline {18.4}Selection Sort}{73}{subsection.0.18.4}%
\contentsline {section}{\numberline {19}Pointers}{76}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}Nullptr}{76}{subsection.0.19.1}%
\contentsline {subsection}{\numberline {19.2}Arrays as pointers}{77}{subsection.0.19.2}%
\contentsline {subsection}{\numberline {19.3}Pointers as Function Parameters}{78}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}Pointers to constants}{78}{subsection.0.19.4}%
\contentsline {subsection}{\numberline {19.5}Constant Pointers}{79}{subsection.0.19.5}%
\contentsline {subsection}{\numberline {19.6}Both pointer to constant and constant pointer}{79}{subsection.0.19.6}%
\contentsline {subsection}{\numberline {19.7}Prereq - Static vs Dynamic memory allocation}{79}{subsection.0.19.7}%
\contentsline {subsection}{\numberline {19.8}Dynamic Memory Allocation}{80}{subsection.0.19.8}%
\contentsline {subsection}{\numberline {19.9}When to use DMA}{81}{subsection.0.19.9}%
\contentsline {subsection}{\numberline {19.10}Returning pointers from a function}{81}{subsection.0.19.10}%
\contentsline {subsection}{\numberline {19.11}Smart Pointers}{82}{subsection.0.19.11}%
\contentsline {section}{\numberline {20}Characters, C-Strings and more about the string class}{84}{section.0.20}%
\contentsline {subsection}{\numberline {20.1}Character Testing}{84}{subsection.0.20.1}%
\contentsline {subsection}{\numberline {20.2}Character case conversion}{84}{subsection.0.20.2}%
\contentsline {subsection}{\numberline {20.3}C Strings }{84}{subsection.0.20.3}%
\contentsline {subsection}{\numberline {20.4}C-Strings stored in arrays}{85}{subsection.0.20.4}%
\contentsline {subsection}{\numberline {20.5}The Strlen function}{85}{subsection.0.20.5}%
\contentsline {subsection}{\numberline {20.6}The strcat Function}{86}{subsection.0.20.6}%
\contentsline {subsection}{\numberline {20.7}The Strcopy function}{86}{subsection.0.20.7}%
\contentsline {subsection}{\numberline {20.8}The strncat and strncpy functions}{87}{subsection.0.20.8}%
\contentsline {subsection}{\numberline {20.9}The strstr function}{87}{subsection.0.20.9}%
\contentsline {subsection}{\numberline {20.10}The strcmp function}{88}{subsection.0.20.10}%
\contentsline {subsection}{\numberline {20.11}String/Numeric Conversion Functions}{88}{subsection.0.20.11}%
\contentsline {subsection}{\numberline {20.12}More on the C++ string (string object)}{90}{subsection.0.20.12}%
\contentsline {subsection}{\numberline {20.13}C++ String definitions}{90}{subsection.0.20.13}%
\contentsline {subsection}{\numberline {20.14}C++ string supported operators}{90}{subsection.0.20.14}%
\contentsline {section}{\numberline {21}Structures}{91}{section.0.21}%
\contentsline {subsection}{\numberline {21.1}Abstraction}{91}{subsection.0.21.1}%
\contentsline {subsection}{\numberline {21.2}Abstract data types}{91}{subsection.0.21.2}%
\contentsline {subsection}{\numberline {21.3}Structures}{91}{subsection.0.21.3}%
\contentsline {subsection}{\numberline {21.4}Accessing structure members}{92}{subsection.0.21.4}%
\contentsline {subsection}{\numberline {21.5}Initializing a structure (Initialization list)}{92}{subsection.0.21.5}%
\contentsline {subsection}{\numberline {21.6}Arrays of structures}{93}{subsection.0.21.6}%
\contentsline {subsection}{\numberline {21.7}Initializing a structure array}{93}{subsection.0.21.7}%
\contentsline {subsection}{\numberline {21.8}Nested Structures}{94}{subsection.0.21.8}%
\contentsline {subsection}{\numberline {21.9}Structures as function arguments}{94}{subsection.0.21.9}%
\contentsline {subsection}{\numberline {21.10}Constant reference parameters}{95}{subsection.0.21.10}%
\contentsline {subsection}{\numberline {21.11}Returning a structure from a function}{95}{subsection.0.21.11}%
\contentsline {subsection}{\numberline {21.12}Pointers to structures}{96}{subsection.0.21.12}%
\contentsline {subsection}{\numberline {21.13}Dynamically allocating a structure}{96}{subsection.0.21.13}%
\contentsline {subsection}{\numberline {21.14}Enumerated data types}{97}{subsection.0.21.14}%
\contentsline {subsection}{\numberline {21.15}Assigning an integer to an enum variable}{97}{subsection.0.21.15}%
\contentsline {subsection}{\numberline {21.16}Assigning an enumerator to an int variable}{98}{subsection.0.21.16}%
\contentsline {subsection}{\numberline {21.17}Using math operators to change the value of an enum variable}{98}{subsection.0.21.17}%
\contentsline {subsection}{\numberline {21.18}Using an enum variable to step through an array's elements}{98}{subsection.0.21.18}%
\contentsline {subsection}{\numberline {21.19}Specifying values in enumerators}{99}{subsection.0.21.19}%
\contentsline {subsection}{\numberline {21.20}declaring the type and defining the variables in one statement}{99}{subsection.0.21.20}%
\contentsline {subsection}{\numberline {21.21}Strongly typed enums}{99}{subsection.0.21.21}%
\contentsline {section}{\numberline {22}String streams}{100}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}Using istringstream}{100}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Using ostringstream}{100}{subsection.0.22.2}%
\contentsline {section}{\numberline {23}Advanced file operations}{102}{section.0.23}%
\contentsline {section}{\numberline {24}C++ Lambdas}{103}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Options for capturing}{103}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Why auto as lambda type}{105}{subsection.0.24.2}%
\contentsline {section}{\numberline {25}Fancy case syntax}{106}{section.0.25}%
\contentsline {section}{\numberline {26}Static globals}{106}{section.0.26}%
\contentsline {section}{\numberline {27}Classes (OOP Principles in C++)}{107}{section.0.27}%
\contentsline {subsection}{\numberline {27.1}Private and Public (access specifiers)}{107}{subsection.0.27.1}%
\contentsline {subsection}{\numberline {27.2}Protected}{108}{subsection.0.27.2}%
\contentsline {subsection}{\numberline {27.3}Constant member functions}{108}{subsection.0.27.3}%
\contentsline {subsection}{\numberline {27.4}The mutable keyword}{108}{subsection.0.27.4}%
\contentsline {subsection}{\numberline {27.5}The friend keyword}{109}{subsection.0.27.5}%
\contentsline {subsection}{\numberline {27.6}Member function prototypes and definitions}{109}{subsection.0.27.6}%
\contentsline {subsection}{\numberline {27.7}Default Constructors}{110}{subsection.0.27.7}%
\contentsline {subsection}{\numberline {27.8}Parameterized Constructor}{110}{subsection.0.27.8}%
\contentsline {subsection}{\numberline {27.9}Copy Constructor}{110}{subsection.0.27.9}%
\contentsline {subsubsection}{\numberline {27.9.1}What invokes the copy constructor?}{110}{subsubsection.0.27.9.1}%
\contentsline {subsection}{\numberline {27.10}Constructor Overloading}{110}{subsection.0.27.10}%
\contentsline {subsection}{\numberline {27.11}Initialization Lists}{111}{subsection.0.27.11}%
\contentsline {subsection}{\numberline {27.12}Delegating Constructors}{111}{subsection.0.27.12}%
\contentsline {subsection}{\numberline {27.13}Explicit Constructors}{111}{subsection.0.27.13}%
\contentsline {subsection}{\numberline {27.14}Destructors}{113}{subsection.0.27.14}%
\contentsline {subsection}{\numberline {27.15}Default destructors}{113}{subsection.0.27.15}%
\contentsline {subsection}{\numberline {27.16}Accessors and Mutators}{113}{subsection.0.27.16}%
\contentsline {subsection}{\numberline {27.17}The "this" pointer}{114}{subsection.0.27.17}%
\contentsline {subsection}{\numberline {27.18}Static}{115}{subsection.0.27.18}%
\contentsline {subsection}{\numberline {27.19}Memberwise assignment}{115}{subsection.0.27.19}%
\contentsline {subsection}{\numberline {27.20}Aggregation}{115}{subsection.0.27.20}%
\contentsline {section}{\numberline {28}Operator Overloading}{116}{section.0.28}%
\contentsline {subsection}{\numberline {28.1}Overloading arithmetic operators}{116}{subsection.0.28.1}%
\contentsline {subsection}{\numberline {28.2}Overloading Stream Operators}{116}{subsection.0.28.2}%
\contentsline {subsection}{\numberline {28.3}Overloading Asssignment operator}{118}{subsection.0.28.3}%
\contentsline {subsection}{\numberline {28.4}Overloading Prefix}{118}{subsection.0.28.4}%
\contentsline {subsection}{\numberline {28.5}Overloading Postfix}{118}{subsection.0.28.5}%
\contentsline {subsection}{\numberline {28.6}Overloading Relational Operators}{120}{subsection.0.28.6}%
\contentsline {subsection}{\numberline {28.7}Overloading subscript operator}{120}{subsection.0.28.7}%
\contentsline {subsection}{\numberline {28.8}Overloading function call operator}{120}{subsection.0.28.8}%
\contentsline {subsection}{\numberline {28.9}Overloading dereference operator}{122}{subsection.0.28.9}%
\contentsline {subsection}{\numberline {28.10}Overloading arrow operator}{122}{subsection.0.28.10}%
\contentsline {subsection}{\numberline {28.11}Object Conversion}{123}{subsection.0.28.11}%
\contentsline {section}{\numberline {29}Class Inheritance}{124}{section.0.29}%
\contentsline {subsection}{\numberline {29.1}Access Specifiers}{125}{subsection.0.29.1}%
\contentsline {subsection}{\numberline {29.2}Constructors and Destructors}{126}{subsection.0.29.2}%
\contentsline {subsection}{\numberline {29.3}Virtual functions and the override keyword}{127}{subsection.0.29.3}%
\contentsline {subsection}{\numberline {29.4}Virtual Destructors}{127}{subsection.0.29.4}%
\contentsline {subsection}{\numberline {29.5}Polymorphism}{128}{subsection.0.29.5}%
\contentsline {subsection}{\numberline {29.6}Base class pointer to child class object}{129}{subsection.0.29.6}%
\contentsline {subsection}{\numberline {29.7}The Final keyword}{130}{subsection.0.29.7}%
\contentsline {section}{\numberline {30}Interface-Based Programming}{131}{section.0.30}%
\contentsline {subsection}{\numberline {30.1}Pure Abstract Classes in C++}{131}{subsection.0.30.1}%
\contentsline {subsection}{\numberline {30.2}Implementing Interfaces in C++}{131}{subsection.0.30.2}%
\contentsline {subsection}{\numberline {30.3}More on the concept of pure virtual functions}{132}{subsection.0.30.3}%
\contentsline {section}{\numberline {31}Separate files (Classes)}{133}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Class declaration in Header Files}{133}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Class Definition in Source Files}{133}{subsection.0.31.2}%
\contentsline {section}{\numberline {32}Rvalue references and move semantics}{134}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}Rvalue references}{134}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}Exception to binding references to literals}{134}{subsection.0.32.2}%
\contentsline {subsection}{\numberline {32.3}Creating a move constructor and std::move()}{136}{subsection.0.32.3}%
\contentsline {subsection}{\numberline {32.4}Move Operations and noexcept}{136}{subsection.0.32.4}%
\contentsline {section}{\numberline {33}Iterators}{138}{section.0.33}%
\contentsline {subsection}{\numberline {33.1}Type of Iterators}{138}{subsection.0.33.1}%
\contentsline {subsection}{\numberline {33.2}Container Iterators}{139}{subsection.0.33.2}%
\contentsline {subsection}{\numberline {33.3}What about C-Array}{139}{subsection.0.33.3}%
\contentsline {subsection}{\numberline {33.4}Contiguous vs Non-Contiguous Memory}{140}{subsection.0.33.4}%
\contentsline {section}{\numberline {34}Other Containers}{141}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Allocation of containers}{141}{subsection.0.34.1}%
\contentsline {subsection}{\numberline {34.2}The std::array<T,n> <array>}{143}{subsection.0.34.2}%
\contentsline {subsection}{\numberline {34.3}The std::list <list>}{143}{subsection.0.34.3}%
\contentsline {subsection}{\numberline {34.4}Sets set<T, comp> <set>}{143}{subsection.0.34.4}%
\contentsline {subsection}{\numberline {34.5}Maps map<T,T, comp> <map>}{143}{subsection.0.34.5}%
\contentsline {section}{\numberline {35}Variadic Functions in C++ (Ellipsis)}{144}{section.0.35}%
\contentsline {section}{\numberline {36}std::function<type(args)> <functional>}{145}{section.0.36}%
\contentsline {section}{\numberline {37}Initializer List as function parameters}{146}{section.0.37}%
\contentsline {section}{\numberline {38}Functions as parameters}{147}{section.0.38}%
\contentsline {subsection}{\numberline {38.1}Function Pointers:}{147}{subsection.0.38.1}%
\contentsline {subsection}{\numberline {38.2}Regular function pointers}{148}{subsection.0.38.2}%
\contentsline {section}{\numberline {39}Typedefs}{149}{section.0.39}%
\contentsline {subsection}{\numberline {39.1}Basic Typedefs}{149}{subsection.0.39.1}%
\contentsline {subsubsection}{\numberline {39.1.1}Example}{149}{subsubsection.0.39.1.1}%
\contentsline {subsection}{\numberline {39.2}Applications of typedef in C++}{149}{subsection.0.39.2}%
\contentsline {subsection}{\numberline {39.3}Using typedef with arrays}{149}{subsection.0.39.3}%
\contentsline {subsubsection}{\numberline {39.3.1}Example}{149}{subsubsection.0.39.3.1}%
\contentsline {subsection}{\numberline {39.4}Using typedef with pointers}{150}{subsection.0.39.4}%
\contentsline {subsubsection}{\numberline {39.4.1}Example:}{150}{subsubsection.0.39.4.1}%
\contentsline {subsection}{\numberline {39.5}Using typedef with function pointers}{150}{subsection.0.39.5}%
\contentsline {subsubsection}{\numberline {39.5.1}Example}{150}{subsubsection.0.39.5.1}%
\contentsline {section}{\numberline {40}Buffers in C++}{151}{section.0.40}%
\contentsline {subsection}{\numberline {40.1}Types of buffers}{151}{subsection.0.40.1}%
\contentsline {subsubsection}{\numberline {40.1.1}Stack-based buffers}{151}{subsubsection.0.40.1.1}%
\contentsline {subsubsection}{\numberline {40.1.2}Heap-based Buffers}{151}{subsubsection.0.40.1.2}%
\contentsline {subsubsection}{\numberline {40.1.3}Standard Library Containers}{151}{subsubsection.0.40.1.3}%
\contentsline {subsection}{\numberline {40.2}Usage in IO Operations}{152}{subsection.0.40.2}%
\contentsline {subsection}{\numberline {40.3}Buffer Overflow}{152}{subsection.0.40.3}%
\contentsline {section}{\numberline {41}The Stack, Heap, Code Segment (Text Segment), and Data Segment (static memory)}{153}{section.0.41}%
\contentsline {subsection}{\numberline {41.1}The Stack}{153}{subsection.0.41.1}%
\contentsline {subsubsection}{\numberline {41.1.1}The Call Stack}{153}{subsubsection.0.41.1.1}%
\contentsline {subsection}{\numberline {41.2}How Many Stacks are There Per Program?}{153}{subsection.0.41.2}%
\contentsline {subsection}{\numberline {41.3}Stack Memory Management}{154}{subsection.0.41.3}%
\contentsline {subsection}{\numberline {41.4}Stack Overflow}{154}{subsection.0.41.4}%
\contentsline {subsection}{\numberline {41.5}What Lives on The Stack?}{154}{subsection.0.41.5}%
\contentsline {subsection}{\numberline {41.6}The Heap}{155}{subsection.0.41.6}%
\contentsline {subsubsection}{\numberline {41.6.1}Characteristics of the Heap}{155}{subsubsection.0.41.6.1}%
\contentsline {subsubsection}{\numberline {41.6.2}Usage}{155}{subsubsection.0.41.6.2}%
\contentsline {subsubsection}{\numberline {41.6.3}Heap Allocatinos in Function Bodys}{156}{subsubsection.0.41.6.3}%
\contentsline {subsection}{\numberline {41.7}The Code Segment (Text Segment)}{156}{subsection.0.41.7}%
\contentsline {subsection}{\numberline {41.8}The Data Segment}{156}{subsection.0.41.8}%
\contentsline {subsubsection}{\numberline {41.8.1}Initialized Data Segment}{156}{subsubsection.0.41.8.1}%
\contentsline {subsubsection}{\numberline {41.8.2}Uninitialized Data Segment}{156}{subsubsection.0.41.8.2}%
\contentsline {section}{\numberline {42}More on Dynamic Memory Allocation}{157}{section.0.42}%
\contentsline {subsection}{\numberline {42.1}Before we Begin: Memory Leaks}{157}{subsection.0.42.1}%
\contentsline {subsubsection}{\numberline {42.1.1}How Memory Leaks Occur}{157}{subsubsection.0.42.1.1}%
\contentsline {subsection}{\numberline {42.2}Malloc}{157}{subsection.0.42.2}%
\contentsline {subsubsection}{\numberline {42.2.1}Basic Usage}{157}{subsubsection.0.42.2.1}%
\contentsline {subsubsection}{\numberline {42.2.2}Example}{157}{subsubsection.0.42.2.2}%
\contentsline {subsubsection}{\numberline {42.2.3}Characteristics}{158}{subsubsection.0.42.2.3}%
\contentsline {subsubsection}{\numberline {42.2.4}Considerations}{158}{subsubsection.0.42.2.4}%
\contentsline {subsubsection}{\numberline {42.2.5}Example of malloc with Error Checking}{158}{subsubsection.0.42.2.5}%
\contentsline {subsection}{\numberline {42.3}Calloc}{158}{subsection.0.42.3}%
\contentsline {subsection}{\numberline {42.4}Realloc}{158}{subsection.0.42.4}%
\contentsline {subsection}{\numberline {42.5}Free}{158}{subsection.0.42.5}%
\contentsline {subsection}{\numberline {42.6}New}{159}{subsection.0.42.6}%
\contentsline {subsection}{\numberline {42.7}Delete}{159}{subsection.0.42.7}%
\contentsline {subsection}{\numberline {42.8}Dangling Pointers}{159}{subsection.0.42.8}%
\contentsline {section}{\numberline {43}Exceptions}{160}{section.0.43}%
\contentsline {section}{\numberline {44}Templates}{161}{section.0.44}%
\contentsline {subsection}{\numberline {44.1}decltype}{161}{subsection.0.44.1}%
