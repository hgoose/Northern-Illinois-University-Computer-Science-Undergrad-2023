\contentsline {section}{\numberline {1}The C++ Language}{15}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Key Features}{15}{subsection.0.1.1}%
\contentsline {section}{\numberline {2}The Compiler}{17}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Preprocessing}{17}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Lexical Analysis}{17}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Syntax Analysis}{17}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Semantic Analysis}{17}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Intermediate Code Generation}{17}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Code Optimization}{18}{subsection.0.2.6}%
\contentsline {subsection}{\numberline {2.7}Code Generation}{18}{subsection.0.2.7}%
\contentsline {subsection}{\numberline {2.8}Assembling}{18}{subsection.0.2.8}%
\contentsline {subsection}{\numberline {2.9}Linking}{18}{subsection.0.2.9}%
\contentsline {subsection}{\numberline {2.10}Complier Options}{18}{subsection.0.2.10}%
\contentsline {subsection}{\numberline {2.11}Header Files}{19}{subsection.0.2.11}%
\contentsline {section}{\numberline {3}Preliminaries: A Quick Tour of C++ Fundamentals}{20}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Boilerplate}{20}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}The main function}{20}{subsection.0.3.2}%
\contentsline {subsection}{\numberline {3.3}Comments}{21}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Data Types, Modifiers, Qualifiers, Inference}{22}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}Primitive Type Ranges and Size}{23}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}Creating strings without the STL}{24}{subsection.0.3.6}%
\contentsline {subsection}{\numberline {3.7}Retrieve size}{25}{subsection.0.3.7}%
\contentsline {subsection}{\numberline {3.8}Retrieve type}{25}{subsection.0.3.8}%
\contentsline {subsection}{\numberline {3.9}Exponential Notation}{26}{subsection.0.3.9}%
\contentsline {subsection}{\numberline {3.10}Type Conversion}{26}{subsection.0.3.10}%
\contentsline {subsection}{\numberline {3.11}Integer Division}{27}{subsection.0.3.11}%
\contentsline {subsection}{\numberline {3.12}Overflow/Underflow}{27}{subsection.0.3.12}%
\contentsline {subsection}{\numberline {3.13}Type Casting}{27}{subsection.0.3.13}%
\contentsline {subsection}{\numberline {3.14}C-style Casts}{28}{subsection.0.3.14}%
\contentsline {subsection}{\numberline {3.15}The Using Directive}{29}{subsection.0.3.15}%
\contentsline {subsection}{\numberline {3.16}Variable Declaration}{30}{subsection.0.3.16}%
\contentsline {subsection}{\numberline {3.17}Multiple Declaration}{30}{subsection.0.3.17}%
\contentsline {subsection}{\numberline {3.18}Initialization}{30}{subsection.0.3.18}%
\contentsline {subsection}{\numberline {3.19}Multiple Initialization}{30}{subsection.0.3.19}%
\contentsline {subsection}{\numberline {3.20}Direct Initialization}{31}{subsection.0.3.20}%
\contentsline {subsection}{\numberline {3.21}List Initialization}{31}{subsection.0.3.21}%
\contentsline {subsection}{\numberline {3.22}Copy Initialization}{31}{subsection.0.3.22}%
\contentsline {subsection}{\numberline {3.23}Assignment}{31}{subsection.0.3.23}%
\contentsline {subsection}{\numberline {3.24}Multiple Assignment}{32}{subsection.0.3.24}%
\contentsline {section}{\numberline {4}Symbols}{33}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Parentheses}{33}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Brackets}{33}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Braces}{33}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Angle Brackets}{33}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Semi Colon}{33}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Colon}{33}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}Comma}{34}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}Ellipsis}{34}{subsection.0.4.8}%
\contentsline {subsection}{\numberline {4.9}Hash}{34}{subsection.0.4.9}%
\contentsline {section}{\numberline {5}Preprocessor Directives}{35}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}\#include}{35}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}\#define}{35}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}\#undef}{35}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}\#ifdef, \#ifndef, \#else, \#elif, \#endif}{35}{subsection.0.5.4}%
\contentsline {subsection}{\numberline {5.5}\#if}{36}{subsection.0.5.5}%
\contentsline {subsection}{\numberline {5.6}\#pragma}{36}{subsection.0.5.6}%
\contentsline {subsection}{\numberline {5.7}\#error}{36}{subsection.0.5.7}%
\contentsline {subsection}{\numberline {5.8}\#line}{36}{subsection.0.5.8}%
\contentsline {section}{\numberline {6}Input/Output}{37}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}iostream}{37}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Output}{37}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Input}{37}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}IO Manipulators}{39}{subsection.0.6.4}%
\contentsline {subsection}{\numberline {6.5}std::setiosflags}{41}{subsection.0.6.5}%
\contentsline {subsection}{\numberline {6.6}Escape Sequences}{41}{subsection.0.6.6}%
\contentsline {subsection}{\numberline {6.7}User Input With Strings}{42}{subsection.0.6.7}%
\contentsline {subsection}{\numberline {6.8}User input with characters}{43}{subsection.0.6.8}%
\contentsline {subsection}{\numberline {6.9}Mixing cin and cin.get}{43}{subsection.0.6.9}%
\contentsline {section}{\numberline {7}Operators}{44}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Arithmetic Operators}{44}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Relational Operators}{44}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}Logical Operators}{44}{subsection.0.7.3}%
\contentsline {subsection}{\numberline {7.4}Bitwise Operators}{44}{subsection.0.7.4}%
\contentsline {subsection}{\numberline {7.5}Assignment Operators}{44}{subsection.0.7.5}%
\contentsline {subsection}{\numberline {7.6}Increment and Decrement Operators}{44}{subsection.0.7.6}%
\contentsline {subsection}{\numberline {7.7}Pointers and References}{44}{subsection.0.7.7}%
\contentsline {subsection}{\numberline {7.8}Scope Resolution Operator}{44}{subsection.0.7.8}%
\contentsline {section}{\numberline {8}Random Numbers}{46}{section.0.8}%
\contentsline {section}{\numberline {9}Conditionals (Decision Structure)}{47}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Decision Structure Flowchart}{48}{subsection.0.9.1}%
\contentsline {subsection}{\numberline {9.2}The Conditional Operator (Ternary)}{48}{subsection.0.9.2}%
\contentsline {subsection}{\numberline {9.3}Switch}{49}{subsection.0.9.3}%
\contentsline {section}{\numberline {10}The While Loop}{50}{section.0.10}%
\contentsline {section}{\numberline {11}The Do-While Loop}{51}{section.0.11}%
\contentsline {section}{\numberline {12}The for loop}{52}{section.0.12}%
\contentsline {section}{\numberline {13}Using Files for Data Storage}{53}{section.0.13}%
\contentsline {subsection}{\numberline {13.1}File Access Methods}{53}{subsection.0.13.1}%
\contentsline {subsection}{\numberline {13.2}Setting up a program for file input/output}{53}{subsection.0.13.2}%
\contentsline {subsection}{\numberline {13.3}File Stream Objects}{53}{subsection.0.13.3}%
\contentsline {subsection}{\numberline {13.4}Creating a file object and opening a file}{54}{subsection.0.13.4}%
\contentsline {subsection}{\numberline {13.5}Closing a file}{55}{subsection.0.13.5}%
\contentsline {subsection}{\numberline {13.6}Reading from a file with an unknown number of lines}{56}{subsection.0.13.6}%
\contentsline {subsection}{\numberline {13.7}Testing for file open errors}{56}{subsection.0.13.7}%
\contentsline {section}{\numberline {14}rvalues and lvalues}{57}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}rvalue (right value):}{57}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}lvalue}{57}{subsection.0.14.2}%
\contentsline {section}{\numberline {15}Breaking and Continuing a loop}{58}{section.0.15}%
\contentsline {section}{\numberline {16}Functions}{59}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Function prototypes (function declarations)}{59}{subsection.0.16.1}%
\contentsline {subsection}{\numberline {16.2}Static locals}{60}{subsection.0.16.2}%
\contentsline {subsection}{\numberline {16.3}PREREQ - Reference variables}{60}{subsection.0.16.3}%
\contentsline {subsection}{\numberline {16.4}Using reference variables as parameters}{61}{subsection.0.16.4}%
\contentsline {subsection}{\numberline {16.5}Overloading Functions}{62}{subsection.0.16.5}%
\contentsline {subsection}{\numberline {16.6}The exit() function}{62}{subsection.0.16.6}%
\contentsline {subsection}{\numberline {16.7}Stubs and Drivers}{63}{subsection.0.16.7}%
\contentsline {section}{\numberline {17}Arrays and Vectors}{64}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Arrays}{64}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Partial array initialization}{64}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}Implicit array sizing}{64}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}Bound violation}{64}{subsection.0.17.4}%
\contentsline {subsection}{\numberline {17.5}The range based for loop}{65}{subsection.0.17.5}%
\contentsline {subsection}{\numberline {17.6}Modifying an array with a range-based for loop}{65}{subsection.0.17.6}%
\contentsline {subsection}{\numberline {17.7}Thou shall not assign}{65}{subsection.0.17.7}%
\contentsline {subsection}{\numberline {17.8}Getting the size of an array}{66}{subsection.0.17.8}%
\contentsline {subsection}{\numberline {17.9}Arrays as function arguments}{66}{subsection.0.17.9}%
\contentsline {subsection}{\numberline {17.10}2D array (matrix)}{68}{subsection.0.17.10}%
\contentsline {subsection}{\numberline {17.11}Passing a matrix to a function}{69}{subsection.0.17.11}%
\contentsline {subsection}{\numberline {17.12}The STL Vector}{70}{subsection.0.17.12}%
\contentsline {subsection}{\numberline {17.13}Defining a vector}{70}{subsection.0.17.13}%
\contentsline {subsection}{\numberline {17.14}Get index position of elements}{70}{subsection.0.17.14}%
\contentsline {subsection}{\numberline {17.15}Adding to a vector}{71}{subsection.0.17.15}%
\contentsline {subsection}{\numberline {17.16}Getting the size of a vector}{71}{subsection.0.17.16}%
\contentsline {subsection}{\numberline {17.17}Removing last element of a vector}{71}{subsection.0.17.17}%
\contentsline {subsection}{\numberline {17.18}Removing elements of a vector }{71}{subsection.0.17.18}%
\contentsline {subsection}{\numberline {17.19}Clearing a vector}{72}{subsection.0.17.19}%
\contentsline {subsection}{\numberline {17.20}Detecting an Empty vector}{72}{subsection.0.17.20}%
\contentsline {subsection}{\numberline {17.21}Resizing a vector}{72}{subsection.0.17.21}%
\contentsline {subsection}{\numberline {17.22}Swapping Vectors}{72}{subsection.0.17.22}%
\contentsline {section}{\numberline {18}Searching and Sorting Arrays}{73}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}The linear search}{73}{subsection.0.18.1}%
\contentsline {subsection}{\numberline {18.2}The binary search}{74}{subsection.0.18.2}%
\contentsline {subsection}{\numberline {18.3}Bubble Sort}{75}{subsection.0.18.3}%
\contentsline {subsection}{\numberline {18.4}Selection Sort}{75}{subsection.0.18.4}%
\contentsline {section}{\numberline {19}Pointers}{78}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}Nullptr}{78}{subsection.0.19.1}%
\contentsline {subsection}{\numberline {19.2}Arrays as pointers}{79}{subsection.0.19.2}%
\contentsline {subsection}{\numberline {19.3}Pointers as Function Parameters}{80}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}Pointers to constants}{80}{subsection.0.19.4}%
\contentsline {subsection}{\numberline {19.5}Constant Pointers}{81}{subsection.0.19.5}%
\contentsline {subsection}{\numberline {19.6}Both pointer to constant and constant pointer}{81}{subsection.0.19.6}%
\contentsline {subsection}{\numberline {19.7}Prereq - Static vs Dynamic memory allocation}{81}{subsection.0.19.7}%
\contentsline {subsection}{\numberline {19.8}Dynamic Memory Allocation}{82}{subsection.0.19.8}%
\contentsline {subsection}{\numberline {19.9}When to use DMA}{83}{subsection.0.19.9}%
\contentsline {subsection}{\numberline {19.10}Returning pointers from a function}{83}{subsection.0.19.10}%
\contentsline {subsection}{\numberline {19.11}Smart Pointers}{84}{subsection.0.19.11}%
\contentsline {section}{\numberline {20}Characters, C-Strings and more about the string class}{86}{section.0.20}%
\contentsline {subsection}{\numberline {20.1}Character Testing}{86}{subsection.0.20.1}%
\contentsline {subsection}{\numberline {20.2}Character case conversion}{86}{subsection.0.20.2}%
\contentsline {subsection}{\numberline {20.3}C Strings }{86}{subsection.0.20.3}%
\contentsline {subsection}{\numberline {20.4}C-Strings stored in arrays}{87}{subsection.0.20.4}%
\contentsline {subsection}{\numberline {20.5}The Strlen function}{87}{subsection.0.20.5}%
\contentsline {subsection}{\numberline {20.6}The strcat Function}{88}{subsection.0.20.6}%
\contentsline {subsection}{\numberline {20.7}The Strcopy function}{88}{subsection.0.20.7}%
\contentsline {subsection}{\numberline {20.8}The strncat and strncpy functions}{89}{subsection.0.20.8}%
\contentsline {subsection}{\numberline {20.9}The strstr function}{89}{subsection.0.20.9}%
\contentsline {subsection}{\numberline {20.10}The strcmp function}{90}{subsection.0.20.10}%
\contentsline {subsection}{\numberline {20.11}String/Numeric Conversion Functions}{90}{subsection.0.20.11}%
\contentsline {subsection}{\numberline {20.12}More on the C++ string (string object)}{92}{subsection.0.20.12}%
\contentsline {subsection}{\numberline {20.13}C++ String definitions}{92}{subsection.0.20.13}%
\contentsline {subsection}{\numberline {20.14}C++ string supported operators}{92}{subsection.0.20.14}%
\contentsline {section}{\numberline {21}Structures}{93}{section.0.21}%
\contentsline {subsection}{\numberline {21.1}Abstraction}{93}{subsection.0.21.1}%
\contentsline {subsection}{\numberline {21.2}Abstract data types}{93}{subsection.0.21.2}%
\contentsline {subsection}{\numberline {21.3}Structures}{93}{subsection.0.21.3}%
\contentsline {subsection}{\numberline {21.4}Accessing structure members}{94}{subsection.0.21.4}%
\contentsline {subsection}{\numberline {21.5}Initializing a structure (Initialization list)}{94}{subsection.0.21.5}%
\contentsline {subsection}{\numberline {21.6}Arrays of structures}{95}{subsection.0.21.6}%
\contentsline {subsection}{\numberline {21.7}Initializing a structure array}{95}{subsection.0.21.7}%
\contentsline {subsection}{\numberline {21.8}Nested Structures}{96}{subsection.0.21.8}%
\contentsline {subsection}{\numberline {21.9}Structures as function arguments}{96}{subsection.0.21.9}%
\contentsline {subsection}{\numberline {21.10}Constant reference parameters}{97}{subsection.0.21.10}%
\contentsline {subsection}{\numberline {21.11}Returning a structure from a function}{97}{subsection.0.21.11}%
\contentsline {subsection}{\numberline {21.12}Pointers to structures}{98}{subsection.0.21.12}%
\contentsline {subsection}{\numberline {21.13}Dynamically allocating a structure}{98}{subsection.0.21.13}%
\contentsline {subsection}{\numberline {21.14}Enumerated data types}{99}{subsection.0.21.14}%
\contentsline {subsection}{\numberline {21.15}Assigning an integer to an enum variable}{99}{subsection.0.21.15}%
\contentsline {subsection}{\numberline {21.16}Assigning an enumerator to an int variable}{100}{subsection.0.21.16}%
\contentsline {subsection}{\numberline {21.17}Using math operators to change the value of an enum variable}{100}{subsection.0.21.17}%
\contentsline {subsection}{\numberline {21.18}Using an enum variable to step through an array's elements}{100}{subsection.0.21.18}%
\contentsline {subsection}{\numberline {21.19}Specifying values in enumerators}{101}{subsection.0.21.19}%
\contentsline {subsection}{\numberline {21.20}declaring the type and defining the variables in one statement}{101}{subsection.0.21.20}%
\contentsline {subsection}{\numberline {21.21}Strongly typed enums}{101}{subsection.0.21.21}%
\contentsline {section}{\numberline {22}String streams}{102}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}Using istringstream}{102}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Using ostringstream}{102}{subsection.0.22.2}%
\contentsline {section}{\numberline {23}Advanced file operations}{104}{section.0.23}%
\contentsline {section}{\numberline {24}C++ Lambdas}{105}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Options for capturing}{105}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Why auto as lambda type}{107}{subsection.0.24.2}%
\contentsline {section}{\numberline {25}Fancy case syntax}{108}{section.0.25}%
\contentsline {section}{\numberline {26}Static globals}{108}{section.0.26}%
\contentsline {section}{\numberline {27}Classes (OOP Principles in C++)}{109}{section.0.27}%
\contentsline {subsection}{\numberline {27.1}Private and Public (access specifiers)}{109}{subsection.0.27.1}%
\contentsline {subsection}{\numberline {27.2}Protected}{110}{subsection.0.27.2}%
\contentsline {subsection}{\numberline {27.3}Constant member functions}{110}{subsection.0.27.3}%
\contentsline {subsection}{\numberline {27.4}The mutable keyword}{110}{subsection.0.27.4}%
\contentsline {subsection}{\numberline {27.5}The friend keyword}{111}{subsection.0.27.5}%
\contentsline {subsection}{\numberline {27.6}Member function prototypes and definitions}{111}{subsection.0.27.6}%
\contentsline {subsection}{\numberline {27.7}Default Constructors}{112}{subsection.0.27.7}%
\contentsline {subsection}{\numberline {27.8}Parameterized Constructor}{112}{subsection.0.27.8}%
\contentsline {subsection}{\numberline {27.9}Copy Constructor}{112}{subsection.0.27.9}%
\contentsline {subsubsection}{\numberline {27.9.1}What invokes the copy constructor?}{113}{subsubsection.0.27.9.1}%
\contentsline {subsubsection}{\numberline {27.9.2}Assignment operator instead of copy constructor}{114}{subsubsection.0.27.9.2}%
\contentsline {subsubsection}{\numberline {27.9.3}Forcing the copy constructor with initialization lists}{114}{subsubsection.0.27.9.3}%
\contentsline {subsection}{\numberline {27.10}Constructor Overloading}{115}{subsection.0.27.10}%
\contentsline {subsection}{\numberline {27.11}Initialization Lists}{116}{subsection.0.27.11}%
\contentsline {subsection}{\numberline {27.12}Delegating Constructors}{116}{subsection.0.27.12}%
\contentsline {subsection}{\numberline {27.13}Explicit Constructors}{116}{subsection.0.27.13}%
\contentsline {subsection}{\numberline {27.14}Destructors}{118}{subsection.0.27.14}%
\contentsline {subsection}{\numberline {27.15}Default destructors}{118}{subsection.0.27.15}%
\contentsline {subsection}{\numberline {27.16}Accessors and Mutators}{118}{subsection.0.27.16}%
\contentsline {subsection}{\numberline {27.17}The "this" pointer}{119}{subsection.0.27.17}%
\contentsline {subsubsection}{\numberline {27.17.1}Returning this}{120}{subsubsection.0.27.17.1}%
\contentsline {subsubsection}{\numberline {27.17.2}Returning *this}{120}{subsubsection.0.27.17.2}%
\contentsline {subsection}{\numberline {27.18}Static}{120}{subsection.0.27.18}%
\contentsline {subsection}{\numberline {27.19}Memberwise assignment}{120}{subsection.0.27.19}%
\contentsline {subsection}{\numberline {27.20}Aggregation}{120}{subsection.0.27.20}%
\contentsline {section}{\numberline {28}Operator Overloading}{121}{section.0.28}%
\contentsline {subsection}{\numberline {28.1}Overloading arithmetic operators}{121}{subsection.0.28.1}%
\contentsline {subsection}{\numberline {28.2}Overloading Stream Operators}{121}{subsection.0.28.2}%
\contentsline {subsection}{\numberline {28.3}Overloading Asssignment operator}{123}{subsection.0.28.3}%
\contentsline {subsection}{\numberline {28.4}Overloading Prefix}{123}{subsection.0.28.4}%
\contentsline {subsection}{\numberline {28.5}Overloading Postfix}{123}{subsection.0.28.5}%
\contentsline {subsection}{\numberline {28.6}Overloading Relational Operators}{125}{subsection.0.28.6}%
\contentsline {subsection}{\numberline {28.7}Overloading subscript operator}{125}{subsection.0.28.7}%
\contentsline {subsection}{\numberline {28.8}Overloading function call operator}{125}{subsection.0.28.8}%
\contentsline {subsection}{\numberline {28.9}Overloading dereference operator}{127}{subsection.0.28.9}%
\contentsline {subsection}{\numberline {28.10}Overloading arrow operator}{127}{subsection.0.28.10}%
\contentsline {subsection}{\numberline {28.11}Object Conversion}{128}{subsection.0.28.11}%
\contentsline {section}{\numberline {29}Class Inheritance}{129}{section.0.29}%
\contentsline {subsection}{\numberline {29.1}Access Specifiers}{130}{subsection.0.29.1}%
\contentsline {subsection}{\numberline {29.2}Constructors and Destructors}{131}{subsection.0.29.2}%
\contentsline {subsection}{\numberline {29.3}Virtual functions and the override keyword}{132}{subsection.0.29.3}%
\contentsline {subsection}{\numberline {29.4}Virtual Destructors}{132}{subsection.0.29.4}%
\contentsline {subsection}{\numberline {29.5}Polymorphism}{133}{subsection.0.29.5}%
\contentsline {subsection}{\numberline {29.6}Base class pointer to child class object}{134}{subsection.0.29.6}%
\contentsline {subsection}{\numberline {29.7}The Final keyword}{135}{subsection.0.29.7}%
\contentsline {section}{\numberline {30}Interface-Based Programming}{136}{section.0.30}%
\contentsline {subsection}{\numberline {30.1}Pure Abstract Classes in C++}{136}{subsection.0.30.1}%
\contentsline {subsection}{\numberline {30.2}Implementing Interfaces in C++}{136}{subsection.0.30.2}%
\contentsline {subsection}{\numberline {30.3}More on the concept of pure virtual functions}{137}{subsection.0.30.3}%
\contentsline {section}{\numberline {31}Separate files (Classes)}{138}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Class declaration in Header Files}{138}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Class Definition in Source Files}{138}{subsection.0.31.2}%
\contentsline {section}{\numberline {32}Rvalue references and move semantics}{139}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}Rvalue references}{139}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}Exception to binding references to literals}{139}{subsection.0.32.2}%
\contentsline {subsection}{\numberline {32.3}Creating a move constructor and std::move()}{141}{subsection.0.32.3}%
\contentsline {subsection}{\numberline {32.4}Move Operations and noexcept}{141}{subsection.0.32.4}%
\contentsline {subsection}{\numberline {32.5}More on std::move}{143}{subsection.0.32.5}%
\contentsline {subsubsection}{\numberline {32.5.1}Syntax}{143}{subsubsection.0.32.5.1}%
\contentsline {subsubsection}{\numberline {32.5.2}Move assignment operator}{143}{subsubsection.0.32.5.2}%
\contentsline {section}{\numberline {33}Iterators}{144}{section.0.33}%
\contentsline {subsection}{\numberline {33.1}Type of Iterators}{144}{subsection.0.33.1}%
\contentsline {subsection}{\numberline {33.2}Container Iterators}{145}{subsection.0.33.2}%
\contentsline {subsection}{\numberline {33.3}What about C-Array}{145}{subsection.0.33.3}%
\contentsline {subsection}{\numberline {33.4}Contiguous vs Non-Contiguous Memory}{146}{subsection.0.33.4}%
\contentsline {section}{\numberline {34}Other Containers}{147}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Allocation of containers}{147}{subsection.0.34.1}%
\contentsline {subsection}{\numberline {34.2}The std::array<T,n> <array>}{149}{subsection.0.34.2}%
\contentsline {subsection}{\numberline {34.3}The std::list <list>}{149}{subsection.0.34.3}%
\contentsline {subsection}{\numberline {34.4}Sets set<T, comp> <set>}{149}{subsection.0.34.4}%
\contentsline {subsection}{\numberline {34.5}Maps map<T,T, comp> <map>}{149}{subsection.0.34.5}%
\contentsline {section}{\numberline {35}Variadic Functions in C++ (Ellipsis)}{150}{section.0.35}%
\contentsline {section}{\numberline {36}std::function<type(args)> <functional>}{151}{section.0.36}%
\contentsline {section}{\numberline {37}Initializer List as function parameters}{152}{section.0.37}%
\contentsline {section}{\numberline {38}Functions as parameters}{153}{section.0.38}%
\contentsline {subsection}{\numberline {38.1}Function Pointers:}{153}{subsection.0.38.1}%
\contentsline {subsection}{\numberline {38.2}Regular function pointers}{154}{subsection.0.38.2}%
\contentsline {section}{\numberline {39}Typedefs}{155}{section.0.39}%
\contentsline {subsection}{\numberline {39.1}Basic Typedefs}{155}{subsection.0.39.1}%
\contentsline {subsubsection}{\numberline {39.1.1}Example}{155}{subsubsection.0.39.1.1}%
\contentsline {subsection}{\numberline {39.2}Applications of typedef in C++}{155}{subsection.0.39.2}%
\contentsline {subsection}{\numberline {39.3}Using typedef with arrays}{155}{subsection.0.39.3}%
\contentsline {subsubsection}{\numberline {39.3.1}Example}{155}{subsubsection.0.39.3.1}%
\contentsline {subsection}{\numberline {39.4}Using typedef with pointers}{156}{subsection.0.39.4}%
\contentsline {subsubsection}{\numberline {39.4.1}Example:}{156}{subsubsection.0.39.4.1}%
\contentsline {subsection}{\numberline {39.5}Using typedef with function pointers}{156}{subsection.0.39.5}%
\contentsline {subsubsection}{\numberline {39.5.1}Example}{156}{subsubsection.0.39.5.1}%
\contentsline {section}{\numberline {40}Buffers in C++}{157}{section.0.40}%
\contentsline {subsection}{\numberline {40.1}Types of buffers}{157}{subsection.0.40.1}%
\contentsline {subsubsection}{\numberline {40.1.1}Stack-based buffers}{157}{subsubsection.0.40.1.1}%
\contentsline {subsubsection}{\numberline {40.1.2}Heap-based Buffers}{157}{subsubsection.0.40.1.2}%
\contentsline {subsubsection}{\numberline {40.1.3}Standard Library Containers}{157}{subsubsection.0.40.1.3}%
\contentsline {subsection}{\numberline {40.2}Usage in IO Operations}{158}{subsection.0.40.2}%
\contentsline {subsection}{\numberline {40.3}Buffer Overflow}{158}{subsection.0.40.3}%
\contentsline {section}{\numberline {41}The Stack, Heap, Code Segment (Text Segment), and Data Segment (static memory)}{159}{section.0.41}%
\contentsline {subsection}{\numberline {41.1}The Stack}{159}{subsection.0.41.1}%
\contentsline {subsubsection}{\numberline {41.1.1}The Call Stack}{159}{subsubsection.0.41.1.1}%
\contentsline {subsection}{\numberline {41.2}How Many Stacks are There Per Program?}{159}{subsection.0.41.2}%
\contentsline {subsection}{\numberline {41.3}Stack Memory Management}{160}{subsection.0.41.3}%
\contentsline {subsection}{\numberline {41.4}Stack Overflow}{160}{subsection.0.41.4}%
\contentsline {subsection}{\numberline {41.5}What Lives on The Stack?}{160}{subsection.0.41.5}%
\contentsline {subsection}{\numberline {41.6}The Heap}{161}{subsection.0.41.6}%
\contentsline {subsubsection}{\numberline {41.6.1}Characteristics of the Heap}{161}{subsubsection.0.41.6.1}%
\contentsline {subsubsection}{\numberline {41.6.2}Usage}{161}{subsubsection.0.41.6.2}%
\contentsline {subsubsection}{\numberline {41.6.3}Heap Allocatinos in Function Bodys}{162}{subsubsection.0.41.6.3}%
\contentsline {subsection}{\numberline {41.7}The Code Segment (Text Segment)}{162}{subsection.0.41.7}%
\contentsline {subsection}{\numberline {41.8}The Data Segment}{162}{subsection.0.41.8}%
\contentsline {subsubsection}{\numberline {41.8.1}Initialized Data Segment}{162}{subsubsection.0.41.8.1}%
\contentsline {subsubsection}{\numberline {41.8.2}Uninitialized Data Segment}{162}{subsubsection.0.41.8.2}%
\contentsline {section}{\numberline {42}More on Dynamic Memory Allocation}{163}{section.0.42}%
\contentsline {subsection}{\numberline {42.1}Before we Begin: Memory Leaks}{163}{subsection.0.42.1}%
\contentsline {subsubsection}{\numberline {42.1.1}How Memory Leaks Occur}{163}{subsubsection.0.42.1.1}%
\contentsline {subsection}{\numberline {42.2}Malloc}{163}{subsection.0.42.2}%
\contentsline {subsubsection}{\numberline {42.2.1}Signature}{163}{subsubsection.0.42.2.1}%
\contentsline {subsubsection}{\numberline {42.2.2}Example}{164}{subsubsection.0.42.2.2}%
\contentsline {subsubsection}{\numberline {42.2.3}Characteristics}{164}{subsubsection.0.42.2.3}%
\contentsline {subsubsection}{\numberline {42.2.4}Considerations}{164}{subsubsection.0.42.2.4}%
\contentsline {subsection}{\numberline {42.3}Calloc}{165}{subsection.0.42.3}%
\contentsline {subsubsection}{\numberline {42.3.1}Signature}{165}{subsubsection.0.42.3.1}%
\contentsline {subsubsection}{\numberline {42.3.2}Example}{165}{subsubsection.0.42.3.2}%
\contentsline {subsubsection}{\numberline {42.3.3}Differences from malloc}{165}{subsubsection.0.42.3.3}%
\contentsline {subsection}{\numberline {42.4}Realloc}{165}{subsection.0.42.4}%
\contentsline {subsubsection}{\numberline {42.4.1}Signature}{166}{subsubsection.0.42.4.1}%
\contentsline {subsubsection}{\numberline {42.4.2}Example}{166}{subsubsection.0.42.4.2}%
\contentsline {subsection}{\numberline {42.5}Free}{166}{subsection.0.42.5}%
\contentsline {subsubsection}{\numberline {42.5.1}Signature}{166}{subsubsection.0.42.5.1}%
\contentsline {subsection}{\numberline {42.6}New}{167}{subsection.0.42.6}%
\contentsline {subsubsection}{\numberline {42.6.1}Syntax}{167}{subsubsection.0.42.6.1}%
\contentsline {subsubsection}{\numberline {42.6.2}Array allocation}{167}{subsubsection.0.42.6.2}%
\contentsline {subsubsection}{\numberline {42.6.3}Custom Constructor Parameters}{167}{subsubsection.0.42.6.3}%
\contentsline {subsubsection}{\numberline {42.6.4}Exception Handling (std::nothrow)}{167}{subsubsection.0.42.6.4}%
\contentsline {subsubsection}{\numberline {42.6.5}Placement New}{168}{subsubsection.0.42.6.5}%
\contentsline {subsection}{\numberline {42.7}Delete}{168}{subsection.0.42.7}%
\contentsline {subsubsection}{\numberline {42.7.1}Syntax}{168}{subsubsection.0.42.7.1}%
\contentsline {subsection}{\numberline {42.8}Dangling Pointers}{169}{subsection.0.42.8}%
\contentsline {subsection}{\numberline {42.9}Overloading new and delete}{170}{subsection.0.42.9}%
\contentsline {subsubsection}{\numberline {42.9.1}Why static?}{170}{subsubsection.0.42.9.1}%
\contentsline {subsubsection}{\numberline {42.9.2}The size\_t parameter in the new overload}{171}{subsubsection.0.42.9.2}%
\contentsline {subsection}{\numberline {42.10}Getting the size of dynamically allocated memory?}{171}{subsection.0.42.10}%
\contentsline {subsection}{\numberline {42.11}Mixing Memory Management Mechanism}{171}{subsection.0.42.11}%
\contentsline {subsubsection}{\numberline {42.11.1}Why Mixing Them is Bad}{171}{subsubsection.0.42.11.1}%
\contentsline {subsection}{\numberline {42.12}Should you be using malloc, calloc, realloc, or free in C++?}{171}{subsection.0.42.12}%
\contentsline {subsubsection}{\numberline {42.12.1}Constructor and Destructor Calls}{172}{subsubsection.0.42.12.1}%
\contentsline {subsubsection}{\numberline {42.12.2}Type Safety}{172}{subsubsection.0.42.12.2}%
\contentsline {subsubsection}{\numberline {42.12.3}Exception Handling}{172}{subsubsection.0.42.12.3}%
\contentsline {section}{\numberline {43}Other Casting Operators}{173}{section.0.43}%
\contentsline {subsection}{\numberline {43.1}dynamic\_cast}{173}{subsection.0.43.1}%
\contentsline {subsubsection}{\numberline {43.1.1}Purpose}{173}{subsubsection.0.43.1.1}%
\contentsline {subsubsection}{\numberline {43.1.2}Syntax}{173}{subsubsection.0.43.1.2}%
\contentsline {subsubsection}{\numberline {43.1.3}Requirements}{173}{subsubsection.0.43.1.3}%
\contentsline {subsubsection}{\numberline {43.1.4}Example}{173}{subsubsection.0.43.1.4}%
\contentsline {subsection}{\numberline {43.2}const\_cast}{174}{subsection.0.43.2}%
\contentsline {subsubsection}{\numberline {43.2.1}Removing const}{174}{subsubsection.0.43.2.1}%
\contentsline {subsubsection}{\numberline {43.2.2}Adding const}{174}{subsubsection.0.43.2.2}%
\contentsline {subsubsection}{\numberline {43.2.3}Use cases}{174}{subsubsection.0.43.2.3}%
\contentsline {subsubsection}{\numberline {43.2.4}Important Points}{175}{subsubsection.0.43.2.4}%
\contentsline {subsubsection}{\numberline {43.2.5}Example}{175}{subsubsection.0.43.2.5}%
\contentsline {subsubsection}{\numberline {43.2.6}When is it unsafe to use}{175}{subsubsection.0.43.2.6}%
\contentsline {subsubsection}{\numberline {43.2.7}The volatile keyword}{175}{subsubsection.0.43.2.7}%
\contentsline {subsubsection}{\numberline {43.2.8}Purpose}{175}{subsubsection.0.43.2.8}%
\contentsline {subsection}{\numberline {43.3}reinterpret_cast}{176}{subsection.0.43.3}%
\contentsline {subsubsection}{\numberline {43.3.1}Key Characteristics}{176}{subsubsection.0.43.3.1}%
\contentsline {subsubsection}{\numberline {43.3.2}Syntax}{176}{subsubsection.0.43.3.2}%
\contentsline {subsubsection}{\numberline {43.3.3}Example}{176}{subsubsection.0.43.3.3}%
\contentsline {subsubsection}{\numberline {43.3.4}Considerations}{177}{subsubsection.0.43.3.4}%
\contentsline {section}{\numberline {44}Namespaces}{178}{section.0.44}%
\contentsline {section}{\numberline {45}Exceptions}{179}{section.0.45}%
\contentsline {section}{\numberline {46}Templates}{180}{section.0.46}%
\contentsline {subsection}{\numberline {46.1}decltype}{180}{subsection.0.46.1}%
