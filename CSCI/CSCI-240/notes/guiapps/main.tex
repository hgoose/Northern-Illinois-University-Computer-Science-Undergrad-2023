\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{GUI Applications with C++} \\
           Build GUI apps for linux with QT
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           November 23, 2023\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak
    \unsect{Preface}
    \bigbreak \noindent 
    Creating a simple GUI application with Qt in C++ involves several steps. First, ensure you have the Qt framework installed on your Linux system. You can download QT on arch linux using pacman.
    \bigbreak \noindent 
    \begin{bashcode}
pacman -Sy qt5
    \end{bashcode}

    \pagebreak
    \unsect{Source File (Simple GUI)}
    \bigbreak \noindent 
    Here we make a simple GUI to show how the projects are built
    \bigbreak \noindent 
    \begin{cppcode}
#include <QApplication>
#include <QProcess>
#include <QWidget>
#include <QPushButton>
#include <iostream>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    QWidget window;

    QPushButton *button = new QPushButton("Click me", &window);
    button->setGeometry(50, 50, 80, 30);

    window.resize(250, 150);
    window.setWindowTitle("Button Example");
    window.show();

    return app.exec();
}
    \end{cppcode}

    \pagebreak
    \unsect{.pro file (Making project)}
    \bigbreak \noindent 
    To build our projects, we need to assemble a .pro file. A sample .pro file for the file above would look something like
    \bigbreak \noindent 
    \begin{cppcode}
TEMPLATE = app
TARGET = your_app_name
CONFIG += console c++11
QT += widgets

# Input
SOURCES += main.cpp

# If you have additional source files, list them here
# SOURCES += source1.cpp source2.cpp

# If you have header files, list them here
# HEADERS += header1.h header2.h

# If you have UI files created using Qt Designer, list them here
# FORMS += mainwindow.ui
    \end{cppcode}
    \begin{itemize}
        \item \textbf{TEMPLATE=app} tells Qt's build system, qmake, that your project is an application. This means qmake will generate a Makefile to build an executable.
        \item \textbf{TARGET=you\_app\_name} specifies the name for the executable
        \item \textbf{CONFIG += console c++11} is used to define various configuration options for the build process
            \begin{itemize}
                \item \textbf{console:} This option is used to specify that the application is a console application. This is particularly relevant on Windows, where it determines whether a console window is opened alongside your application. For GUI applications, you typically wouldn't include console, as GUI applications on Windows usually don't need a console window. On Linux and macOS, the distinction is less significant, as terminal-based and graphical applications are not as strictly separated as on Windows.
                \item \textbf{c++11} tells the compiler to use the C++11 standard
            \end{itemize}
        \item \textbf{QT += widgets} is used to add the widgets module form the list of modules to be included in the application 
        \item \textbf{SOURCES += main.cpp} is used to add source files in the build process
    \end{itemize}

    \bigbreak \noindent 
    \unsect{Building the application}
    \bigbreak \noindent 
    Once we have made the .pro file, we can begin the build process
    \bigbreak \noindent 
    \begin{bashcode}
qmake filename.pro # First
make # Then
    \end{bashcode}

    \pagebreak
    \unsect{Other options for pro file variables}
    \begin{itemize}
        \item \textbf{TEMPLATE:} 
            \begin{itemize}
                \item \textbf{app:} This is used for building an application. It will create an executable. When you're developing a typical GUI or console application, you use TEMPLATE = app.
                \item \textbf{lib:} This is used for building a library. If you're developing a library (either static or dynamic), you would use TEMPLATE = lib. When you choose this, qmake will generate a Makefile suitable for building a library instead of an executable.
                \item \textbf{subdirs:} This is used for a project that contains multiple subprojects. The subdirs template is useful when your project is large and split across multiple directories, each of which is a different project (either an application or a library). With TEMPLATE = subdirs, qmake will manage these subprojects according to the instructions you provide in the .pro file.
                \item \textbf{aux:} This template is used for auxiliary files that are not compiled but are included in the project. It's less commonly used compared to the other templates.
                \item \textbf{vcapp and vclib:} These are for Visual Studio integration on Windows.
            \end{itemize}
        \item \textbf{CONFIG:}
            \begin{itemize}
                \item \textbf{debug:} Builds the application with debugging symbols. Useful for debugging the application.
                \item \textbf{release:} Builds the application in release mode, which typically includes optimizations and lacks debugging symbols.
                \item \textbf{qml\_debug:} Enables debugging of QML code. Useful if you are using QML for your application's UI.
                \item \textbf{qt:} Ensures that Qt-specific build steps are executed, like running the Meta-Object Compiler (MOC) on classes that use Qt's signal and slot mechanism.
                \item \textbf{c++11, c++14, c++17, c++20:} Specifies the C++ standard to be used. You should match this with the version of C++ your code is written in.
                \item \textbf{warn\_on:} Enables all compiler warnings. This is useful for ensuring that potential code issues are highlighted during the build process.
                \item \textbf{static:} When building a library, this option specifies that the library should be static rather than dynamic.
                \item \textbf{shared:} Opposite of static, this is used for building shared libraries.
                \item \textbf{testcase:} Used when building a project as a test case using Qt Test.
                \item \textbf{lex yacc:} Includes support for Lex and Yacc if you are using these tools in your project.
                \item \textbf{thread:} Enables multi-threading support in your application.
                \item \textbf{exceptions:} Enables support for C++ exceptions.
                \item \textbf{no\_keywords:} Disables the use of Qt-specific keywords like slots, signals, and emit to avoid conflicts with third-party libraries.
                \item \textbf{opengl:} Enables the use of OpenGL in the application.
                \item \textbf{widgets:} Includes the QtWidgets module, necessary for applications using Qt Widgets.
                \item \textbf{network:} Includes the QtNetwork module for network programming.
                \item \textbf{sql:} Includes the Qt SQL module for database operations.
                \item \textbf{xml:} Includes the Qt XML module for XML processing.
                \item \textbf{link\_pkgconfig:} Allows the use of pkg-config to find libraries.
                \item \textbf{precompile\_header:} Enables the use of precompiled headers to speed up compilation.
            \end{itemize}
            \pagebreak
        \item \textbf{QT: (List of modules we can add or remove)}
            \begin{itemize}
                    \item \textbf{core:} This is included by default and provides core non-GUI functionality. It's essential for any Qt application.
                   \item \textbf{gui:} Also included by default in most cases, this module is necessary for any application that uses Qt's graphical user interface elements.
                \item \textbf{widgets:} For applications that use QWidget-based user interfaces. This is a key module for traditional desktop GUI applications.
                \item \textbf{network:} Adds network communication capabilities, like handling TCP/IP connections, for your application.
                \item \textbf{sql:} If your application needs to interact with SQL databases, this module provides the necessary functionality.
                \item \textbf{qml:} Necessary for applications that use the QML language for designing user interfaces, especially in combination with the Qt Quick module.
                \item \textbf{quick:} Used in conjunction with QML to create fluid, dynamic user interfaces. It's a part of the Qt Quick framework.
                \item \textbf{multimedia:} For applications that need to handle audio, video, radio, and camera functionality.
                \item \textbf{bluetooth:} Provides classes for writing Bluetooth applications.
                \item \textbf{concurrent:} Enables easier use of multi-threading in applications.
                \item \textbf{printsupport:} For applications that require printing capabilities.
                \item \textbf{webkit or webengine:} For applications that need to embed web content using WebKit or Qt WebEngine.
                \item \textbf{xml:} Adds support for reading and writing XML data.
                \item \textbf{opengl:} For applications that use OpenGL for rendering graphics.
                \item \textbf{testlib:} For writing unit tests.
                \item \textbf{positioning:} For applications that require location and positioning functionality.
                \item \textbf{sensors:} Access to various hardware sensors like accelerometers, gyroscopes, etc.
                \item \textbf{serialport:} For applications that communicate with devices over serial ports.
                \item \textbf{svg:} Support for Scalable Vector Graphics (SVG) files.
                \item \textbf{dbus:} For applications that communicate with other applications using the D-Bus protocol (mostly relevant on Linux). 
            \end{itemize}
    \end{itemize}

    \pagebreak
    \unsect{Includes}
    \bigbreak \noindent 
    The main include we need to build our GUI apps is <QApplication>, this class manages the GUI application's control flow and main settings
    \bigbreak \noindent 
    The <QWidget> class is the base class of all user interface objects. 
    \bigbreak \noindent 
    The <QProcess> allows us to launch external processes

    \bigbreak \noindent 
    \unsect{Example Application}
    \bigbreak \noindent 
    Here is a sample application which creates a clickable button that takes us to a certain directory in a new terminal window
    \bigbreak \noindent 
    \begin{cppcode}
#include <QApplication>
#include <QWidget>
#include <QPushButton>
#include <QProcess>
#include <iostream>

class MyWindow : public QWidget {
    Q_OBJECT

public:
    MyWindow(QWidget *parent = nullptr) : QWidget(parent) {
        QPushButton *button = new QPushButton("Open Terminal", this);
        button->setGeometry(50, 50, 120, 30);
        connect(button, &QPushButton::clicked, this, &MyWindow::onButtonClicked);
    }

public slots:
    void onButtonClicked() {
        QProcess::startDetached("kitty --working-directory=/home/datura/tmp/cpp");
    }
};

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    MyWindow window;
    window.resize(250, 150);
    window.setWindowTitle("Button Example");
    window.show();

    return app.exec();
}

#include "main.moc"
    \end{cppcode}

    \pagebreak
    \unsect{Q\_OBJECT}
    \bigbreak \noindent 
    The Q\_OBJECT macro is essential in Qt applications for any class that defines signals or slots, and it enables several key features provided by Qt's meta-object system.

    \bigbreak \noindent 
    \unsect{Signals and Slots}
    \bigbreak \noindent 
    Signals and slots are fundamental aspects of Qt and form the basis of its event communication system. They are used for communication between objects and are an integral part of Qt's programming model, especially in GUI applications. Here's a breakdown of what they are and how they work:
    \bigbreak \noindent 
    \subsection{Signals}
    \bigbreak \noindent 
    \textbf{Definition:} A signal is a message sent by an object to indicate that some event has occurred or some state has changed. In Qt, signals are declared in a class, but they are not implemented in the class. They are just emitted (or "fired") when the event they represent occurs.
    \bigbreak \noindent 
    \textbf{Usage:} Signals are used to broadcast information. Any number of slots can listen and react to a particular signal.
    \bigbreak \noindent 
    \textbf{Syntax:} In Qt, signals are declared with the signals keyword.
    \bigbreak \noindent 
    \begin{cppcode}
signals:
    void mySignal();
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Slots}
    \bigbreak \noindent 
    \textbf{Definition:} A slot is a function that is used to receive and respond to a signal. Slots can be normal member functions of a class.
    \bigbreak \noindent 
    \textbf{Usage:} Slots are used to perform actions in response to the occurrence of the event signified by a signal. A slot does not know if it has received a signal from a signal or directly as a regular function call.
    \bigbreak \noindent 
    \textbf{Syntax:} Slots are declared with the slots keyword or can be just regular member functions. They can also be private or protected.
    \bigbreak \noindent 
    \begin{cppcode}
public slots:
    void mySlot();
    \end{cppcode}

    \pagebreak
    \subsection{Connecting Signals to Slots}
    \bigbreak \noindent 
    \textbf{Mechanism:} In Qt, objects communicate with each other via signals and slots. When a signal is emitted, all connected slots are called.
    \bigbreak \noindent 
    \textbf{Dynamic Connection:} The connection between signals and slots can be made at runtime using the QObject::connect() function.
    \bigbreak \noindent 
    \begin{cppcode}
    connect(sender, SIGNAL(mySignal()), receiver, SLOT(mySlot()));
    \end{cppcode}

    \bigbreak \noindent 
    \unsect{The MyWindow Constructor and Widget Hierarchy}
    \bigbreak \noindent
    In Qt, the concept of parent-child relationships is pivotal for managing widgets (the graphical user interface elements). When you create a custom widget like MyWindow, which inherits from QWidget, you often include a constructor that allows for specifying a parent widget. This relationship is crucial for several aspects of a widget's behavior and lifecycle.
    \bigbreak \noindent 
    \begin{cppcode}
MyWindow(QWidget *parent = nullptr) : QWidget(parent) {
    // Constructor body
}
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Optional Parent Argument:} The constructor of MyWindow takes an optional parameter parent, which is a pointer to a QWidget. The default value of this parameter is nullptr.
        \item \textbf{Delegating to QWidget Constructor:} Inside the constructor, we use an initialization list to call the base class QWidget's constructor with the parent argument. This is a common C++ technique for initializing base class members.
        \item \textbf{Behavior Based on parent Argument:}
        \begin{itemize}
            \item \textbf{Top-Level Window:} If nullptr is passed to MyWindow (or no argument is provided), it implies that MyWindow does not have a parent widget. In this case, MyWindow acts as a top-level window. This means it can be a standalone window with its own window decorations (like a title bar, minimize/maximize buttons, etc.).
            \item \textbf{Child Widget:} If a valid QWidget pointer is passed as the parent, MyWindow becomes a child widget of the specified parent widget. As a child widget, it will be contained within the parent widget's window and subject to its geometry and visibility. Additionally, the parent widget will manage the lifetime of MyWindow, automatically deleting it when the parent widget is destroyed.
        \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    This constructor design allows MyWindow to be versatile: it can either be an independent window or part of a larger interface, depending on how it's instantiated. This flexibility is a key feature of Qt's approach to building user interfaces, where the composition of widgets can be dynamically arranged.

    \pagebreak
    \unsect{Main Semantics}
    \bigbreak \noindent 
    In a Qt application, the main function serves as the entry point and is responsible for setting up and running the application's main event loop
    \bigbreak \noindent 
    \subsection{QApplication Initialization:}
    \bigbreak \noindent 
    \begin{cppcode}
    QApplication app(argc, argv);
    \end{cppcode}
    \begin{itemize}
        \item QApplication is a class that manages application-wide resources and is necessary for any Qt GUI application.
        \item It needs to be instantiated at the beginning of main.
        \item argc and argv are passed to QApplication to handle any command-line arguments that are relevant to Qt applications (like GUI style, plugin paths, etc.).
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Creating a Window}
    \bigbreak \noindent 
    If no custom window class is made, we can create a window with
    \bigbreak \noindent 
    \begin{cppcode}
Qwidget window;
window.resize(250, 150);
window.setWindowTitle("Title Text");
Window.show();
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Starting the Event Loop:}
    \bigbreak \noindent 
    \begin{cppcode}
    return app.exec();
    \end{cppcode}
    \begin{itemize}
        \item app.exec() starts the application's event loop. This is a crucial call; it enters the main loop where events (like mouse clicks, keypresses, or custom events) are received and dispatched to the appropriate widgets.
        \item The event loop continues to run until exit() is called, usually as a response to events like closing the main window.
    \end{itemize}

    \pagebreak
    \unsect{main.moc}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{What is main.moc?:} The .moc files are generated by the Meta-Object Compiler (MOC) in Qt. MOC is a tool that processes Qt's specific extensions, like the Q\_OBJECT macro, signals, and slots. It generates standard C++ code from these extensions, enabling features like signal-slot connections and introspection.
        \item \textbf{Role of main.moc:} Typically, for classes that include the Q\_OBJECT macro or define signals and slots, a corresponding .moc file is generated. However, it's unusual to have a main.moc. In standard Qt applications, the main function usually doesn't define a new class and doesn't include Q\_OBJECT. If your main.cpp includes definitions of such Qt classes, then main.moc might be generated and should be included at the end of the main.cpp file. This is not common practice and usually indicates that the application structure could be improved by moving Qt class definitions out of main.cpp.
    \end{itemize}

    \bigbreak \noindent 
    \unsect{Defining our own window object}
    \bigbreak \noindent 
    \begin{cppcode}
#include <QApplication>
#include <QWidget>
#include <iostream>
#include <iomanip>

class MainWindow : public QWidget {
private:
    Q_OBJECT;

public:
    MainWindow(QWidget* parent=nullptr) : QWidget(parent) {

    }

};

int main(int argc, char* argv[]) {
    QApplication app(argc, argv);

    MainWindow window;
    window.resize(1080,700);
    window.setWindowTitle("Title Name");
    window.show();

    return app.exec();
}
#include "main.moc"
    \end{cppcode}

    \pagebreak
    \unsect{Creating a button}
    \bigbreak \noindent 
    Now that we have most of the jargon out of the way, lets create some stuff.
    \bigbreak \noindent 
    \subsection{Include Necessary Headers}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QPushButton>
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Creation}
    \bigbreak \noindent 
    In our custom window class, 
    \bigbreak \noindent 
    \begin{cppcode}
    MainWindow(QWidget *parent = nullptr) : QWidget(parent) {
        QPushButton *button = new QPushButton("Do Something", this);
        button->setGeometry(50, 50, 120, 30);
    }
    \end{cppcode}
    \begin{itemize}
        \item \textbf{QPushButton *button = new QPushButton("Open Terminal", this):} creates a new instance of QPushButton. The text "Open Terminal" is set as the button's label. The this pointer is passed as the parent of the button, which means the button is a child widget of MyWindow. As a child widget, it will be displayed within MyWindow and will be deleted when MyWindow is deleted (automatic memory management by Qt).
        \item \textbf{button->setGeometry(50, 50, 120, 30):} sets the position and size of the button within its parent widget (MyWindow). The button is placed at coordinates (50, 50) with a width of 120 pixels and a height of 30 pixels.
    \end{itemize}
    
    \bigbreak \noindent 
    \subsection{Making the button do something}
    \bigbreak \noindent 
    First, lets create a member function for our window class that provides functionality for our button
    \bigbreak \noindent 
    \begin{cppcode}
#include <QProcess>
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
public slots:
    void onButtonClick() {
        QProcess::startDetached("kitty --working-directory=$HOME/tmp/cpp");

    }
    \end{cppcode}
    \pagebreak
    Then in the constructor we can add the connection 
    \bigbreak \noindent 
    \begin{cppcode}
    connect(object1, signal1, object2, slot2);
    connect(button, &QPushButton::clicked, this, &MainWindow::onButtonClicked);
    \end{cppcode}
    \begin{itemize}
        \item connect(button, \&QPushButton::clicked, this, \&MainWindow::onButtonClicked); establishes a connection between the clicked signal of the button and the onButtonClicked slot method of MainWindow. This is using the signal-slot mechanism in Qt.
        \item When the button is clicked, the clicked signal is emitted. Because of the connection established by connect, this will trigger the onButtonClicked method in the MainWindow class.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Args}
    \begin{itemize}
        \item \textbf{First Argument - button:}
            \begin{itemize}
                \item This is the source object that emits the signal. In your case, it's the pointer to the QPushButton instance you've created. The signal will be emitted from this button.
            \end{itemize}
        \item \textbf{Second Argument - \&QPushButton::clicked:}
            \begin{itemize}
                \item  This specifies the signal you want to connect from the source object. The \&QPushButton::clicked is a pointer to the clicked signal of the QPushButton class. This signal is emitted by Qt when the button is clicked.
            \end{itemize}
        \item \textbf{Third Argument - this:}
            \begin{itemize}
               \item This is the receiver object, which is the object that owns the slot method you want to call. In this case, this refers to the current instance of the MainWindow class, indicating that the slot method belongs to this instance.
            \end{itemize}
        \item \textbf{Fourth Argument - \&MainWindow::onButtonClicked:}
            \begin{itemize}
                \item  This specifies the slot, which is the method that will be called in response to the signal. \&MainWindow::onButtonClicked is a pointer to the onButtonClicked method of the Wainwindow class. This method should be defined in MainWindow and will be executed when the button is clicked.
            \end{itemize}
    \end{itemize}

    \pagebreak
    \unsect{Creating Labels}
    \bigbreak \noindent 
    First, we need to make sure that we have <QLabel> included 
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QLabel>
    \end{cppcode}
    \bigbreak \noindent 
    Then, in our windows constructor, we can create the label
    \bigbreak \noindent 
    \begin{cppcode}
    label = new QLabel("Hello, World!", this);
    label->setAlignment(Qt::AlignCenter);
    label->setGeometry(0, 75, 250, 50); // Adjust geometry as needed
    label->hide();
    \end{cppcode}

    \bigbreak \noindent 
    \unsect{QStrings}
    \bigbreak \noindent 
    QString is a fundamental part of the Qt framework, designed to represent strings of text in a way that is optimized for performance and flexibility, especially in the context of internationalization. It's a powerful alternative to standard C++ string types like std::string and C-style strings (char*).
    \bigbreak \noindent 
    We must use QStrings instead of std::string in our applications to avoid getting errors.
    \bigbreak \noindent 
    \subsection{Creating a QString}
    \bigbreak \noindent 
    Before we create any Qstrings, we must include the header.
    \bigbreak \noindent 
    \begin{cppcode}
#include <QString>
    \end{cppcode}
    \bigbreak \noindent 
    Then we can create our QString objects
    \bigbreak \noindent 
    \begin{cppcode}
    QString a = "My QString";
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Converting to QString}
    \bigbreak \noindent 
    \begin{cppcode}
std::string a = "String"
QString b = QString::fromStdString(a); // QString::toStdString() for the reverse
    \end{cppcode}

    \pagebreak
    \subsection{Converting numeric types to QString}
    \bigbreak \noindent 
    \begin{cppcode}
    QString a = QString::number(20);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{QStringList}
    \bigbreak \noindent 
    To use QStringList objcets, we first must include the necessary header
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QStringList>
    \end{cppcode}
    \bigbreak \noindent 
    Then to create a QStringList objcet
    \bigbreak \noindent 
    \begin{cppcode}
    QStringList mylist;
    mylist << "item1" << "item2";

    list.append("Item 4");
    list.insert(2, "Inserted Item");  // Inserts at the specified index
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{Other useful functions}
    \begin{itemize}
        \item \textbf{join:} Concatenates all the strings in the list into a single string with a specified separator.
        \item \textbf{sort:} Sorts the list in ascending order.
        \item \textbf{filter:} Returns a new list containing only the strings that match a given pattern.
        \item \textbf{size/count:} Returns the number of items in the list.
        \item \textbf{isEmpty:} Checks if the list is empty.
        \item \textbf{clear:} Clears all items from the list.
    \end{itemize}


    \pagebreak
    \unsect{Backgrounds}
    \bigbreak \noindent 
    In Qt, there are various ways you can manipulate the background of a widget. These methods offer a range of visual customizations, from simple color changes to more complex patterns and gradients. Here's how you set the background color for the window
    \bigbreak \noindent 
    \begin{cppcode}
    window.setStyleSheet("background-color: blue;");
    widget->setStyleSheet("background-color: blue;"); // More generally
    \end{cppcode}
    \bigbreak \noindent 
    Here's an overview of the different things you can do with backgrounds in Qt:
    \begin{itemize}
        \item \textbf{Set a Solid Background Color:}
            \begin{itemize}
                \item Use setStyleSheet with the background-color property.
                \item Example: widget->setStyleSheet("background-color: red;");
            \end{itemize}
        \item \textbf{Use Gradient Backgrounds:}
            \begin{itemize}
                \item Linear, radial, and conical gradients can be set using style sheets.
                \item Example: widget->setStyleSheet("background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 white, stop:1 black);");
            \end{itemize}
        \item \textbf{Set a Background Image:}
            \begin{itemize}
                \item Use setStyleSheet with the background-image property.
                \item Example: widget->setStyleSheet("background-image: url(:/images/background.png);");
                \item You can control how the image is displayed (e.g., stretched, tiled) using background-repeat and background-position.
            \end{itemize}
        \item \textbf{Use a Pixmap as a Background:}
            \begin{itemize}
                \item This can be done by overriding the paintEvent method in a custom widget.
                \item In the paintEvent, use QPainter to draw a QPixmap as the background.
        \end{itemize}
        \item \textbf{Set a Transparent Background:}
            \begin{itemize}
                \item Useful for creating overlay widgets or for special effects.
                \item Example: widget->setStyleSheet("background: transparent;");
            \end{itemize}
        \item \textbf{Apply Box Shadows:}
            \begin{itemize}
                \item You can use style sheets to add shadows to the background, creating a layer effect.
                \item Example: widget->setStyleSheet("box-shadow: 10px 10px 5px \#888888;");
            \end{itemize}
        \item \textbf{Use Patterns and Textures:}
            \begin{itemize}
                \item Similar to using an image, but typically involves tiling a smaller image to create a repeating pattern.
                \item Example: widget->setStyleSheet("background-image: url(:/images/pattern.png); background-repeat: repeat;");
            \end{itemize}
        \item \textbf{Adjusting Opacity:}
            \begin{itemize}
                \item You can adjust the opacity of the background using style sheets.
                \item Example: widget->setStyleSheet("background-color: rgba(255, 0, 0, 128);"); (semi-transparent red)
            \end{itemize}
        \item \textbf{Border Customization:}
            \begin{itemize}
                \item Although not strictly part of the background, borders often complement background customization.
                \item Style the borders using properties like border-style, border-width, and border-color.
            \end{itemize}
        \item \textbf{Dynamic Background Changes:}
            \begin{itemize}
                \item  Change backgrounds in response to events like mouse hover, clicks, or other widget states.
                \item Use pseudo-states in style sheets (:hover, :pressed, etc.) to achieve this.
           \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Gradients}

    \bigbreak \noindent 
    \phantomsection
    \addcontentsline{toc}{subsection}{Getting the width and height}
    \section*{Getting the width and height}
    The QWidget class provides two methods for obtaining these measures \textbf{width()} and \textbf{height()}

    \bigbreak \noindent 
    \unsect{Creating shapes (QPainter)}
    \bigbreak \noindent 
    Creating shapes in a Qt application typically involves using the QPainter class, which provides a rich set of functions to draw various shapes and figures. Here's a guide on how to create different shapes:
    \pagebreak 
    \subsection{Headers}
    \bigbreak \noindent 
    \begin{cppcode}
        #include <QPainter>      // Used for drawing graphics in widgets
        #include <QPoint>        // Represents x and y coordinates in a 2D space
        #include <QRect>         // Defines a rectangle in the plane using integer precision
        #include <QPolygon>      // Represents a polygon defined by a vector of points
        #include <QBrush>        // Used for filling shapes with solid colors, patterns, or gradients
        #include <QPen>          // Used for drawing lines and outlines of shapes
        #include <QImage>        // Represents an image; used in conjunction with QPainter
        #include <QGradient>     // To create gradient objects
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Creating a shape}
    \bigbreak \noindent 
    To create shapes, we typically  subclass the QWidget class. However, since this document has examples that already have a QWidget derived class (the window class), we use this class insstead. Then we override the paintEvent
    \bigbreak \noindent 
    \begin{cppcode}
class MyWidget : public MainWindow {
protected:
    void paintEvent(QPaintEvent *event) override;
};
void MyWidget::paintEvent(QPaintEvent *event) {
    QPainter painter(this);

    // Draw a rectangle
    painter.drawRect(10, 10, 100, 50);

    // Draw a circle
    painter.drawEllipse(10, 70, 50, 50);

    // Draw a line
    painter.drawLine(10, 130, 110, 130);

    // Draw a polygon (triangle in this case)
    QPolygon polygon;
    polygon << QPoint(130, 140) << QPoint(180, 190) << QPoint(80, 190);
    painter.drawPolygon(polygon);
}
    \end{cppcode}


    \pagebreak
    \subsection{QPen}
    \bigbreak \noindent 
    \begin{concept}
        \textbf{QPen} is used to define the style of the outline of shapes and lines. It primarily sets the color, width, and style of the lines.
        \bigbreak \noindent 
        \begin{cppcode}
            QPen mypen(Qt::red);
        \end{cppcode}
        \begin{itemize}
            \item \textbf{Color functions:} 
                \begin{itemize}
                    \item \textbf{setColor(const QColor \&color)}: Set the color of the pen.
                    \item \textbf{color()}: Retrieve the current color of the pen.
                \end{itemize}
            \item \textbf{Width functions:} 
                \begin{itemize}
                    \item \textbf{setWidth(int width)}: Set the width of the pen in pixels.
                    \item \textbf{width()}: Retrieve the current width of the pen.
                \end{itemize}
            \item \textbf{Style functions:} 
                \begin{itemize}
                    \item \textbf{setStyle(Qt::PenStyle style)}: Set the style of the pen.
                    \item \textbf{style()}: Retrieve the current style of the pen.
                \end{itemize}
            \item \textbf{Cap Style functions:} 
                \begin{itemize}
                    \item \textbf{setCapStyle(Qt::PenCapStyle capStyle)}: Define the end style of lines.
                \end{itemize}
            \item \textbf{Join Style functions:} 
                \begin{itemize}
                    \item \textbf{setJoinStyle(Qt::PenJoinStyle joinStyle)}: Set the style of the joins between line segments.
                \end{itemize}
            \item \textbf{Brush functions:} 
                \begin{itemize}
                    \item \textbf{setBrush(const QBrush \&brush)}: Set a brush for the pen.
                    \item \textbf{brush()}: Retrieve the current brush of the pen.
                \end{itemize}
            \item \textbf{Miter Limit functions:} 
                \begin{itemize}
                    \item \textbf{setMiterLimit(qreal limit)}: Set the miter limit for miter joins.
                    \item \textbf{miterLimit()}: Retrieve the current miter limit.
                \end{itemize}
            \item \textbf{Cosmetic functions:} 
                \begin{itemize}
                    \item \textbf{setCosmetic(bool cosmetic)}: Set whether the pen is cosmetic.
                \end{itemize}
        \end{itemize}
    \end{concept}

    \pagebreak
    \subsection{QBrush}
    \bigbreak \noindent 
    \begin{concept}
        \textbf{QBrush} is used to define the fill pattern of shapes. It can be a solid color, a gradient, or a pattern.
        \begin{itemize}
            \item \textbf{Color functions:} 
                \begin{itemize}
                    \item \textbf{setColor(const QColor \&color)}: Set the color of the brush.
                    \item \textbf{color()}: Retrieve the current color of the brush.
                \end{itemize}
            \item \textbf{Style functions:} 
                \begin{itemize}
                    \item \textbf{setStyle(Qt::BrushStyle style)}: Set the style of the brush.
                    \item \textbf{style()}: Retrieve the current style of the brush.
                \end{itemize}
            \item \textbf{Texture functions:} 
                \begin{itemize}
                    \item \textbf{setTexture(const QPixmap \&pixmap)}: Set a pixmap as a texture for the brush.
                    \item \textbf{setTextureImage(const QImage \&image)}: Set an image as the texture for the brush.
                \end{itemize}
            \item \textbf{Gradient functions:} 
                \begin{itemize}
                    \item \textbf{setGradient(const QGradient \&gradient)}: Set a gradient for the brush.
                \end{itemize}
            \item \textbf{Transformation functions:} 
                \begin{itemize}
                    \item \textbf{setTransform(const QTransform \&transform)}: Apply transformations to the brush's pattern.
                \end{itemize}
        \end{itemize}
    \end{concept}

    \bigbreak \noindent 
    \subsection{Colors for pen and brush}
    \begin{itemize}
        \item \textbf{Qt::black}: Represents the color black.
        \item \textbf{Qt::white}: Represents the color white.
        \item \textbf{Qt::red}: Represents the color red.
        \item \textbf{Qt::green}: Represents the color green.
        \item \textbf{Qt::blue}: Represents the color blue.
        \item \textbf{Qt::cyan}: Represents the color cyan (a mix of green and blue).
        \item \textbf{Qt::magenta}: Represents the color magenta (a mix of red and blue).
        \item \textbf{Qt::yellow}: Represents the color yellow.
        \item \textbf{Qt::darkRed}: Represents a dark shade of red.
        \item \textbf{Qt::darkGreen}: Represents a dark shade of green.
        \item \textbf{Qt::darkBlue}: Represents a dark shade of blue.
        \item \textbf{Qt::darkCyan}: Represents a dark shade of cyan.
        \item \textbf{Qt::darkMagenta}: Represents a dark shade of magenta.
        \item \textbf{Qt::darkYellow}: Represents a dark shade of yellow.
        \item \textbf{Qt::gray}: Represents the color gray.
        \item \textbf{Qt::darkGray}: Represents a dark shade of gray.
        \item \textbf{Qt::lightGray}: Represents a light shade of gray.
        \item \textbf{Qt::transparent}: Represents a transparent color.
    \end{itemize}

    \pagebreak
    \subsection{QPainter methods}
    \begin{itemize}
        \item \textbf{setPen(const QPen \&pen)}: Sets the pen for the painter to \textit{pen}.
        \item \textbf{setBrush(const QBrush \&brush)}: Sets the brush for the painter to \textit{brush}.
        \item \textbf{setFont(const QFont \&font)}: Sets the font for the painter to \textit{font}.
        \item \textbf{setRenderHint(QPainter::RenderHint hint, bool on = true)}: Sets render hints for the painter.
        \item \textbf{save()}: Saves the current state of the painter.
        \item \textbf{restore()}: Restores the painter to its previously saved state.
        \item \textbf{begin(QPaintDevice *device)}: Begins painting on the specified device.
        \item \textbf{end()}: Ends the painting operation.
        \item \textbf{drawPoint(const QPoint \&point)}: Draws a point at the specified position.
        \item \textbf{drawLine(const QPoint \&p1, const QPoint \&p2)}: Draws a line between two points.
        \item \textbf{drawRect(const QRect \&rect)}: Draws a rectangle with the specified dimensions.
        \item \textbf{drawEllipse(const QRect \&rect)}: Draws an ellipse within the specified rectangle.
        \item \textbf{drawPolygon(const QPolygon \&polygon, Qt::FillRule fillRule = Qt::OddEvenFill)}: Draws a polygon with the specified points and fill rule.
        \item \textbf{drawText(const QRect \&rect, int flags, const QString \&text)}: Draws the specified text within the given rectangle.
        \item \textbf{drawImage(const QPoint \&point, const QImage \&image)}: Draws an image at the specified position.
        \item \textbf{drawPixmap(const QRect \&rect, const QPixmap \&pixmap)}: Draws a pixmap within the specified rectangle.
        \item \textbf{setTransform(const QTransform \&transform, bool combine = false)}: Sets a transformation matrix for the painter.
        \item \textbf{translate(const QPointF \&offset)}: Translates the coordinate system by the given offset.
        \item \textbf{rotate(qreal angle)}: Rotates the coordinate system by the specified angle.
        \item \textbf{scale(qreal sx, qreal sy)}: Scales the coordinate system by the given factors.
        \item \textbf{setClipRect(const QRect \&rect)}: Sets a clipping rectangle for the painter.
        \item \textbf{setOpacity(qreal opacity)}: Sets the opacity level for the painter.
    \end{itemize}

    
    \pagebreak
    \subsection{Shape Objects and their methods}
    \begin{itemize}
    \item \textbf{QRect}
        \begin{itemize}
            \item QRect()
            \item QRect(const QPoint \&topLeft, const QSize \&size)
            \item QRect(const QPoint \&topLeft, const QPoint \&bottomRight)
            \item QRect(int left, int top, int width, int height)
        \end{itemize}
    \item \textbf{QRectF}
        \begin{itemize}
            \item QRectF()
            \item QRectF(const QPointF \&topLeft, const QSizeF \&size)
            \item QRectF(const QPointF \&topLeft, const QPointF \&bottomRight)
            \item QRectF(qreal left, qreal top, qreal width, qreal height)
        \end{itemize}
    \item \textbf{QPoint}
        \begin{itemize}
            \item QPoint()
            \item QPoint(int xpos, int ypos)
        \end{itemize}
    \item \textbf{QPointF}
        \begin{itemize}
            \item QPointF()
            \item QPointF(qreal xpos, qreal ypos)
            \item QPointF(const QPoint \&point)
        \end{itemize}
    \item \textbf{QLine}
        \begin{itemize}
            \item QLine()
            \item QLine(const QPoint \&p1, const QPoint \&p2)
            \item QLine(int x1, int y1, int x2, int y2)
        \end{itemize}
    \item \textbf{QLineF}
        \begin{itemize}
            \item QLineF()
            \item QLineF(const QPointF \&p1, const QPointF \&p2)
            \item QLineF(qreal x1, qreal y1, qreal x2, qreal y2)
            \item QLineF(const QLine \&line)
        \end{itemize}
    \item \textbf{QPolygon}
        \begin{itemize}
            \item QPolygon()
            \item QPolygon(int size)
            \item QPolygon(const QPolygon \&polygon)
            \item QPolygon(const QVector<QPoint> \&points)
            \item QPolygon(const QRect \&rectangle, bool closed = false)
        \end{itemize}
    \item \textbf{QPolygonF}
        \begin{itemize}
            \item QPolygonF()
            \item QPolygonF(int size)
            \item QPolygonF(const QPolygonF \&polygon)
            \item QPolygonF(const QVector<QPointF> \&points)
            \item QPolygonF(const QRectF \&rectangle)
        \end{itemize}
    \item \textbf{QRegion}
        \begin{itemize}
            \item QRegion()
            \item QRegion(const QRegion \&region)
            \item QRegion(const QRect \&rect, QRegion::RegionType type = QRegion::Rectangle)
            \item QRegion(int x, int y, int w, int h, QRegion::RegionType type = QRegion::Rectangle)
        \end{itemize}
    \item \textbf{QSize}
        \begin{itemize}
            \item QSize()
            \item QSize(int width, int height)
        \end{itemize}
    \item \textbf{QSizeF}
        \begin{itemize}
            \item QSizeF()
            \item QSizeF(qreal width, qreal height)
            \item QSizeF(const QSize \&sz)
        \end{itemize}
    \item \textbf{QVector2D}
        \begin{itemize}
            \item QVector2D()
            \item QVector2D(qreal xpos, qreal ypos)
            \item QVector2D(const QPoint \&point)
            \item QVector2D(const QPointF \&point)
        \end{itemize}
    \item \textbf{QVector3D}
        \begin{itemize}
            \item QVector3D()
            \item QVector3D(qreal xpos, qreal ypos, qreal zpos)
            \item QVector3D(const QPoint \&point)
            \item QVector3D(const QPointF \&point)
        \end{itemize}
    \item \textbf{QVector4D}
        \begin{itemize}
            \item QVector4D()
            \item QVector4D(qreal xpos, qreal ypos, qreal zpos, qreal wpos)
            \item QVector4D(const QVector2D \&vector)
            \item QVector4D(const QVector3D \&vector)
            \item QVector4D(const QVector3D \&vector, qreal wpos)
        \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Drawing the objects}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{drawLine(const QPoint \&p1, const QPoint \&p2)}: Draws a line between the points \textit{p1} and \textit{p2}.
        \item \textbf{drawRect(const QRect \&rect)}: Draws the outline of a rectangle specified by \textit{rect}.
        \item \textbf{fillRect(const QRect \&rect, const QBrush \&brush)}: Fills the rectangle \textit{rect} with the brush \textit{brush}.
        \item \textbf{drawEllipse(const QRect \&rect)}: Draws an ellipse inscribed in the rectangle \textit{rect}.
        \item \textbf{drawPolygon(const QPolygon \&polygon, Qt::FillRule fillRule = Qt::OddEvenFill)}: Draws a polygon defined by \textit{polygon} with the specified fill rule.
        \item \textbf{drawArc(const QRect \&rect, int startAngle, int spanAngle)}: Draws an arc defined by the rectangle \textit{rect}, starting at \textit{startAngle} and spanning \textit{spanAngle}.
        \item \textbf{drawPie(const QRect \&rect, int startAngle, int spanAngle)}: Draws a pie section defined by the rectangle \textit{rect}, starting at \textit{startAngle} and spanning \textit{spanAngle}.
        \item \textbf{drawChord(const QRect \&rect, int startAngle, int spanAngle)}: Draws a chord (a segment of an ellipse) defined by the rectangle \textit{rect}, starting at \textit{startAngle} and spanning \textit{spanAngle}.
        \item \textbf{drawText(const QRect \&rect, int flags, const QString \&text)}: Draws the text \textit{text} within the rectangle \textit{rect}, using the alignment flags \textit{flags}.
        \item \textbf{drawImage(const QRect \&target, const QImage \&image, const QRect \&source)}: Draws the part of the image \textit{image} specified by \textit{source} into the rectangle \textit{target}.
    \end{itemize}

    \bigbreak \noindent 
    \begin{notebox}
       Only use one painter object per paintevent 
    \end{notebox}
    

    \pagebreak
    \unsect{QColor (defining colors)}
    \bigbreak \noindent 
    \begin{concept}
        In Qt, you can use HTML-style color codes with QColor and then set that QColor to a QBrush. HTML-style color codes are typically hex values prefixed with a hash (\#). Here's how you can modify your code to use an HTML color for your QBrush:
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QColor>

    QColor mycolor("#808080");
    QBrush newbrush(mycolor);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Gradients}
    \subsubsection{Header}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QGradient>
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Types of Gradients}
    \begin{itemize}
        \item \textbf{QLinearGradient(x1,y1,x2,y2)}
            \begin{itemize}
                \item (x1, y1) and (x2, y2) are the starting and ending points of the gradient line.
            \end{itemize}
        \item \textbf{QRadialGradient(cx, cy, radius, fx, fy)}
            \begin{itemize}
                \item (cx, cy) is the center of the circle.
                \item radius is the radius of the circle.
                \item (fx, fy) is the focal point of the gradient; if not set, it defaults to the center.
            \end{itemize}
        \item \textbf{QConicalGradient(cx, cy, startAngl)}
            \begin{itemize}
                \item (cx, cy) is the center point of the gradient.
                \item startAngle is the angle in degrees at which the gradient starts.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{setColorAt}
    \bigbreak \noindent 
    To set the colors of the Gradient objects, we use the \textbf{setColorAt()} function. This function has the following signature
    \begin{itemize}
        \item \textbf{setColorAt(qreal position, const QColor\& color)}
            \begin{itemize}
                \item \textbf{position:} A qreal value (a floating-point number) that represents the position along the gradient's axis. For linear and radial gradients, this value is typically between 0.0 and 1.0, where 0.0 represents the start of the gradient and 1.0 represents the end. In a conical gradient, it represents an angle in degrees.
                \item \textbf{color:} A QColor object representing the color to be used at the specified position.
            \end{itemize}
    \end{itemize}


    \pagebreak
    \unsect{Stylesheets}
    \bigbreak \noindent 
    \begin{concept}
        Qt Stylesheets provide a powerful mechanism for customizing the appearance of widgets in a Qt application, similar to how CSS is used for styling web pages. Here's a brief overview of how they work: 
        \begin{itemize}
            \item \textbf{CSS-like Syntax:} Qt Stylesheets use a syntax similar to Cascading Style Sheets (CSS) in web development. They allow you to define the appearance of widgets using style rules.
            \item \textbf{Selector and Declaration:} Each stylesheet rule consists of a selector and a declaration block. The selector specifies which widget or widgets the rule applies to, and the declaration block defines one or more properties to style these widgets.
        \end{itemize}
    \end{concept}
    \bigbreak \noindent 
    \textbf{Example:}
    \bigbreak \noindent 
    \begin{cppcode}
        button = new QPushButton("Example", this);
        button->setGeometry(50,50,150,100);
        button->setStyleSheet("QPushButton {"
                      "  border: 2px solid black;"  
                      "  border-radius: 50px;"
                      "  background-color: lightgray;"  
                      "  color: black;"  
                      "}"
                      "QPushButton:hover {"
                      "  background-color: gray;"  
                      "}"
                      "QPushButton:pressed {"
                      "  background-color: darkgray;"  
                      "}");
    \end{cppcode}

    \pagebreak 
    \unsect{Other QWidget Children}
    \begin{enumerate}[label=\textbf{\arabic*.}]
        \item \textbf{QLineEdit}: Allows single line text editing.
        \item \textbf{QTextEdit}: A rich text editor widget which allows multi-line text editing.
        \item \textbf{QComboBox}: A combined button and dropdown list.
        \item \textbf{QCheckBox}: A checkbox with a text label.
        \item \textbf{QRadioButton}: A radio button, typically used in groups to select one of many options.
        \item \textbf{QSlider}: A slider widget for selecting a value from a range.
        \item \textbf{QSpinBox}: Allows input of a single number through a spin box interface.
        \item \textbf{QDoubleSpinBox}: Like QSpinBox, but for decimal numbers.
        \item \textbf{QProgressBar}: Shows progress of a lengthy operation.
        \item \textbf{QScrollBar}: A scrollbar widget.
        \item \textbf{QDial}: A circular dial used to select a value.
        \item \textbf{QTabWidget}: Allows tabbed navigation between different widgets.
        \item \textbf{QListWidget}: Displays a list of items.
        \item \textbf{QTreeWidget}: Displays items in a tree structure.
        \item \textbf{QTableWidget}: Displays items in a table format.
        \item \textbf{QGroupBox}: Groups related widgets together in a box.
        \item \textbf{QStackedWidget}: Stacks widgets on top of one another; only one is visible at a time.
        \item \textbf{QMainWindow}: The main window class, providing a framework for windowed applications.
        \item \textbf{QDialog}: Used for creating dialog windows.
    \end{enumerate}

    \pagebreak 
    \unsect{QWidget Methods}
    \bigbreak \noindent 
    \begin{enumerate}
         \item \textbf{Display Control:}
        \begin{itemize}
            \item void show()
            \item void hide()
            \item void setVisible(bool)
            \item void setEnabled(bool)
        \end{itemize}

        \item \textbf{Geometry and Positioning:}
        \begin{itemize}
            \item void setGeometry(int x, int y, int width, int height)
            \item void move(int x, int y)
            \item void resize(int width, int height)
            \item QRect geometry() const
            \item QSize size() const
            \item int width() const
            \item int height() const
            \item QPoint pos() const
        \end{itemize}

        \item \textbf{Layout Management:}
        \begin{itemize}
            \item void setLayout(QLayout *layout)
            \item QLayout *layout() const
        \end{itemize}

        \item \textbf{Style and Appearance:}
        \begin{itemize}
            \item void setStyleSheet(const QString \&styleSheet)
            \item QString styleSheet() const
            \item void setPalette(const QPalette \&palette)
            \item QPalette palette() const
        \end{itemize}

        \item \textbf{Event Handling:}
        \begin{itemize}
            \item void installEventFilter(QObject *filterObj)
            \item bool event(QEvent *event)
            \item void update()
        \end{itemize}

        \item \textbf{Parent-Child Relationship:}
        \begin{itemize}
            \item void setParent(QWidget *parent)
            \item QWidget *parentWidget() const
        \end{itemize}

        \item \textbf{Window and Dialog Functions:}
        \begin{itemize}
            \item void setWindowTitle(const QString \&title)
            \item QString windowTitle() const
            \item void setWindowIcon(const QIcon \&icon)
            \item QIcon windowIcon() const
            \item void setWindowFlags(Qt::WindowFlags type)
            \item Qt::WindowFlags windowFlags() const
            \item bool isWindow() const
            \item bool isModal() const
        \end{itemize}

        \item \textbf{Size Constraints:}
        \begin{itemize}
            \item void setFixedSize(int w, int h)
            \item void setFixedSize(const QSize \&size)
            \item void setMinimumSize(int minw, int minh)
            \item void setMaximumSize(int maxw, int maxh)
        \end{itemize}

        \item \textbf{Focus Handling:}
        \begin{itemize}
            \item void setFocus()
            \item bool hasFocus() const
            \item void setFocusPolicy(Qt::FocusPolicy policy)
        \end{itemize}
    \end{enumerate}


    \pagebreak 
    \unsect{Button Methods}
    \bigbreak \noindent 
    \begin{enumerate}
     \item \textbf{Setting Button Properties:}
        \begin{itemize}
            \item void setDefault(bool)
            \item void setFlat(bool)
            \item void setMenu(QMenu *)
            \item void setShowMenuInside(bool)
        \end{itemize}

        \item \textbf{Accessing Button Properties:}
        \begin{itemize}
            \item bool isDefault() const
            \item bool isFlat() const
            \item QMenu *menu() const
        \end{itemize}

        \item \textbf{Auto-Repeat Functionality (Inherited from QAbstractButton):}
        \begin{itemize}
            \item void setAutoRepeat(bool)
            \item void setAutoRepeatDelay(int)
            \item void setAutoRepeatInterval(int)
        \end{itemize}

        \item \textbf{Handling Pressed and Released States:}
        \begin{itemize}
            \item void setDown(bool)
        \end{itemize}

        \item \textbf{Signals:}
        \begin{itemize}
            \item void clicked(bool checked = false)
            \item void pressed()
            \item void released()
            \item void toggled(bool)
        \end{itemize}

        \item \textbf{Methods Inherited from QAbstractButton and QWidget:}
        \begin{itemize}
            \item void setText(const QString \&)
            \item QString text() const
            \item void setIcon(const QIcon \&)
            \item QIcon icon() const
            \item void setChecked(bool)
            \item bool isChecked() const
            \item void toggle()
        \end{itemize}
        \item \textbf{Size Control (Inherited from QWidget):}
    \begin{itemize}
        \item void setFixedSize(int width, int height): Sets both the width and height of the button.
        \item void setFixedWidth(int width): Sets only the width of the button.
        \item void setFixedHeight(int height): Sets only the height of the button.
        \item void resize(int width, int height): Adjusts the size of the button.
    \end{itemize}

    \item \textbf{Size Information (Inherited from QWidget):}
    \begin{itemize}
        \item QSize size() const: Returns the size of the button.
        \item int width() const: Returns the width of the button.
        \item int height() const: Returns the height of the button.
    \end{itemize}
    \end{enumerate}

    \pagebreak 
    \unsect{Label Methods}
    \begin{enumerate}[label=\textbf{\arabic*.}]
        \item \textbf{Constructor and Destructor:}
        \begin{itemize}
            \item QLabel(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags())
            \item QLabel(const QString \&text, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags())
            \item \~QLabel()
        \end{itemize}

        \item \textbf{Setting Text and Image:}
        \begin{itemize}
            \item void setText(const QString \&)
            \item void setPixmap(const QPixmap \&)
            \item void setPicture(const QPicture \&)
            \item void setMovie(QMovie *)
        \end{itemize}

        \item \textbf{Text and Image Information:}
        \begin{itemize}
            \item QString text() const
            \item const QPixmap *pixmap() const
            \item const QPicture *picture() const
            \item QMovie *movie() const
        \end{itemize}

        \item \textbf{Appearance and Alignment:}
        \begin{itemize}
            \item void setAlignment(Qt::Alignment)
            \item Qt::Alignment alignment() const
            \item void setWordWrap(bool)
            \item bool wordWrap() const
        \end{itemize}

        \item \textbf{Size Control (Inherited from QWidget):}
        \begin{itemize}
            \item void setFixedSize(int width, int height)
            \item void setFixedWidth(int width)
            \item void setFixedHeight(int height)
            \item void resize(int width, int height)
        \end{itemize}

        \item \textbf{Size Information (Inherited from QWidget):}
        \begin{itemize}
            \item QSize size() const
            \item int width() const
            \item int height() const
        \end{itemize}
        
        \item \textbf{Other QLabel-Specific Features:}
        \begin{itemize}
            \item void setIndent(int)
            \item int indent() const
            \item void setMargin(int)
            \item int margin() const
            \item void setTextFormat(Qt::TextFormat)
            \item Qt::TextFormat textFormat() const
        \end{itemize}
    \end{enumerate}



    \pagebreak 
    \unsect{Responsive Design}
    \bigbreak \noindent 
    \begin{concept}
       Responsive design in Qt refers to the practice of creating user interfaces (UIs) that adapt to various screen sizes and resolutions, ensuring a consistent and functional experience across different devices. Qt, being a versatile framework for both widget-based and QML-based UI development, provides several tools and techniques to achieve responsive design: 
    \end{concept}
    \begin{enumerate}
        \item \textbf{Layout Managers:}
            \begin{itemize}
                \item Qt's layout managers (QHBoxLayout, QVBoxLayout, QGridLayout, etc.) automatically adjust the size and position of widgets within a window or a parent widget.
                \item They respond to window resize events and reorganize the contained widgets accordingly, maintaining their relative positions and sizes.
           \end{itemize}
       \item \textbf{Size Policies:}
           \begin{itemize}
               \item Widgets in Qt have size policies (QSizePolicy) that determine how they grow or shrink in response to available space.
               \item These policies can be set to make widgets more flexible or rigid in their size adjustments.
           \end{itemize}
       \item \textbf{Scalable Units:}
           \begin{itemize}
               \item Using scalable units like points or ems for dimensions instead of fixed pixel sizes helps maintain the UI's appearance across different screen resolutions.
               \item Qt Quick's GridUnit and dp (density-independent pixels) are examples of scalable units.
           \end{itemize}
    \end{enumerate}

    \bigbreak \noindent 
    \subsection{Layout Managers}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QLayout>
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{QHBoxLayout} 
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QHBoxLayout>
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Purpose:} QHBoxLayout arranges child widgets in a horizontal line.
        \item \textbf{Usage:} It's typically used when you want to place widgets next to each other from left to right.
        \item \textbf{Spacing and Alignment:} It automatically manages the spacing between widgets and can align them in various ways (left, center, right).
        \item \textbf{Stretch Factors:} You can assign stretch factors to child widgets to control how much space each widget occupies relative to the others.
        \item \textbf{Example:} Placing a label and a line edit horizontally, where the label is the description and the line edit is the field for user input.
    \end{itemize}

    \pagebreak 
    \subsubsection{QVBoxLayout}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QVBoxLayout>
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Purpose:} QVBoxLayout arranges child widgets in a vertical column.
        \item \textbf{Usage:} It's used when you want to stack widgets on top of each other from top to bottom.
        \item \textbf{Spacing and Alignment:} Like QHBoxLayout, it manages the spacing and supports various alignment options (top, center, bottom).
        \item \textbf{Stretch Factors:} You can also assign stretch factors to dictate the relative space each widget takes up.
        \item \textbf{Example:} Creating a form layout where each label and input field pair is stacked vertically.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{QHBoxLayout and QVBoxLayout Methods}
    \begin{enumerate}[label=\textbf{\arabic*.}]
    \item \textbf{Methods from QBoxLayout:}
    \begin{itemize}
        \item void \textbf{addWidget}(QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0)
        \begin{itemize}
            \item Adds a widget to the end of the layout with optional stretch factor and alignment.
        \end{itemize}
        
        \item void \textbf{addLayout}(QLayout *layout, int stretch = 0)
        \begin{itemize}
            \item Adds a nested layout to the end of this layout with optional stretch factor.
        \end{itemize}
        
        \item void \textbf{addStretch}(int stretch = 0)
        \begin{itemize}
            \item Adds a stretchable space with a stretch factor to the layout.
        \end{itemize}
        
        \item void \textbf{insertWidget}(int index, QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0)
        \begin{itemize}
            \item Inserts a widget into the layout at the specified index.
        \end{itemize}
        
        \item void \textbf{insertLayout}(int index, QLayout *layout, int stretch = 0)
        \begin{itemize}
            \item Inserts a nested layout at a specified index in this layout.
        \end{itemize}
        
        \item void \textbf{insertStretch}(int index, int stretch = 0)
        \begin{itemize}
            \item Inserts a stretchable space at a specified index in the layout.
        \end{itemize}
        
        \item bool \textbf{setStretchFactor}(QWidget *widget, int stretch)
        \begin{itemize}
            \item Sets the stretch factor for a widget in this layout.
        \end{itemize}
        
        \item bool \textbf{setStretchFactor}(QLayout *layout, int stretch)
        \begin{itemize}
            \item Sets the stretch factor for a nested layout in this layout.
        \end{itemize}
    \end{itemize}

    \item \textbf{Methods from QLayout:}
    \begin{itemize}
        \item void \textbf{setAlignment}(QWidget *widget, Qt::Alignment alignment)
        \begin{itemize}
            \item Sets the alignment for a widget in this layout.
        \end{itemize}
        
        \item void \textbf{setAlignment}(QLayout *layout, Qt::Alignment alignment)
        \begin{itemize}
            \item Sets the alignment for a nested layout in this layout.
        \end{itemize}
        
        \item void \textbf{setSizeConstraint}(QLayout::SizeConstraint constraint)
        \begin{itemize}
            \item Sets the size constraint for this layout.
        \end{itemize}
        
        \item QLayout::SizeConstraint \textbf{sizeConstraint}() const
        \begin{itemize}
            \item Returns the size constraint of this layout.
        \end{itemize}
        
        \item void \textbf{setSpacing}(int spacing)
        \begin{itemize}
            \item Sets the spacing between widgets in this layout.
        \end{itemize}
        
        \item int \textbf{spacing}() const
        \begin{itemize}
            \item Returns the spacing between widgets in this layout.
        \end{itemize}
        
        \item void \textbf{setContentsMargins}(int left, int top, int right, int bottom)
        \begin{itemize}
            \item Sets the margins around the layout.
        \end{itemize}
        
        \item void \textbf{getContentsMargins}(int *left, int *top, int *right, int *bottom) const
        \begin{itemize}
            \item Retrieves the margins around the layout.
        \end{itemize}
        
        \item QRect \textbf{geometry}() const
        \begin{itemize}
            \item Returns the geometry of the layout.
        \end{itemize}
        
        \item bool \textbf{isActive}() const
        \begin{itemize}
            \item Returns true if the layout is enabled; otherwise returns false.
        \end{itemize}
        
        \item QWidget* \textbf{parentWidget}() const
        \begin{itemize}
            \item Returns the parent widget of this layout.
        \end{itemize}
        \end{itemize}
    \end{enumerate}

    \pagebreak \bigbreak \noindent 
    \subsection{QVBoxLayout Example}
    \bigbreak \noindent 
    Consider the code snippet
    \bigbreak \noindent 
    \begin{cppcode}

        // Create a container for our vboxlayout and the vboxlayout itself
        QWidget* layoutContainer = new QWidget(this);
        QVBoxLayout* layout = new QVBoxLayout;

        // Create some buttons
        QPushButton* button1 = new QPushButton("1", this);
        QPushButton* button2 = new QPushButton("1", this);

        // Add the buttons to the layout
        layout->addWidget(button1);
        layout->addWidget(button2);

        // Set the container as the container
        layoutContainer->setLayout(layout);

    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Importance of Setting the Layout at the End}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Layout Initialization:} It's crucial to add all widgets you want to be managed by the layout before setting the layout on the container. This ensures that when the layout is applied, it already contains all the widgets it needs to manage.
        \item \textbf{Efficient Redrawing:} Setting a layout on a widget can trigger a redraw of the widget and its children. If you set the layout before adding all the widgets, there could be unnecessary redraws and layout recalculations each time a new widget is added.
        \item \textbf{Avoiding Layout Conflicts:} Once a layout is set on a widget, adding the widget to another layout would cause issues, as a widget (or layout) can only belong to one layout at a time. Setting the layout at the end avoids such conflicts or double management.
    \end{itemize}

    \pagebreak 
    \unsect{The resizeEvent override}
    \bigbreak \noindent 
    \begin{concept}
        The resizeEvent is an important event in Qt that is triggered whenever a widget undergoes a resize operation. This event is part of the event handling mechanism in Qt, which is central to its graphical user interface (GUI) framework.
    \end{concept}
    \begin{itemize}
        \item \textbf{What is resizeEvent?}
            \begin{itemize}
                \item The resizeEvent is a function that is called automatically by the Qt framework when the size of a widget changes. This includes when the widget is first shown (as it is sized to fit the contents or the specified dimensions), and when it is resized manually by the user (like adjusting the size of a window).
            \end{itemize}
        \item \textbf{Declaration and Usage:}
            \begin{itemize}
                \item The resizeEvent is a protected member function of the QWidget class. It can be overridden in a subclass to implement custom behavior when the widget is resized.
                \item The function signature is: void resizeEvent(QResizeEvent *event);
            \end{itemize}
        \item \textbf{Purpose:}
            \begin{itemize}
                \item The primary purpose of overriding resizeEvent is to perform tasks that are necessary when the widget changes size. This could include adjusting the layout of child widgets, reallocating resources, or redrawing graphics.
                \item For example, in a custom widget displaying a graph, you might need to recalculate the graph's dimensions and redraw it to fit the new size.
            \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
void MainWindow::resizeEvent(QResizeEvent* event) override {
    // Call base class implementation (important for proper functionality)
    QWidget::resizeEvent(event);

    // Recalculate the width of the left divider
    leftDividerEndX = (this->width() / 5) - 15;

    for (auto it = buttons.begin(); it != buttons.end(); ++it) {
        (*it)->setFixedWidth(leftDividerEndX);
    }

    if (selectorHead) {
        selectorHead->setFixedWidth(leftDividerEndX);
    }
}

    \end{cppcode}
    





    







    
    
\end{document}
