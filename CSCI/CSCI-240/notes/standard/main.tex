\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\lhead{Warner \thepage}
\rhead{}
% \lhead{\leftmark}
\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ STL} \\
           Standard library (Functions etc.)
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak \bigbreak \noindent
    \section{\LARGE C++ Strings (<string>)}
    \bigbreak \noindent 
    \begin{interlude}
       Before we begin with the C++ string methods, there are two things to know.
       \begin{itemize}
           \item \textbf{size\_t}: an unsigned integral type, and it's designed to be able to represent the size of any object in bytes
            \item \textbf{npos}: (Constant) It's the largest possible value representable by the size\_type of std::string
       \end{itemize}
    \end{interlude}
    \bigbreak \noindent 
    \nt{size\_t is used as the return value for methods such as "find" to indicate unsuccessful}
    
    \bigbreak \noindent 
    \subsection{Element Access}
    \begin{itemize}
        \item \textbf{at(r:size\_t pos):}$\mapsto$ char\& --- Returns a reference to the character at the specified position. Store return value in char\&
        \item \textbf{str.front():}$\mapsto$ char\& --- returns reference to the first character. 
        \item \textbf{str.back():}$\mapsto$ char\& --- returns a reference to the last character. 
        \item \textbf{str.c\_str():}$\rightarrow$ const char* pointing to the null-terminated character array.
        \item \textbf{str.data():}$\to$ const char* pointing to the underlying character array.        
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Capacity}
    \begin{itemize}
        \item \textbf{str.length():}$\mapsto$ size\_t --- Returns the number of characters in the string 
        \item \textbf{str.size():}$\mapsto$ size\_t --- Returns the number of characters in the string 
        \item \textbf{str.empty():}$\mapsto$ bool --- Returns true if the string is empty, false otherwise 
        \item \textbf{resize(r:size\_t n, o:char c):}$\mapsto$ void --- Resizes the string to contain $n$ characters.
        \item \textbf{capacity():}$\mapsto$ size\_t --- Returns the size of the storage space currently allocated 
        \item \textbf{reserve(size\_t new\_cap):}$\mapsto$ void --- Reserves storage (increases capacity).
        \item \textbf{max\_size():}$\mapsto$ size\_t --- Returns the maximum number of characters the string can hold 
        \item \textbf{shrink\_to\_fit():}$\mapsto$ void --- Reduces memory usage by freeing unused memory 
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Modifiers}
    \begin{itemize}
        \item \textbf{append(string str):}$\mapsto$ std::string\& mutated\_string --- String to append. (Has other overloads.) (Doesnt need to be saved in T\&)
        \item \textbf{push\_back(char c):}$\mapsto$ void --- Character to append.
        \item \textbf{assign(string str, o:start,o:stop):}$\mapsto$ std::string\& mutated\_string  --- used to replace the current content of the string with a new set of characters. (Has other overloads.)
        \item \textbf{insert(size\_t pos, string str):}$\mapsto$ std::string\& mutated\_str --- Position and string to insert. (Has other overloads.)
        \item \textbf{replace(size\_t pos, size\_t len, string str):}$\mapsto $ mutated\_string --- Position, length, and string for replacement. (Has other overloads.)
        \item \textbf{swap(string str):}$\mapsto$ void --- String to swap with.
        \item \textbf{pop\_back():} $\mapsto$ void --- Removes the last character in the string
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \subsection{String Operations}
    \begin{itemize}
        \item \textbf{substr(pos, o:len):}$\mapsto$ string --- Generate a substr from a string 
        \item \textbf{copy(char[] dest, o:len, pos):}$\mapsto$ size\_t (number of characters that were copied) send contents of string to some character array
        \item \textbf{find(substr, o:pos):}$\mapsto$ size\_t=npos find a substr from within a string
        \item \textbf{rfind(substr, o:pos):}$\mapsto$ size\_t=npos  find a substr form withing as string, starting search from the end of the string
        \item \textbf{find\_first\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos Find character in string (public member function)
        \item \textbf{find\_last\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos	Find character in string from the end (public member function)
        \item \textbf{find\_first\_not\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos	Find absence of character in string (public member function)
        \item \textbf{find\_last\_not\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos	Find non-matching character in string from the end (public member function)
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Comparison}
    \begin{itemize}
        \item \textbf{compare(o:pos, o:len, str):}$\mapsto$ unsigned integral
            \begin{itemize}
                \item 0: they compare equal 
                \item <0: Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter.
                \item >0: Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversions (These are functions)}
    \begin{itemize}
        \item \textbf{stoi(str, o:idx, o:base):}$\mapsto$ int (idx is a pointer to a size\_t object)
        \item \textbf{stol(str, o:idx, o:base):}$\mapsto$ long
        \item \textbf{stoul(str, o:idx, o:base):}$\mapsto$ unsigned long
        \item \textbf{stoll(str, o:idx, o:base):}$\mapsto$ long long
        \item \textbf{stoull(str, o:idx, o:base):}$\mapsto$ unsigned long long
        \item \textbf{stof(str, o:idx):}$\mapsto$ float
        \item \textbf{stod(str, o:idx):}$\mapsto$ double
        \item \textbf{stold(str, o:idx):}$\mapsto$ long double
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE C-strings (<cstring>)}
    \bigbreak \noindent 
    \subsection{Manipulation}
    \begin{itemize}
        \item \textbf{strncpy(char[] dest, char[] src, size\_t n):}$\mapsto$ const char* --- Copy up to n characters from the string src to dest.
        \item \textbf{strcpy(char[] dest, char[] src)}$\mapsto$ const char* ---- Copies the C string pointed by source into the array pointed by destination
        \item \textbf{strncat(char[] dest, char[] src, size\_t n):}$\mapsto$ const char* --- Append up to n characters from the string src onto the end of dest.
        \item \textbf{strcat(char[] dest, char[] src)}$\mapsto$ const char* --- Appends a copy of the source string to the destination string.
        \bigbreak \noindent 
        \textbf{Note:} cpy functions return a const char* comprised of the characters from the src array that were used.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Examination}
    \begin{itemize}
        \item \textbf{strnlen(char[] src, size\_t maxlen)}$\mapsto$ size\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strlen(char[] src):}$\mapsto$ size\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strncmp(char[] src1, char[] src2, size\_t n):}$\mapsto$ uint (value varies) --- Compare up to n characters of two strings.
        \item \textbf{strcmp(char[] src1, char[] src2)}$\mapsto$ size\_t (value varires) --- compare two strings
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Searching}
    \begin{itemize}
        \item \textbf{strchr(char[] src, char c):}$\mapsto$ char* ---- get pointer to the first occurrence of character c in the string s, or nullptr if c is not found.
        \item \textbf{strrchr(char[] src, char c):}$\mapsto$ char* --- get pointer to the last occurrence of character c in the string s.
        \item \textbf{strstr(char[] src, char[] str):}$\mapsto$ const char* --- Return a pointer to the first occurrence of the substring 
        \item \textbf{strspn(char[] src, char[] charset):}$\mapsto$ size\_t --- Returns the length of the initial portion of str1 which consists only of characters that are part of str2.
        \item \textbf{strcspn(char[] src, char[] charset):}$\mapsto$ size\_t --- Get position of first character found from charset 
        \item \textbf{strpbrk(char[] src, char[] charset):}$\mapsto$ const char* --- Return string consisting of first match form character set in string onward
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Error}
    \begin{itemize}
        \item \textbf{strerror(errno)}$\mapsto$ const char* ---  Get pointer to error message string (we are literally passing in the defined variable \textit{errno})
            \begin{verbatim}
std::ifstream inf("file.txt");
if (inf.fail()) { cout << strerrror(errno); } // No such file in directory 
(Because that is what the error string is set to after inf.fail())
            \end{verbatim}
        we also have control over the error we can pass in, errors that are defined in <cerrno>. Rather than leaving it up to errno. We have:
    \begin{description}
      \item[E2BIG (C++11)] Argument list too long (macro constant)
      \item[EACCES (C++11)] Permission denied (macro constant)
      \item[EADDRINUSE (C++11)] Address in use (macro constant)
      \item[EADDRNOTAVAIL (C++11)] Address not available (macro constant)
      \item[EAFNOSUPPORT (C++11)] Address family not supported (macro constant)
      \item[EAGAIN (C++11)] Resource unavailable, try again (macro constant)
      \item[EALREADY (C++11)] Connection already in progress (macro constant)
      \item[EBADF (C++11)] Bad file descriptor (macro constant)
      \item[EBADMSG (C++11)] Bad message (macro constant)
      \item[EBUSY (C++11)] Device or resource busy (macro constant)
      \item[ECANCELED (C++11)] Operation canceled (macro constant)
      \item[ECHILD (C++11)] No child processes (macro constant)
      \item[ECONNABORTED (C++11)] Connection aborted (macro constant)
      \item[ECONNREFUSED (C++11)] Connection refused (macro constant)
      \item[ECONNRESET (C++11)] Connection reset (macro constant)
      \item[EDEADLK (C++11)] Resource deadlock would occur (macro constant)
      \item[EDESTADDRREQ (C++11)] Destination address required (macro constant)
      \item[EDOM] Mathematics argument out of domain of function (macro constant)
      \item[EEXIST (C++11)] File exists (macro constant)
      \item[EFAULT (C++11)] Bad address (macro constant)
      \item[EFBIG (C++11)] File too large (macro constant)
      \item[EHOSTUNREACH (C++11)] Host is unreachable (macro constant)
      \item[EIDRM (C++11)] Identifier removed (macro constant)
      \item[EILSEQ] Illegal byte sequence (macro constant)
      \item[EINPROGRESS (C++11)] Operation in progress (macro constant)
      \item[EINTR (C++11)] Interrupted function (macro constant)
      \item[EINVAL (C++11)] Invalid argument (macro constant)
      \item[EIO (C++11)] I/O error (macro constant)
      \item[EISCONN (C++11)] Socket is connected (macro constant)
      \item[EISDIR (C++11)] Is a directory (macro constant)
      \item[ELOOP (C++11)] Too many levels of symbolic links (macro constant)
      \item[EMFILE (C++11)] File descriptor value too large (macro constant)
      \item[EMLINK (C++11)] Too many links (macro constant)
      \item[EMSGSIZE (C++11)] Message too large (macro constant)
      \item[ENAMETOOLONG (C++11)] Filename too long (macro constant)
      \item[ENETDOWN (C++11)] Network is down (macro constant)
      \item[ENETRESET (C++11)] Connection aborted by network (macro constant)
      \item[ENETUNREACH (C++11)] Network unreachable (macro constant)
      \item[ENFILE (C++11)] Too many files open in system (macro constant)
      \item[ENOBUFS (C++11)] No buffer space available (macro constant)
      \item[ENODATA (C++11)(deprecated in C++23)] No message is available on the STREAM head read queue (macro constant)
      \item[ENODEV (C++11)] No such device (macro constant)
      \item[ENOENT (C++11)] No such file or directory (macro constant)
      \item[ENOEXEC (C++11)] Executable file format error (macro constant)
      \item[ENOLCK (C++11)] No locks available (macro constant)
      \item[ENOLINK (C++11)] Link has been severed (macro constant)
      \item[ENOMEM (C++11)] Not enough space (macro constant)
      \item[ENOMSG (C++11)] No message of the desired type (macro constant)
      \item[ENOPROTOOPT (C++11)] Protocol not available (macro constant)
      \item[ENOSPC (C++11)] No space left on device (macro constant)
      \item[ENOSR (C++11)(deprecated in C++23)] No STREAM resources (macro constant)
      \item[ENOSTR (C++11)(deprecated in C++23)] Not a STREAM (macro constant)
      \item[ENOSYS (C++11)] Function not supported (macro constant)
      \item[ENOTCONN (C++11)] The socket is not connected (macro constant)
      \item[ENOTDIR (C++11)] Not a directory (macro constant)
      \item[ENOTEMPTY (C++11)] Directory not empty (macro constant)
      \item[ENOTRECOVERABLE (C++11)] State not recoverable (macro constant)
      \item[ENOTSOCK (C++11)] Not a socket (macro constant)
      \item[ENOTSUP (C++11)] Not supported (macro constant)
      \item[ENOTTY (C++11)] Inappropriate I/O control operation (macro constant)
      \item[ENXIO (C++11)] No such device or address (macro constant)
      \item[EOPNOTSUPP (C++11)] Operation not supported on socket (macro constant)
      \item[EOVERFLOW (C++11)] Value too large to be stored in data type (macro constant)
      \item[EOWNERDEAD (C++11)] Previous owner died (macro constant)
      \item[EPERM (C++11)] Operation not permitted (macro constant)
      \item[EPIPE (C++11)] Broken pipe (macro constant)
      \item[EPROTO (C++11)] Protocol error (macro constant)
      \item[EPROTONOSUPPORT (C++11)] Protocol not supported (macro constant)
      \item[EPROTOTYPE (C++11)] Protocol wrong type for socket (macro constant)
      \item[ERANGE] Result too large (macro constant)
      \item[EROFS (C++11)] Read-only file system (macro constant)
      \item[ESPIPE (C++11)] Invalid seek (macro constant)
      \item[ESRCH (C++11)] No such process (macro constant)
      \item[ETIME (C++11)(deprecated in C++23)] Stream ioctl() timeout (macro constant)
      \item[ETIMEDOUT (C++11)] Connection timed out (macro constant)
      \item[ETXTBSY (C++11)] Text file busy (macro constant)
      \item[EWOULDBLOCK (C++11)] Operation would block (macro constant)
      \item[EXDEV (C++11)] Cross-device link (macro constant)
    \end{description}

    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversion}
    \begin{itemize}
        \item \textbf{atoi(char[])} - Converts a C-string to an int.
        \item \textbf{atol(char[])} - Converts a C-string to a long.
        \item \textbf{atoll(char[])} - Converts a C-string to a long long.
        \item \textbf{atof(char[])} - Converts a C-string to a double.
        \item \textbf{strtol(char[], entdptr, base)} - Converts a C-string to a long int, with error checking and more flexibility with base representations.
        \item \textbf{strtoul(char[], entdptr, base)} - Converts a C-string to an unsigned long int.
        \item \textbf{strtoll(char[], entdptr, base)} - Converts a C-string to a long long int.
        \item \textbf{strtoull(char[], entdptr, base)} - Converts a C-string to an unsigned long long int.
        \item \textbf{strtof(char[], entdptr)} - Converts a C-string to a float.
        \item \textbf{strtod(char[], entdptr)} - Converts a C-string to a double.
        \item \textbf{strtold(char[], entdptr)} - Converts a C-string to a long double.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Note:} Consider the codeblock
    \begin{verbatim}
const char* a = "12.322string";
char* ptr;

double val = strtod(a, &ptr); // ptr will hold the value "string"
    \end{verbatim}
    \bigbreak \noindent 
    In this example, you can see that we are making use of the endptr optional parameter, \textit{endptr} is the address to a char pointer. It allows us to send all the string data that is not able to be converted to the requested data type . It allows us to send all the string data that is not able to be converted to the requested data type to this pointer. Only data AFTER the converted data will be sent.

    
    \pagebreak \bigbreak \noindent 
    \section{\LARGE Numeric to string conversions <string>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{to\_string(n):}$\mapsto$ string --- converts numeric type to c++ string
    \end{itemize}



    \bigbreak \noindent
    \section{\LARGE Characters (<cctype>)}
    \bigbreak \noindent 
    \subsection{Character Classification}
    \begin{itemize}
        \item \textbf{isalpha(char c):} Checks if the character is an alphabet (either uppercase or lowercase).
        \item \textbf{isdigit(char c):} Checks if the character is a digit (0-9).
        \item \textbf{isalnum(char c):} Checks if the character is either an alphabet or a digit.
        \item \textbf{isspace(char c):} Checks if the character is a whitespace character (like space, tab, newline, etc.).
        \item \textbf{isupper(char c):} Checks if the character is uppercase.
        \item \textbf{islower(char c):} Checks if the character is lowercase.
        \item \textbf{ispunct(char c):} Checks if the character is a punctuation character.
        \item \textbf{isprint(char c):} Checks if the character is printable.
        \item \textbf{iscntrl(char c):} Checks if the character is a control character.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Character Conversion:}
    \begin{itemize}
        \item \textbf{toupper(char c):} Converts the character to uppercase (if it's lowercase).
        \item \textbf{tolower(char c):} Converts the character to lowercase (if it's uppercase).
    \end{itemize}

    % \pagebreak \bigbreak \noindent 
    % \section{\LARGE Numeric types}

    \pagebreak \bigbreak \noindent 
    \section{C++ Arrays <array>}
    \bigbreak \noindent 
    \textbf{Note:} C++ Arrays are defined
    \smallbreak \noindent
    \begin{verbatim}
std::array<T,N> name;
    \end{verbatim}
    \begin{itemize}
        \item \textbf{at(size\_t)}$\mapsto$ T\&: Accesses the element at the specified \textit{position} with bounds checking.
        \item \textbf{front()}$\mapsto$ T\&: Returns a reference to the first element.
        \item \textbf{back()}$\mapsto$ T\&: Returns a reference to the last element.
        \item \textbf{data()}$\mapsto$ T*: Returns a direct pointer to the first element in the array, usefull if we want to use our std::array as if it were a c-style array
        \item \textbf{empty()}$\mapsto$ bool: Checks if the container has no elements.
        \item \textbf{size()}$\mapsto$ size\_t: Returns the number of elements in the container.
        \item \textbf{max\_size()}$\mapsto$ size\_t: Returns the maximum number of elements the container can hold (same as size).
        \item \textbf{fill(value)}$\mapsto$ void: Fills the array with the specified \textit{value}.
        \item \textbf{swap(other)}$\mapsto$ void: Swaps the contents of the array with those of \textit{other}.
        \item \textbf{begin()}\(\mapsto\) Iterator: Returns an iterator pointing to the first element.
        \item \textbf{cbegin()}\(\mapsto\) Const\_Iterator: Returns a const iterator pointing to the first element.
        \item \textbf{end()}\(\mapsto\) Iterator: Returns an iterator pointing to one-past-the-last element.
        \item \textbf{cend()}\(\mapsto\) Const\_Iterator: Returns a const iterator pointing to one-past-the-last element.
        \item \textbf{rbegin()}\(\mapsto\) Reverse\_Iterator: Returns a reverse iterator pointing to the last element.
        \item \textbf{crbegin()}\(\mapsto\) Const\_Reverse\_Iterator: Returns a const reverse iterator pointing to the last element.
        \item \textbf{rend()}\(\mapsto\) Reverse\_Iterator: Returns a reverse iterator pointing to one-past-the-first element.
        \item \textbf{crend()}\(\mapsto\) Const\_Reverse\_Iterator: Returns a const reverse iterator pointing to one-past-the-first element.
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE C-Style Arrays (<algorithm>) }
    \bigbreak \noindent 
    Prereq: Vocab
    \begin{itemize}
        \item An \textbf{InputIterator} is a type of iterator that can be used to read data from a sequence of elements. It supports operations like incrementing (to move to the next element in the sequence), dereferencing (to access the value of the element it currently points to), and comparing with other iterators (to check for the end of the sequence). Input iterators are the least powerful, but most widely applicable kind of iterator, as they only require single-pass, read-only access.
        \item An \textbf{ForwardIterator} is a type of iterator that has all the capabilities of an InputIterator but with some additional properties:
            \begin{itemize}
                \item It can be incremented multiple times and will always give the same sequence of results (multi-pass guarantee).
                \item It supports both it++ and ++it operations with the same effect.
                \item Two dereferenced copies of a ForwardIterator are guaranteed to reference the same element (if neither is modified).
            \end{itemize}
            ForwardIterator is used in contexts where an algorithm might need to pass over a range of elements multiple times.
        \item A \textbf{UnaryPredicate} is a function or a function object that takes a single argument and returns a bool. It is used to test whether a certain condition is true for the elements in a sequence. The predicate can be a regular function, a lambda expression, or an object of a class that overloads the function call operator.
        \item A \textbf{UnaryOperator} refers to a function or a function object that takes a single argument and returns some value.
        \item An \textbf{OutputIterator} is a type of iterator that can be used to write to a sequence of elements. It's a concept from the C++ Standard Library that defines the requirements for an iterator that can be used to output or write data to a container. 
            \bigbreak \noindent 
            \textbf{Note:} A standard iterator can be used in place of a outputiterator, however, here is how we can use a outputiterator to write contents of an array to the output buffer
            1br
            \begin{cppcode}
                int arr[5] = {1,2,3,4,5};
                std::copy(std::begin(arr), std::end(arr), std::ostream_iterator<int>(cout, " "));
            \end{cppcode}
    \end{itemize}
    \bigbreak \noindent  
    \textbf{std::pair type}: std::pair is a class template that provides a way to store two heterogeneous objects as a single unit. The way we access the elements is with .first and .second
    \subsection{Non-Modifying}
    \begin{itemize}
        \item \textbf{all\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) bool: Returns true if the predicate is true for all elements in the given range.
        \item \textbf{any\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) bool: Returns true if the predicate is true for any element in the range.
        \item \textbf{none\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) bool: Returns true if the predicate is false for all elements in the range.
        \item \textbf{for\_each(InputIterator, InputIterator, Function)} \(\mapsto\) Function: Applies a function to each element in the range.
        \item \textbf{count(InputIterator, InputIterator, const T\&)} \(\mapsto\) size\_t: Counts elements equal to the specified value.
        \item \textbf{count\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) size\_t: Counts elements for which the predicate is true.
        \item \textbf{mismatch(InputIterator1, InputIterator1, InputIterator2)} \(\mapsto\) pair<InputIterator1, InputIterator2>: Finds the first position where two ranges differ.
        \item \textbf{find(InputIterator, InputIterator, const T\&)} \(\mapsto\) InputIterator: Finds the first element equal to the specified value.
        \item \textbf{find\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) InputIterator: Finds the first element for which the predicate is true.
        \item \textbf{find\_if\_not(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) InputIterator: Finds the first element for which the predicate is false.
        \item \textbf{find\_end(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) InputIterator: Finds the last occurrence of a subsequence.
        \item \textbf{find\_first\_of(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) InputIterator: Finds the first element that matches any element in another range.
        \item \textbf{adjacent\_find(InputIterator, InputIterator, o:UnaryPredicate)} \(\mapsto\) InputIterator: Finds the first two adjacent items that are equal (or satisfy a given predicate).
        \item \textbf{search(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) InputIterator: Searches for the first occurrence of a subsequence.
        \item \textbf{search\_n(InputIterator, InputIterator, size\_t, const T\&)} \(\mapsto\) InputIterator: Searches for a sequence of repeated elements.
    \end{itemize}
    \bigbreak \noindent 
    \begin{notebox}
       The for\_each function returns the function that was used to map each element.
    \end{notebox}

    \pagebreak \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{copy(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) OutputIterator: Copies a range of elements to a new location.
    \item \textbf{copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate)} \(\mapsto\) OutputIterator: Copies elements satisfying a condition to a new location.
    \item \textbf{copy\_n(InputIterator, Size, OutputIterator)} \(\mapsto\) OutputIterator: Copies a number of elements to a new location.
    \item \textbf{copy\_backward(BidirectionalIterator1, BidirectionalIterator1, BidirectionalIterator2)} \(\mapsto\) BidirectionalIterator2: Copies elements in reverse order.
    \item \textbf{move(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) OutputIterator: Moves a range of elements to a new location.
    \item \textbf{move\_backward(BidirectionalIterator1, BidirectionalIterator1, BidirectionalIterator2)} \(\mapsto\) BidirectionalIterator2: Moves elements in reverse order.
    \item \textbf{fill(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) void: Assigns a value to all elements in a range.
    \item \textbf{fill\_n(OutputIterator, Size, const T\&)} \(\mapsto\) OutputIterator: Assigns a value to a number of elements.
    \item \textbf{transform(InputIterator, InputIterator, OutputIterator, UnaryOperation)} \(\mapsto\) OutputIterator: Applies a function to a range of elements.
    \item \textbf{generate(ForwardIterator, ForwardIterator, Generator)} \(\mapsto\) void: Fills a range with the results of successive function calls.
    \item \textbf{generate\_n(OutputIterator, Size, Generator)} \(\mapsto\) OutputIterator: Fills a range with N results of successive function calls.
    \item \textbf{remove(InputIterator, InputIterator, const T\&)} \(\mapsto\) InputIterator: Removes elements equal to a value.
    \item \textbf{remove\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) InputIterator: Removes elements satisfying a condition.
    \item \textbf{remove\_copy(InputIterator, InputIterator, OutputIterator, const T\&)} \(\mapsto\) OutputIterator: Copies elements not equal to a value.
    \item \textbf{remove\_copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate)} \(\mapsto\) OutputIterator: Copies elements not satisfying a condition.
    \item \textbf{replace(InputIterator, InputIterator, const T\&, const T\&)} \(\mapsto\) void: Replaces all values equal to a specified value.
    \item \textbf{replace\_if(InputIterator, InputIterator, UnaryPredicate, const T\&)} \(\mapsto\) void: Replaces values satisfying a condition.
    \item \textbf{replace\_copy(InputIterator, InputIterator, OutputIterator, const T\&, const T\&)} \(\mapsto\) OutputIterator: Copies and replaces values.
    \item \textbf{replace\_copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate, const T\&)} \(\mapsto\) OutputIterator: Copies and replaces values based on a condition.
    \item \textbf{swap(T\&, T\&)} \(\mapsto\) void: Swaps the values of two objects.
    \item \textbf{swap\_ranges(ForwardIterator1, ForwardIterator1, ForwardIterator2)} \(\mapsto\) ForwardIterator2: Swaps two ranges of elements.
    \item \textbf{iter\_swap(ForwardIterator1, ForwardIterator2)} \(\mapsto\) void: Swaps elements pointed to by two iterators.
    \item \textbf{reverse(BidirectionalIterator, BidirectionalIterator)} \(\mapsto\) void: Reverses the order of elements in a range.
    \item \textbf{reverse\_copy(BidirectionalIterator, BidirectionalIterator, OutputIterator)} \(\mapsto\) OutputIterator: Creates a reversed copy of a range.
    \item \textbf{rotate(ForwardIterator, ForwardIterator, ForwardIterator)} \(\mapsto\) ForwardIterator: Rotates the order of elements in a range.
    \item \textbf{rotate\_copy(ForwardIterator, ForwardIterator, ForwardIterator, OutputIterator)} \(\mapsto\) OutputIterator: Copies and rotates a range of elements.
    \item \textbf{shift\_left(ForwardIterator, ForwardIterator, Size)} \(\mapsto\) ForwardIterator: Shifts elements in a range to the left.
    \item \textbf{shift\_right(ForwardIterator, ForwardIterator, Size)} \(\mapsto\) ForwardIterator: Shifts elements in a range to the right.
    \item \textbf{random\_shuffle(RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) void: Randomly re-orders elements in a range.
    \item \textbf{shuffle(RandomAccessIterator, RandomAccessIterator, URNG\&)} \(\mapsto\) void: Randomly re-orders elements in a range using a generator.
    \item \textbf{sample(InputIterator, InputIterator, OutputIterator, Size, URNG\&)} \(\mapsto\) OutputIterator: Selects N random elements from a sequence.
    \item \textbf{unique(ForwardIterator, ForwardIterator)} \(\mapsto\) ForwardIterator: Removes consecutive duplicate elements in a range.
    \item \textbf{unique\_copy(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) OutputIterator: Creates a copy of a range without consecutive duplicates.
    \end{itemize}
    
    \bigbreak \noindent 
    \subsection{Using lambdas for these functions}
    \bigbreak \noindent 
    \begin{cppcode}
        int arr[]  = {1,2,3};
        std::for_each(arr, arr+3, [](int& a) -> int { return ++x; });
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Getting position of element from returned iterator}
    \bigbreak \noindent 
    \begin{concept}
        If we subtract the iterator (which is the address of the array element) from the beginning of the array, we get the distance between the two pointers (so the index position of the iterator value) 
        \bigbreak \noindent 
        \begin{cppcode}
        idx = it - std::begin(array);
        \end{cppcode}
    \end{concept}

    \pagebreak \bigbreak \noindent 
    \subsection{Sorting operations}
    \begin{itemize}
        
    \end{itemize}

    \pagebreak \bigbreak \noindent
    \section{\LARGE Iterators <iterator>}
    \bigbreak \noindent 

    

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Vectors}
    \bigbreak \noindent 

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Set}
    \bigbreak \noindent 

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Map}
    \bigbreak \noindent 




%
%
%     

%
%
%

    
\end{document}
