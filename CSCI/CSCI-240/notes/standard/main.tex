\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\lhead{Warner \thepage}
\rhead{}
% \lhead{\leftmark}
\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ STL} \\
           Standard library (Functions etc.)
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak \bigbreak \noindent
    \section{\LARGE C++ Strings (<string>)}
    \bigbreak \noindent 
    \subsection{Element Access}
    \begin{itemize}
        \item \textbf{at(size\_t \textbf{pos):} Returns a reference to the character at the specified position. Throws std::}out\_of\_range if pos >= size().
        \item \textbf{front():} Returns a reference to the first character.
        \item \textbf{back():} Returns a reference to the last character.
        \item \textbf{c\_str():} Returns a const char* pointing to the null-terminated character array.
        \item \textbf{data():} Returns a const char* pointing to the underlying character array.        
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Capacity}
    \begin{itemize}
        \item \textbf{length(), \textbf{size():}} Returns the number of characters in the string (size\_t).
        \item \textbf{empty():} Returns true if the string is empty, false otherwise (bool).
        \item \textbf{resize(size\_t \textbf{n, char c = char()):}} Resizes the string to contain n characters.
        \item \textbf{capacity():} Returns the size of the storage space currently allocated (size\_t).
        \item \textbf{reserve(size\_t \textbf{new\_cap = 0):}} Reserves storage.
        \item \textbf{max\_size():} Returns the maximum number of characters the string can hold (size\_t).
        \item \textbf{shrink\_to\_fit():} Reduces memory usage by freeing unused memory (no return value).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Modifiers}
    \begin{itemize}
        \item \textbf{append(const \textbf{string\& str):}}- Required: String to append. (Has other overloads.)
        \item \textbf{push\_back(char c):}- Required: Character to append.
        \item \textbf{assign(const \textbf{string\& str, o:start,o:take[n]characters):}}- Required: String to assign. (Has other overloads.)
        \item \textbf{insert(size\_t \textbf{pos, const string\& str):}}- Required: Position and string to insert. (Has other overloads.)
        \item \textbf{replace(size\_t \textbf{pos, size\_t len, const string\& str):}}- Required: Position, length, and string for replacement. (Has other overloads.)
        \item \textbf{swap(string\& \textbf{str):}}- Required: String to swap with.
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \subsection{String Operations}
    \begin{itemize}
        \item \textbf{substr(size\_t \textbf{pos = 0, size\_t len = npos):}} -> string Optional: Starting position and length.
        \item \textbf{copy(char* s, size\_t len, size\_t pos = 0) const:} -> size\_t (number of characters that were copied) Required: Destination and length. Optional: Starting position.
        \item \textbf{find(substr, pos) const:} -> size\_t=npos Required: String to find. Optional: Starting position.
        \item \textbf{rfind(substr, pos = npos) const:} -> size\_t=npos Required: String to find. Optional: Starting position from the end.
        \item \textbf{find\_first\_of(substr, pos)} -> size\_t=npos Find character in string (public member function)
        \item \textbf{find\_last\_of(substr, pos)} -> size\_t=npos	Find character in string from the end (public member function)
        \item \textbf{find\_first\_not\_of(substr, pos)} -> size\_t=npos	Find absence of character in string (public member function)
        \item \textbf{find\_last\_not\_of(substr, pos)} -> size\_t=npos	Find non-matching character in string from the end (public member function)
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Comparison}
    \begin{itemize}
        \item \textbf{compare(const string\& str) const:}- Required: String to compare with. (Has other overloads.)
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversions}
    \begin{itemize}
        \item \textbf{c\_str}: converts to c-string
        \item \textbf{stoi}: int
        \item \textbf{stol}: long
        \item \textbf{stoul}: unsigned long
        \item \textbf{stoll}: long long
        \item \textbf{stoull}: unsigned long long
        \item \textbf{stof}: float
        \item \textbf{stod}: double
        \item \textbf{stold}: long double
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE C-strings (<cstring>)}
    \bigbreak \noindent 
    \subsection{Manipulation}
    \begin{itemize}
        \item \textbf{strncpy(char dest, const char src, size\_t n):} Copy up to n characters from the string src to dest.
        \item \textbf{strncat(char dest, const char src, size\_t n):} Append up to n characters from the string src onto the end of dest.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Examination}
    \begin{itemize}
        \item \textbf{strlen(const char s):} Return the length of the string (not including the null terminator).
        \item \textbf{strncmp(const char s1, const char s2, size\_t n):} Compare up to n characters of two strings.
        \item \textbf{strchr(const char s, int c):} Return a pointer to the first occurrence of character c in the string s, or nullptr if c is not found.
        \item \textbf{strrchr(const char s, int c):} Return a pointer to the last occurrence of character c in the string s.
        \item \textbf{strstr(const char haystack, const char needle):} Return a pointer to the first occurrence of the substring needle in the string haystack, or nullptr if the substring is not found.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversion}
    \begin{itemize}
        \item \textbf{atoi:} converts C-String to an integer 
        \item \textbf{atol:} converts C-String to a long integer 
        \item \textbf{atof:} converts C-String to a double
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Characters (<cctype>)}
    \bigbreak \noindent 
    \subsection{Character Classification}
    \begin{itemize}
        \item \textbf{isalpha(char c):} Checks if the character is an alphabet (either uppercase or lowercase).
        \item \textbf{isdigit(char c):} Checks if the character is a digit (0-9).
        \item \textbf{isalnum(char c):} Checks if the character is either an alphabet or a digit.
        \item \textbf{isspace(char c):} Checks if the character is a whitespace character (like space, tab, newline, etc.).
        \item \textbf{isupper(char c):} Checks if the character is uppercase.
        \item \textbf{islower(char c):} Checks if the character is lowercase.
        \item \textbf{ispunct(char c):} Checks if the character is a punctuation character.
        \item \textbf{isprint(char c):} Checks if the character is printable.
        \item \textbf{iscntrl(char c):} Checks if the character is a control character.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Character Conversion:}
    \begin{itemize}
        \item \textbf{toupper(char c):} Converts the character to uppercase (if it's lowercase).
        \item \textbf{tolower(char c):} Converts the character to lowercase (if it's uppercase).
    \end{itemize}

    % \pagebreak \bigbreak \noindent 
    % \section{\LARGE Numeric types}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Other Containers in C++ }
    \bigbreak \noindent 
    So far we have discussed things like arrays and vectors, but we have a few other containers that we can use in c++
    \bigbreak \noindent 
    \subsection{}


    \pagebreak \bigbreak \noindent 
    \section{\LARGE Arrays (<array> and <algorithm>) }
    \bigbreak \noindent 
    \subsection{From <algorithm>}
    \begin{itemize}
         \item \textbf{sort(first, last)} -> void: Sorts the elements in the range [first, last).
        \item \textbf{find(first, last, value)} -> Iterator: Returns an iterator to the first occurrence of value. If not found, returns last.
        \item \textbf{copy(first, last, destination\_first)} -> Iterator: Copies the elements from [first, last) to the beginning at d\_first.
        \item \textbf{fill(first, last, value)} -> void: Assigns value to all the elements in the range [first, last).
        \item \textbf{count(first, last, value)} -> size\_t: Counts elements that are equal to value.
        \item \textbf{reverse(first, last)} -> void: Reverses the elements in the range [first, last).
        \item \textbf{replace(first, last, old\_value, new\_value)} -> void: Replaces all elements equal to old\_value with new\_value.
        \item \textbf{min\_element(first, last)} -> Iterator: Returns an iterator pointing to the first instance of the smallest element.
        \item \textbf{max\_element(first, last)} -> Iterator: Returns an iterator pointing to the first instance of the largest element.
        \item \textbf{binary\_search(first, last, value)} -> bool: Checks if value exists in the sorted sequence.
        \item \textbf{equal(first1, last1, first2)} -> bool: Checks if two sequences are the same.
        \item \textbf{mismatch(first1, last1, first2)} -> Pair: Returns a pair of iterators pointing to the first unequal elements.
    \end{itemize}
    \bigbreak \noindent \bigbreak \noindent 
    Example: Find function
    \smallbreak \noindent
    \begin{minted}{cpp}
#define _SIZE(a) sizeof(a) / sizeof(a[0])

int arr[] = {5,4,3,2,1};
auto it = std::find(arr,_SIZE(arr), 3); // Pointer to that element in our array

if (it != _SIZE(a)) {
    cout << "Found at index pos: " << it - arr;
}
    \end{minted}
    \bigbreak \noindent 
    If the element is not found, the find function will return a iterator to the last element in the array, so we check to see if this is the case.
    When we subtract two pointers, we are computed the distance between those two pointers. Hence it-arr gives the position of our element.

    \pagebreak \bigbreak \noindent 
    \subsection{From <array>}
    \begin{itemize}
        \item \textbf{at(position)} -> T\&: Accesses the element at the specified \textit{position} with bounds checking.
        \item \textbf{operator[position]} -> T\&: Accesses the element at the specified \textit{position} without bounds checking.
        \item \textbf{front()} -> T\&: Returns a reference to the first element.
        \item \textbf{back()} -> T\&: Returns a reference to the last element.
        \item \textbf{data()} -> T*: Returns a direct pointer to the underlying array serving as the element storage.
        \item \textbf{begin()} -> Iterator: Returns an iterator pointing to the first element.
        \item \textbf{end()} -> Iterator: Returns an iterator pointing to one-past-the-last element.
        \item \textbf{cbegin()} -> Const\_Iterator: Returns a const iterator pointing to the first element.
        \item \textbf{cend()} -> Const\_Iterator: Returns a const iterator pointing to one-past-the-last element.
        \item \textbf{rbegin()} -> Reverse\_Iterator: Returns a reverse iterator pointing to the last element.
        \item \textbf{rend()} -> Reverse\_Iterator: Returns a reverse iterator pointing to one-past-the-first element.
        \item \textbf{crbegin()} -> Const\_Reverse\_Iterator: Returns a const reverse iterator pointing to the last element.
        \item \textbf{crend()} -> Const\_Reverse\_Iterator: Returns a const reverse iterator pointing to one-past-the-first element.
        \item \textbf{empty()} -> bool: Checks if the container has no elements.
        \item \textbf{size()} -> size\_t: Returns the number of elements in the container.
        \item \textbf{max\_size()} -> size\_t: Returns the maximum number of elements the container can hold (same as size).
        \item \textbf{fill(value)} -> void: Fills the array with the specified \textit{value}.
        \item \textbf{swap(other)} -> void: Swaps the contents of the array with those of \textit{other}.
    \end{itemize}

    





    
\end{document}
