\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\lhead{Warner \thepage}
\rhead{}
% \lhead{\leftmark}
\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ STL} \\
           Standard library (Functions etc.)
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak \bigbreak \noindent
    \section{\LARGE C++ Strings (<string>)}
    \bigbreak \noindent 
    \begin{interlude}
       Before we begin with the C++ string methods, there are two things to know.
       \begin{itemize}
           \item \textbf{size\_t}: an unsigned integral type, and it's designed to be able to represent the size of any object in bytes
            \item \textbf{npos}: (Constant) It's the largest possible value representable by the size\_type of std::string
       \end{itemize}
    \end{interlude}
    \bigbreak \noindent 
    \nt{size\_t is used as the return value for methods such as "find" to indicate unsuccessful}
    
    \bigbreak \noindent 
    \subsection{Element Access}
    \begin{itemize}
        \item \textbf{at(r:size\_t pos):}$\mapsto$ char\& --- Returns a reference to the character at the specified position. Store return value in char\&
        \item \textbf{str.front():}$\mapsto$ char\& --- returns reference to the first character. 
        \item \textbf{str.back():}$\mapsto$ char\& --- returns a reference to the last character. 
        \item \textbf{str.c\_str():}$\rightarrow$ const char* pointing to the null-terminated character array.
        \item \textbf{str.data():}$\to$ const char* pointing to the underlying character array.        
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Capacity}
    \begin{itemize}
        \item \textbf{str.length():}$\mapsto$ size\_t --- Returns the number of characters in the string 
        \item \textbf{str.size():}$\mapsto$ size\_t --- Returns the number of characters in the string 
        \item \textbf{str.empty():}$\mapsto$ bool --- Returns true if the string is empty, false otherwise 
        \item \textbf{resize(r:size\_t n, o:char c):}$\mapsto$ void --- Resizes the string to contain $n$ characters.
        \item \textbf{capacity():}$\mapsto$ size\_t --- Returns the size of the storage space currently allocated 
        \item \textbf{reserve(size\_t new\_cap):}$\mapsto$ void --- Reserves storage (increases capacity).
        \item \textbf{max\_size():}$\mapsto$ size\_t --- Returns the maximum number of characters the string can hold 
        \item \textbf{shrink\_to\_fit():}$\mapsto$ void --- Reduces memory usage by freeing unused memory 
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Modifiers}
    \begin{itemize}
        \item \textbf{append(string str):}$\mapsto$ std::string\& mutated\_string --- String to append. (Has other overloads.) (Doesnt need to be saved in T\&)
        \item \textbf{push\_back(char c):}$\mapsto$ void --- Character to append.
        \item \textbf{assign(string str, o:start,o:stop):}$\mapsto$ std::string\& mutated\_string  --- used to replace the current content of the string with a new set of characters. (Has other overloads.)
        \item \textbf{insert(size\_t pos, string str):}$\mapsto$ std::string\& mutated\_str --- Position and string to insert. (Has other overloads.)
        \item \textbf{replace(size\_t pos, size\_t len, string str):}$\mapsto $ mutated\_string --- Position, length, and string for replacement. (Has other overloads.)
        \item \textbf{swap(string str):}$\mapsto$ void --- String to swap with.
        \item \textbf{pop\_back():} $\mapsto$ void --- Removes the last character in the string
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \subsection{String Operations}
    \begin{itemize}
        \item \textbf{substr(pos, o:len):}$\mapsto$ string --- Generate a substr from a string 
        \item \textbf{copy(char[] dest, o:len, pos):}$\mapsto$ size\_t (number of characters that were copied) send contents of string to some character array
        \item \textbf{find(substr, o:pos):}$\mapsto$ size\_t=npos find a substr from within a string
        \item \textbf{rfind(substr, o:pos):}$\mapsto$ size\_t=npos  find a substr form withing as string, starting search from the end of the string
        \item \textbf{find\_first\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos Find character in string (public member function)
        \item \textbf{find\_last\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos	Find character in string from the end (public member function)
        \item \textbf{find\_first\_not\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos	Find absence of character in string (public member function)
        \item \textbf{find\_last\_not\_of(substr (or char), o:pos)}$\mapsto$ size\_t=npos	Find non-matching character in string from the end (public member function)
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Comparison}
    \begin{itemize}
        \item \textbf{compare(o:pos, o:len, str):}$\mapsto$ unsigned integral
            \begin{itemize}
                \item 0: they compare equal 
                \item <0: Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter.
                \item >0: Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversions (These are functions)}
    \begin{itemize}
        \item \textbf{stoi(str, o:idx, o:base):}$\mapsto$ int (idx is a pointer to a size\_t object)
        \item \textbf{stol(str, o:idx, o:base):}$\mapsto$ long
        \item \textbf{stoul(str, o:idx, o:base):}$\mapsto$ unsigned long
        \item \textbf{stoll(str, o:idx, o:base):}$\mapsto$ long long
        \item \textbf{stoull(str, o:idx, o:base):}$\mapsto$ unsigned long long
        \item \textbf{stof(str, o:idx):}$\mapsto$ float
        \item \textbf{stod(str, o:idx):}$\mapsto$ double
        \item \textbf{stold(str, o:idx):}$\mapsto$ long double
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE C-strings (<cstring>)}
    \bigbreak \noindent 
    \subsection{Manipulation}
    \begin{itemize}
        \item \textbf{strncpy(char[] dest, char[] src, size\_t n):}$\mapsto$ const char* --- Copy up to n characters from the string src to dest.
        \item \textbf{strcpy(char[] dest, char[] src)}$\mapsto$ const char* ---- Copies the C string pointed by source into the array pointed by destination
        \item \textbf{strncat(char[] dest, char[] src, size\_t n):}$\mapsto$ const char* --- Append up to n characters from the string src onto the end of dest.
        \item \textbf{strcat(char[] dest, char[] src)}$\mapsto$ const char* --- Appends a copy of the source string to the destination string.
        \bigbreak \noindent 
        \textbf{Note:} cpy functions return a const char* comprised of the characters from the src array that were used.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Examination}
    \begin{itemize}
        \item \textbf{strnlen(char[] src, size\_t maxlen)}$\mapsto$ size\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strlen(char[] src):}$\mapsto$ size\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strncmp(char[] src1, char[] src2, size\_t n):}$\mapsto$ uint (value varies) --- Compare up to n characters of two strings.
        \item \textbf{strcmp(char[] src1, char[] src2)}$\mapsto$ size\_t (value varires) --- compare two strings
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Searching}
    \begin{itemize}
        \item \textbf{strchr(char[] src, char c):}$\mapsto$ char* ---- get pointer to the first occurrence of character c in the string s, or nullptr if c is not found.
        \item \textbf{strrchr(char[] src, char c):}$\mapsto$ char* --- get pointer to the last occurrence of character c in the string s.
        \item \textbf{strstr(char[] src, char[] str):}$\mapsto$ const char* --- Return a pointer to the first occurrence of the substring 
        \item \textbf{strspn(char[] src, char[] charset):}$\mapsto$ size\_t --- Returns the length of the initial portion of str1 which consists only of characters that are part of str2.
        \item \textbf{strcspn(char[] src, char[] charset):}$\mapsto$ size\_t --- Get position of first character found from charset 
        \item \textbf{strpbrk(char[] src, char[] charset):}$\mapsto$ const char* --- Return string consisting of first match form character set in string onward
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Error}
    \begin{itemize}
        \item \textbf{strerror(errno)}$\mapsto$ const char* ---  Get pointer to error message string (we are literally passing in the defined variable \textit{errno})
            \begin{verbatim}
std::ifstream inf("file.txt");
if (inf.fail()) { cout << strerrror(errno); } // No such file in directory 
(Because that is what the error string is set to after inf.fail())
            \end{verbatim}
        we also have control over the error we can pass in, errors that are defined in <cerrno>. Rather than leaving it up to errno. We have:
    \begin{description}
      \item[E2BIG (C++11)] Argument list too long (macro constant)
      \item[EACCES (C++11)] Permission denied (macro constant)
      \item[EADDRINUSE (C++11)] Address in use (macro constant)
      \item[EADDRNOTAVAIL (C++11)] Address not available (macro constant)
      \item[EAFNOSUPPORT (C++11)] Address family not supported (macro constant)
      \item[EAGAIN (C++11)] Resource unavailable, try again (macro constant)
      \item[EALREADY (C++11)] Connection already in progress (macro constant)
      \item[EBADF (C++11)] Bad file descriptor (macro constant)
      \item[EBADMSG (C++11)] Bad message (macro constant)
      \item[EBUSY (C++11)] Device or resource busy (macro constant)
      \item[ECANCELED (C++11)] Operation canceled (macro constant)
      \item[ECHILD (C++11)] No child processes (macro constant)
      \item[ECONNABORTED (C++11)] Connection aborted (macro constant)
      \item[ECONNREFUSED (C++11)] Connection refused (macro constant)
      \item[ECONNRESET (C++11)] Connection reset (macro constant)
      \item[EDEADLK (C++11)] Resource deadlock would occur (macro constant)
      \item[EDESTADDRREQ (C++11)] Destination address required (macro constant)
      \item[EDOM] Mathematics argument out of domain of function (macro constant)
      \item[EEXIST (C++11)] File exists (macro constant)
      \item[EFAULT (C++11)] Bad address (macro constant)
      \item[EFBIG (C++11)] File too large (macro constant)
      \item[EHOSTUNREACH (C++11)] Host is unreachable (macro constant)
      \item[EIDRM (C++11)] Identifier removed (macro constant)
      \item[EILSEQ] Illegal byte sequence (macro constant)
      \item[EINPROGRESS (C++11)] Operation in progress (macro constant)
      \item[EINTR (C++11)] Interrupted function (macro constant)
      \item[EINVAL (C++11)] Invalid argument (macro constant)
      \item[EIO (C++11)] I/O error (macro constant)
      \item[EISCONN (C++11)] Socket is connected (macro constant)
      \item[EISDIR (C++11)] Is a directory (macro constant)
      \item[ELOOP (C++11)] Too many levels of symbolic links (macro constant)
      \item[EMFILE (C++11)] File descriptor value too large (macro constant)
      \item[EMLINK (C++11)] Too many links (macro constant)
      \item[EMSGSIZE (C++11)] Message too large (macro constant)
      \item[ENAMETOOLONG (C++11)] Filename too long (macro constant)
      \item[ENETDOWN (C++11)] Network is down (macro constant)
      \item[ENETRESET (C++11)] Connection aborted by network (macro constant)
      \item[ENETUNREACH (C++11)] Network unreachable (macro constant)
      \item[ENFILE (C++11)] Too many files open in system (macro constant)
      \item[ENOBUFS (C++11)] No buffer space available (macro constant)
      \item[ENODATA (C++11)(deprecated in C++23)] No message is available on the STREAM head read queue (macro constant)
      \item[ENODEV (C++11)] No such device (macro constant)
      \item[ENOENT (C++11)] No such file or directory (macro constant)
      \item[ENOEXEC (C++11)] Executable file format error (macro constant)
      \item[ENOLCK (C++11)] No locks available (macro constant)
      \item[ENOLINK (C++11)] Link has been severed (macro constant)
      \item[ENOMEM (C++11)] Not enough space (macro constant)
      \item[ENOMSG (C++11)] No message of the desired type (macro constant)
      \item[ENOPROTOOPT (C++11)] Protocol not available (macro constant)
      \item[ENOSPC (C++11)] No space left on device (macro constant)
      \item[ENOSR (C++11)(deprecated in C++23)] No STREAM resources (macro constant)
      \item[ENOSTR (C++11)(deprecated in C++23)] Not a STREAM (macro constant)
      \item[ENOSYS (C++11)] Function not supported (macro constant)
      \item[ENOTCONN (C++11)] The socket is not connected (macro constant)
      \item[ENOTDIR (C++11)] Not a directory (macro constant)
      \item[ENOTEMPTY (C++11)] Directory not empty (macro constant)
      \item[ENOTRECOVERABLE (C++11)] State not recoverable (macro constant)
      \item[ENOTSOCK (C++11)] Not a socket (macro constant)
      \item[ENOTSUP (C++11)] Not supported (macro constant)
      \item[ENOTTY (C++11)] Inappropriate I/O control operation (macro constant)
      \item[ENXIO (C++11)] No such device or address (macro constant)
      \item[EOPNOTSUPP (C++11)] Operation not supported on socket (macro constant)
      \item[EOVERFLOW (C++11)] Value too large to be stored in data type (macro constant)
      \item[EOWNERDEAD (C++11)] Previous owner died (macro constant)
      \item[EPERM (C++11)] Operation not permitted (macro constant)
      \item[EPIPE (C++11)] Broken pipe (macro constant)
      \item[EPROTO (C++11)] Protocol error (macro constant)
      \item[EPROTONOSUPPORT (C++11)] Protocol not supported (macro constant)
      \item[EPROTOTYPE (C++11)] Protocol wrong type for socket (macro constant)
      \item[ERANGE] Result too large (macro constant)
      \item[EROFS (C++11)] Read-only file system (macro constant)
      \item[ESPIPE (C++11)] Invalid seek (macro constant)
      \item[ESRCH (C++11)] No such process (macro constant)
      \item[ETIME (C++11)(deprecated in C++23)] Stream ioctl() timeout (macro constant)
      \item[ETIMEDOUT (C++11)] Connection timed out (macro constant)
      \item[ETXTBSY (C++11)] Text file busy (macro constant)
      \item[EWOULDBLOCK (C++11)] Operation would block (macro constant)
      \item[EXDEV (C++11)] Cross-device link (macro constant)
    \end{description}

    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversion}
    \begin{itemize}
        \item \textbf{atoi(char[])} - Converts a C-string to an int.
        \item \textbf{atol(char[])} - Converts a C-string to a long.
        \item \textbf{atoll(char[])} - Converts a C-string to a long long.
        \item \textbf{atof(char[])} - Converts a C-string to a double.
        \item \textbf{strtol(char[], entdptr, base)} - Converts a C-string to a long int, with error checking and more flexibility with base representations.
        \item \textbf{strtoul(char[], entdptr, base)} - Converts a C-string to an unsigned long int.
        \item \textbf{strtoll(char[], entdptr, base)} - Converts a C-string to a long long int.
        \item \textbf{strtoull(char[], entdptr, base)} - Converts a C-string to an unsigned long long int.
        \item \textbf{strtof(char[], entdptr)} - Converts a C-string to a float.
        \item \textbf{strtod(char[], entdptr)} - Converts a C-string to a double.
        \item \textbf{strtold(char[], entdptr)} - Converts a C-string to a long double.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Note:} Consider the codeblock
    \begin{verbatim}
const char* a = "12.322string";
char* ptr;

double val = strtod(a, &ptr); // ptr will hold the value "string"
    \end{verbatim}
    \bigbreak \noindent 
    In this example, you can see that we are making use of the endptr optional parameter, \textit{endptr} is the address to a char pointer. It allows us to send all the string data that is not able to be converted to the requested data type . It allows us to send all the string data that is not able to be converted to the requested data type to this pointer. Only data AFTER the converted data will be sent.

    
    \pagebreak \bigbreak \noindent 
    \section{\LARGE Numeric to string conversions <string>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{to\_string(n):}$\mapsto$ string --- converts numeric type to c++ string
    \end{itemize}



    \bigbreak \noindent
    \section{\LARGE Characters (<cctype>)}
    \bigbreak \noindent 
    \subsection{Character Classification}
    \begin{itemize}
        \item \textbf{isalpha(char c):} Checks if the character is an alphabet (either uppercase or lowercase).
        \item \textbf{isdigit(char c):} Checks if the character is a digit (0-9).
        \item \textbf{isalnum(char c):} Checks if the character is either an alphabet or a digit.
        \item \textbf{isspace(char c):} Checks if the character is a whitespace character (like space, tab, newline, etc.).
        \item \textbf{isupper(char c):} Checks if the character is uppercase.
        \item \textbf{islower(char c):} Checks if the character is lowercase.
        \item \textbf{ispunct(char c):} Checks if the character is a punctuation character.
        \item \textbf{isprint(char c):} Checks if the character is printable.
        \item \textbf{iscntrl(char c):} Checks if the character is a control character.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Character Conversion:}
    \begin{itemize}
        \item \textbf{toupper(char c):} Converts the character to uppercase (if it's lowercase).
        \item \textbf{tolower(char c):} Converts the character to lowercase (if it's uppercase).
    \end{itemize}

    % \pagebreak \bigbreak \noindent 
    % \section{\LARGE Numeric types}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Other Containers in C++ }
    \bigbreak \noindent 
    So far we have discussed things like arrays and vectors, but we have a few other containers that we can use in c++
    \bigbreak \noindent 

    \pagebreak \bigbreak \noindent 
    \section{C++ Arrays <array>}
    \bigbreak \noindent 
    \textbf{Note:} C++ Arrays are defined
    \smallbreak \noindent
    \begin{verbatim}
std::array<T,N> name;
    \end{verbatim}
    \begin{itemize}
        \item \textbf{at(size\_t)}$\mapsto$ T\&: Accesses the element at the specified \textit{position} with bounds checking.
        \item \textbf{front()}$\mapsto$ T\&: Returns a reference to the first element.
        \item \textbf{back()}$\mapsto$ T\&: Returns a reference to the last element.
        \item \textbf{data()}$\mapsto$ T*: Returns a direct pointer to the first element in the array, usefull if we want to use our std::array as if it were a c-style array
        \item \textbf{empty()} -> bool: Checks if the container has no elements.
        \item \textbf{size()} -> size\_t: Returns the number of elements in the container.
        \item \textbf{max\_size()} -> size\_t: Returns the maximum number of elements the container can hold (same as size).
        \item \textbf{swap(other)} -> void: Swaps the contents of the array with those of \textit{other}.
        \item \textbf{fill(value)} -> void: Fills the array with the specified \textit{value}.
        \item \textbf{begin()} -> Iterator: Returns an iterator pointing to the first element.
        \item \textbf{cbegin()} -> Const\_Iterator: Returns a const iterator pointing to the first element.
        \item \textbf{end()} -> Iterator: Returns an iterator pointing to one-past-the-last element.
        \item \textbf{cend()} -> Const\_Iterator: Returns a const iterator pointing to one-past-the-last element.
        \item \textbf{rbegin()} -> Reverse\_Iterator: Returns a reverse iterator pointing to the last element.
        \item \textbf{crbegin()} -> Const\_Reverse\_Iterator: Returns a const reverse iterator pointing to the last element.
        \item \textbf{rend()} -> Reverse\_Iterator: Returns a reverse iterator pointing to one-past-the-first element.
        \item \textbf{crend()} -> Const\_Reverse\_Iterator: Returns a const reverse iterator pointing to one-past-the-first element.
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE C-Style Arrays (<algorithm>) }
    \begin{itemize}
         \item \textbf{sort(first, last)} -> void: Sorts the elements in the range [first, last).
        \item \textbf{find(first, last, value)} -> Iterator: Returns an iterator to the first occurrence of value. If not found, returns last.
        \item \textbf{copy(first, last, destination\_first)} -> Iterator: Copies the elements from [first, last) to the beginning at d\_first.
        \item \textbf{fill(first, last, value)} -> void: Assigns value to all the elements in the range [first, last).
        \item \textbf{count(first, last, value)} -> size\_t: Counts elements that are equal to value.
        \item \textbf{reverse(first, last)} -> void: Reverses the elements in the range [first, last).
        \item \textbf{replace(first, last, old\_value, new\_value)} -> void: Replaces all elements equal to old\_value with new\_value.
        \item \textbf{min\_element(first, last)} -> Iterator: Returns an iterator pointing to the first instance of the smallest element.
        \item \textbf{max\_element(first, last)} -> Iterator: Returns an iterator pointing to the first instance of the largest element.
        \item \textbf{binary\_search(first, last, value)} -> bool: Checks if value exists in the sorted sequence.
        \item \textbf{equal(first1, last1, first2)} -> bool: Checks if two sequences are the same.
        \item \textbf{mismatch(first1, last1, first2)} -> Pair: Returns a pair of iterators pointing to the first unequal elements.
    \end{itemize}
    \bigbreak \noindent \bigbreak \noindent 
    Example: Find function
    \smallbreak \noindent
    \begin{minted}{cpp}
#define _SIZE(a) sizeof(a) / sizeof(a[0])

int arr[] = {5,4,3,2,1};
auto it = std::find(arr,_SIZE(arr), 3); // Pointer to that element in our array

if (it != _SIZE(a)) {
    cout << "Found at index pos: " << it - arr;
}
    \end{minted}
    \bigbreak \noindent 
    If the element is not found, the find function will return a iterator to the last element in the array, so we check to see if this is the case.
    When we subtract two pointers, we are computed the distance between those two pointers. Hence it-arr gives the position of our element.


    

%
%
%

    
\end{document}
