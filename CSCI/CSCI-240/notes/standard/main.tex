\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\lhead{Warner \thepage}
\rhead{}
% \lhead{\leftmark}
\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ STL} \\
           Standard library (Functions etc.)
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak \bigbreak \noindent
    \section{\LARGE C++ Strings (<string>)}
    \bigbreak \noindent 
    \begin{interlude}
       Before we begin with the C++ string methods, there are two things to know.
       \begin{itemize}
           \item \textbf{size\_t}: an unsigned integral type, and it's designed to be able to represent the size of any object in bytes
            \item \textbf{npos}: (Constant) It's the largest possible value representable by the size\_type of std::string
       \end{itemize}
    \end{interlude}
    \bigbreak \noindent 
    \nt{size\_t is used as the return value for methods such as "find" to indicate unsuccessful}
    
    \bigbreak \noindent 
    \subsection{Element Access}
    \begin{itemize}
        \item \textbf{at(r:size\_t pos):}$\mapsto$ \texttt{char}\& --- Returns a reference to the character at the specified position. Store return value in char\&
        \item \textbf{str.front():}$\mapsto$ \texttt{char}\& --- returns reference to the first character. 
        \item \textbf{str.back():}$\mapsto$ \texttt{char}\& --- returns a reference to the last character. 
        \item \textbf{str.c\_str():}$\rightarrow$ const char* pointing to the null-terminated character array.
        \item \textbf{str.data():}$\to$ const char* pointing to the underlying character array.        
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Capacity}
    \begin{itemize}
        \item \textbf{str.length():}$\mapsto$ \texttt{size}\_t --- Returns the number of characters in the string 
        \item \textbf{str.size():}$\mapsto$ \texttt{size}\_t --- Returns the number of characters in the string 
        \item \textbf{str.empty():}$\mapsto$ \texttt{bool} --- Returns true if the string is empty, false otherwise 
        \item \textbf{resize(r:size\_t n, o:char c):}$\mapsto$ \texttt{void} --- Resizes the string to contain $n$ characters.
        \item \textbf{capacity():}$\mapsto$ \texttt{size}\_t --- Returns the size of the storage space currently allocated 
        \item \textbf{reserve(size\_t new\_cap):}$\mapsto$ \texttt{void} --- Reserves storage (increases capacity).
        \item \textbf{max\_size():}$\mapsto$ \texttt{size}\_t --- Returns the maximum number of characters the string can hold 
        \item \textbf{shrink\_to\_fit():}$\mapsto$ \texttt{void} --- Reduces memory usage by freeing unused memory 
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Modifiers}
    \begin{itemize}
        \item \textbf{append(string str):}$\mapsto$ \texttt{std}::string\& mutated\_string --- String to append. (Has other overloads.) (Doesnt need to be saved in T\&)
        \item \textbf{push\_back(char c):}$\mapsto$ \texttt{void} --- Character to append.
        \item \textbf{assign(string str, o:start,o:stop):}$\mapsto$ \texttt{std}::string\& mutated\_string  --- used to replace the current content of the string with a new set of characters. (Has other overloads.)
        \item \textbf{insert(size\_t pos, string str):}$\mapsto$ \texttt{std}::string\& mutated\_str --- Position and string to insert. (Has other overloads.)
        \item \textbf{replace(size\_t pos, size\_t len, string str):}$\mapsto $ \texttt{mutated}\_string --- Position, length, and string for replacement. (Has other overloads.)
        \item \textbf{swap(string str):}$\mapsto$ \texttt{void} --- String to swap with.
        \item \textbf{pop\_back():} $\mapsto$ \texttt{void} --- Removes the last character in the string
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \subsection{String Operations}
    \begin{itemize}
        \item \textbf{substr(pos, o:len):}$\mapsto$ \texttt{string} --- Generate a substr from a string 
        \item \textbf{copy(char[] dest, o:len, pos):}$\mapsto$ \texttt{size}\_t (number of characters that were copied) send contents of string to some character array
        \item \textbf{find(substr, o:pos):}$\mapsto$ \texttt{size}\_t=npos find a substr from within a string
        \item \textbf{rfind(substr, o:pos):}$\mapsto$ \texttt{size}\_t=npos  find a substr form withing as string, starting search from the end of the string
        \item \textbf{find\_first\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos Find character in string (public member function)
        \item \textbf{find\_last\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos	Find character in string from the end (public member function)
        \item \textbf{find\_first\_not\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos	Find absence of character in string (public member function)
        \item \textbf{find\_last\_not\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos	Find non-matching character in string from the end (public member function)
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Comparison}
    \begin{itemize}
        \item \textbf{compare(o:pos, o:len, str):}$\mapsto$ \texttt{unsigned} integral
            \begin{itemize}
                \item 0: they compare equal 
                \item <0: Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter.
                \item >0: Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversions (These are functions)}
    \begin{itemize}
        \item \textbf{stoi(str, o:idx, o:base):}$\mapsto$ \texttt{int} (idx is a pointer to a size\_t object)
        \item \textbf{stol(str, o:idx, o:base):}$\mapsto$ \texttt{long}
        \item \textbf{stoul(str, o:idx, o:base):}$\mapsto$ \texttt{unsigned} long
        \item \textbf{stoll(str, o:idx, o:base):}$\mapsto$ \texttt{long} long
        \item \textbf{stoull(str, o:idx, o:base):}$\mapsto$ \texttt{unsigned} long long
        \item \textbf{stof(str, o:idx):}$\mapsto$ \texttt{float}
        \item \textbf{stod(str, o:idx):}$\mapsto$ \texttt{double}
        \item \textbf{stold(str, o:idx):}$\mapsto$ \texttt{long} double
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE C-strings (<cstring>)}
    \bigbreak \noindent 
    \subsection{Manipulation}
    \begin{itemize}
        \item \textbf{strncpy(char[] dest, char[] src, size\_t n):}$\mapsto$ \texttt{const} char* --- Copy up to n characters from the string src to dest.
        \item \textbf{strcpy(char[] dest, char[] src)}$\mapsto$ \texttt{const} char* ---- Copies the C string pointed by source into the array pointed by destination
        \item \textbf{strncat(char[] dest, char[] src, size\_t n):}$\mapsto$ \texttt{const} char* --- Append up to n characters from the string src onto the end of dest.
        \item \textbf{strcat(char[] dest, char[] src)}$\mapsto$ \texttt{const} char* --- Appends a copy of the source string to the destination string.
        \bigbreak \noindent 
        \textbf{Note:} cpy functions return a const char* comprised of the characters from the src array that were used.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Examination}
    \begin{itemize}
        \item \textbf{strnlen(char[] src, size\_t maxlen)}$\mapsto$ \texttt{size}\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strlen(char[] src):}$\mapsto$ \texttt{size}\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strncmp(char[] src1, char[] src2, size\_t n):}$\mapsto$ \texttt{uint} (value varies) --- Compare up to n characters of two strings.
        \item \textbf{strcmp(char[] src1, char[] src2)}$\mapsto$ \texttt{size}\_t (value varires) --- compare two strings
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Searching}
    \begin{itemize}
        \item \textbf{strchr(char[] src, char c):}$\mapsto$ \texttt{char}* ---- get pointer to the first occurrence of character c in the string s, or nullptr if c is not found.
        \item \textbf{strrchr(char[] src, char c):}$\mapsto$ \texttt{char}* --- get pointer to the last occurrence of character c in the string s.
        \item \textbf{strstr(char[] src, char[] str):}$\mapsto$ \texttt{const} char* --- Return a pointer to the first occurrence of the substring 
        \item \textbf{strspn(char[] src, char[] charset):}$\mapsto$ \texttt{size}\_t --- Returns the length of the initial portion of str1 which consists only of characters that are part of str2.
        \item \textbf{strcspn(char[] src, char[] charset):}$\mapsto$ \texttt{size}\_t --- Get position of first character found from charset 
        \item \textbf{strpbrk(char[] src, char[] charset):}$\mapsto$ \texttt{const} char* --- Return string consisting of first match form character set in string onward
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Error}
    \begin{itemize}
        \item \textbf{strerror(errno)}$\mapsto$ \texttt{const} char* ---  Get pointer to error message string (we are literally passing in the defined variable \textit{errno})
            \begin{verbatim}
std::ifstream inf("file.txt");
if (inf.fail()) { cout << strerrror(errno); } // No such file in directory 
(Because that is what the error string is set to after inf.fail())
            \end{verbatim}
        we also have control over the error we can pass in, errors that are defined in <cerrno>. Rather than leaving it up to errno. We have:

    \bigbreak \noindent 
    \begin{description}
      \item[E2BIG (C++11)] Argument list too long (macro constant)
      \item[EACCES (C++11)] Permission denied (macro constant)
      \item[EADDRINUSE (C++11)] Address in use (macro constant)
      \item[EADDRNOTAVAIL (C++11)] Address not available (macro constant)
      \item[EAFNOSUPPORT (C++11)] Address family not supported (macro constant)
      \item[EAGAIN (C++11)] Resource unavailable, try again (macro constant)
      \item[EALREADY (C++11)] Connection already in progress (macro constant)
      \item[EBADF (C++11)] Bad file descriptor (macro constant)
      \item[EBADMSG (C++11)] Bad message (macro constant)
      \item[EBUSY (C++11)] Device or resource busy (macro constant)
      \item[ECANCELED (C++11)] Operation canceled (macro constant)
      \item[ECHILD (C++11)] No child processes (macro constant)
      \item[ECONNABORTED (C++11)] Connection aborted (macro constant)
      \item[ECONNREFUSED (C++11)] Connection refused (macro constant)
      \item[ECONNRESET (C++11)] Connection reset (macro constant)
      \item[EDEADLK (C++11)] Resource deadlock would occur (macro constant)
      \item[EDESTADDRREQ (C++11)] Destination address required (macro constant)
      \item[EDOM] Mathematics argument out of domain of function (macro constant)
      \item[EEXIST (C++11)] File exists (macro constant)
      \item[EFAULT (C++11)] Bad address (macro constant)
      \item[EFBIG (C++11)] File too large (macro constant)
      \item[EHOSTUNREACH (C++11)] Host is unreachable (macro constant)
      \item[EIDRM (C++11)] Identifier removed (macro constant)
      \item[EILSEQ] Illegal byte sequence (macro constant)
      \item[EINPROGRESS (C++11)] Operation in progress (macro constant)
      \item[EINTR (C++11)] Interrupted function (macro constant)
      \item[EINVAL (C++11)] Invalid argument (macro constant)
      \item[EIO (C++11)] I/O error (macro constant)
      \item[EISCONN (C++11)] Socket is connected (macro constant)
      \item[EISDIR (C++11)] Is a directory (macro constant)
      \item[ELOOP (C++11)] Too many levels of symbolic links (macro constant)
      \item[EMFILE (C++11)] File descriptor value too large (macro constant)
      \item[EMLINK (C++11)] Too many links (macro constant)
      \item[EMSGSIZE (C++11)] Message too large (macro constant)
      \item[ENAMETOOLONG (C++11)] Filename too long (macro constant)
      \item[ENETDOWN (C++11)] Network is down (macro constant)
      \item[ENETRESET (C++11)] Connection aborted by network (macro constant)
      \item[ENETUNREACH (C++11)] Network unreachable (macro constant)
      \item[ENFILE (C++11)] Too many files open in system (macro constant)
      \item[ENOBUFS (C++11)] No buffer space available (macro constant)
      \item[ENODATA (C++11)(deprecated in C++23)] No message is available on the STREAM head read queue (macro constant)
      \item[ENODEV (C++11)] No such device (macro constant)
      \item[ENOENT (C++11)] No such file or directory (macro constant)
      \item[ENOEXEC (C++11)] Executable file format error (macro constant)
      \item[ENOLCK (C++11)] No locks available (macro constant)
      \item[ENOLINK (C++11)] Link has been severed (macro constant)
      \item[ENOMEM (C++11)] Not enough space (macro constant)
      \item[ENOMSG (C++11)] No message of the desired type (macro constant)
      \item[ENOPROTOOPT (C++11)] Protocol not available (macro constant)
      \item[ENOSPC (C++11)] No space left on device (macro constant)
      \item[ENOSR (C++11)(deprecated in C++23)] No STREAM resources (macro constant)
      \item[ENOSTR (C++11)(deprecated in C++23)] Not a STREAM (macro constant)
      \item[ENOSYS (C++11)] Function not supported (macro constant)
      \item[ENOTCONN (C++11)] The socket is not connected (macro constant)
      \item[ENOTDIR (C++11)] Not a directory (macro constant)
      \item[ENOTEMPTY (C++11)] Directory not empty (macro constant)
      \item[ENOTRECOVERABLE (C++11)] State not recoverable (macro constant)
      \item[ENOTSOCK (C++11)] Not a socket (macro constant)
      \item[ENOTSUP (C++11)] Not supported (macro constant)
      \item[ENOTTY (C++11)] Inappropriate I/O control operation (macro constant)
      \item[ENXIO (C++11)] No such device or address (macro constant)
      \item[EOPNOTSUPP (C++11)] Operation not supported on socket (macro constant)
      \item[EOVERFLOW (C++11)] Value too large to be stored in data type (macro constant)
      \item[EOWNERDEAD (C++11)] Previous owner died (macro constant)
      \item[EPERM (C++11)] Operation not permitted (macro constant)
      \item[EPIPE (C++11)] Broken pipe (macro constant)
      \item[EPROTO (C++11)] Protocol error (macro constant)
      \item[EPROTONOSUPPORT (C++11)] Protocol not supported (macro constant)
      \item[EPROTOTYPE (C++11)] Protocol wrong type for socket (macro constant)
      \item[ERANGE] Result too large (macro constant)
      \item[EROFS (C++11)] Read-only file system (macro constant)
      \item[ESPIPE (C++11)] Invalid seek (macro constant)
      \item[ESRCH (C++11)] No such process (macro constant)
      \item[ETIME (C++11)(deprecated in C++23)] Stream ioctl() timeout (macro constant)
      \item[ETIMEDOUT (C++11)] Connection timed out (macro constant)
      \item[ETXTBSY (C++11)] Text file busy (macro constant)
      \item[EWOULDBLOCK (C++11)] Operation would block (macro constant)
      \item[EXDEV (C++11)] Cross-device link (macro constant)
    \end{description}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversion Found in <cstdlib>}
    \begin{itemize}
        \item \textbf{atoi(char[])} - Converts a C-string to an int.
        \item \textbf{atol(char[])} - Converts a C-string to a long.
        \item \textbf{atoll(char[])} - Converts a C-string to a long long.
        \item \textbf{atof(char[])} - Converts a C-string to a double.
        \item \textbf{strtol(char[], endptr, base)} - Converts a C-string to a long int, with error checking and more flexibility with base representations.
        \item \textbf{strtoul(char[], endptr, base)} - Converts a C-string to an unsigned long int.
        \item \textbf{strtoll(char[], endptr, base)} - Converts a C-string to a long long int.
        \item \textbf{strtoull(char[], endptr, base)} - Converts a C-string to an unsigned long long int.
        \item \textbf{strtof(char[], endptr)} - Converts a C-string to a float.
        \item \textbf{strtod(char[], endptr)} - Converts a C-string to a double.
        \item \textbf{strtold(char[], endptr)} - Converts a C-string to a long double.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Note:} Consider the codeblock
    \begin{verbatim}
const char* a = "12.322string";
char* ptr;

double val = strtod(a, &ptr); // ptr will hold the value "string"
    \end{verbatim}
    \bigbreak \noindent 
    In this example, you can see that we are making use of the endptr optional parameter, \textit{endptr} is the address to a char pointer. It allows us to send all the string data that is not able to be converted to the requested data type . It allows us to send all the string data that is not able to be converted to the requested data type to this pointer. Only data AFTER the converted data will be sent.
    
    \bigbreak \noindent 
    \section{\LARGE Numeric to string conversions <string>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{to\_string(n):}$\mapsto$ \texttt{string} --- converts numeric type to c++ string
    \end{itemize}



    \bigbreak \noindent
    \section{\LARGE Characters (<cctype>)}
    \bigbreak \noindent 
    \subsection{Character Classification}
    \begin{itemize}
        \item \textbf{isalpha(char c):} Checks if the character is an alphabet (either uppercase or lowercase).
        \item \textbf{isdigit(char c):} Checks if the character is a digit (0-9).
        \item \textbf{isalnum(char c):} Checks if the character is either an alphabet or a digit.
        \item \textbf{isspace(char c):} Checks if the character is a whitespace character (like space, tab, newline, etc.).
        \item \textbf{isupper(char c):} Checks if the character is uppercase.
        \item \textbf{islower(char c):} Checks if the character is lowercase.
        \item \textbf{ispunct(char c):} Checks if the character is a punctuation character.
        \item \textbf{isprint(char c):} Checks if the character is printable.
        \item \textbf{iscntrl(char c):} Checks if the character is a control character.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Character Conversion:}
    \begin{itemize}
        \item \textbf{toupper(char c):} Converts the character to uppercase (if it's lowercase).
        \item \textbf{tolower(char c):} Converts the character to lowercase (if it's uppercase).
    \end{itemize}

    % \pagebreak \bigbreak \noindent 
    % \section{\LARGE Numeric types}

    \pagebreak \bigbreak \noindent 
    \section{C++ Arrays <array>}
    \bigbreak \noindent 
    \textbf{Note:} C++ Arrays are defined
    \smallbreak \noindent
    \begin{verbatim}
std::array<T,N> name;
    \end{verbatim}
    \begin{itemize}
        \item \textbf{at(size\_t)}$\mapsto$ \texttt{T}\&: Accesses the element at the specified \textit{position} with bounds checking.
        \item \textbf{front()}$\mapsto$ \texttt{T}\&: Returns a reference to the first element.
        \item \textbf{back()}$\mapsto$ \texttt{T}\&: Returns a reference to the last element.
        \item \textbf{data()}$\mapsto$ \texttt{T}*: Returns a direct pointer to the first element in the array, usefull if we want to use our std::array as if it were a c-style array
        \item \textbf{empty()}$\mapsto$ \texttt{bool}: Checks if the container has no elements.
        \item \textbf{size()}$\mapsto$ \texttt{size}\_t: Returns the number of elements in the container.
        \item \textbf{max\_size()}$\mapsto$ \texttt{size}\_t: Returns the maximum number of elements the container can hold (same as size).
        \item \textbf{fill(value)}$\mapsto$ \texttt{void}: Fills the array with the specified \textit{value}.
        \item \textbf{swap(other)}$\mapsto$ \texttt{void}: Swaps the contents of the array with those of \textit{other}.
        \item \textbf{begin()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the first element.
        \item \textbf{cbegin()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to the first element.
        \item \textbf{end()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to one-past-the-last element.
        \item \textbf{cend()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to one-past-the-last element.
        \item \textbf{rbegin()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to the last element.
        \item \textbf{crbegin()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to the last element.
        \item \textbf{rend()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to one-past-the-first element.
        \item \textbf{crend()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to one-past-the-first element.
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Algorithms <algorithm> }
    \bigbreak \noindent 
    Prereq: Vocab
    \begin{itemize}
        \item An \textbf{InputIterator} is a type of iterator that can be used to read data from a sequence of elements. It supports operations like incrementing (to move to the next element in the sequence), dereferencing (to access the value of the element it currently points to), and comparing with other iterators (to check for the end of the sequence). Input iterators are the least powerful, but most widely applicable kind of iterator, as they only require single-pass, read-only access.
        \item An \textbf{ForwardIterator} is a type of iterator that has all the capabilities of an InputIterator but with some additional properties:
            \begin{itemize}
                \item It can be incremented multiple times and will always give the same sequence of results (multi-pass guarantee).
                \item It supports both it++ and ++it operations with the same effect.
                \item Two dereferenced copies of a ForwardIterator are guaranteed to reference the same element (if neither is modified).
            \end{itemize}
            ForwardIterator is used in contexts where an algorithm might need to pass over a range of elements multiple times.
        \item A \textbf{UnaryPredicate} is a function or a function object that takes a single argument and returns a bool. It is used to test whether a certain condition is true for the elements in a sequence. The predicate can be a regular function, a lambda expression, or an object of a class that overloads the function call operator.
        \item A \textbf{UnaryOperator} refers to a function or a function object that takes a single argument and returns some value.
        \item An \textbf{OutputIterator} is a type of iterator that can be used to write to a sequence of elements. It's a concept from the C++ Standard Library that defines the requirements for an iterator that can be used to output or write data to a container. 
            \bigbreak \noindent 
            \textbf{Note:} A standard iterator can be used in place of a outputiterator, however, here is how we can use a outputiterator to write contents of an array to the output buffer
            1br
            \begin{cppcode}
                int arr[5] = {1,2,3,4,5};
                std::copy(std::begin(arr), std::end(arr), std::ostream_iterator<int>(cout, " "));
            \end{cppcode}
    \end{itemize}
    \bigbreak \noindent  
    \textbf{std::pair type}: std::pair is a class template that provides a way to store two heterogeneous objects as a single unit. The way we access the elements is with .first and .second
    \subsection{Non-Modifying}
    \begin{itemize}
        \item \textbf{all\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{bool}: Returns true if the predicate is true for all elements in the given range.
        \item \textbf{any\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{bool}: Returns true if the predicate is true for any element in the range.
        \item \textbf{none\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{bool}: Returns true if the predicate is false for all elements in the range.
        \item \textbf{for\_each(InputIterator, InputIterator, Function)} \(\mapsto\) \texttt{Function}: Applies a function to each element in the range.
        \item \textbf{count(InputIterator, InputIterator, const T\&)} \(\mapsto\) \texttt{size\_t}: Counts elements equal to the specified value.
        \item \textbf{count\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{size\_t}: Counts elements for which the predicate is true.
        \item \textbf{mismatch(InputIterator1, InputIterator1, InputIterator2)} \(\mapsto\) \texttt{pair<InputIterator1, InputIterator2>}: Finds the first position where two ranges differ.
        \item \textbf{find(InputIterator, InputIterator, const T\&)} \(\mapsto\) \texttt{InputIterator}: Finds the first element equal to the specified value.
        \item \textbf{find\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Finds the first element for which the predicate is true.
        \item \textbf{find\_if\_not(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Finds the first element for which the predicate is false.
        \item \textbf{find\_end(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) \texttt{InputIterator}: Finds the last occurrence of a subsequence.
        \item \textbf{find\_first\_of(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) \texttt{InputIterator}: Finds the first element that matches any element in another range.
        \item \textbf{adjacent\_find(InputIterator, InputIterator, o:UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Finds the first two adjacent items that are equal (or satisfy a given predicate).
        \item \textbf{search(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) \texttt{InputIterator}: Searches for the first occurrence of a subsequence.
        \item \textbf{search\_n(InputIterator, InputIterator, size\_t, const T\&)} \(\mapsto\) \texttt{InputIterator}: Searches for a sequence of repeated elements.
    \end{itemize}
    \bigbreak \noindent 
    \begin{notebox}
       The for\_each function returns the function that was used to map each element.
    \end{notebox}

    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{copy(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Copies a range of elements to a new location.
        \item \textbf{copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate)} \(\mapsto\) \texttt{OutputIterator}: Copies elements satisfying a condition to a new location.
        \item \textbf{copy\_n(InputIterator, Size, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Copies a number of elements to a new location.
        \item \textbf{copy\_backward(BidirectionalIterator1, BidirectionalIterator1, BidirectionalIterator2)} \(\mapsto\) \texttt{BidirectionalIterator2}: Copies elements in reverse order.
        \item \textbf{move(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Moves a range of elements to a new location.
        \item \textbf{move\_backward(BidirectionalIterator1, BidirectionalIterator1, BidirectionalIterator2)} \(\mapsto\) \texttt{BidirectionalIterator2}: Moves elements in reverse order.
        \item \textbf{fill(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{void}: Assigns a value to all elements in a range.
        \item \textbf{fill\_n(OutputIterator, Size, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Assigns a value to a number of elements.
        \item \textbf{transform(InputIterator, InputIterator, OutputIterator, UnaryOperation)} \(\mapsto\) \texttt{OutputIterator}: Applies a function to a range of elements.
        \item \textbf{generate(ForwardIterator, ForwardIterator, Generator)} \(\mapsto\) \texttt{void}: Fills a range with the results of successive function calls.
        \item \textbf{generate\_n(OutputIterator, Size, Generator)} \(\mapsto\) \texttt{OutputIterator}: Fills a range with N results of successive function calls.
        \item \textbf{remove(InputIterator, InputIterator, const T\&)} \(\mapsto\) \texttt{InputIterator}: Removes elements equal to a value.
        \item \textbf{remove\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Removes elements satisfying a condition.
        \item \textbf{remove\_copy(InputIterator, InputIterator, OutputIterator, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Copies elements not equal to a value.
        \item \textbf{remove\_copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate)} \(\mapsto\) \texttt{OutputIterator}: Copies elements not satisfying a condition.
        \item \textbf{replace(InputIterator, InputIterator, const T\&, const T\&)} \(\mapsto\) \texttt{void}: Replaces all values equal to a specified value.
        \item \textbf{replace\_if(InputIterator, InputIterator, UnaryPredicate, const T\&)} \(\mapsto\) \texttt{void}: Replaces values satisfying a condition.
        \item \textbf{replace\_copy(InputIterator, InputIterator, OutputIterator, const T\&, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Copies and replaces values.
        \item \textbf{replace\_copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Copies and replaces values based on a condition.
        \item \textbf{swap(T\&, T\&)} \(\mapsto\) \texttt{void}: Swaps the values of two objects.
        \item \textbf{swap\_ranges(ForwardIterator1, ForwardIterator1, ForwardIterator2)} \(\mapsto\) \texttt{ForwardIterator2}: Swaps two ranges of elements.
        \item \textbf{iter\_swap(ForwardIterator1, ForwardIterator2)} \(\mapsto\) \texttt{void}: Swaps elements pointed to by two iterators.
        \item \textbf{reverse(BidirectionalIterator, BidirectionalIterator)} \(\mapsto\) \texttt{void}: Reverses the order of elements in a range.
        \item \textbf{reverse\_copy(BidirectionalIterator, BidirectionalIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Creates a reversed copy of a range.
        \item \textbf{rotate(ForwardIterator, ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Rotates the order of elements in a range.
        \item \textbf{rotate\_copy(ForwardIterator, ForwardIterator, ForwardIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Copies and rotates a range of elements.
        \item \textbf{shift\_left(ForwardIterator, ForwardIterator, Size)} \(\mapsto\) \texttt{ForwardIterator}: Shifts elements in a range to the left.
        \item \textbf{shift\_right(ForwardIterator, ForwardIterator, Size)} \(\mapsto\) \texttt{ForwardIterator}: Shifts elements in a range to the right.
        \item \textbf{random\_shuffle(RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Randomly re-orders elements in a range.
        \item \textbf{shuffle(RandomAccessIterator, RandomAccessIterator, URNG\&)} \(\mapsto\) \texttt{void}: Randomly re-orders elements in a range using a generator.
        \item \textbf{sample(InputIterator, InputIterator, OutputIterator, Size, URNG\&)} \(\mapsto\) \texttt{OutputIterator}: Selects N random elements from a sequence.
        \item \textbf{unique(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Removes consecutive duplicate elements in a range.
        \item \textbf{unique\_copy(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Creates a copy of a range without consecutive duplicates.
        \item \textbf{partition(BidirectionalIterator, BidirectionalIterator, UnaryPredicate)}$\mapsto$ \texttt{Iterator}: Partition range in two
        \item \textbf{partition\_copy(BidirectionalIterator, BidirectionalIterator, UutputIterator)}$\mapsto $ \texttt{OutputIterator}: Partition range in two
        \item \textbf{stable\_partition(BidirectionalIterator, BidirectionalIterator, UnaryPredicate)}$\mapsto $ \texttt{Iterator}: Partition range in two - stable ordering 
    \end{itemize}
    
    \bigbreak \noindent 
    \subsection{Using lambdas for these functions}
    \bigbreak \noindent 
    \begin{cppcode}
        int arr[]  = {1,2,3};
        std::for_each(arr, arr+3, [](int& a) -> int { return ++x; });
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Getting position of element from returned iterator}
    \bigbreak \noindent 
    \begin{concept}
        If we subtract the iterator (which is the address of the array element) from the beginning of the array, we get the distance between the two pointers (so the index position of the iterator value) 
        \bigbreak \noindent 
        \begin{cppcode}
        idx = it - std::begin(array);
        \end{cppcode}
    \end{concept}

    \bigbreak \noindent 
    \subsection{Using shuffle and sample}
    \bigbreak \noindent 
    For these functions we need two components, a seed and a random engine
    \bigbreak \noindent 
    \begin{cppcode}
#include <chrono>
#include <random>

unsigned seed std::chrono::system_clock::now().time_since_epoch().count();
std::default_random_engine engine(seed);
    \end{cppcode}
    \bigbreak \noindent 
    We then use the engine variable in place of URNG\&

    \bigbreak \noindent 
    \subsection{Sorting operations}
    \begin{itemize}
        \item \textbf{is\_sorted(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{bool}: Checks whether a range is sorted into ascending order.
        \item \textbf{is\_sorted\_until(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Finds the largest sorted subrange.
        \item \textbf{sort(RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Sorts a range into ascending order.
        \item \textbf{partial\_sort(RandomAccessIterator, RandomAccessIterator, RandomAccessIterator, comp)} \(\mapsto\) \texttt{void}: Sorts the first N elements of a range.
        \item \textbf{partial\_sort\_copy(InputIterator, InputIterator, RandomAccessIterator, RandomAccessIterator, comp)} \(\mapsto\) \texttt{RandomAccessIterator}: Copies and partially sorts a range of elements.
        \item \textbf{stable\_sort(RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Sorts a range of elements while preserving order between equal elements.
        \item \textbf{nth\_element(RandomAccessIterator, RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Partially sorts the given range making sure that it is partitioned by the given element.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Binary search operations (on sorted ranges)}
    \begin{itemize}
          \item \textbf{lower\_bound(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the first element in the range [first, last) that is not less than (i.e., greater or equal to) the given value.
        \item \textbf{upper\_bound(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the first element in the range [first, last) that is greater than the given value.
        \item \textbf{binary\_search(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{bool}: Determines if an element equal to the given value exists within the range [first, last).
        \item \textbf{equal\_range(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{pair<ForwardIterator, ForwardIterator>}: Returns a range containing all elements equivalent to the given value in the range [first, last).
    \end{itemize}


    \bigbreak \noindent 
    \subsection{Minimum/maximum operations}
    \begin{itemize}
         \item \textbf{max(const T\&, const T\&)} \(\mapsto\) \texttt{T}: Returns the greater of the two given values.
        \item \textbf{max\_element(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the largest element in the range [first, last).
        \item \textbf{min(const T\&, const T\&)} \(\mapsto\) \texttt{T}: Returns the smaller of the two given values.
        \item \textbf{min\_element(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the smallest element in the range [first, last).
        \item \textbf{minmax(const T\&, const T\&)} \(\mapsto\) \texttt{pair<T, T>}: Returns a pair consisting of the smaller and larger of the two elements.
        \item \textbf{minmax\_element(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{pair<ForwardIterator, ForwardIterator>}: Returns a pair of iterators to the smallest and the largest elements in the range [first, last).
        \item \textbf{clamp(const T\&, const T\&, const T\&)} \(\mapsto\) \texttt{T}: Clamps a value between a pair of boundary values.  If the value is less than the lower bound, it returns the lower bound. If it's greater than the upper bound, it returns the upper bound. Otherwise, it returns the value itself.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Other}
    \begin{itemize}
        \item \textbf{merge(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Merges two sorted ranges [first1, last1) and [first2, last2). The resulting range is also sorted.
        \item \textbf{inplace\_merge(BidirectionalIterator, BidirectionalIterator, BidirectionalIterator)} $\mapsto$ \texttt{void}: Merges two consecutive ordered ranges [first, middle) and [middle, last) into a single ordered range [first, last).
        \item \textbf{equal(InputIterator1, InputIterator1, InputIterator2)} $\mapsto$ \texttt{bool}: Determines if the range [InputIterator1, InputIterator1) is equal to the range starting at Inputiterator2.
        \item \textbf{is\_permutation(ForwardIterator1, ForwardIterator1, ForwardIterator2)} $\mapsto$ \texttt{bool} (C++11): Determines if the range [first1, last1) is a permutation of the range starting at first2.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Set Operations}
    \begin{itemize}
        \item \textbf{includes(InputIterator1, InputIterator1, InputIterator2, InputIterator2)} $\mapsto$ \texttt{bool}: Returns true if the range [first2, last2) is a subsequence of the range [first1, last1).
        \item \textbf{set\_difference(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the difference of two sets. The result contains elements that are in the first set but not in the second.
        \item \textbf{set\_intersection(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the intersection of two sets. The result contains elements that are present in both sets.
        \item \textbf{set\_symmetric\_difference(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the symmetric difference between two sets. The result contains elements that are in either of the sets but not in their intersection.
        \item \textbf{set\_union(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the union of two sets. The result contains all elements that are present in either of the sets, without duplicates.
    \end{itemize}

    \pagebreak \bigbreak \noindent
    \section{\LARGE Iterators <iterator>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{advance(Iterator\&, Distance)}$\mapsto$ \texttt{void}: Advances the iterator by the given distance.
        \item \textbf{distance(InputIterator, InputIterator)} \(\mapsto\) \texttt{typename iterator\_traits<InputIterator>::difference\_type}: Returns the number of steps between two iterators.
        \item \textbf{begin(Container\&)} \(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the first element of the container.
        \item \textbf{end(Container\&)} \(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the past-the-end element of the container.
        \item \textbf{prev(BidirectionalIterator)} \(\mapsto\) \texttt{BidirectionalIterator}: Returns an iterator pointing to the element immediately before the given iterator.
        \item \textbf{next(ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator pointing to the element immediately after the given iterator.
    \end{itemize}


    \bigbreak \noindent 
    \subsection{Iterator generators:}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{back\_inserter(Container\&)} \(\mapsto\) \texttt{BackInsertIterator}: Constructs a back-insert iterator that appends new elements to the end of the specified container.
        \item \textbf{front\_inserter(Container\&)} \(\mapsto\) \texttt{FrontInsertIterator}: Constructs a front-insert iterator that prepends new elements to the beginning of the specified container.
        \item \textbf{inserter(Container\&, Iterator)} \(\mapsto\) \texttt{InsertIterator}: Constructs an insert iterator for inserting new elements into the container at the position specified by the given iterator.
        \item \textbf{make\_move\_iterator(Iterator)} \(\mapsto\) \texttt{MoveIterator}: Converts a regular iterator into a move iterator, causing the elements to be moved rather than copied.
    \end{itemize}
    

    

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Vectors}
    \bigbreak \noindent 
    \subsection{Element Access}
    \begin{itemize}
        \item \textbf{at(size\_type n)} \(\mapsto\) T\& Accesses the element at the specified position \textit{n} in the container, with bounds checking. Throws an out-of-range exception if \textit{n} is not within the range of the container.
        \item \textbf{front()} \(\mapsto\) T\& Accesses the first element in the container. Undefined behavior if the container is empty.
        \item \textbf{back()} \(\mapsto\) T\& Accesses the last element in the container. Undefined behavior if the container is empty.
        \item \textbf{data()} \(\mapsto\) \texttt{\texttt{T*}}: Provides direct access to the underlying array in the container. Returns a pointer to the array.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Capacity}
    \begin{itemize}
        \item \textbf{empty()} \(\mapsto\) \texttt{bool}: Checks whether the container is empty. Returns \texttt{true} if the container is empty, \texttt{false} otherwise.
        \item \textbf{size()} \(\mapsto\) \texttt{size\_type}: Returns the number of elements in the container.
        \item \textbf{max\_size()} \(\mapsto\) \texttt{size\_type}: Returns the maximum number of elements that the container can hold.
        \item \textbf{capacity()} \(\mapsto\) \texttt{size\_type}: Returns the number of elements that can be held in currently allocated storage.
        \item \textbf{reserve(size\_type n)}$\mapsto$ \texttt{void}: Reserves storage to make the container capable of holding at least \textit{n} elements. If \textit{n} is greater than the current \texttt{capacity()}, new storage is allocated, otherwise the method does nothing.
        \item \textbf{shrink\_to\_fit()}$\mapsto$ \texttt{void}: Reduces memory usage by freeing unused memory. This is a non-binding request to reduce \texttt{capacity()} to \texttt{size()}. The implementation is allowed to optimize otherwise or ignore the request.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Modifiers}
    \begin{itemize}
        \item \textbf{push\_back(const T\& value)}$\mapsto$ \texttt{void} Adds an element to the end of the container.
        \item \textbf{pop\_back()}$\mapsto$ \texttt{void}: Removes the last element from the container.
        \item \textbf{insert(iterator pos, const T\& value)}$\mapsto$ \texttt{iterator}: Inserts an element at the position given by \textit{pos}. 
        \item \textbf{insert(iterator pos, size\_t count, tconst T\& value)}$\mapsto$ \texttt{iterator}: Inserts a specified number of element at the position given by \textit{pos}. 
        \item \textbf{insert(iterator pos, iteratorFirst, iteratorSecond)}$\mapsto$ \texttt{iterator}: Inserts a range of elements at the position given by \textit{pos}. 
        % \item \textbf{insert(iterator pos, initlist)}$\mapsto$ \texttt{iterator}: Inserts a range of elements at the position given by \textit{pos}. 
        \item \textbf{clear()}$\mapsto$ \texttt{void}: Clears the contents of the container. After this call, \texttt{size()} returns zero.
        \item \textbf{erase(iterator pos)} \(\mapsto\) \texttt{iterator}: Erases the element at the position given by \textit{pos}. Returns an iterator following the last removed element.
        \item \textbf{emplace(iterator pos, Args&&... args)}$\mapsto$ \texttt{iterator}: Constructs an element in-place at the position given by \textit{pos}. The arguments \textit{args} are forwarded to the constructor of the element type.
        \item \textbf{emplace\_back(Args&&... args)}$\mapsto$ \texttt{T\&}: Constructs an element in-place at the end of the container. The arguments \textit{args} are forwarded to the constructor of the element type.
        \item \textbf{resize(size\_type sz)}$\mapsto$ \texttt{void}: Changes the number of elements stored. If \textit{sz} is smaller than the current size, the container is reduced to its first \textit{sz} elements.
        \item \textbf{swap(Container\& other)}$\mapsto$ \texttt{void}: Swaps the contents with \textit{other} container. The swap operation is generally very fast and never fails.
        \item \textbf{assign(InputIterator first, InputIterator last)}$\mapsto$ \texttt{void}: Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly. The new contents are elements constructed from each of the elements in the range between \textit{first} and \textit{last}, in the same order.
        \item \textbf{assign(size\_type n, const T\& val)}$\mapsto$ \texttt{void}: Assigns \textit{n} elements to the vector, each copy of \textit{val}. If \textit{n} is larger than the current vector size, additional elements are appended; if \textit{n} is smaller, the container is reduced to its first \textit{n} elements.
        \item \textbf{assign(std::initializer\_list<T> il)}$\mapsto$ \texttt{void}: Assigns new contents to the vector, replacing its current contents with the elements in the initializer list \textit{il}.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Iterators}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{begin()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the first element.
        \item \textbf{cbegin()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to the first element.
        \item \textbf{end()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to one-past-the-last element.
        \item \textbf{cend()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to one-past-the-last element.
        \item \textbf{rbegin()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to the last element.
        \item \textbf{crbegin()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to the last element.
        \item \textbf{rend()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to one-past-the-first element.
        \item \textbf{crend()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to one-past-the-first element.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Emplace example <vector>}
    \bigbreak \noindent 
    \begin{cppcode}
class MyClass {
public:
    MyClass(int x, double y) : x(x), y(y) {}

    void print() const { std::cout << "MyClass(" << x << ", " << y << ")\n"; }
private:
    int x;
    double y;
};

int main() {
    std::vector<MyClass> vec;
    // Construct MyClass objects directly at the end of the vector
    vec.emplace_back(10, 3.14);
    vec.emplace_back(20, 6.28); return 0; }
    \end{cppcode}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE List <list>}
    \bigbreak \noindent 
    \subsection{Element Access}
    \begin{itemize}
        \item \textbf{front()} $\mapsto$ \texttt{T\&}: Accesses the first element.
        \item \textbf{back()} $\mapsto$ \texttt{T\&}: Accesses the last element.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Capacity}
    \begin{itemize}
        \item \textbf{empty()} $\mapsto$ \texttt{bool}: Checks whether the container is empty.
        \item \textbf{size()} $\mapsto$ \texttt{size\_type}: Returns the number of elements.
        \item \textbf{max\_size()} $\mapsto$ \texttt{size\_type}: Returns the maximum possible number of elements.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Modifiers}
    \begin{itemize}
        \item \textbf{resize(size\_type sz)} $\mapsto$ \texttt{void}: Changes the number of elements stored.
        \item \textbf{push\_back(const T\& value)} $\mapsto$ \texttt{void}: Adds an element to the end.
        \item \textbf{push\_front(const T\& value)} $\mapsto$ \texttt{void}: Inserts an element to the beginning.
        \item \textbf{pop\_back()} $\mapsto$ \texttt{void}: Removes the last element.
        \item \textbf{pop\_front()} $\mapsto$ \texttt{void}: Removes the first element.
        \item \textbf{assign(InputIterator first, InputIterator last)} $\mapsto$ \texttt{void}: Assigns values to the container.
        \item \textbf{assign(size\_type n, const T\& val)}$\mapsto$ \texttt{void}: Assigns \textit{n} elements to the vector, each copy of \textit{val}. If \textit{n} is larger than the current vector size, additional elements are appended; if \textit{n} is smaller, the container is reduced to its first \textit{n} elements.
        \item \textbf{assign(std::initializer\_list<T> il)}$\mapsto$ \texttt{void}: Assigns new contents to the vector, replacing its current contents with the elements in the initializer list \textit{il}.
        \item \textbf{insert(Iterator pos, const T\& value)} $\mapsto$ \texttt{Iterator}: Inserts elements.
        \item \textbf{remove(const T\& value)} $\mapsto$ \texttt{size\_T}: Removes elements satisfying specific criteria.
        \item \textbf{remove\_if(UnaryPredicate pred)} $\mapsto$ \texttt{size\_T}: Removes elements satisfying specific criteria.
        \item \textbf{reverse()} $\mapsto$ \texttt{void}: Reverses the order of the elements.
        \item \textbf{clear()} $\mapsto$ \texttt{void}: Clears the contents.
        \item \textbf{erase(Iterator pos)} $\mapsto$ \texttt{Iterator}: Erases elements.
        \item \textbf{emplace(Iterator pos, Args\&\&... args)} $\mapsto$ \texttt{Iterator}: Constructs element in-place.
        \item \textbf{emplace\_back(Args\&\&... args)} $\mapsto$ \texttt{T\&}: Constructs an element in-place at the end.
        \item \textbf{emplace\_front(Args\&\&... args)} $\mapsto$ \texttt{T\&}: Constructs an element in-place at the beginning.
        \item \textbf{merge(List\& other)} $\mapsto$ \texttt{void}: Merges two sorted lists.
        \item \textbf{splice(Iterator pos, List\& other)} $\mapsto$ \texttt{void}: Moves elements from another list.
        \item \textbf{unique()} $\mapsto$ \texttt{size\_t}: Removes consecutive duplicate elements.
        \item \textbf{swap(Container\& other)} $\mapsto$ \texttt{void}: Swaps the contents.
        \item \textbf{sort()} $\mapsto$ \texttt{void}: Sorts the elements.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Iterators}
    \begin{itemize}
         \item \textbf{begin()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the first element.
        \item \textbf{cbegin()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to the first element.
        \item \textbf{end()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to one-past-the-last element.
        \item \textbf{cend()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to one-past-the-last element.
        \item \textbf{rbegin()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to the last element.
        \item \textbf{crbegin()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to the last element.
        \item \textbf{rend()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to one-past-the-first element.
        \item \textbf{crend()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to one-past-the-first element.
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Set <set>}
    \bigbreak \noindent 

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Map <map>}
    \bigbreak \noindent 

    \pagebreak \bigbreak \noindent 
    \section{\LARGE cstdarg (For variadic functions)}
    \bigbreak \noindent 
    \subsection{Types}
    \begin{itemize}
        \item \textbf{va\_list} Type to hold information about variable arguments 
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Functions}
    \begin{itemize}
        \item \textbf{va\_start}	Initialize a variable argument list 
        \item \textbf{va\_arg} Retrieve next argument 
        \item \textbf{va\_end} End using variable argument list 
        \item \textbf{va\_copy} Copy variable argument list 
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Functional}
    \bigbreak \noindent 

    \pagebreak \bigbreak \noindent 
    \unsect{Memory stuff from Cstdlib and <cstring>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{calloc(size\_t num, size\_t size)} $\mapsto$ \texttt{void*}: Allocate and zero-initialize an array. Returns a pointer to the allocated memory, or NULL if the allocation fails.
        \item \textbf{free(void* ptr)} $\mapsto$ \texttt{void}: Deallocate memory block. Frees the memory space pointed to by \texttt{ptr}, which must have been returned by a previous call to \texttt{malloc}, \texttt{calloc}, or \texttt{realloc}. Otherwise, or if \texttt{free(ptr)} is called more than once, undefined behavior occurs.
        \item \textbf{malloc(size\_t size)} $\mapsto$ \texttt{void*}: Allocate a memory block. Returns a pointer to the allocated memory, or NULL if the allocation fails.
        \item \textbf{realloc(void* ptr, size\_t new\_size)} $\mapsto$ \texttt{void*}: Reallocate a memory block. Changes the size of the memory block pointed to by \texttt{ptr} to \texttt{new\_size}. The function may move the memory block to a new location, in which case the new location is returned. Returns NULL if the allocation fails.
         \item \textbf{memchr(const void* str, int c, size\_t n)} $\mapsto$ \texttt{void*}: Searches for the first occurrence of the character \texttt{c} (an unsigned char) in the first \texttt{n} bytes of the string pointed to by \texttt{str}. Returns a pointer to the matching byte or NULL if the character does not occur in the given memory area.
        \item \textbf{memcmp(const void* str1, const void* str2, size\_t n)} $\mapsto$ \texttt{int}: Compares the first \texttt{n} bytes of the memory areas \texttt{str1} and \texttt{str2}. Returns an integer less than, equal to, or greater than zero if \texttt{str1} is found, respectively, to be less than, to match, or be greater than \texttt{str2}.
        \item \textbf{memset(void* str, int c, size\_t n)} $\mapsto$ \texttt{void*}: Fills the first \texttt{n} bytes of the memory area pointed to by \texttt{str} with the constant byte \texttt{c}. Returns a pointer to the memory area \texttt{str}.
        \item \textbf{memcpy(void* dest, const void* src, size\_t n)} $\mapsto$ \texttt{void*}: Copies \texttt{n} bytes from memory area \texttt{src} to memory area \texttt{dest}. The memory areas must not overlap. Returns a pointer to \texttt{dest}.
        \item \textbf{memmove(void* dest, const void* src, size\_t n)} $\mapsto$ \texttt{void*}: Moves \texttt{n} bytes from memory area \texttt{src} to memory area \texttt{dest}. The memory areas may overlap. Returns a pointer to \texttt{dest}.
    \end{itemize}





%
%
%     

%
%
%

    
\end{document}
