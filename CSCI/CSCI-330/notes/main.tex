\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Unix and Network Programming}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Unix and Network Programming} \\
           With Linux and C++
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           February 16, 2023 \\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Commands}
    \begin{itemize}
        \item \textbf{more, less, pg}: Display contents of file one page at a time
        \item \textbf{head}: Display beginning  portion of file (Default: 10 lines)
        \item \textbf{tail}: Display end portion of file 
        \item \textbf{wc}: Count file content (-l -w -c)  (lines, words, characters)
        \item \textbf{diff}: Compare two files line by line
        \item \textbf{gzip, gunzip, zcat}: compress file content (.gz files)
        \item \textbf{sort}: Sort file contents (-r -n -t -k -f) (reverse, numeric, field delimiter, field1[,field2], ignore case)
        \item \textbf{quota -v}: Disk quota
        \item \textbf{lpr}: Send files to printer, -P to specify printer (lpcsl, lpfrl, etc)
        \item \textbf{lpq}: Show print queue
        \item \textbf{lprm}: Remove job from print queue
    \end{itemize}



    \pagebreak 
    \unsect{Permissions}
    \bigbreak \noindent 
    Unix uses discretionary access control (DAC) model
    \begin{itemize}
        \item Each directory/file has owner
        \item Owner has discretion over access control details
    \end{itemize}
    With the exception of the super user

    \bigbreak \noindent 
    \subsection{Changing Permissions}
    \bigbreak \noindent 
    There are four categories regarding permissions 
    \begin{itemize}
        \item User 
        \item Group
        \item Other
        \item All
    \end{itemize}
    \bigbreak \noindent 
    To change the permissions of a file, we use the \texttt{chmod} command
    \bigbreak \noindent 
    \begin{bashcode}
    chmod -options mode file/directory
    \end{bashcode}
    \bigbreak \noindent 
    \subsubsection{Changing Permissions: Symbolic mode}
    \bigbreak \noindent 
    \fig{0.5}{./figures/1.png}
    \bigbreak \noindent  \bigbreak \noindent 
    \fig{0.5}{./figures/2.png}



    \pagebreak 
    \subsubsection{Changing permissions: Octal mode}
    \fig{.8}{./figures/3.png}

    \bigbreak \noindent 
    \subsubsection{Exercise: Changing permissions}
    \bigbreak \noindent 
    Suppose we want to change the permissions of "myfile". We want
    \begin{itemize}
        \item Read, write, and execute for user 
        \item Read and execute for group
        \item Execute for other
    \end{itemize}
    \bigbreak \noindent 
    \begin{bashcode}
    chmod u=rwx, g=rx, o=x myfile
    chmod 751 myfile
    \end{bashcode}

    \bigbreak \noindent 
    \subsection{Special Permissions}
    \bigbreak \noindent 
    3 additional permissions can be set on files and directories
    \begin{itemize}
        \item Set user ID (SUID)
        \item Set group ID (SGID)
        \item Sticky bit
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Set user ID (SUID)}
    \bigbreak \noindent 
    \begin{concept}
       SUID is used for executable files, it makes executables run with permissions of file owner, rather than invoker 
    \end{concept}
    \bigbreak \noindent 
    For example, the passwd command uses this permission. This allows user access to otherwise protected system files while changing password

    \pagebreak 
    \subsubsection{Set group ID (SGID)}
    \bigbreak \noindent 
    \begin{concept}
        \begin{itemize}
            \item \textbf{For executables}: The logic for SGID is the same as SUID, but for group owner rather than file owner
            \item \textbf{For directories}: A file created in the directory will be owned by the group owner of the directory, not the group of the user who created the file
        \end{itemize}
    \end{concept}

    \bigbreak \noindent 
    \subsubsection{Sticky Bit}
    \bigbreak \noindent 
    \begin{concept}
       \begin{itemize}
           \item \textbf{For executables}: Executable is kept in memory even after it ended
            \item \textbf{For directories}: Files can only be deleted by the user that created it 
       \end{itemize} 
    \end{concept}

    \bigbreak \noindent 
    \subsubsection{Displaying special permissions}
    \bigbreak \noindent 
    \begin{concept}
        The \texttt{ls -l}  command does not display special permission bits. However, since special permissions require execute, they mask the execute permission when displayed with \texttt{ls -l}
    \end{concept}

    \bigbreak \noindent 
    \subsubsection{Setting special permissions (octal)}
    \bigbreak \noindent 
    \fig{.8}{./figures/4.png}

    \pagebreak 
    \subsubsection{Setting special permissions (Symbolic)}
    \bigbreak \noindent 
    \fig{.8}{./figures/5.png}

    \bigbreak \noindent 
    \subsection{User mask (umask)}
    \bigbreak \noindent 
    \fig{.8}{./figures/6.png}

    \pagebreak 
    \subsubsection{Examples}
    \bigbreak \noindent 
    \fig{.8}{./figures/7.png}

    \bigbreak \noindent 
    \subsection{Permissions needed for file and directory actions}
    \bigbreak \noindent 
    \subsubsection{Files}
    \begin{itemize}
        \item \textbf{Read:} View file contents (open, read)
        \item \textbf{Write:} Change file contents
        \item \textbf{Execute:} Run executable file
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Directories}
    \begin{itemize}
        \item \textbf{Read:} List directory contents (Only names)
        \item \textbf{Write:} Change directory contents (need execute aswell)
        \item \textbf{Execute:} Make it current directory, search for files in it 
        \item \textbf{Renaming files:} Write and execute permissions on the directory
        \item \textbf{Deleting files:} Write and execute permissions on the directory
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Both files and directories}
    \begin{itemize}
        \item \textbf{Moving files:} Read permissions on file and write permissions on target directory
    \end{itemize}

    \pagebreak 
    \unsect{Network Utilitys}

    \begin{itemize}
        \item Login to another computer 
            \begin{itemize}
                \item telnet, rlogin, rsh, ssh
            \end{itemize}
        \item Copy files to another computer 
            \begin{itemize}
                \item scp
                \item ftp, sftp
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Login to another computer}
    \bigbreak \noindent 
    \begin{itemize}
        \item telnet rlogin, rsh no longer used
            \begin{itemize}
                \item Transmit username/password without encryption
            \end{itemize}
        \item ssh
            \begin{itemize}
                \item Invokes shell on remote computer securely
                \item \textbf{Used to:} Remote login and run command on remote computer
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{ssh}

    \bigbreak \noindent 
    \subsubsection{Syntax}
    \begin{bashcode}
        ssh [user@]hostname [command]
    \end{bashcode}
    \bigbreak \noindent 
    This command logs in user to hostname, or if command is given, runs it on remote host 

    \bigbreak \noindent 
    \subsubsection{Common options}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{-l}: login-name 
        \item \textbf{-X}: enable X11 forwarding
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Examples}
    \bigbreak \noindent 
    \fig{1}{./figures/8.png}

    \pagebreak 
    \subsection{Copy files to another computer}

    \bigbreak \noindent 
    \subsubsection{Currently in use}
    \begin{itemize}
        \item ftp
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Secure, encrypted, part of OpenSSH}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{sftp}: Secure file transfer
        \item \textbf{scp}: Secure copy to remote host
    \end{itemize}

    \bigbreak \noindent 
    \subsection{ftp}
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \bigbreak \noindent 
    \begin{bashcode}
        ftp hostname
    \end{bashcode}
    \bigbreak \noindent 
    This will prompt for userid and password

    \bigbreak \noindent 
    \subsubsection{Anonymous ftp}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Userid}: ftp or anonymous
        \item \textbf{Password}: Your email address
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Commands}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{help}
        \item \textbf{ls}
        \item \textbf{cd} 
        \item \textbf{put, get}
            \begin{itemize}
                \item copy a file from local to remote host, or vice versa 
            \end{itemize}
        \item \textbf{mput, mget}
            \begin{itemize}
                \item put/get multiple files, can use wildcards
            \end{itemize}
        \item \textbf{bye}
    \end{itemize}

    \pagebreak 
    \subsection{sftp (Secure file transfer)}

    \bigbreak \noindent 
    \subsubsection{Syntax}
    \bigbreak \noindent 
    \begin{bashcode}
    sftp user@hostname
    \end{bashcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item Will prompt for password
        \item Same commands as ftp
    \end{itemize}

    \bigbreak \noindent 
    \subsection{scp}
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \bigbreak \noindent 
    \begin{bashcode}
        scp source target
    \end{bashcode}
    \begin{itemize}
        \item source and target use extended form of pathname
            \bigbreak \noindent 
            \begin{bashcode}
            user@host:pathname
            \end{bashcode}
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Common options}
    \begin{itemize}
        \item \textbf{-r}: Recursively copy entire directories
        \item \textbf{-C}: Enables compression
        \item \textbf{-l}: Limit bandwidth, specified in Kbit/s
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Examples}
    \bigbreak \noindent 
    \begin{bashcode}
    scp screenshot.png z123456@turing.cs.niu.edu:
    scp z123456@hopper.cs.niu.edu:assign1.cc .
    \end{bashcode}

    \pagebreak 
    \unsect{Shell: Part 1}
    \bigbreak \noindent 
    \subsection{Basics}
    \bigbreak \noindent 
    \subsubsection{Customization}
    \begin{itemize}
        \item variables, prompt, aliases
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Command line behavior}
    \begin{itemize}
        \item history
        \item sequence and substitution
        \item redirections and pipe
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Predefined variables}
    \begin{itemize}
        \item \textbf{HOME}: full pathname of home directory
        \item \textbf{PATH}: list of directories to search for commands
        \item \textbf{USER}: your user name, also UID for user id
        \item \textbf{SHELL}: full pathname of your login shell
        \item \textbf{PWD}: Current working directory
        \item \textbf{HOSTNAME}: current hostname of the system
        \item \textbf{HISTSIZE}: Number of commands to remember
        \item \textbf{PS1}: Primary prompty (also PS2, ...)
        \item \textbf{?}: Return status of most recently executed command
        \item \textbf{\$}: Process id of current process
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Customizing bash shell prompt}
    \bigbreak \noindent 
    Can be set via the PS1 shell variable
    \bigbreak \noindent 
    \subsubsection{Example:}
    \begin{bashcode}
    PS1="$USER > " 
    \end{bashcode}
    \bigbreak \noindent 
    \subsubsection{Special PS1 shell variable settings}
    \begin{itemize}
        \item \textbf{\textbackslash w}: current working directory
        \item \textbf{\textbackslash h}: hostname
        \item \textbf{\textbackslash u}: username
        \item \textbf{\textbackslash d}: date
        \item \textbf{\textbackslash t}: time
        \item \textbf{\textbackslash a}: ring the "bell"
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Customization}
    \begin{itemize}
        \item Via command line options: Rarely done
        \item Instead we use startup initialization file
            \begin{itemize}
                \item $\sim$/.profile (login session shell)
                \item $\sim$/.bashrc (invoked from command line)
            \end{itemize}
    \end{itemize}
    \textbf{Note:} we also have /etc/profile and /etc/bash.bashrc

    \bigbreak \noindent 
    \subsection{Command line behavior}
    \begin{itemize}
        \item History
        \item Sequence
        \item Substition
        \item I/O redirection and pipe
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Shell history}
    \begin{itemize}
        \item Record of previously entered commands
            \begin{itemize}
                \item can be re-called, edited, and re-executed
            \end{itemize}
        \item Size of history is set via shell variables
            \begin{itemize}
                \item HISTSIZE=500 (per session)
                \item HISTFILESIZE=100 (per user)
            \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \begin{bashcode}
        history [-c] [count]
    \end{bashcode}
    \bigbreak \noindent 
    Where -c is used to search for specific text
    \bigbreak \noindent 
    \nt{We use arrow keys to navigate, delete and backspace to remove, and tab to execute command}
    \bigbreak \noindent 
    \subsection{Command substitution}
    \bigbreak \noindent 
    \subsubsection{Backtics}
    The first method is using backticks
    \begin{itemize}
        \item Command surrounded by back quotes `` is run and replaced by its standard output
        \item Newlines in the output are replaced by spaces
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Dollar sign parenthesis notation}
    \bigbreak \noindent 
    Alternatively, we use the following syntax
    \begin{bashcode}
    $(command)
    \end{bashcode}
    \bigbreak \noindent 
    \subsection{Here document}
    \bigbreak \noindent 
    This uses $<<$. With this we can read input for current source
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \begin{bashcode}
    command << LABEL
    \end{bashcode}
    \bigbreak \noindent 
    Reads following lines until line starting with "LABEL"
    \bigbreak \noindent 
    \subsubsection{Example:}
    \begin{bashcode}
     wc -l << DONE
        > line one
        > line two 
        > DONE
    2
    \end{bashcode}
    \pagebreak 
    \subsection{File Descriptor}
    \begin{itemize}
        \item Positive integer for every open file
        \item Process tracks its open files with this number
            \begin{itemize}
                \item 0 - standard input
                \item 1 - standard output
                \item 2 - standard error output
            \end{itemize}
        \item Bash can use file descriptor to refer to a file
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Table of redirection operators}
    \bigbreak \noindent 
    \begin{table}[ht]
        \centering
        \caption{Common Redirection Syntaxes in Linux}
        \label{tab:redirection}
        \begin{tabular}{@{}ll@{}}
            \toprule
            Syntax      & Description                                           \\ \midrule
            \texttt{>} or \texttt{1>}  & Redirects standard output (\texttt{stdout}) to a file, overwriting the file. \\
            \texttt{>>} or \texttt{1>>} & Redirects standard output (\texttt{stdout}) to a file, appending to the file. \\
            \texttt{2>}  & Redirects standard error (\texttt{stderr}) to a file, overwriting the file. \\
            \texttt{2>>} & Redirects standard error (\texttt{stderr}) to a file, appending to the file. \\
            \texttt{\&>} & Redirects both standard output and standard error to a file, overwriting the file. \\
            \texttt{>\&} & Redirects both standard output and standard error to a file, overwriting the file. \\
            \texttt{<} or \texttt{0<}  & Redirects a file to standard input (\texttt{stdin}). \\
            \texttt{<<}  & Here document: redirects inline input to standard input. \\
            \texttt{<<<} & Here string: redirects a single line of input to standard input. \\
            \bottomrule
        \end{tabular}
    \end{table}

    \bigbreak \noindent 
    \subsubsection{Combining redirection}
    \bigbreak \noindent 
    Before $&>$ was introduced, the way to redirect both stderr and stdout to a file looked something like
    \bigbreak \noindent 
    \begin{bashcode}
        command > file 2>&1
    \end{bashcode}
    \bigbreak \noindent 
    This tells bash to redirect stdout from command to file, and then redirect stderr (2) to stdout (which is now pointing to file). Note that the order does matter, for example the following will not work
    \bigbreak \noindent 
    \begin{bashcode}
    command 2>&1 > file 
    \end{bashcode}
    \bigbreak \noindent 
    This would redirect stderr to whereever stdout is pointing, and then redirect stdout to file. Thus not bringing along stderr

    \pagebreak 
    \subsection{The pipe}
    \bigbreak \noindent 
    Bash introduced a concise way to redirect the output from a command as the input to some other command. For this, we use the pipe (|)
    \bigbreak \noindent 
    \begin{bashcode}
    command1 | command2
    \end{bashcode}
    \bigbreak \noindent 
    Before the pipe syntax, we would have to do something like
    \bigbreak \noindent 
    \begin{bashcode}
    command1 > file; command2 < file
    \end{bashcode}

    \bigbreak \noindent 
    \subsection{Wildcards}
    \bigbreak \noindent 
    Bash has special characters knows as wildcards, these allow us to match filenames on the command line
    \begin{itemize}
        \item * (asterisk): Matches zero or more characters
        \item ? (question mark): Matches exactly one character (any character)
        \item \relax [...] (characters enclosed by brackets): Maches any of the enclosed characters
        \item \relax [a-z] (range syntax): matches any characters in the specified range
        \item \{word1, word2,...\} (brace syntax): Similar to the brackets, but for words
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Character classes}
    \bigbreak \noindent 
    Character classes are defined by the bracket syntax, as we say in the previous list.
    \bigbreak \noindent 
    \begin{bashcode}
        ls test[a-z] # Matches test followed by any character a-z
        ls test[a-z]* # Matches test followed by any character a-z followed by any character
        ls test[^a-z] # matches test followed by any character not found within the range a-z
        ls test[!a-z] # matches test followed by any character not found within the range a-z
        ls test[123] # maches test1, test2, or test3
    \end{bashcode}
    \bigbreak \noindent 
    \subsubsection{Posix character classes}
    \bigbreak \noindent 
    POSIX character classes are a special notation used in regular expressions and pattern matching that provides a locale-independent way to specify groups of characters. 
    \bigbreak \noindent 
    \begin{bashcode}
        ls [[:upper:]]* 
    \end{bashcode}
    \bigbreak \noindent 
    The first set of brackets defines a bash character class, and within that we define a posix character class. We also have
    \begin{itemize}
        \item \relax[[:alpha:]]: Matches any letter.
        \item \relax[[:digit:]]: Matches any digit.
        \item \relax[[:lower:]]: Matches any lowercase letter.
        \item \relax[[:upper:]]: Matches any uppercase letter.
        \item \relax[[:space:]]: Matches any whitespace character (including spaces, tabs, and form feeds).
        \item \relax[[:alnum:]]: Matches any alphanumeric character (letters and digits).
    \end{itemize}

    \pagebreak 
    \unsect{Shell Scripts}
    \bigbreak \noindent 
    \subsection{Local / Global Variables}
    \bigbreak \noindent 
    \begin{concept}
        In the Bash shell, variables defined within functions are not automatically local to those functions. By default, \textbf{variables in Bash functions are global}, meaning if you define or modify a variable within a function without explicitly declaring it as local, its value is accessible and can affect the script outside the function. 
    \end{concept}
    









    
\end{document}
