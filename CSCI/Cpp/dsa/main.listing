procedure sift_down(array : list of sortable items, start : starting
  subscript of heap, end : ending subscript of heap)
    // root : array subscript
    // largest : array subscript
    // child : array subscript

    // Repair the heap whose root element is at subscript 'start',
    // assuming the heaps rooted at its children are valid

    root = start

    // While the root has at least one child
    while (2 * root + 1) <= end
        child = 2 * root + 1 // Left child of root
        largest = root // Assume root is largest

        // If left child is larger than root, left child is largest
        if array[largest] < array[child]
            largest = child
        end if

        // If there is a right child and it is greater than largest,
        // right child is largest
        if (child + 1) <= end and array[largest] < array[child+1]
            largest = child + 1
        end if

        // If root is largest, no need to continue
        if largest == root
            return
        else
            swap array[root] and array[largest]
            root = largest
        end if

    end while
end procedure
