\contentsline {section}{\numberline {1}The C++ Language}{17}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Key Features}{17}{subsection.0.1.1}%
\contentsline {section}{\numberline {2}The Compiler}{19}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Preprocessing}{19}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Lexical Analysis}{19}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Syntax Analysis}{19}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Semantic Analysis}{19}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Intermediate Code Generation}{19}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Code Optimization}{20}{subsection.0.2.6}%
\contentsline {subsection}{\numberline {2.7}Code Generation}{20}{subsection.0.2.7}%
\contentsline {subsection}{\numberline {2.8}Assembling}{20}{subsection.0.2.8}%
\contentsline {subsection}{\numberline {2.9}Linking}{20}{subsection.0.2.9}%
\contentsline {subsection}{\numberline {2.10}Complier Options}{20}{subsection.0.2.10}%
\contentsline {subsection}{\numberline {2.11}Header Files}{21}{subsection.0.2.11}%
\contentsline {section}{\numberline {3}Preliminaries: A Quick Tour of C++ Fundamentals}{22}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Boilerplate}{22}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}The main function}{22}{subsection.0.3.2}%
\contentsline {subsection}{\numberline {3.3}Comments}{23}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Data Types, Modifiers, Qualifiers, Inference}{24}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}Primitive Type Ranges and Size}{25}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}Creating strings without the STL}{26}{subsection.0.3.6}%
\contentsline {subsection}{\numberline {3.7}Retrieve size}{27}{subsection.0.3.7}%
\contentsline {subsection}{\numberline {3.8}Retrieve type}{27}{subsection.0.3.8}%
\contentsline {subsection}{\numberline {3.9}Exponential Notation}{28}{subsection.0.3.9}%
\contentsline {subsection}{\numberline {3.10}Type Conversion}{28}{subsection.0.3.10}%
\contentsline {subsection}{\numberline {3.11}Integer Division}{29}{subsection.0.3.11}%
\contentsline {subsection}{\numberline {3.12}Overflow/Underflow}{29}{subsection.0.3.12}%
\contentsline {subsection}{\numberline {3.13}Type Casting}{29}{subsection.0.3.13}%
\contentsline {subsection}{\numberline {3.14}C-style Casts}{30}{subsection.0.3.14}%
\contentsline {subsection}{\numberline {3.15}The Using Directive}{31}{subsection.0.3.15}%
\contentsline {subsection}{\numberline {3.16}Variable Declaration}{32}{subsection.0.3.16}%
\contentsline {subsection}{\numberline {3.17}Multiple Declaration}{32}{subsection.0.3.17}%
\contentsline {subsection}{\numberline {3.18}Initialization}{32}{subsection.0.3.18}%
\contentsline {subsection}{\numberline {3.19}Multiple Initialization}{32}{subsection.0.3.19}%
\contentsline {subsection}{\numberline {3.20}Direct Initialization}{33}{subsection.0.3.20}%
\contentsline {subsection}{\numberline {3.21}List Initialization}{33}{subsection.0.3.21}%
\contentsline {subsection}{\numberline {3.22}Copy Initialization}{33}{subsection.0.3.22}%
\contentsline {subsection}{\numberline {3.23}Assignment}{33}{subsection.0.3.23}%
\contentsline {subsection}{\numberline {3.24}Multiple Assignment}{34}{subsection.0.3.24}%
\contentsline {section}{\numberline {4}Symbols}{35}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Parentheses}{35}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Brackets}{35}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Braces}{35}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Angle Brackets}{35}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Semi Colon}{35}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Colon}{35}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}Comma}{36}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}Ellipsis}{36}{subsection.0.4.8}%
\contentsline {subsection}{\numberline {4.9}Hash}{36}{subsection.0.4.9}%
\contentsline {section}{\numberline {5}Preprocessor Directives}{37}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}\#include}{37}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}\#define}{37}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}\#undef}{37}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}\#ifdef, \#ifndef, \#else, \#elif, \#endif}{37}{subsection.0.5.4}%
\contentsline {subsection}{\numberline {5.5}\#if}{38}{subsection.0.5.5}%
\contentsline {subsection}{\numberline {5.6}\#pragma}{38}{subsection.0.5.6}%
\contentsline {subsection}{\numberline {5.7}\#error}{38}{subsection.0.5.7}%
\contentsline {subsection}{\numberline {5.8}\#line}{38}{subsection.0.5.8}%
\contentsline {section}{\numberline {6}Input/Output}{39}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}iostream}{39}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Output}{39}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Input}{39}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}IO Manipulators}{41}{subsection.0.6.4}%
\contentsline {subsection}{\numberline {6.5}std::setiosflags}{43}{subsection.0.6.5}%
\contentsline {subsection}{\numberline {6.6}Escape Sequences}{43}{subsection.0.6.6}%
\contentsline {subsection}{\numberline {6.7}User Input With Strings}{44}{subsection.0.6.7}%
\contentsline {subsection}{\numberline {6.8}User input with characters}{45}{subsection.0.6.8}%
\contentsline {subsection}{\numberline {6.9}Mixing cin and cin.get}{45}{subsection.0.6.9}%
\contentsline {section}{\numberline {7}Operators}{46}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Arithmetic Operators}{46}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Relational Operators}{46}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}Logical Operators}{46}{subsection.0.7.3}%
\contentsline {subsection}{\numberline {7.4}Bitwise Operators}{46}{subsection.0.7.4}%
\contentsline {subsection}{\numberline {7.5}Assignment Operators}{46}{subsection.0.7.5}%
\contentsline {subsection}{\numberline {7.6}Increment and Decrement Operators}{46}{subsection.0.7.6}%
\contentsline {subsection}{\numberline {7.7}Pointers and References}{46}{subsection.0.7.7}%
\contentsline {subsection}{\numberline {7.8}Scope Resolution Operator}{46}{subsection.0.7.8}%
\contentsline {section}{\numberline {8}Random Numbers}{48}{section.0.8}%
\contentsline {section}{\numberline {9}Conditionals (Decision Structure)}{49}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Decision Structure Flowchart}{50}{subsection.0.9.1}%
\contentsline {subsection}{\numberline {9.2}The Conditional Operator (Ternary)}{50}{subsection.0.9.2}%
\contentsline {subsection}{\numberline {9.3}Switch}{51}{subsection.0.9.3}%
\contentsline {section}{\numberline {10}The While Loop}{52}{section.0.10}%
\contentsline {section}{\numberline {11}The Do-While Loop}{53}{section.0.11}%
\contentsline {section}{\numberline {12}The for loop}{54}{section.0.12}%
\contentsline {section}{\numberline {13}Using Files for Data Storage}{55}{section.0.13}%
\contentsline {subsection}{\numberline {13.1}File Access Methods}{55}{subsection.0.13.1}%
\contentsline {subsection}{\numberline {13.2}Setting up a program for file input/output}{55}{subsection.0.13.2}%
\contentsline {subsection}{\numberline {13.3}File Stream Objects}{55}{subsection.0.13.3}%
\contentsline {subsection}{\numberline {13.4}Creating a file object and opening a file}{56}{subsection.0.13.4}%
\contentsline {subsection}{\numberline {13.5}Closing a file}{57}{subsection.0.13.5}%
\contentsline {subsection}{\numberline {13.6}Reading from a file with an unknown number of lines}{58}{subsection.0.13.6}%
\contentsline {subsection}{\numberline {13.7}Testing for file open errors}{58}{subsection.0.13.7}%
\contentsline {section}{\numberline {14}rvalues and lvalues}{59}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}rvalue (right value):}{59}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}lvalue}{59}{subsection.0.14.2}%
\contentsline {section}{\numberline {15}Breaking and Continuing a loop}{60}{section.0.15}%
\contentsline {section}{\numberline {16}Functions}{61}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Function prototypes (function declarations)}{61}{subsection.0.16.1}%
\contentsline {subsection}{\numberline {16.2}Static locals}{62}{subsection.0.16.2}%
\contentsline {subsection}{\numberline {16.3}PREREQ - Reference variables}{62}{subsection.0.16.3}%
\contentsline {subsection}{\numberline {16.4}Using reference variables as parameters}{63}{subsection.0.16.4}%
\contentsline {subsection}{\numberline {16.5}Overloading Functions}{64}{subsection.0.16.5}%
\contentsline {subsection}{\numberline {16.6}The exit() function}{64}{subsection.0.16.6}%
\contentsline {subsection}{\numberline {16.7}Stubs and Drivers}{65}{subsection.0.16.7}%
\contentsline {section}{\numberline {17}Arrays and Vectors}{66}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Arrays}{66}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Partial array initialization}{66}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}Implicit array sizing}{66}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}Bound violation}{66}{subsection.0.17.4}%
\contentsline {subsection}{\numberline {17.5}The range based for loop}{67}{subsection.0.17.5}%
\contentsline {subsection}{\numberline {17.6}Modifying an array with a range-based for loop}{67}{subsection.0.17.6}%
\contentsline {subsection}{\numberline {17.7}Thou shall not assign}{67}{subsection.0.17.7}%
\contentsline {subsection}{\numberline {17.8}Getting the size of an array}{68}{subsection.0.17.8}%
\contentsline {subsection}{\numberline {17.9}Arrays as function arguments}{68}{subsection.0.17.9}%
\contentsline {subsection}{\numberline {17.10}2D array (matrix)}{70}{subsection.0.17.10}%
\contentsline {subsection}{\numberline {17.11}Passing a matrix to a function}{71}{subsection.0.17.11}%
\contentsline {subsection}{\numberline {17.12}The STL Vector}{72}{subsection.0.17.12}%
\contentsline {subsection}{\numberline {17.13}Defining a vector}{72}{subsection.0.17.13}%
\contentsline {subsection}{\numberline {17.14}Get index position of elements}{72}{subsection.0.17.14}%
\contentsline {subsection}{\numberline {17.15}Adding to a vector}{73}{subsection.0.17.15}%
\contentsline {subsection}{\numberline {17.16}Getting the size of a vector}{73}{subsection.0.17.16}%
\contentsline {subsection}{\numberline {17.17}Removing last element of a vector}{73}{subsection.0.17.17}%
\contentsline {subsection}{\numberline {17.18}Removing elements of a vector }{73}{subsection.0.17.18}%
\contentsline {subsection}{\numberline {17.19}Clearing a vector}{74}{subsection.0.17.19}%
\contentsline {subsection}{\numberline {17.20}Detecting an Empty vector}{74}{subsection.0.17.20}%
\contentsline {subsection}{\numberline {17.21}Resizing a vector}{74}{subsection.0.17.21}%
\contentsline {subsection}{\numberline {17.22}Swapping Vectors}{74}{subsection.0.17.22}%
\contentsline {section}{\numberline {18}Searching and Sorting Arrays}{75}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}The linear search}{75}{subsection.0.18.1}%
\contentsline {subsection}{\numberline {18.2}The binary search}{76}{subsection.0.18.2}%
\contentsline {subsection}{\numberline {18.3}Bubble Sort}{77}{subsection.0.18.3}%
\contentsline {subsection}{\numberline {18.4}Selection Sort}{77}{subsection.0.18.4}%
\contentsline {section}{\numberline {19}Pointers}{80}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}Nullptr}{80}{subsection.0.19.1}%
\contentsline {subsection}{\numberline {19.2}Arrays as pointers}{81}{subsection.0.19.2}%
\contentsline {subsection}{\numberline {19.3}Pointers as Function Parameters}{82}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}Pointers to constants}{82}{subsection.0.19.4}%
\contentsline {subsection}{\numberline {19.5}Constant Pointers}{83}{subsection.0.19.5}%
\contentsline {subsection}{\numberline {19.6}Both pointer to constant and constant pointer}{83}{subsection.0.19.6}%
\contentsline {subsection}{\numberline {19.7}Prereq - Static vs Dynamic memory allocation}{83}{subsection.0.19.7}%
\contentsline {subsection}{\numberline {19.8}Dynamic Memory Allocation}{84}{subsection.0.19.8}%
\contentsline {subsection}{\numberline {19.9}When to use DMA}{85}{subsection.0.19.9}%
\contentsline {subsection}{\numberline {19.10}Returning pointers from a function}{85}{subsection.0.19.10}%
\contentsline {subsection}{\numberline {19.11}Smart Pointers}{86}{subsection.0.19.11}%
\contentsline {section}{\numberline {20}Characters, C-Strings and more about the string class}{88}{section.0.20}%
\contentsline {subsection}{\numberline {20.1}Character Testing}{88}{subsection.0.20.1}%
\contentsline {subsection}{\numberline {20.2}Character case conversion}{88}{subsection.0.20.2}%
\contentsline {subsection}{\numberline {20.3}C Strings }{88}{subsection.0.20.3}%
\contentsline {subsection}{\numberline {20.4}C-Strings stored in arrays}{89}{subsection.0.20.4}%
\contentsline {subsection}{\numberline {20.5}The Strlen function}{89}{subsection.0.20.5}%
\contentsline {subsection}{\numberline {20.6}The strcat Function}{90}{subsection.0.20.6}%
\contentsline {subsection}{\numberline {20.7}The Strcopy function}{90}{subsection.0.20.7}%
\contentsline {subsection}{\numberline {20.8}The strncat and strncpy functions}{91}{subsection.0.20.8}%
\contentsline {subsection}{\numberline {20.9}The strstr function}{91}{subsection.0.20.9}%
\contentsline {subsection}{\numberline {20.10}The strcmp function}{92}{subsection.0.20.10}%
\contentsline {subsection}{\numberline {20.11}String/Numeric Conversion Functions}{92}{subsection.0.20.11}%
\contentsline {subsection}{\numberline {20.12}More on the C++ string (string object)}{94}{subsection.0.20.12}%
\contentsline {subsection}{\numberline {20.13}C++ String definitions}{94}{subsection.0.20.13}%
\contentsline {subsection}{\numberline {20.14}C++ string supported operators}{94}{subsection.0.20.14}%
\contentsline {section}{\numberline {21}Structures}{95}{section.0.21}%
\contentsline {subsection}{\numberline {21.1}Abstraction}{95}{subsection.0.21.1}%
\contentsline {subsection}{\numberline {21.2}Abstract data types}{95}{subsection.0.21.2}%
\contentsline {subsection}{\numberline {21.3}Structures}{95}{subsection.0.21.3}%
\contentsline {subsection}{\numberline {21.4}Accessing structure members}{96}{subsection.0.21.4}%
\contentsline {subsection}{\numberline {21.5}Initializing a structure (Initialization list)}{96}{subsection.0.21.5}%
\contentsline {subsection}{\numberline {21.6}Arrays of structures}{97}{subsection.0.21.6}%
\contentsline {subsection}{\numberline {21.7}Initializing a structure array}{97}{subsection.0.21.7}%
\contentsline {subsection}{\numberline {21.8}Nested Structures}{98}{subsection.0.21.8}%
\contentsline {subsection}{\numberline {21.9}Structures as function arguments}{98}{subsection.0.21.9}%
\contentsline {subsection}{\numberline {21.10}Constant reference parameters}{99}{subsection.0.21.10}%
\contentsline {subsection}{\numberline {21.11}Returning a structure from a function}{99}{subsection.0.21.11}%
\contentsline {subsection}{\numberline {21.12}Pointers to structures}{100}{subsection.0.21.12}%
\contentsline {subsection}{\numberline {21.13}Dynamically allocating a structure}{100}{subsection.0.21.13}%
\contentsline {section}{\numberline {22}Enumerated data types}{101}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}General Syntax}{101}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Example}{101}{subsection.0.22.2}%
\contentsline {subsection}{\numberline {22.3}Basic Concepts}{101}{subsection.0.22.3}%
\contentsline {subsection}{\numberline {22.4}Assigning an integer to an enumerator}{102}{subsection.0.22.4}%
\contentsline {subsection}{\numberline {22.5}Assigning an enumerator to an int variable}{102}{subsection.0.22.5}%
\contentsline {subsection}{\numberline {22.6}Using math operators to change the value of an enum variable}{102}{subsection.0.22.6}%
\contentsline {subsection}{\numberline {22.7}Specifying values in enumerators}{103}{subsection.0.22.7}%
\contentsline {subsection}{\numberline {22.8}Changing the type}{103}{subsection.0.22.8}%
\contentsline {subsection}{\numberline {22.9}Quick instantiation}{103}{subsection.0.22.9}%
\contentsline {subsection}{\numberline {22.10}Strongly typed enums}{104}{subsection.0.22.10}%
\contentsline {section}{\numberline {23}Unions}{105}{section.0.23}%
\contentsline {section}{\numberline {24}String streams}{106}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Using istringstream}{106}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Using ostringstream}{106}{subsection.0.24.2}%
\contentsline {section}{\numberline {25}Advanced file operations}{108}{section.0.25}%
\contentsline {section}{\numberline {26}C++ Lambdas}{109}{section.0.26}%
\contentsline {subsection}{\numberline {26.1}Options for capturing}{109}{subsection.0.26.1}%
\contentsline {subsection}{\numberline {26.2}Why auto as lambda type}{111}{subsection.0.26.2}%
\contentsline {section}{\numberline {27}Fancy case syntax}{112}{section.0.27}%
\contentsline {section}{\numberline {28}Static globals}{112}{section.0.28}%
\contentsline {section}{\numberline {29}Classes (OOP Principles in C++)}{113}{section.0.29}%
\contentsline {subsection}{\numberline {29.1}Private and Public (access specifiers)}{113}{subsection.0.29.1}%
\contentsline {subsection}{\numberline {29.2}Protected}{114}{subsection.0.29.2}%
\contentsline {subsection}{\numberline {29.3}Constant member functions}{114}{subsection.0.29.3}%
\contentsline {subsection}{\numberline {29.4}The mutable keyword}{114}{subsection.0.29.4}%
\contentsline {subsection}{\numberline {29.5}The friend keyword}{115}{subsection.0.29.5}%
\contentsline {subsection}{\numberline {29.6}Member function prototypes and definitions}{115}{subsection.0.29.6}%
\contentsline {subsection}{\numberline {29.7}Default Constructors}{116}{subsection.0.29.7}%
\contentsline {subsection}{\numberline {29.8}Parameterized Constructor}{116}{subsection.0.29.8}%
\contentsline {subsection}{\numberline {29.9}Copy Constructor}{116}{subsection.0.29.9}%
\contentsline {subsubsection}{\numberline {29.9.1}What invokes the copy constructor?}{117}{subsubsection.0.29.9.1}%
\contentsline {subsubsection}{\numberline {29.9.2}Assignment operator instead of copy constructor}{118}{subsubsection.0.29.9.2}%
\contentsline {subsubsection}{\numberline {29.9.3}Forcing the copy constructor with initialization lists}{118}{subsubsection.0.29.9.3}%
\contentsline {subsection}{\numberline {29.10}Constructor Overloading}{119}{subsection.0.29.10}%
\contentsline {subsection}{\numberline {29.11}Initialization Lists}{120}{subsection.0.29.11}%
\contentsline {subsection}{\numberline {29.12}Delegating Constructors}{120}{subsection.0.29.12}%
\contentsline {subsection}{\numberline {29.13}Explicit Constructors}{120}{subsection.0.29.13}%
\contentsline {subsection}{\numberline {29.14}Destructors}{122}{subsection.0.29.14}%
\contentsline {subsection}{\numberline {29.15}Default destructors}{122}{subsection.0.29.15}%
\contentsline {subsection}{\numberline {29.16}Accessors and Mutators}{122}{subsection.0.29.16}%
\contentsline {subsection}{\numberline {29.17}The "this" pointer}{123}{subsection.0.29.17}%
\contentsline {subsubsection}{\numberline {29.17.1}Returning this}{124}{subsubsection.0.29.17.1}%
\contentsline {subsubsection}{\numberline {29.17.2}Returning *this}{124}{subsubsection.0.29.17.2}%
\contentsline {subsection}{\numberline {29.18}Static Member Variables}{124}{subsection.0.29.18}%
\contentsline {subsubsection}{\numberline {29.18.1}Initialization}{124}{subsubsection.0.29.18.1}%
\contentsline {subsubsection}{\numberline {29.18.2}Access}{124}{subsubsection.0.29.18.2}%
\contentsline {subsubsection}{\numberline {29.18.3}Example}{124}{subsubsection.0.29.18.3}%
\contentsline {subsubsection}{\numberline {29.18.4}Static constant member variables}{125}{subsubsection.0.29.18.4}%
\contentsline {subsubsection}{\numberline {29.18.5}The 'inline' keyword}{125}{subsubsection.0.29.18.5}%
\contentsline {subsection}{\numberline {29.19}Static member function}{125}{subsection.0.29.19}%
\contentsline {subsubsection}{\numberline {29.19.1}Access}{125}{subsubsection.0.29.19.1}%
\contentsline {subsubsection}{\numberline {29.19.2}Restrictions}{125}{subsubsection.0.29.19.2}%
\contentsline {subsubsection}{\numberline {29.19.3}Example}{126}{subsubsection.0.29.19.3}%
\contentsline {subsubsection}{\numberline {29.19.4}Pragmatic Example}{127}{subsubsection.0.29.19.4}%
\contentsline {subsection}{\numberline {29.20}Memberwise assignment}{127}{subsection.0.29.20}%
\contentsline {subsection}{\numberline {29.21}Aggregation}{127}{subsection.0.29.21}%
\contentsline {subsection}{\numberline {29.22}Constant Objects}{127}{subsection.0.29.22}%
\contentsline {section}{\numberline {30}Operator Overloading}{128}{section.0.30}%
\contentsline {subsection}{\numberline {30.1}Overloading arithmetic operators}{128}{subsection.0.30.1}%
\contentsline {subsection}{\numberline {30.2}Overloading Stream Operators}{128}{subsection.0.30.2}%
\contentsline {subsection}{\numberline {30.3}Overloading Asssignment operator}{130}{subsection.0.30.3}%
\contentsline {subsection}{\numberline {30.4}Overloading Prefix}{130}{subsection.0.30.4}%
\contentsline {subsection}{\numberline {30.5}Overloading Postfix}{130}{subsection.0.30.5}%
\contentsline {subsection}{\numberline {30.6}Overloading Relational Operators}{132}{subsection.0.30.6}%
\contentsline {subsection}{\numberline {30.7}Overloading subscript operator}{132}{subsection.0.30.7}%
\contentsline {subsection}{\numberline {30.8}Overloading function call operator}{132}{subsection.0.30.8}%
\contentsline {subsection}{\numberline {30.9}Overloading dereference operator}{134}{subsection.0.30.9}%
\contentsline {subsection}{\numberline {30.10}Overloading arrow operator}{134}{subsection.0.30.10}%
\contentsline {subsection}{\numberline {30.11}Object Conversion}{135}{subsection.0.30.11}%
\contentsline {section}{\numberline {31}Class Inheritance}{136}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Access Specifiers}{137}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Constructors and Destructors}{138}{subsection.0.31.2}%
\contentsline {subsection}{\numberline {31.3}Virtual functions and the override keyword}{139}{subsection.0.31.3}%
\contentsline {subsection}{\numberline {31.4}Virtual Destructors}{139}{subsection.0.31.4}%
\contentsline {subsection}{\numberline {31.5}Polymorphism}{140}{subsection.0.31.5}%
\contentsline {subsection}{\numberline {31.6}Base class pointer to child class object}{141}{subsection.0.31.6}%
\contentsline {subsection}{\numberline {31.7}The Final keyword}{142}{subsection.0.31.7}%
\contentsline {section}{\numberline {32}Interface-Based Programming}{143}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}Pure Abstract Classes in C++}{143}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}Implementing Interfaces in C++}{143}{subsection.0.32.2}%
\contentsline {subsection}{\numberline {32.3}More on the concept of pure virtual functions}{144}{subsection.0.32.3}%
\contentsline {section}{\numberline {33}Separate files (Classes)}{145}{section.0.33}%
\contentsline {subsection}{\numberline {33.1}Class declaration in Header Files}{145}{subsection.0.33.1}%
\contentsline {subsection}{\numberline {33.2}Class Definition in Source Files}{145}{subsection.0.33.2}%
\contentsline {section}{\numberline {34}Rvalue references and move semantics}{146}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Rvalue references}{146}{subsection.0.34.1}%
\contentsline {subsection}{\numberline {34.2}Exception to binding references to literals}{146}{subsection.0.34.2}%
\contentsline {subsection}{\numberline {34.3}Creating a move constructor and std::move()}{148}{subsection.0.34.3}%
\contentsline {subsection}{\numberline {34.4}Move Operations and noexcept}{148}{subsection.0.34.4}%
\contentsline {subsection}{\numberline {34.5}More on std::move}{150}{subsection.0.34.5}%
\contentsline {subsubsection}{\numberline {34.5.1}Syntax}{150}{subsubsection.0.34.5.1}%
\contentsline {subsubsection}{\numberline {34.5.2}Move assignment operator}{150}{subsubsection.0.34.5.2}%
\contentsline {section}{\numberline {35}Iterators}{151}{section.0.35}%
\contentsline {subsection}{\numberline {35.1}Type of Iterators}{151}{subsection.0.35.1}%
\contentsline {subsection}{\numberline {35.2}Container Iterators}{152}{subsection.0.35.2}%
\contentsline {subsection}{\numberline {35.3}What about C-Array}{152}{subsection.0.35.3}%
\contentsline {subsection}{\numberline {35.4}Contiguous vs Non-Contiguous Memory}{153}{subsection.0.35.4}%
\contentsline {section}{\numberline {36}Other Containers}{154}{section.0.36}%
\contentsline {subsection}{\numberline {36.1}Allocation of containers}{154}{subsection.0.36.1}%
\contentsline {subsection}{\numberline {36.2}The std::array<T,n> <array>}{156}{subsection.0.36.2}%
\contentsline {subsection}{\numberline {36.3}The std::list <list>}{156}{subsection.0.36.3}%
\contentsline {subsection}{\numberline {36.4}Sets set<T, comp> <set>}{156}{subsection.0.36.4}%
\contentsline {subsection}{\numberline {36.5}Maps map<T,T, comp> <map>}{156}{subsection.0.36.5}%
\contentsline {section}{\numberline {37}Variadic Functions in C++ (Ellipsis)}{157}{section.0.37}%
\contentsline {section}{\numberline {38}std::function<type(args)> <functional>}{158}{section.0.38}%
\contentsline {section}{\numberline {39}Initializer List as function parameters}{159}{section.0.39}%
\contentsline {section}{\numberline {40}Functions as parameters}{160}{section.0.40}%
\contentsline {subsection}{\numberline {40.1}Function Pointers:}{160}{subsection.0.40.1}%
\contentsline {subsection}{\numberline {40.2}Regular function pointers}{161}{subsection.0.40.2}%
\contentsline {section}{\numberline {41}Typedefs}{162}{section.0.41}%
\contentsline {subsection}{\numberline {41.1}Basic Typedefs}{162}{subsection.0.41.1}%
\contentsline {subsubsection}{\numberline {41.1.1}Example}{162}{subsubsection.0.41.1.1}%
\contentsline {subsection}{\numberline {41.2}Applications of typedef in C++}{162}{subsection.0.41.2}%
\contentsline {subsection}{\numberline {41.3}Using typedef with arrays}{162}{subsection.0.41.3}%
\contentsline {subsubsection}{\numberline {41.3.1}Example}{162}{subsubsection.0.41.3.1}%
\contentsline {subsection}{\numberline {41.4}Using typedef with pointers}{163}{subsection.0.41.4}%
\contentsline {subsubsection}{\numberline {41.4.1}Example:}{163}{subsubsection.0.41.4.1}%
\contentsline {subsection}{\numberline {41.5}Using typedef with function pointers}{163}{subsection.0.41.5}%
\contentsline {subsubsection}{\numberline {41.5.1}Example}{163}{subsubsection.0.41.5.1}%
\contentsline {section}{\numberline {42}Buffers in C++}{164}{section.0.42}%
\contentsline {subsection}{\numberline {42.1}Types of buffers}{164}{subsection.0.42.1}%
\contentsline {subsubsection}{\numberline {42.1.1}Stack-based buffers}{164}{subsubsection.0.42.1.1}%
\contentsline {subsubsection}{\numberline {42.1.2}Heap-based Buffers}{164}{subsubsection.0.42.1.2}%
\contentsline {subsubsection}{\numberline {42.1.3}Standard Library Containers}{164}{subsubsection.0.42.1.3}%
\contentsline {subsection}{\numberline {42.2}Usage in IO Operations}{165}{subsection.0.42.2}%
\contentsline {subsection}{\numberline {42.3}Buffer Overflow}{165}{subsection.0.42.3}%
\contentsline {subsection}{\numberline {42.4}Buffer operations}{165}{subsection.0.42.4}%
\contentsline {section}{\numberline {43}The Stack, Heap, Code Segment (Text Segment), and Data Segment (static memory)}{166}{section.0.43}%
\contentsline {subsection}{\numberline {43.1}The Stack}{166}{subsection.0.43.1}%
\contentsline {subsubsection}{\numberline {43.1.1}The Call Stack}{166}{subsubsection.0.43.1.1}%
\contentsline {subsection}{\numberline {43.2}How Many Stacks are There Per Program?}{166}{subsection.0.43.2}%
\contentsline {subsection}{\numberline {43.3}Stack Memory Management}{167}{subsection.0.43.3}%
\contentsline {subsection}{\numberline {43.4}Stack Overflow}{167}{subsection.0.43.4}%
\contentsline {subsection}{\numberline {43.5}What Lives on The Stack?}{167}{subsection.0.43.5}%
\contentsline {subsection}{\numberline {43.6}The Heap}{168}{subsection.0.43.6}%
\contentsline {subsubsection}{\numberline {43.6.1}Characteristics of the Heap}{168}{subsubsection.0.43.6.1}%
\contentsline {subsubsection}{\numberline {43.6.2}Usage}{168}{subsubsection.0.43.6.2}%
\contentsline {subsubsection}{\numberline {43.6.3}Heap Allocatinos in Function Bodys}{169}{subsubsection.0.43.6.3}%
\contentsline {subsection}{\numberline {43.7}The Code Segment (Text Segment)}{169}{subsection.0.43.7}%
\contentsline {subsection}{\numberline {43.8}The Data Segment}{169}{subsection.0.43.8}%
\contentsline {subsubsection}{\numberline {43.8.1}Initialized Data Segment}{169}{subsubsection.0.43.8.1}%
\contentsline {subsubsection}{\numberline {43.8.2}Uninitialized Data Segment}{169}{subsubsection.0.43.8.2}%
\contentsline {section}{\numberline {44}More on Dynamic Memory Allocation}{170}{section.0.44}%
\contentsline {subsection}{\numberline {44.1}Before we Begin: Memory Leaks}{170}{subsection.0.44.1}%
\contentsline {subsubsection}{\numberline {44.1.1}How Memory Leaks Occur}{170}{subsubsection.0.44.1.1}%
\contentsline {subsection}{\numberline {44.2}Malloc}{170}{subsection.0.44.2}%
\contentsline {subsubsection}{\numberline {44.2.1}Signature}{170}{subsubsection.0.44.2.1}%
\contentsline {subsubsection}{\numberline {44.2.2}Example}{171}{subsubsection.0.44.2.2}%
\contentsline {subsubsection}{\numberline {44.2.3}Characteristics}{171}{subsubsection.0.44.2.3}%
\contentsline {subsubsection}{\numberline {44.2.4}Considerations}{171}{subsubsection.0.44.2.4}%
\contentsline {subsection}{\numberline {44.3}Calloc}{172}{subsection.0.44.3}%
\contentsline {subsubsection}{\numberline {44.3.1}Signature}{172}{subsubsection.0.44.3.1}%
\contentsline {subsubsection}{\numberline {44.3.2}Example}{172}{subsubsection.0.44.3.2}%
\contentsline {subsubsection}{\numberline {44.3.3}Differences from malloc}{172}{subsubsection.0.44.3.3}%
\contentsline {subsection}{\numberline {44.4}Realloc}{172}{subsection.0.44.4}%
\contentsline {subsubsection}{\numberline {44.4.1}Signature}{173}{subsubsection.0.44.4.1}%
\contentsline {subsubsection}{\numberline {44.4.2}Example}{173}{subsubsection.0.44.4.2}%
\contentsline {subsection}{\numberline {44.5}Free}{173}{subsection.0.44.5}%
\contentsline {subsubsection}{\numberline {44.5.1}Signature}{173}{subsubsection.0.44.5.1}%
\contentsline {subsection}{\numberline {44.6}New}{174}{subsection.0.44.6}%
\contentsline {subsubsection}{\numberline {44.6.1}Syntax}{174}{subsubsection.0.44.6.1}%
\contentsline {subsubsection}{\numberline {44.6.2}Array allocation}{174}{subsubsection.0.44.6.2}%
\contentsline {subsubsection}{\numberline {44.6.3}Custom Constructor Parameters}{174}{subsubsection.0.44.6.3}%
\contentsline {subsubsection}{\numberline {44.6.4}Exception Handling (std::nothrow)}{174}{subsubsection.0.44.6.4}%
\contentsline {subsubsection}{\numberline {44.6.5}Placement New}{175}{subsubsection.0.44.6.5}%
\contentsline {subsection}{\numberline {44.7}Delete}{175}{subsection.0.44.7}%
\contentsline {subsubsection}{\numberline {44.7.1}Syntax}{175}{subsubsection.0.44.7.1}%
\contentsline {subsection}{\numberline {44.8}Dangling Pointers}{176}{subsection.0.44.8}%
\contentsline {subsection}{\numberline {44.9}Overloading new and delete}{177}{subsection.0.44.9}%
\contentsline {subsubsection}{\numberline {44.9.1}Why static?}{177}{subsubsection.0.44.9.1}%
\contentsline {subsubsection}{\numberline {44.9.2}The size\_t parameter in the new overload}{178}{subsubsection.0.44.9.2}%
\contentsline {subsection}{\numberline {44.10}Getting the size of dynamically allocated memory?}{178}{subsection.0.44.10}%
\contentsline {subsection}{\numberline {44.11}Mixing Memory Management Mechanism}{178}{subsection.0.44.11}%
\contentsline {subsubsection}{\numberline {44.11.1}Why Mixing Them is Bad}{178}{subsubsection.0.44.11.1}%
\contentsline {subsection}{\numberline {44.12}Should you be using malloc, calloc, realloc, or free in C++?}{178}{subsection.0.44.12}%
\contentsline {subsubsection}{\numberline {44.12.1}Constructor and Destructor Calls}{179}{subsubsection.0.44.12.1}%
\contentsline {subsubsection}{\numberline {44.12.2}Type Safety}{179}{subsubsection.0.44.12.2}%
\contentsline {subsubsection}{\numberline {44.12.3}Exception Handling}{179}{subsubsection.0.44.12.3}%
\contentsline {section}{\numberline {45}Other Casting Operators}{180}{section.0.45}%
\contentsline {subsection}{\numberline {45.1}dynamic\_cast}{180}{subsection.0.45.1}%
\contentsline {subsubsection}{\numberline {45.1.1}Purpose}{180}{subsubsection.0.45.1.1}%
\contentsline {subsubsection}{\numberline {45.1.2}Syntax}{180}{subsubsection.0.45.1.2}%
\contentsline {subsubsection}{\numberline {45.1.3}Requirements}{180}{subsubsection.0.45.1.3}%
\contentsline {subsubsection}{\numberline {45.1.4}Example}{180}{subsubsection.0.45.1.4}%
\contentsline {subsection}{\numberline {45.2}const\_cast}{181}{subsection.0.45.2}%
\contentsline {subsubsection}{\numberline {45.2.1}Removing const}{181}{subsubsection.0.45.2.1}%
\contentsline {subsubsection}{\numberline {45.2.2}Adding const}{181}{subsubsection.0.45.2.2}%
\contentsline {subsubsection}{\numberline {45.2.3}Use cases}{181}{subsubsection.0.45.2.3}%
\contentsline {subsubsection}{\numberline {45.2.4}Important Points}{182}{subsubsection.0.45.2.4}%
\contentsline {subsubsection}{\numberline {45.2.5}Example}{182}{subsubsection.0.45.2.5}%
\contentsline {subsubsection}{\numberline {45.2.6}When is it unsafe to use}{182}{subsubsection.0.45.2.6}%
\contentsline {subsubsection}{\numberline {45.2.7}The volatile keyword}{182}{subsubsection.0.45.2.7}%
\contentsline {subsubsection}{\numberline {45.2.8}Purpose}{182}{subsubsection.0.45.2.8}%
\contentsline {subsection}{\numberline {45.3}reinterpret_cast}{183}{subsection.0.45.3}%
\contentsline {subsubsection}{\numberline {45.3.1}Key Characteristics}{183}{subsubsection.0.45.3.1}%
\contentsline {subsubsection}{\numberline {45.3.2}Syntax}{183}{subsubsection.0.45.3.2}%
\contentsline {subsubsection}{\numberline {45.3.3}Example}{183}{subsubsection.0.45.3.3}%
\contentsline {subsubsection}{\numberline {45.3.4}Considerations}{184}{subsubsection.0.45.3.4}%
\contentsline {section}{\numberline {46}Namespaces}{185}{section.0.46}%
\contentsline {subsection}{\numberline {46.1}Syntax}{185}{subsection.0.46.1}%
\contentsline {subsection}{\numberline {46.2}Using Namespaces}{185}{subsection.0.46.2}%
\contentsline {subsection}{\numberline {46.3}Nested Namespaces}{185}{subsection.0.46.3}%
\contentsline {subsection}{\numberline {46.4}Anonymous Namespaces}{186}{subsection.0.46.4}%
\contentsline {section}{\numberline {47}Exceptions}{187}{section.0.47}%
\contentsline {subsection}{\numberline {47.1}Concepts}{187}{subsection.0.47.1}%
\contentsline {subsection}{\numberline {47.2}Syntax}{187}{subsection.0.47.2}%
\contentsline {subsection}{\numberline {47.3}Example}{188}{subsection.0.47.3}%
\contentsline {subsection}{\numberline {47.4}Why does catch take a const reference?}{188}{subsection.0.47.4}%
\contentsline {subsubsection}{\numberline {47.4.1}Safety and Efficiency}{188}{subsubsection.0.47.4.1}%
\contentsline {subsubsection}{\numberline {47.4.2}Const Correctness}{188}{subsubsection.0.47.4.2}%
\contentsline {subsection}{\numberline {47.5}Catching any exception}{189}{subsection.0.47.5}%
\contentsline {subsection}{\numberline {47.6}cerr (standard error)}{189}{subsection.0.47.6}%
\contentsline {subsubsection}{\numberline {47.6.1}Unbuffered Output}{189}{subsubsection.0.47.6.1}%
\contentsline {subsection}{\numberline {47.7}The what() function}{189}{subsection.0.47.7}%
\contentsline {subsubsection}{\numberline {47.7.1}Signature}{189}{subsubsection.0.47.7.1}%
\contentsline {subsection}{\numberline {47.8}What can we throw/catch?}{189}{subsection.0.47.8}%
\contentsline {subsection}{\numberline {47.9}noexcept in function signatures}{190}{subsection.0.47.9}%
\contentsline {subsection}{\numberline {47.10}Syntax and Usage}{190}{subsection.0.47.10}%
\contentsline {subsection}{\numberline {47.11}Benefits}{190}{subsection.0.47.11}%
\contentsline {subsection}{\numberline {47.12}OOP Approach to exceptions (Custom exception class)}{191}{subsection.0.47.12}%
\contentsline {subsection}{\numberline {47.13}Unwinding the stack}{192}{subsection.0.47.13}%
\contentsline {subsection}{\numberline {47.14}More on 'new'}{192}{subsection.0.47.14}%
\contentsline {subsubsection}{\numberline {47.14.1}Handling bad\_alloc}{192}{subsubsection.0.47.14.1}%
\contentsline {subsubsection}{\numberline {47.14.2}nothrow}{192}{subsubsection.0.47.14.2}%
\contentsline {section}{\numberline {48}Templates}{193}{section.0.48}%
\contentsline {subsection}{\numberline {48.1}Function Templates}{193}{subsection.0.48.1}%
\contentsline {subsubsection}{\numberline {48.1.1}Syntax}{193}{subsubsection.0.48.1.1}%
\contentsline {subsubsection}{\numberline {48.1.2}Example}{193}{subsubsection.0.48.1.2}%
\contentsline {subsection}{\numberline {48.2}Class Templates}{194}{subsection.0.48.2}%
\contentsline {subsubsection}{\numberline {48.2.1}Example}{194}{subsubsection.0.48.2.1}%
\contentsline {subsection}{\numberline {48.3}Function Template Specialization}{195}{subsection.0.48.3}%
\contentsline {subsection}{\numberline {48.4}Class/Struct Template Specialization}{195}{subsection.0.48.4}%
\contentsline {subsection}{\numberline {48.5}Template Parameters}{195}{subsection.0.48.5}%
\contentsline {subsection}{\numberline {48.6}Trailing return type}{195}{subsection.0.48.6}%
\contentsline {subsubsection}{\numberline {48.6.1}Syntax}{196}{subsubsection.0.48.6.1}%
\contentsline {subsubsection}{\numberline {48.6.2}Example}{196}{subsubsection.0.48.6.2}%
\contentsline {subsection}{\numberline {48.7}decltype}{196}{subsection.0.48.7}%
\contentsline {subsubsection}{\numberline {48.7.1}Syntax}{196}{subsubsection.0.48.7.1}%
\contentsline {subsubsection}{\numberline {48.7.2}Example}{196}{subsubsection.0.48.7.2}%
\contentsline {subsection}{\numberline {48.8}Template functions with mixed types (Trailing return type)}{196}{subsection.0.48.8}%
\contentsline {subsection}{\numberline {48.9}Template functions with mixed types (Deduced return type)}{198}{subsection.0.48.9}%
\contentsline {subsection}{\numberline {48.10}The use of 'static' in template programming}{198}{subsection.0.48.10}%
\contentsline {subsubsection}{\numberline {48.10.1}Declaring and Defining Static Members in a Template Class}{198}{subsubsection.0.48.10.1}%
\contentsline {subsubsection}{\numberline {48.10.2}Key points}{199}{subsubsection.0.48.10.2}%
\contentsline {subsection}{\numberline {48.11}Non-Type Template Parameters}{199}{subsection.0.48.11}%
\contentsline {subsubsection}{\numberline {48.11.1}Array sizes}{199}{subsubsection.0.48.11.1}%
\contentsline {subsubsection}{\numberline {48.11.2}Compile-Time Calculations}{200}{subsubsection.0.48.11.2}%
\contentsline {section}{\numberline {49}Elementary compile time computations}{201}{section.0.49}%
\contentsline {section}{\numberline {50}Extra Information}{202}{section.0.50}%
\contentsline {subsection}{\numberline {50.1}constexpr}{202}{subsection.0.50.1}%
\contentsline {subsection}{\numberline {50.2}consteval}{202}{subsection.0.50.2}%
\contentsline {subsection}{\numberline {50.3}constinit}{202}{subsection.0.50.3}%
\contentsline {subsection}{\numberline {50.4}More on 'inline'}{202}{subsection.0.50.4}%
\contentsline {subsection}{\numberline {50.5}Measuring the speed of C++ programs}{202}{subsection.0.50.5}%
