\contentsline {section}{\numberline {1}The C++ Language}{17}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Key Features}{17}{subsection.0.1.1}%
\contentsline {section}{\numberline {2}The Compiler}{19}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Preprocessing}{19}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Lexical Analysis}{19}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Syntax Analysis}{19}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Semantic Analysis}{19}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Intermediate Code Generation}{19}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Code Optimization}{20}{subsection.0.2.6}%
\contentsline {subsection}{\numberline {2.7}Code Generation}{20}{subsection.0.2.7}%
\contentsline {subsection}{\numberline {2.8}Assembling}{20}{subsection.0.2.8}%
\contentsline {subsection}{\numberline {2.9}Linking}{20}{subsection.0.2.9}%
\contentsline {subsection}{\numberline {2.10}Complier Options}{20}{subsection.0.2.10}%
\contentsline {subsection}{\numberline {2.11}Header Files}{21}{subsection.0.2.11}%
\contentsline {section}{\numberline {3}Preliminaries: A Quick Tour of C++ Fundamentals}{22}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Boilerplate}{22}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}The main function}{22}{subsection.0.3.2}%
\contentsline {subsection}{\numberline {3.3}Comments}{22}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Data Types, Modifiers, Qualifiers, Inference}{24}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}Primitive Type Ranges and Size}{25}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}Creating strings without the STL}{26}{subsection.0.3.6}%
\contentsline {subsection}{\numberline {3.7}Retrieve size}{27}{subsection.0.3.7}%
\contentsline {subsection}{\numberline {3.8}Retrieve type}{27}{subsection.0.3.8}%
\contentsline {subsection}{\numberline {3.9}Exponential Notation}{28}{subsection.0.3.9}%
\contentsline {subsection}{\numberline {3.10}Type Conversion}{28}{subsection.0.3.10}%
\contentsline {subsection}{\numberline {3.11}Integer Division}{29}{subsection.0.3.11}%
\contentsline {subsection}{\numberline {3.12}Overflow/Underflow}{29}{subsection.0.3.12}%
\contentsline {subsection}{\numberline {3.13}Type Casting}{29}{subsection.0.3.13}%
\contentsline {subsection}{\numberline {3.14}C-style Casts}{30}{subsection.0.3.14}%
\contentsline {subsection}{\numberline {3.15}The Using Directive}{31}{subsection.0.3.15}%
\contentsline {subsection}{\numberline {3.16}Variable Declaration}{32}{subsection.0.3.16}%
\contentsline {subsection}{\numberline {3.17}Multiple Declaration}{32}{subsection.0.3.17}%
\contentsline {subsection}{\numberline {3.18}Initialization}{32}{subsection.0.3.18}%
\contentsline {subsection}{\numberline {3.19}Multiple Initialization}{32}{subsection.0.3.19}%
\contentsline {subsection}{\numberline {3.20}Direct Initialization}{33}{subsection.0.3.20}%
\contentsline {subsection}{\numberline {3.21}List Initialization}{33}{subsection.0.3.21}%
\contentsline {subsection}{\numberline {3.22}Copy Initialization}{33}{subsection.0.3.22}%
\contentsline {subsection}{\numberline {3.23}Assignment}{33}{subsection.0.3.23}%
\contentsline {subsection}{\numberline {3.24}Multiple Assignment}{34}{subsection.0.3.24}%
\contentsline {section}{\numberline {4}Symbols}{35}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Parentheses}{35}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Brackets}{35}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Braces}{35}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Angle Brackets}{35}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Semi Colon}{35}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Colon}{35}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}Comma}{36}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}Ellipsis}{36}{subsection.0.4.8}%
\contentsline {subsection}{\numberline {4.9}Hash}{36}{subsection.0.4.9}%
\contentsline {section}{\numberline {5}Preprocessor Directives}{37}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}\#include}{37}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}\#define}{37}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}\#undef}{37}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}\#ifdef, \#ifndef, \#else, \#elif, \#endif}{37}{subsection.0.5.4}%
\contentsline {subsection}{\numberline {5.5}\#if}{38}{subsection.0.5.5}%
\contentsline {subsection}{\numberline {5.6}\#pragma}{38}{subsection.0.5.6}%
\contentsline {subsection}{\numberline {5.7}\#error}{38}{subsection.0.5.7}%
\contentsline {subsection}{\numberline {5.8}\#line}{38}{subsection.0.5.8}%
\contentsline {section}{\numberline {6}Input/Output}{39}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}iostream}{39}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Output}{39}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Input}{39}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}IO Manipulators}{41}{subsection.0.6.4}%
\contentsline {subsection}{\numberline {6.5}std::setiosflags}{43}{subsection.0.6.5}%
\contentsline {subsection}{\numberline {6.6}Escape Sequences}{43}{subsection.0.6.6}%
\contentsline {subsection}{\numberline {6.7}User Input With Strings}{44}{subsection.0.6.7}%
\contentsline {subsection}{\numberline {6.8}User input with characters}{45}{subsection.0.6.8}%
\contentsline {subsection}{\numberline {6.9}Mixing cin and cin.get}{45}{subsection.0.6.9}%
\contentsline {section}{\numberline {7}Operators}{46}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Arithmetic Operators}{46}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Relational Operators}{46}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}Logical Operators}{46}{subsection.0.7.3}%
\contentsline {subsection}{\numberline {7.4}Bitwise Operators}{46}{subsection.0.7.4}%
\contentsline {subsection}{\numberline {7.5}Assignment Operators}{46}{subsection.0.7.5}%
\contentsline {subsection}{\numberline {7.6}Increment and Decrement Operators}{46}{subsection.0.7.6}%
\contentsline {subsection}{\numberline {7.7}Pointers and References}{46}{subsection.0.7.7}%
\contentsline {subsection}{\numberline {7.8}Scope Resolution Operator}{46}{subsection.0.7.8}%
\contentsline {section}{\numberline {8}Random Numbers}{48}{section.0.8}%
\contentsline {section}{\numberline {9}Conditionals (Decision Structure)}{49}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Decision Structure Flowchart}{50}{subsection.0.9.1}%
\contentsline {subsection}{\numberline {9.2}The Conditional Operator (Ternary)}{50}{subsection.0.9.2}%
\contentsline {subsection}{\numberline {9.3}Switch}{51}{subsection.0.9.3}%
\contentsline {section}{\numberline {10}The While Loop}{52}{section.0.10}%
\contentsline {section}{\numberline {11}The Do-While Loop}{53}{section.0.11}%
\contentsline {section}{\numberline {12}The for loop}{54}{section.0.12}%
\contentsline {section}{\numberline {13}Using Files for Data Storage}{55}{section.0.13}%
\contentsline {subsection}{\numberline {13.1}File Access Methods}{55}{subsection.0.13.1}%
\contentsline {subsection}{\numberline {13.2}Setting up a program for file input/output}{55}{subsection.0.13.2}%
\contentsline {subsection}{\numberline {13.3}File Stream Objects}{55}{subsection.0.13.3}%
\contentsline {subsection}{\numberline {13.4}Creating a file object and opening a file}{56}{subsection.0.13.4}%
\contentsline {subsection}{\numberline {13.5}Closing a file}{57}{subsection.0.13.5}%
\contentsline {subsection}{\numberline {13.6}Reading from a file with an unknown number of lines}{58}{subsection.0.13.6}%
\contentsline {subsection}{\numberline {13.7}Testing for file open errors}{58}{subsection.0.13.7}%
\contentsline {section}{\numberline {14}rvalues and lvalues}{59}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}rvalue (right value):}{59}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}lvalue}{59}{subsection.0.14.2}%
\contentsline {section}{\numberline {15}Breaking and Continuing a loop}{60}{section.0.15}%
\contentsline {section}{\numberline {16}Functions}{61}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Function prototypes (function declarations)}{61}{subsection.0.16.1}%
\contentsline {subsection}{\numberline {16.2}Static locals}{62}{subsection.0.16.2}%
\contentsline {subsection}{\numberline {16.3}PREREQ - Reference variables}{62}{subsection.0.16.3}%
\contentsline {subsection}{\numberline {16.4}Using reference variables as parameters}{63}{subsection.0.16.4}%
\contentsline {subsection}{\numberline {16.5}Overloading Functions}{64}{subsection.0.16.5}%
\contentsline {subsection}{\numberline {16.6}The exit() function}{64}{subsection.0.16.6}%
\contentsline {subsection}{\numberline {16.7}Stubs and Drivers}{65}{subsection.0.16.7}%
\contentsline {section}{\numberline {17}Arrays and Vectors}{66}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Arrays}{66}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Partial array initialization}{66}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}Implicit array sizing}{66}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}Bound violation}{66}{subsection.0.17.4}%
\contentsline {subsection}{\numberline {17.5}The range based for loop}{67}{subsection.0.17.5}%
\contentsline {subsection}{\numberline {17.6}Modifying an array with a range-based for loop}{67}{subsection.0.17.6}%
\contentsline {subsection}{\numberline {17.7}Thou shall not assign}{67}{subsection.0.17.7}%
\contentsline {subsection}{\numberline {17.8}Getting the size of an array}{68}{subsection.0.17.8}%
\contentsline {subsection}{\numberline {17.9}Arrays as function arguments}{68}{subsection.0.17.9}%
\contentsline {subsection}{\numberline {17.10}2D array (matrix)}{70}{subsection.0.17.10}%
\contentsline {subsection}{\numberline {17.11}Passing a matrix to a function}{71}{subsection.0.17.11}%
\contentsline {subsection}{\numberline {17.12}The STL Vector}{72}{subsection.0.17.12}%
\contentsline {subsection}{\numberline {17.13}Defining a vector}{72}{subsection.0.17.13}%
\contentsline {subsection}{\numberline {17.14}Get index position of elements}{72}{subsection.0.17.14}%
\contentsline {subsection}{\numberline {17.15}Adding to a vector}{73}{subsection.0.17.15}%
\contentsline {subsection}{\numberline {17.16}Getting the size of a vector}{73}{subsection.0.17.16}%
\contentsline {subsection}{\numberline {17.17}Removing last element of a vector}{73}{subsection.0.17.17}%
\contentsline {subsection}{\numberline {17.18}Removing elements of a vector }{73}{subsection.0.17.18}%
\contentsline {subsection}{\numberline {17.19}Clearing a vector}{74}{subsection.0.17.19}%
\contentsline {subsection}{\numberline {17.20}Detecting an Empty vector}{74}{subsection.0.17.20}%
\contentsline {subsection}{\numberline {17.21}Resizing a vector}{74}{subsection.0.17.21}%
\contentsline {subsection}{\numberline {17.22}Swapping Vectors}{74}{subsection.0.17.22}%
\contentsline {section}{\numberline {18}Searching and Sorting Arrays}{75}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}The linear search}{75}{subsection.0.18.1}%
\contentsline {subsection}{\numberline {18.2}The binary search}{76}{subsection.0.18.2}%
\contentsline {subsection}{\numberline {18.3}Bubble Sort}{77}{subsection.0.18.3}%
\contentsline {subsection}{\numberline {18.4}Selection Sort}{77}{subsection.0.18.4}%
\contentsline {section}{\numberline {19}Pointers}{80}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}Nullptr}{80}{subsection.0.19.1}%
\contentsline {subsection}{\numberline {19.2}Arrays as pointers}{81}{subsection.0.19.2}%
\contentsline {subsection}{\numberline {19.3}Pointers as Function Parameters}{82}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}Pointers to constants}{82}{subsection.0.19.4}%
\contentsline {subsection}{\numberline {19.5}Constant Pointers}{83}{subsection.0.19.5}%
\contentsline {subsection}{\numberline {19.6}Both pointer to constant and constant pointer}{83}{subsection.0.19.6}%
\contentsline {subsection}{\numberline {19.7}Prereq - Static vs Dynamic memory allocation}{83}{subsection.0.19.7}%
\contentsline {subsection}{\numberline {19.8}Dynamic Memory Allocation}{84}{subsection.0.19.8}%
\contentsline {subsection}{\numberline {19.9}When to use DMA}{85}{subsection.0.19.9}%
\contentsline {subsection}{\numberline {19.10}Returning pointers from a function}{85}{subsection.0.19.10}%
\contentsline {subsection}{\numberline {19.11}Smart Pointers}{86}{subsection.0.19.11}%
\contentsline {section}{\numberline {20}Characters, C-Strings and more about the string class}{88}{section.0.20}%
\contentsline {subsection}{\numberline {20.1}Character Testing}{88}{subsection.0.20.1}%
\contentsline {subsection}{\numberline {20.2}Character case conversion}{88}{subsection.0.20.2}%
\contentsline {subsection}{\numberline {20.3}C Strings }{88}{subsection.0.20.3}%
\contentsline {subsection}{\numberline {20.4}C-Strings stored in arrays}{89}{subsection.0.20.4}%
\contentsline {subsection}{\numberline {20.5}The Strlen function}{89}{subsection.0.20.5}%
\contentsline {subsection}{\numberline {20.6}The strcat Function}{90}{subsection.0.20.6}%
\contentsline {subsection}{\numberline {20.7}The Strcopy function}{90}{subsection.0.20.7}%
\contentsline {subsection}{\numberline {20.8}The strncat and strncpy functions}{91}{subsection.0.20.8}%
\contentsline {subsection}{\numberline {20.9}The strstr function}{91}{subsection.0.20.9}%
\contentsline {subsection}{\numberline {20.10}The strcmp function}{92}{subsection.0.20.10}%
\contentsline {subsection}{\numberline {20.11}String/Numeric Conversion Functions}{92}{subsection.0.20.11}%
\contentsline {subsection}{\numberline {20.12}More on the C++ string (string object)}{93}{subsection.0.20.12}%
\contentsline {subsection}{\numberline {20.13}C++ String definitions}{93}{subsection.0.20.13}%
\contentsline {subsection}{\numberline {20.14}C++ string supported operators}{93}{subsection.0.20.14}%
\contentsline {section}{\numberline {21}Type Punning}{94}{section.0.21}%
\contentsline {section}{\numberline {22}Structures}{96}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}Abstraction}{96}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Abstract data types}{96}{subsection.0.22.2}%
\contentsline {subsection}{\numberline {22.3}Structures}{96}{subsection.0.22.3}%
\contentsline {subsection}{\numberline {22.4}Accessing structure members}{97}{subsection.0.22.4}%
\contentsline {subsection}{\numberline {22.5}Initializing a structure (Initialization list)}{97}{subsection.0.22.5}%
\contentsline {subsection}{\numberline {22.6}Arrays of structures}{98}{subsection.0.22.6}%
\contentsline {subsection}{\numberline {22.7}Initializing a structure array}{98}{subsection.0.22.7}%
\contentsline {subsection}{\numberline {22.8}Nested Structures}{99}{subsection.0.22.8}%
\contentsline {subsection}{\numberline {22.9}Structures as function arguments}{99}{subsection.0.22.9}%
\contentsline {subsection}{\numberline {22.10}Constant reference parameters}{100}{subsection.0.22.10}%
\contentsline {subsection}{\numberline {22.11}Returning a structure from a function}{100}{subsection.0.22.11}%
\contentsline {subsection}{\numberline {22.12}Pointers to structures}{101}{subsection.0.22.12}%
\contentsline {subsection}{\numberline {22.13}Dynamically allocating a structure}{101}{subsection.0.22.13}%
\contentsline {section}{\numberline {23}Enumerated data types}{102}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}General Syntax}{102}{subsection.0.23.1}%
\contentsline {subsection}{\numberline {23.2}Example}{102}{subsection.0.23.2}%
\contentsline {subsection}{\numberline {23.3}Basic Concepts}{102}{subsection.0.23.3}%
\contentsline {subsection}{\numberline {23.4}Assigning an integer to an enumerator}{103}{subsection.0.23.4}%
\contentsline {subsection}{\numberline {23.5}Assigning an enumerator to an int variable}{103}{subsection.0.23.5}%
\contentsline {subsection}{\numberline {23.6}Using math operators to change the value of an enum variable}{103}{subsection.0.23.6}%
\contentsline {subsection}{\numberline {23.7}Specifying values in enumerators}{104}{subsection.0.23.7}%
\contentsline {subsection}{\numberline {23.8}Changing the type}{104}{subsection.0.23.8}%
\contentsline {subsection}{\numberline {23.9}Quick instantiation}{104}{subsection.0.23.9}%
\contentsline {subsection}{\numberline {23.10}Strongly typed enums}{105}{subsection.0.23.10}%
\contentsline {section}{\numberline {24}Unions}{106}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Propertys}{106}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Example}{106}{subsection.0.24.2}%
\contentsline {subsubsection}{\numberline {24.2.1}Assigning Values}{106}{subsubsection.0.24.2.1}%
\contentsline {subsubsection}{\numberline {24.2.2}Accessing Values}{106}{subsubsection.0.24.2.2}%
\contentsline {subsection}{\numberline {24.3}Use Cases}{107}{subsection.0.24.3}%
\contentsline {subsection}{\numberline {24.4}Important Points}{107}{subsection.0.24.4}%
\contentsline {subsection}{\numberline {24.5}Type punning with unions}{107}{subsection.0.24.5}%
\contentsline {section}{\numberline {25}String streams}{109}{section.0.25}%
\contentsline {subsection}{\numberline {25.1}Using istringstream}{109}{subsection.0.25.1}%
\contentsline {subsection}{\numberline {25.2}Using ostringstream}{109}{subsection.0.25.2}%
\contentsline {section}{\numberline {26}Advanced file operations}{111}{section.0.26}%
\contentsline {section}{\numberline {27}C++ Lambdas}{112}{section.0.27}%
\contentsline {subsection}{\numberline {27.1}Options for capturing}{112}{subsection.0.27.1}%
\contentsline {subsection}{\numberline {27.2}Why auto as lambda type}{114}{subsection.0.27.2}%
\contentsline {section}{\numberline {28}Fancy case syntax}{115}{section.0.28}%
\contentsline {section}{\numberline {29}Static globals}{115}{section.0.29}%
\contentsline {section}{\numberline {30}Classes (OOP Principles in C++)}{116}{section.0.30}%
\contentsline {subsection}{\numberline {30.1}Private and Public (access specifiers)}{116}{subsection.0.30.1}%
\contentsline {subsection}{\numberline {30.2}Protected}{117}{subsection.0.30.2}%
\contentsline {subsection}{\numberline {30.3}Constant member functions}{117}{subsection.0.30.3}%
\contentsline {subsection}{\numberline {30.4}The mutable keyword}{117}{subsection.0.30.4}%
\contentsline {subsection}{\numberline {30.5}The friend keyword}{118}{subsection.0.30.5}%
\contentsline {subsection}{\numberline {30.6}Member function prototypes and definitions}{118}{subsection.0.30.6}%
\contentsline {subsection}{\numberline {30.7}Default Constructors}{119}{subsection.0.30.7}%
\contentsline {subsection}{\numberline {30.8}Parameterized Constructor}{119}{subsection.0.30.8}%
\contentsline {subsection}{\numberline {30.9}Copy Constructor}{119}{subsection.0.30.9}%
\contentsline {subsubsection}{\numberline {30.9.1}What invokes the copy constructor?}{120}{subsubsection.0.30.9.1}%
\contentsline {subsubsection}{\numberline {30.9.2}Assignment operator instead of copy constructor}{121}{subsubsection.0.30.9.2}%
\contentsline {subsubsection}{\numberline {30.9.3}Forcing the copy constructor with initialization lists}{121}{subsubsection.0.30.9.3}%
\contentsline {subsection}{\numberline {30.10}Constructor Overloading}{122}{subsection.0.30.10}%
\contentsline {subsection}{\numberline {30.11}Initialization Lists}{123}{subsection.0.30.11}%
\contentsline {subsection}{\numberline {30.12}Delegating Constructors}{123}{subsection.0.30.12}%
\contentsline {subsection}{\numberline {30.13}Explicit Constructors}{123}{subsection.0.30.13}%
\contentsline {subsection}{\numberline {30.14}Destructors}{125}{subsection.0.30.14}%
\contentsline {subsection}{\numberline {30.15}Default destructors}{125}{subsection.0.30.15}%
\contentsline {subsection}{\numberline {30.16}Accessors and Mutators}{125}{subsection.0.30.16}%
\contentsline {subsection}{\numberline {30.17}The "this" pointer}{126}{subsection.0.30.17}%
\contentsline {subsubsection}{\numberline {30.17.1}Returning this}{127}{subsubsection.0.30.17.1}%
\contentsline {subsubsection}{\numberline {30.17.2}Returning *this}{127}{subsubsection.0.30.17.2}%
\contentsline {subsection}{\numberline {30.18}Static Member Variables}{127}{subsection.0.30.18}%
\contentsline {subsubsection}{\numberline {30.18.1}Initialization}{127}{subsubsection.0.30.18.1}%
\contentsline {subsubsection}{\numberline {30.18.2}Access}{127}{subsubsection.0.30.18.2}%
\contentsline {subsubsection}{\numberline {30.18.3}Example}{127}{subsubsection.0.30.18.3}%
\contentsline {subsubsection}{\numberline {30.18.4}Static constant member variables}{128}{subsubsection.0.30.18.4}%
\contentsline {subsubsection}{\numberline {30.18.5}The 'inline' keyword}{128}{subsubsection.0.30.18.5}%
\contentsline {subsection}{\numberline {30.19}Static member function}{128}{subsection.0.30.19}%
\contentsline {subsubsection}{\numberline {30.19.1}Access}{128}{subsubsection.0.30.19.1}%
\contentsline {subsubsection}{\numberline {30.19.2}Restrictions}{128}{subsubsection.0.30.19.2}%
\contentsline {subsubsection}{\numberline {30.19.3}Example}{129}{subsubsection.0.30.19.3}%
\contentsline {subsubsection}{\numberline {30.19.4}Pragmatic Example}{130}{subsubsection.0.30.19.4}%
\contentsline {subsection}{\numberline {30.20}Memberwise assignment}{130}{subsection.0.30.20}%
\contentsline {subsection}{\numberline {30.21}Aggregation}{130}{subsection.0.30.21}%
\contentsline {subsection}{\numberline {30.22}Constant Objects}{130}{subsection.0.30.22}%
\contentsline {section}{\numberline {31}Operator Overloading}{131}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Overloading arithmetic operators}{131}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Overloading Stream Operators}{131}{subsection.0.31.2}%
\contentsline {subsection}{\numberline {31.3}Overloading Asssignment operator}{133}{subsection.0.31.3}%
\contentsline {subsection}{\numberline {31.4}Overloading Prefix}{133}{subsection.0.31.4}%
\contentsline {subsection}{\numberline {31.5}Overloading Postfix}{133}{subsection.0.31.5}%
\contentsline {subsection}{\numberline {31.6}Overloading Relational Operators}{135}{subsection.0.31.6}%
\contentsline {subsection}{\numberline {31.7}Overloading subscript operator}{135}{subsection.0.31.7}%
\contentsline {subsection}{\numberline {31.8}Overloading function call operator}{135}{subsection.0.31.8}%
\contentsline {subsection}{\numberline {31.9}Overloading dereference operator}{137}{subsection.0.31.9}%
\contentsline {subsection}{\numberline {31.10}Overloading arrow operator}{137}{subsection.0.31.10}%
\contentsline {subsection}{\numberline {31.11}Object Conversion}{138}{subsection.0.31.11}%
\contentsline {section}{\numberline {32}Class Inheritance}{139}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}Access Specifiers}{140}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}Constructors and Destructors}{141}{subsection.0.32.2}%
\contentsline {subsection}{\numberline {32.3}Virtual functions and the override keyword}{142}{subsection.0.32.3}%
\contentsline {subsection}{\numberline {32.4}Virtual Destructors}{142}{subsection.0.32.4}%
\contentsline {subsection}{\numberline {32.5}Polymorphism}{143}{subsection.0.32.5}%
\contentsline {subsection}{\numberline {32.6}Base class pointer to child class object}{144}{subsection.0.32.6}%
\contentsline {subsection}{\numberline {32.7}The Final keyword}{145}{subsection.0.32.7}%
\contentsline {section}{\numberline {33}Interface-Based Programming}{146}{section.0.33}%
\contentsline {subsection}{\numberline {33.1}Pure Abstract Classes in C++}{146}{subsection.0.33.1}%
\contentsline {subsection}{\numberline {33.2}Implementing Interfaces in C++}{146}{subsection.0.33.2}%
\contentsline {subsection}{\numberline {33.3}More on the concept of pure virtual functions}{147}{subsection.0.33.3}%
\contentsline {section}{\numberline {34}Separate files (Classes)}{148}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Class declaration in Header Files}{148}{subsection.0.34.1}%
\contentsline {subsection}{\numberline {34.2}Class Definition in Source Files}{148}{subsection.0.34.2}%
\contentsline {section}{\numberline {35}Rvalue references and move semantics}{149}{section.0.35}%
\contentsline {subsection}{\numberline {35.1}Rvalue references}{149}{subsection.0.35.1}%
\contentsline {subsection}{\numberline {35.2}Exception to binding references to literals}{149}{subsection.0.35.2}%
\contentsline {subsection}{\numberline {35.3}Creating a move constructor and std::move()}{151}{subsection.0.35.3}%
\contentsline {subsection}{\numberline {35.4}Move Operations and noexcept}{151}{subsection.0.35.4}%
\contentsline {subsection}{\numberline {35.5}More on std::move}{153}{subsection.0.35.5}%
\contentsline {subsubsection}{\numberline {35.5.1}Syntax}{153}{subsubsection.0.35.5.1}%
\contentsline {subsubsection}{\numberline {35.5.2}Move assignment operator}{153}{subsubsection.0.35.5.2}%
\contentsline {section}{\numberline {36}Iterators}{154}{section.0.36}%
\contentsline {subsection}{\numberline {36.1}Type of Iterators}{154}{subsection.0.36.1}%
\contentsline {subsection}{\numberline {36.2}Container Iterators}{155}{subsection.0.36.2}%
\contentsline {subsection}{\numberline {36.3}What about C-Array}{155}{subsection.0.36.3}%
\contentsline {subsection}{\numberline {36.4}Contiguous vs Non-Contiguous Memory}{156}{subsection.0.36.4}%
\contentsline {section}{\numberline {37}Other Containers}{157}{section.0.37}%
\contentsline {subsection}{\numberline {37.1}Allocation of containers}{157}{subsection.0.37.1}%
\contentsline {subsection}{\numberline {37.2}The std::array<T,n> <array>}{159}{subsection.0.37.2}%
\contentsline {subsection}{\numberline {37.3}The std::list <list>}{159}{subsection.0.37.3}%
\contentsline {subsection}{\numberline {37.4}Sets set<T, comp> <set>}{159}{subsection.0.37.4}%
\contentsline {subsection}{\numberline {37.5}Maps map<T,T, comp> <map>}{159}{subsection.0.37.5}%
\contentsline {section}{\numberline {38}Variadic Functions in C++ (Ellipsis)}{160}{section.0.38}%
\contentsline {section}{\numberline {39}std::function<type(args)> <functional>}{161}{section.0.39}%
\contentsline {section}{\numberline {40}Initializer List as function parameters}{162}{section.0.40}%
\contentsline {section}{\numberline {41}Functions as parameters}{163}{section.0.41}%
\contentsline {subsection}{\numberline {41.1}Function Pointers:}{163}{subsection.0.41.1}%
\contentsline {subsection}{\numberline {41.2}Regular function pointers}{164}{subsection.0.41.2}%
\contentsline {section}{\numberline {42}Typedefs}{165}{section.0.42}%
\contentsline {subsection}{\numberline {42.1}Basic Typedefs}{165}{subsection.0.42.1}%
\contentsline {subsubsection}{\numberline {42.1.1}Example}{165}{subsubsection.0.42.1.1}%
\contentsline {subsection}{\numberline {42.2}Applications of typedef in C++}{165}{subsection.0.42.2}%
\contentsline {subsection}{\numberline {42.3}Using typedef with arrays}{165}{subsection.0.42.3}%
\contentsline {subsubsection}{\numberline {42.3.1}Example}{165}{subsubsection.0.42.3.1}%
\contentsline {subsection}{\numberline {42.4}Using typedef with pointers}{166}{subsection.0.42.4}%
\contentsline {subsubsection}{\numberline {42.4.1}Example:}{166}{subsubsection.0.42.4.1}%
\contentsline {subsection}{\numberline {42.5}Using typedef with function pointers}{166}{subsection.0.42.5}%
\contentsline {subsubsection}{\numberline {42.5.1}Example}{166}{subsubsection.0.42.5.1}%
\contentsline {section}{\numberline {43}Buffers in C++}{167}{section.0.43}%
\contentsline {subsection}{\numberline {43.1}Types of buffers}{167}{subsection.0.43.1}%
\contentsline {subsubsection}{\numberline {43.1.1}Stack-based buffers}{167}{subsubsection.0.43.1.1}%
\contentsline {subsubsection}{\numberline {43.1.2}Heap-based Buffers}{167}{subsubsection.0.43.1.2}%
\contentsline {subsubsection}{\numberline {43.1.3}Standard Library Containers}{167}{subsubsection.0.43.1.3}%
\contentsline {subsection}{\numberline {43.2}Usage in IO Operations}{168}{subsection.0.43.2}%
\contentsline {subsection}{\numberline {43.3}Buffer Overflow}{168}{subsection.0.43.3}%
\contentsline {subsection}{\numberline {43.4}Buffer operations}{168}{subsection.0.43.4}%
\contentsline {section}{\numberline {44}The Stack, Heap, Code Segment (Text Segment), and Data Segment (static memory)}{169}{section.0.44}%
\contentsline {subsection}{\numberline {44.1}The Stack}{169}{subsection.0.44.1}%
\contentsline {subsubsection}{\numberline {44.1.1}The Call Stack}{169}{subsubsection.0.44.1.1}%
\contentsline {subsection}{\numberline {44.2}How Many Stacks are There Per Program?}{169}{subsection.0.44.2}%
\contentsline {subsection}{\numberline {44.3}Stack Memory Management}{170}{subsection.0.44.3}%
\contentsline {subsection}{\numberline {44.4}Stack Overflow}{170}{subsection.0.44.4}%
\contentsline {subsection}{\numberline {44.5}What Lives on The Stack?}{170}{subsection.0.44.5}%
\contentsline {subsection}{\numberline {44.6}The Heap}{171}{subsection.0.44.6}%
\contentsline {subsubsection}{\numberline {44.6.1}Characteristics of the Heap}{171}{subsubsection.0.44.6.1}%
\contentsline {subsubsection}{\numberline {44.6.2}Usage}{171}{subsubsection.0.44.6.2}%
\contentsline {subsubsection}{\numberline {44.6.3}Heap Allocatinos in Function Bodys}{172}{subsubsection.0.44.6.3}%
\contentsline {subsection}{\numberline {44.7}The Code Segment (Text Segment)}{172}{subsection.0.44.7}%
\contentsline {subsection}{\numberline {44.8}The Data Segment}{172}{subsection.0.44.8}%
\contentsline {subsubsection}{\numberline {44.8.1}Initialized Data Segment}{172}{subsubsection.0.44.8.1}%
\contentsline {subsubsection}{\numberline {44.8.2}Uninitialized Data Segment}{172}{subsubsection.0.44.8.2}%
\contentsline {section}{\numberline {45}More on Dynamic Memory Allocation}{173}{section.0.45}%
\contentsline {subsection}{\numberline {45.1}Before we Begin: Memory Leaks}{173}{subsection.0.45.1}%
\contentsline {subsubsection}{\numberline {45.1.1}How Memory Leaks Occur}{173}{subsubsection.0.45.1.1}%
\contentsline {subsection}{\numberline {45.2}Malloc}{173}{subsection.0.45.2}%
\contentsline {subsubsection}{\numberline {45.2.1}Signature}{173}{subsubsection.0.45.2.1}%
\contentsline {subsubsection}{\numberline {45.2.2}Example}{174}{subsubsection.0.45.2.2}%
\contentsline {subsubsection}{\numberline {45.2.3}Characteristics}{174}{subsubsection.0.45.2.3}%
\contentsline {subsubsection}{\numberline {45.2.4}Considerations}{174}{subsubsection.0.45.2.4}%
\contentsline {subsection}{\numberline {45.3}Calloc}{175}{subsection.0.45.3}%
\contentsline {subsubsection}{\numberline {45.3.1}Signature}{175}{subsubsection.0.45.3.1}%
\contentsline {subsubsection}{\numberline {45.3.2}Example}{175}{subsubsection.0.45.3.2}%
\contentsline {subsubsection}{\numberline {45.3.3}Differences from malloc}{175}{subsubsection.0.45.3.3}%
\contentsline {subsection}{\numberline {45.4}Realloc}{175}{subsection.0.45.4}%
\contentsline {subsubsection}{\numberline {45.4.1}Signature}{176}{subsubsection.0.45.4.1}%
\contentsline {subsubsection}{\numberline {45.4.2}Example}{176}{subsubsection.0.45.4.2}%
\contentsline {subsection}{\numberline {45.5}Free}{176}{subsection.0.45.5}%
\contentsline {subsubsection}{\numberline {45.5.1}Signature}{176}{subsubsection.0.45.5.1}%
\contentsline {subsection}{\numberline {45.6}New}{177}{subsection.0.45.6}%
\contentsline {subsubsection}{\numberline {45.6.1}Syntax}{177}{subsubsection.0.45.6.1}%
\contentsline {subsubsection}{\numberline {45.6.2}Array allocation}{177}{subsubsection.0.45.6.2}%
\contentsline {subsubsection}{\numberline {45.6.3}Custom Constructor Parameters}{177}{subsubsection.0.45.6.3}%
\contentsline {subsubsection}{\numberline {45.6.4}Exception Handling (std::nothrow)}{177}{subsubsection.0.45.6.4}%
\contentsline {subsubsection}{\numberline {45.6.5}Placement New}{178}{subsubsection.0.45.6.5}%
\contentsline {subsection}{\numberline {45.7}Delete}{178}{subsection.0.45.7}%
\contentsline {subsubsection}{\numberline {45.7.1}Syntax}{178}{subsubsection.0.45.7.1}%
\contentsline {subsection}{\numberline {45.8}Dangling Pointers}{179}{subsection.0.45.8}%
\contentsline {subsection}{\numberline {45.9}Overloading new and delete}{180}{subsection.0.45.9}%
\contentsline {subsubsection}{\numberline {45.9.1}Why static?}{180}{subsubsection.0.45.9.1}%
\contentsline {subsubsection}{\numberline {45.9.2}The size\_t parameter in the new overload}{181}{subsubsection.0.45.9.2}%
\contentsline {subsection}{\numberline {45.10}Getting the size of dynamically allocated memory?}{181}{subsection.0.45.10}%
\contentsline {subsection}{\numberline {45.11}Mixing Memory Management Mechanism}{181}{subsection.0.45.11}%
\contentsline {subsubsection}{\numberline {45.11.1}Why Mixing Them is Bad}{181}{subsubsection.0.45.11.1}%
\contentsline {subsection}{\numberline {45.12}Should you be using malloc, calloc, realloc, or free in C++?}{181}{subsection.0.45.12}%
\contentsline {subsubsection}{\numberline {45.12.1}Constructor and Destructor Calls}{182}{subsubsection.0.45.12.1}%
\contentsline {subsubsection}{\numberline {45.12.2}Type Safety}{182}{subsubsection.0.45.12.2}%
\contentsline {subsubsection}{\numberline {45.12.3}Exception Handling}{182}{subsubsection.0.45.12.3}%
\contentsline {section}{\numberline {46}Other Casting Operators}{183}{section.0.46}%
\contentsline {subsection}{\numberline {46.1}dynamic\_cast}{183}{subsection.0.46.1}%
\contentsline {subsubsection}{\numberline {46.1.1}Purpose}{183}{subsubsection.0.46.1.1}%
\contentsline {subsubsection}{\numberline {46.1.2}Syntax}{183}{subsubsection.0.46.1.2}%
\contentsline {subsubsection}{\numberline {46.1.3}Requirements}{183}{subsubsection.0.46.1.3}%
\contentsline {subsubsection}{\numberline {46.1.4}Example}{183}{subsubsection.0.46.1.4}%
\contentsline {subsection}{\numberline {46.2}const\_cast}{184}{subsection.0.46.2}%
\contentsline {subsubsection}{\numberline {46.2.1}Removing const}{184}{subsubsection.0.46.2.1}%
\contentsline {subsubsection}{\numberline {46.2.2}Adding const}{184}{subsubsection.0.46.2.2}%
\contentsline {subsubsection}{\numberline {46.2.3}Use cases}{184}{subsubsection.0.46.2.3}%
\contentsline {subsubsection}{\numberline {46.2.4}Important Points}{185}{subsubsection.0.46.2.4}%
\contentsline {subsubsection}{\numberline {46.2.5}Example}{185}{subsubsection.0.46.2.5}%
\contentsline {subsubsection}{\numberline {46.2.6}When is it unsafe to use}{185}{subsubsection.0.46.2.6}%
\contentsline {subsubsection}{\numberline {46.2.7}The volatile keyword}{185}{subsubsection.0.46.2.7}%
\contentsline {subsubsection}{\numberline {46.2.8}Purpose}{185}{subsubsection.0.46.2.8}%
\contentsline {subsection}{\numberline {46.3}reinterpret\_cast}{186}{subsection.0.46.3}%
\contentsline {subsubsection}{\numberline {46.3.1}Key Characteristics}{186}{subsubsection.0.46.3.1}%
\contentsline {subsubsection}{\numberline {46.3.2}Syntax}{186}{subsubsection.0.46.3.2}%
\contentsline {subsubsection}{\numberline {46.3.3}Example}{186}{subsubsection.0.46.3.3}%
\contentsline {subsubsection}{\numberline {46.3.4}Considerations}{187}{subsubsection.0.46.3.4}%
\contentsline {section}{\numberline {47}Namespaces}{188}{section.0.47}%
\contentsline {subsection}{\numberline {47.1}Syntax}{188}{subsection.0.47.1}%
\contentsline {subsection}{\numberline {47.2}Using Namespaces}{188}{subsection.0.47.2}%
\contentsline {subsection}{\numberline {47.3}Nested Namespaces}{188}{subsection.0.47.3}%
\contentsline {subsection}{\numberline {47.4}Anonymous Namespaces}{189}{subsection.0.47.4}%
\contentsline {section}{\numberline {48}Exceptions}{190}{section.0.48}%
\contentsline {subsection}{\numberline {48.1}Concepts}{190}{subsection.0.48.1}%
\contentsline {subsection}{\numberline {48.2}Syntax}{190}{subsection.0.48.2}%
\contentsline {subsection}{\numberline {48.3}Example}{191}{subsection.0.48.3}%
\contentsline {subsection}{\numberline {48.4}Why does catch take a const reference?}{191}{subsection.0.48.4}%
\contentsline {subsubsection}{\numberline {48.4.1}Safety and Efficiency}{191}{subsubsection.0.48.4.1}%
\contentsline {subsubsection}{\numberline {48.4.2}Const Correctness}{191}{subsubsection.0.48.4.2}%
\contentsline {subsection}{\numberline {48.5}Catching any exception}{192}{subsection.0.48.5}%
\contentsline {subsection}{\numberline {48.6}cerr (standard error)}{192}{subsection.0.48.6}%
\contentsline {subsubsection}{\numberline {48.6.1}Unbuffered Output}{192}{subsubsection.0.48.6.1}%
\contentsline {subsection}{\numberline {48.7}The what() function}{192}{subsection.0.48.7}%
\contentsline {subsubsection}{\numberline {48.7.1}Signature}{192}{subsubsection.0.48.7.1}%
\contentsline {subsection}{\numberline {48.8}What can we throw/catch?}{192}{subsection.0.48.8}%
\contentsline {subsection}{\numberline {48.9}noexcept in function signatures}{193}{subsection.0.48.9}%
\contentsline {subsection}{\numberline {48.10}Syntax and Usage}{193}{subsection.0.48.10}%
\contentsline {subsection}{\numberline {48.11}Benefits}{193}{subsection.0.48.11}%
\contentsline {subsection}{\numberline {48.12}OOP Approach to exceptions (Custom exception class)}{194}{subsection.0.48.12}%
\contentsline {subsection}{\numberline {48.13}Unwinding the stack}{195}{subsection.0.48.13}%
\contentsline {subsection}{\numberline {48.14}More on 'new'}{195}{subsection.0.48.14}%
\contentsline {subsubsection}{\numberline {48.14.1}Handling bad\_alloc}{195}{subsubsection.0.48.14.1}%
\contentsline {subsubsection}{\numberline {48.14.2}nothrow}{195}{subsubsection.0.48.14.2}%
\contentsline {section}{\numberline {49}Templates}{196}{section.0.49}%
\contentsline {subsection}{\numberline {49.1}Function Templates}{196}{subsection.0.49.1}%
\contentsline {subsubsection}{\numberline {49.1.1}Syntax}{196}{subsubsection.0.49.1.1}%
\contentsline {subsubsection}{\numberline {49.1.2}Example}{196}{subsubsection.0.49.1.2}%
\contentsline {subsection}{\numberline {49.2}Class Templates}{197}{subsection.0.49.2}%
\contentsline {subsubsection}{\numberline {49.2.1}Example}{197}{subsubsection.0.49.2.1}%
\contentsline {subsection}{\numberline {49.3}Function Template Specialization}{198}{subsection.0.49.3}%
\contentsline {subsection}{\numberline {49.4}Class/Struct Template Specialization}{198}{subsection.0.49.4}%
\contentsline {subsection}{\numberline {49.5}Template Parameters}{198}{subsection.0.49.5}%
\contentsline {subsection}{\numberline {49.6}Trailing return type}{198}{subsection.0.49.6}%
\contentsline {subsubsection}{\numberline {49.6.1}Syntax}{199}{subsubsection.0.49.6.1}%
\contentsline {subsubsection}{\numberline {49.6.2}Example}{199}{subsubsection.0.49.6.2}%
\contentsline {subsection}{\numberline {49.7}decltype}{199}{subsection.0.49.7}%
\contentsline {subsubsection}{\numberline {49.7.1}Syntax}{199}{subsubsection.0.49.7.1}%
\contentsline {subsubsection}{\numberline {49.7.2}Example}{199}{subsubsection.0.49.7.2}%
\contentsline {subsection}{\numberline {49.8}Template functions with mixed types (Trailing return type)}{199}{subsection.0.49.8}%
\contentsline {subsection}{\numberline {49.9}Template functions with mixed types (Deduced return type)}{201}{subsection.0.49.9}%
\contentsline {subsection}{\numberline {49.10}The use of 'static' in template programming}{201}{subsection.0.49.10}%
\contentsline {subsubsection}{\numberline {49.10.1}Declaring and Defining Static Members in a Template Class}{201}{subsubsection.0.49.10.1}%
\contentsline {subsubsection}{\numberline {49.10.2}Key points}{202}{subsubsection.0.49.10.2}%
\contentsline {subsection}{\numberline {49.11}Non-Type Template Parameters}{202}{subsection.0.49.11}%
\contentsline {subsubsection}{\numberline {49.11.1}Array sizes}{202}{subsubsection.0.49.11.1}%
\contentsline {subsubsection}{\numberline {49.11.2}Compile-Time Calculations}{203}{subsubsection.0.49.11.2}%
\contentsline {section}{\numberline {50}Elementary compile time computations}{204}{section.0.50}%
\contentsline {section}{\numberline {51}Linkage}{205}{section.0.51}%
\contentsline {subsection}{\numberline {51.1}Basics}{205}{subsection.0.51.1}%
\contentsline {subsection}{\numberline {51.2}Declaration vs. Definition}{205}{subsection.0.51.2}%
\contentsline {subsubsection}{\numberline {51.2.1}Variables}{205}{subsubsection.0.51.2.1}%
\contentsline {subsection}{\numberline {51.3}Forward Declaring}{206}{subsection.0.51.3}%
\contentsline {subsubsection}{\numberline {51.3.1}Example}{206}{subsubsection.0.51.3.1}%
\contentsline {subsubsection}{\numberline {51.3.2}Usage Frequency}{206}{subsubsection.0.51.3.2}%
\contentsline {subsection}{\numberline {51.4}Translation Units}{207}{subsection.0.51.4}%
\contentsline {subsection}{\numberline {51.5}Linkage}{207}{subsection.0.51.5}%
\contentsline {subsection}{\numberline {51.6}External Linkage}{207}{subsection.0.51.6}%
\contentsline {subsubsection}{\numberline {51.6.1}Usage}{208}{subsubsection.0.51.6.1}%
\contentsline {subsection}{\numberline {51.7}Internal Linkage}{208}{subsection.0.51.7}%
\contentsline {subsubsection}{\numberline {51.7.1}Example}{209}{subsubsection.0.51.7.1}%
\contentsline {section}{\numberline {52}Extra Information}{210}{section.0.52}%
\contentsline {subsection}{\numberline {52.1}constexpr}{210}{subsection.0.52.1}%
\contentsline {subsection}{\numberline {52.2}consteval}{210}{subsection.0.52.2}%
\contentsline {subsection}{\numberline {52.3}constinit}{210}{subsection.0.52.3}%
\contentsline {subsection}{\numberline {52.4}More on 'inline'}{210}{subsection.0.52.4}%
\contentsline {subsection}{\numberline {52.5}Measuring the speed of C++ programs}{210}{subsection.0.52.5}%
