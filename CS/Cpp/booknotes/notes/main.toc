\contentsline {section}{\numberline {1}The C++ Language}{18}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Key Features}{18}{subsection.0.1.1}%
\contentsline {section}{\numberline {2}The Compiler}{20}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Preprocessing}{20}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Lexical Analysis}{20}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Syntax Analysis}{20}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Semantic Analysis}{20}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Intermediate Code Generation}{20}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Code Optimization}{21}{subsection.0.2.6}%
\contentsline {subsection}{\numberline {2.7}Code Generation}{21}{subsection.0.2.7}%
\contentsline {subsection}{\numberline {2.8}Assembling}{21}{subsection.0.2.8}%
\contentsline {subsection}{\numberline {2.9}Linking}{21}{subsection.0.2.9}%
\contentsline {subsection}{\numberline {2.10}Complier Options}{21}{subsection.0.2.10}%
\contentsline {subsection}{\numberline {2.11}Header Files}{22}{subsection.0.2.11}%
\contentsline {section}{\numberline {3}Preliminaries: A Quick Tour of C++ Fundamentals}{23}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Boilerplate}{23}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}The main function}{23}{subsection.0.3.2}%
\contentsline {subsection}{\numberline {3.3}Comments}{23}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Data Types, Modifiers, Qualifiers, Inference}{25}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}Primitive Type Ranges and Size}{26}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}Creating strings without the STL}{27}{subsection.0.3.6}%
\contentsline {subsection}{\numberline {3.7}Retrieve size}{28}{subsection.0.3.7}%
\contentsline {subsection}{\numberline {3.8}Retrieve type}{28}{subsection.0.3.8}%
\contentsline {subsection}{\numberline {3.9}Exponential Notation}{29}{subsection.0.3.9}%
\contentsline {subsection}{\numberline {3.10}Type Conversion}{29}{subsection.0.3.10}%
\contentsline {subsection}{\numberline {3.11}Integer Division}{30}{subsection.0.3.11}%
\contentsline {subsection}{\numberline {3.12}Overflow/Underflow}{30}{subsection.0.3.12}%
\contentsline {subsection}{\numberline {3.13}Type Casting}{30}{subsection.0.3.13}%
\contentsline {subsection}{\numberline {3.14}C-style Casts}{31}{subsection.0.3.14}%
\contentsline {subsection}{\numberline {3.15}The Using Directive}{32}{subsection.0.3.15}%
\contentsline {subsection}{\numberline {3.16}Variable Declaration}{33}{subsection.0.3.16}%
\contentsline {subsection}{\numberline {3.17}Multiple Declaration}{33}{subsection.0.3.17}%
\contentsline {subsection}{\numberline {3.18}Initialization}{33}{subsection.0.3.18}%
\contentsline {subsection}{\numberline {3.19}Multiple Initialization}{33}{subsection.0.3.19}%
\contentsline {subsection}{\numberline {3.20}Direct Initialization}{34}{subsection.0.3.20}%
\contentsline {subsection}{\numberline {3.21}List Initialization}{34}{subsection.0.3.21}%
\contentsline {subsection}{\numberline {3.22}Copy Initialization}{34}{subsection.0.3.22}%
\contentsline {subsection}{\numberline {3.23}Assignment}{34}{subsection.0.3.23}%
\contentsline {subsection}{\numberline {3.24}Multiple Assignment}{35}{subsection.0.3.24}%
\contentsline {section}{\numberline {4}Symbols}{36}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Parentheses}{36}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Brackets}{36}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Braces}{36}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Angle Brackets}{36}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Semi Colon}{36}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Colon}{36}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}Comma}{37}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}Ellipsis}{37}{subsection.0.4.8}%
\contentsline {subsection}{\numberline {4.9}Hash}{37}{subsection.0.4.9}%
\contentsline {section}{\numberline {5}Preprocessor Directives}{38}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}\#include}{38}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}\#define}{38}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}\#undef}{38}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}\#ifdef, \#ifndef, \#else, \#elif, \#endif}{38}{subsection.0.5.4}%
\contentsline {subsection}{\numberline {5.5}\#if}{39}{subsection.0.5.5}%
\contentsline {subsection}{\numberline {5.6}\#pragma}{39}{subsection.0.5.6}%
\contentsline {subsection}{\numberline {5.7}\#error}{39}{subsection.0.5.7}%
\contentsline {subsection}{\numberline {5.8}\#line}{39}{subsection.0.5.8}%
\contentsline {section}{\numberline {6}Input/Output}{40}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}iostream}{40}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Output}{40}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Input}{40}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}IO Manipulators}{42}{subsection.0.6.4}%
\contentsline {subsection}{\numberline {6.5}std::setiosflags}{44}{subsection.0.6.5}%
\contentsline {subsection}{\numberline {6.6}Escape Sequences}{44}{subsection.0.6.6}%
\contentsline {subsection}{\numberline {6.7}User Input With Strings}{45}{subsection.0.6.7}%
\contentsline {subsection}{\numberline {6.8}User input with characters}{46}{subsection.0.6.8}%
\contentsline {subsection}{\numberline {6.9}Mixing cin and cin.get}{46}{subsection.0.6.9}%
\contentsline {section}{\numberline {7}Operators}{47}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Arithmetic Operators}{47}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Relational Operators}{47}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}Logical Operators}{47}{subsection.0.7.3}%
\contentsline {subsection}{\numberline {7.4}Bitwise Operators}{47}{subsection.0.7.4}%
\contentsline {subsection}{\numberline {7.5}Assignment Operators}{47}{subsection.0.7.5}%
\contentsline {subsection}{\numberline {7.6}Increment and Decrement Operators}{47}{subsection.0.7.6}%
\contentsline {subsection}{\numberline {7.7}Pointers and References}{47}{subsection.0.7.7}%
\contentsline {subsection}{\numberline {7.8}Scope Resolution Operator}{47}{subsection.0.7.8}%
\contentsline {section}{\numberline {8}Random Numbers}{49}{section.0.8}%
\contentsline {section}{\numberline {9}Conditionals (Decision Structure)}{50}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Decision Structure Flowchart}{51}{subsection.0.9.1}%
\contentsline {subsection}{\numberline {9.2}The Conditional Operator (Ternary)}{51}{subsection.0.9.2}%
\contentsline {subsection}{\numberline {9.3}Switch}{52}{subsection.0.9.3}%
\contentsline {section}{\numberline {10}The While Loop}{53}{section.0.10}%
\contentsline {section}{\numberline {11}The Do-While Loop}{54}{section.0.11}%
\contentsline {section}{\numberline {12}The for loop}{55}{section.0.12}%
\contentsline {section}{\numberline {13}Using Files for Data Storage}{56}{section.0.13}%
\contentsline {subsection}{\numberline {13.1}File Access Methods}{56}{subsection.0.13.1}%
\contentsline {subsection}{\numberline {13.2}Setting up a program for file input/output}{56}{subsection.0.13.2}%
\contentsline {subsection}{\numberline {13.3}File Stream Objects}{56}{subsection.0.13.3}%
\contentsline {subsection}{\numberline {13.4}Creating a file object and opening a file}{57}{subsection.0.13.4}%
\contentsline {subsection}{\numberline {13.5}Closing a file}{58}{subsection.0.13.5}%
\contentsline {subsection}{\numberline {13.6}Reading from a file with an unknown number of lines}{59}{subsection.0.13.6}%
\contentsline {subsection}{\numberline {13.7}Testing for file open errors}{59}{subsection.0.13.7}%
\contentsline {section}{\numberline {14}rvalues and lvalues}{60}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}rvalue (right value):}{60}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}lvalue}{60}{subsection.0.14.2}%
\contentsline {section}{\numberline {15}Breaking and Continuing a loop}{61}{section.0.15}%
\contentsline {section}{\numberline {16}Functions}{62}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Function prototypes (function declarations)}{62}{subsection.0.16.1}%
\contentsline {subsection}{\numberline {16.2}Static locals}{63}{subsection.0.16.2}%
\contentsline {subsection}{\numberline {16.3}PREREQ - Reference variables}{63}{subsection.0.16.3}%
\contentsline {subsection}{\numberline {16.4}Using reference variables as parameters}{64}{subsection.0.16.4}%
\contentsline {subsection}{\numberline {16.5}Overloading Functions}{65}{subsection.0.16.5}%
\contentsline {subsection}{\numberline {16.6}The exit() function}{65}{subsection.0.16.6}%
\contentsline {subsection}{\numberline {16.7}Stubs and Drivers}{66}{subsection.0.16.7}%
\contentsline {section}{\numberline {17}Arrays and Vectors}{67}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Arrays}{67}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Partial array initialization}{67}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}Implicit array sizing}{67}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}Bound violation}{67}{subsection.0.17.4}%
\contentsline {subsection}{\numberline {17.5}The range based for loop}{68}{subsection.0.17.5}%
\contentsline {subsection}{\numberline {17.6}Modifying an array with a range-based for loop}{68}{subsection.0.17.6}%
\contentsline {subsection}{\numberline {17.7}Thou shall not assign}{68}{subsection.0.17.7}%
\contentsline {subsection}{\numberline {17.8}Getting the size of an array}{69}{subsection.0.17.8}%
\contentsline {subsection}{\numberline {17.9}Arrays as function arguments}{69}{subsection.0.17.9}%
\contentsline {subsection}{\numberline {17.10}2D array (matrix)}{71}{subsection.0.17.10}%
\contentsline {subsection}{\numberline {17.11}Passing a matrix to a function}{72}{subsection.0.17.11}%
\contentsline {subsection}{\numberline {17.12}The STL Vector}{73}{subsection.0.17.12}%
\contentsline {subsection}{\numberline {17.13}Defining a vector}{73}{subsection.0.17.13}%
\contentsline {subsection}{\numberline {17.14}Get index position of elements}{73}{subsection.0.17.14}%
\contentsline {subsection}{\numberline {17.15}Adding to a vector}{74}{subsection.0.17.15}%
\contentsline {subsection}{\numberline {17.16}Getting the size of a vector}{74}{subsection.0.17.16}%
\contentsline {subsection}{\numberline {17.17}Removing last element of a vector}{74}{subsection.0.17.17}%
\contentsline {subsection}{\numberline {17.18}Removing elements of a vector }{74}{subsection.0.17.18}%
\contentsline {subsection}{\numberline {17.19}Clearing a vector}{75}{subsection.0.17.19}%
\contentsline {subsection}{\numberline {17.20}Detecting an Empty vector}{75}{subsection.0.17.20}%
\contentsline {subsection}{\numberline {17.21}Resizing a vector}{75}{subsection.0.17.21}%
\contentsline {subsection}{\numberline {17.22}Swapping Vectors}{75}{subsection.0.17.22}%
\contentsline {section}{\numberline {18}Searching and Sorting Arrays}{76}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}The linear search}{76}{subsection.0.18.1}%
\contentsline {subsection}{\numberline {18.2}The binary search}{77}{subsection.0.18.2}%
\contentsline {subsection}{\numberline {18.3}Bubble Sort}{78}{subsection.0.18.3}%
\contentsline {subsection}{\numberline {18.4}Selection Sort}{78}{subsection.0.18.4}%
\contentsline {section}{\numberline {19}Pointers}{81}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}Nullptr}{81}{subsection.0.19.1}%
\contentsline {subsection}{\numberline {19.2}Arrays as pointers}{82}{subsection.0.19.2}%
\contentsline {subsection}{\numberline {19.3}Pointers as Function Parameters}{83}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}Pointers to constants}{83}{subsection.0.19.4}%
\contentsline {subsection}{\numberline {19.5}Constant Pointers}{84}{subsection.0.19.5}%
\contentsline {subsection}{\numberline {19.6}Both pointer to constant and constant pointer}{84}{subsection.0.19.6}%
\contentsline {subsection}{\numberline {19.7}Prereq - Static vs Dynamic memory allocation}{84}{subsection.0.19.7}%
\contentsline {subsection}{\numberline {19.8}Dynamic Memory Allocation}{85}{subsection.0.19.8}%
\contentsline {subsection}{\numberline {19.9}When to use DMA}{86}{subsection.0.19.9}%
\contentsline {subsection}{\numberline {19.10}Returning pointers from a function}{86}{subsection.0.19.10}%
\contentsline {subsection}{\numberline {19.11}Smart Pointers}{87}{subsection.0.19.11}%
\contentsline {section}{\numberline {20}Characters, C-Strings and more about the string class}{89}{section.0.20}%
\contentsline {subsection}{\numberline {20.1}Character Testing}{89}{subsection.0.20.1}%
\contentsline {subsection}{\numberline {20.2}Character case conversion}{89}{subsection.0.20.2}%
\contentsline {subsection}{\numberline {20.3}C Strings }{89}{subsection.0.20.3}%
\contentsline {subsection}{\numberline {20.4}C-Strings stored in arrays}{90}{subsection.0.20.4}%
\contentsline {subsection}{\numberline {20.5}The Strlen function}{90}{subsection.0.20.5}%
\contentsline {subsection}{\numberline {20.6}The strcat Function}{91}{subsection.0.20.6}%
\contentsline {subsection}{\numberline {20.7}The Strcopy function}{91}{subsection.0.20.7}%
\contentsline {subsection}{\numberline {20.8}The strncat and strncpy functions}{92}{subsection.0.20.8}%
\contentsline {subsection}{\numberline {20.9}The strstr function}{92}{subsection.0.20.9}%
\contentsline {subsection}{\numberline {20.10}The strcmp function}{93}{subsection.0.20.10}%
\contentsline {subsection}{\numberline {20.11}String/Numeric Conversion Functions}{93}{subsection.0.20.11}%
\contentsline {subsection}{\numberline {20.12}More on the C++ string (string object)}{94}{subsection.0.20.12}%
\contentsline {subsection}{\numberline {20.13}C++ String definitions}{94}{subsection.0.20.13}%
\contentsline {subsection}{\numberline {20.14}C++ string supported operators}{94}{subsection.0.20.14}%
\contentsline {section}{\numberline {21}Type Punning}{95}{section.0.21}%
\contentsline {section}{\numberline {22}Structures}{97}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}Abstraction}{97}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Abstract data types}{97}{subsection.0.22.2}%
\contentsline {subsection}{\numberline {22.3}Structures}{97}{subsection.0.22.3}%
\contentsline {subsection}{\numberline {22.4}Accessing structure members}{98}{subsection.0.22.4}%
\contentsline {subsection}{\numberline {22.5}Initializing a structure (Initialization list)}{98}{subsection.0.22.5}%
\contentsline {subsection}{\numberline {22.6}Arrays of structures}{99}{subsection.0.22.6}%
\contentsline {subsection}{\numberline {22.7}Initializing a structure array}{99}{subsection.0.22.7}%
\contentsline {subsection}{\numberline {22.8}Nested Structures}{100}{subsection.0.22.8}%
\contentsline {subsection}{\numberline {22.9}Structures as function arguments}{100}{subsection.0.22.9}%
\contentsline {subsection}{\numberline {22.10}Constant reference parameters}{101}{subsection.0.22.10}%
\contentsline {subsection}{\numberline {22.11}Returning a structure from a function}{101}{subsection.0.22.11}%
\contentsline {subsection}{\numberline {22.12}Pointers to structures}{102}{subsection.0.22.12}%
\contentsline {subsection}{\numberline {22.13}Dynamically allocating a structure}{102}{subsection.0.22.13}%
\contentsline {section}{\numberline {23}Enumerated data types}{103}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}General Syntax}{103}{subsection.0.23.1}%
\contentsline {subsection}{\numberline {23.2}Example}{103}{subsection.0.23.2}%
\contentsline {subsection}{\numberline {23.3}Basic Concepts}{103}{subsection.0.23.3}%
\contentsline {subsection}{\numberline {23.4}Assigning an integer to an enumerator}{104}{subsection.0.23.4}%
\contentsline {subsection}{\numberline {23.5}Assigning an enumerator to an int variable}{104}{subsection.0.23.5}%
\contentsline {subsection}{\numberline {23.6}Using math operators to change the value of an enum variable}{104}{subsection.0.23.6}%
\contentsline {subsection}{\numberline {23.7}Specifying values in enumerators}{105}{subsection.0.23.7}%
\contentsline {subsection}{\numberline {23.8}Changing the type}{105}{subsection.0.23.8}%
\contentsline {subsection}{\numberline {23.9}Quick instantiation}{105}{subsection.0.23.9}%
\contentsline {subsection}{\numberline {23.10}Strongly typed enums}{106}{subsection.0.23.10}%
\contentsline {section}{\numberline {24}Unions}{107}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Propertys}{107}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Example}{107}{subsection.0.24.2}%
\contentsline {subsubsection}{\numberline {24.2.1}Assigning Values}{107}{subsubsection.0.24.2.1}%
\contentsline {subsubsection}{\numberline {24.2.2}Accessing Values}{107}{subsubsection.0.24.2.2}%
\contentsline {subsection}{\numberline {24.3}Use Cases}{108}{subsection.0.24.3}%
\contentsline {subsection}{\numberline {24.4}Important Points}{108}{subsection.0.24.4}%
\contentsline {subsection}{\numberline {24.5}Type punning with unions}{108}{subsection.0.24.5}%
\contentsline {section}{\numberline {25}String streams}{110}{section.0.25}%
\contentsline {subsection}{\numberline {25.1}Using istringstream}{110}{subsection.0.25.1}%
\contentsline {subsection}{\numberline {25.2}Using ostringstream}{110}{subsection.0.25.2}%
\contentsline {section}{\numberline {26}Advanced file operations}{112}{section.0.26}%
\contentsline {section}{\numberline {27}C++ Lambdas}{113}{section.0.27}%
\contentsline {subsection}{\numberline {27.1}Options for capturing}{113}{subsection.0.27.1}%
\contentsline {subsection}{\numberline {27.2}Why auto as lambda type}{115}{subsection.0.27.2}%
\contentsline {section}{\numberline {28}Fancy case syntax}{116}{section.0.28}%
\contentsline {section}{\numberline {29}Static globals}{116}{section.0.29}%
\contentsline {section}{\numberline {30}Classes (OOP Principles in C++)}{117}{section.0.30}%
\contentsline {subsection}{\numberline {30.1}Private and Public (access specifiers)}{117}{subsection.0.30.1}%
\contentsline {subsection}{\numberline {30.2}Protected}{118}{subsection.0.30.2}%
\contentsline {subsection}{\numberline {30.3}Constant member functions}{118}{subsection.0.30.3}%
\contentsline {subsection}{\numberline {30.4}The mutable keyword}{118}{subsection.0.30.4}%
\contentsline {subsection}{\numberline {30.5}The friend keyword for member functions}{119}{subsection.0.30.5}%
\contentsline {subsection}{\numberline {30.6}The friend keyword for classes}{119}{subsection.0.30.6}%
\contentsline {subsubsection}{\numberline {30.6.1}Example}{119}{subsubsection.0.30.6.1}%
\contentsline {subsection}{\numberline {30.7}Member function prototypes and definitions}{120}{subsection.0.30.7}%
\contentsline {subsection}{\numberline {30.8}Default Constructors}{121}{subsection.0.30.8}%
\contentsline {subsection}{\numberline {30.9}Parameterized Constructor}{121}{subsection.0.30.9}%
\contentsline {subsection}{\numberline {30.10}Copy Constructor}{121}{subsection.0.30.10}%
\contentsline {subsubsection}{\numberline {30.10.1}What invokes the copy constructor?}{122}{subsubsection.0.30.10.1}%
\contentsline {subsubsection}{\numberline {30.10.2}Assignment operator instead of copy constructor}{123}{subsubsection.0.30.10.2}%
\contentsline {subsubsection}{\numberline {30.10.3}Forcing the copy constructor with initialization lists}{123}{subsubsection.0.30.10.3}%
\contentsline {subsection}{\numberline {30.11}Constructor Overloading}{124}{subsection.0.30.11}%
\contentsline {subsection}{\numberline {30.12}Initialization Lists}{125}{subsection.0.30.12}%
\contentsline {subsection}{\numberline {30.13}Delegating Constructors}{125}{subsection.0.30.13}%
\contentsline {subsection}{\numberline {30.14}Explicit Constructors}{125}{subsection.0.30.14}%
\contentsline {subsection}{\numberline {30.15}Destructors}{127}{subsection.0.30.15}%
\contentsline {subsection}{\numberline {30.16}Default destructors}{127}{subsection.0.30.16}%
\contentsline {subsection}{\numberline {30.17}Accessors and Mutators}{127}{subsection.0.30.17}%
\contentsline {subsection}{\numberline {30.18}The "this" pointer}{128}{subsection.0.30.18}%
\contentsline {subsubsection}{\numberline {30.18.1}Returning this}{129}{subsubsection.0.30.18.1}%
\contentsline {subsubsection}{\numberline {30.18.2}Returning *this}{129}{subsubsection.0.30.18.2}%
\contentsline {subsection}{\numberline {30.19}Static Member Variables}{129}{subsection.0.30.19}%
\contentsline {subsubsection}{\numberline {30.19.1}Initialization}{129}{subsubsection.0.30.19.1}%
\contentsline {subsubsection}{\numberline {30.19.2}Access}{129}{subsubsection.0.30.19.2}%
\contentsline {subsubsection}{\numberline {30.19.3}Example}{129}{subsubsection.0.30.19.3}%
\contentsline {subsubsection}{\numberline {30.19.4}Static constant member variables}{130}{subsubsection.0.30.19.4}%
\contentsline {subsubsection}{\numberline {30.19.5}The 'inline' keyword}{130}{subsubsection.0.30.19.5}%
\contentsline {subsection}{\numberline {30.20}Static member function}{130}{subsection.0.30.20}%
\contentsline {subsubsection}{\numberline {30.20.1}Access}{130}{subsubsection.0.30.20.1}%
\contentsline {subsubsection}{\numberline {30.20.2}Restrictions}{130}{subsubsection.0.30.20.2}%
\contentsline {subsubsection}{\numberline {30.20.3}Example}{131}{subsubsection.0.30.20.3}%
\contentsline {subsubsection}{\numberline {30.20.4}Pragmatic Example}{132}{subsubsection.0.30.20.4}%
\contentsline {subsection}{\numberline {30.21}Memberwise assignment}{132}{subsection.0.30.21}%
\contentsline {subsection}{\numberline {30.22}Aggregation}{132}{subsection.0.30.22}%
\contentsline {subsection}{\numberline {30.23}Constant Objects}{132}{subsection.0.30.23}%
\contentsline {section}{\numberline {31}Operator Overloading}{133}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Overloading arithmetic operators}{133}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Overloading Stream Operators}{134}{subsection.0.31.2}%
\contentsline {subsection}{\numberline {31.3}Overloading Asssignment operator}{135}{subsection.0.31.3}%
\contentsline {subsection}{\numberline {31.4}Overloading Prefix}{135}{subsection.0.31.4}%
\contentsline {subsection}{\numberline {31.5}Overloading Postfix}{135}{subsection.0.31.5}%
\contentsline {subsection}{\numberline {31.6}Overloading Relational Operators}{136}{subsection.0.31.6}%
\contentsline {subsection}{\numberline {31.7}Overloading subscript operator}{136}{subsection.0.31.7}%
\contentsline {subsection}{\numberline {31.8}Overloading function call operator}{137}{subsection.0.31.8}%
\contentsline {subsection}{\numberline {31.9}Overloading dereference operator}{138}{subsection.0.31.9}%
\contentsline {subsection}{\numberline {31.10}Overloading arrow operator}{139}{subsection.0.31.10}%
\contentsline {subsection}{\numberline {31.11}Object Conversion}{140}{subsection.0.31.11}%
\contentsline {subsection}{\numberline {31.12}Aspects of an Operator That Cannot Be Changed by Operator Overloading}{140}{subsection.0.31.12}%
\contentsline {section}{\numberline {32}Class Inheritance}{141}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}Access Specifiers}{142}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}Constructors and Destructors}{143}{subsection.0.32.2}%
\contentsline {subsection}{\numberline {32.3}Virtual functions and the override keyword}{144}{subsection.0.32.3}%
\contentsline {subsection}{\numberline {32.4}Virtual Destructors}{144}{subsection.0.32.4}%
\contentsline {subsection}{\numberline {32.5}Polymorphism}{145}{subsection.0.32.5}%
\contentsline {subsection}{\numberline {32.6}Base class pointer to child class object}{146}{subsection.0.32.6}%
\contentsline {subsection}{\numberline {32.7}The Final keyword}{147}{subsection.0.32.7}%
\contentsline {section}{\numberline {33}Interface-Based Programming}{148}{section.0.33}%
\contentsline {subsection}{\numberline {33.1}Pure Abstract Classes in C++}{148}{subsection.0.33.1}%
\contentsline {subsection}{\numberline {33.2}Implementing Interfaces in C++}{148}{subsection.0.33.2}%
\contentsline {subsection}{\numberline {33.3}More on the concept of pure virtual functions}{149}{subsection.0.33.3}%
\contentsline {section}{\numberline {34}Separate files (Classes)}{150}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Class declaration in Header Files}{150}{subsection.0.34.1}%
\contentsline {subsection}{\numberline {34.2}Class Definition in Source Files}{150}{subsection.0.34.2}%
\contentsline {section}{\numberline {35}Rvalue references and move semantics}{151}{section.0.35}%
\contentsline {subsection}{\numberline {35.1}Rvalue references}{151}{subsection.0.35.1}%
\contentsline {subsection}{\numberline {35.2}Exception to binding references to literals}{151}{subsection.0.35.2}%
\contentsline {subsection}{\numberline {35.3}Creating a move constructor and std::move()}{153}{subsection.0.35.3}%
\contentsline {subsection}{\numberline {35.4}Move Operations and noexcept}{153}{subsection.0.35.4}%
\contentsline {subsection}{\numberline {35.5}More on std::move}{155}{subsection.0.35.5}%
\contentsline {subsubsection}{\numberline {35.5.1}Syntax}{155}{subsubsection.0.35.5.1}%
\contentsline {subsubsection}{\numberline {35.5.2}Move assignment operator}{155}{subsubsection.0.35.5.2}%
\contentsline {section}{\numberline {36}Iterators}{156}{section.0.36}%
\contentsline {subsection}{\numberline {36.1}Type of Iterators}{156}{subsection.0.36.1}%
\contentsline {subsection}{\numberline {36.2}Container Iterators}{157}{subsection.0.36.2}%
\contentsline {subsection}{\numberline {36.3}What about C-Array}{157}{subsection.0.36.3}%
\contentsline {subsection}{\numberline {36.4}Contiguous vs Non-Contiguous Memory}{158}{subsection.0.36.4}%
\contentsline {section}{\numberline {37}Other Containers}{159}{section.0.37}%
\contentsline {subsection}{\numberline {37.1}Allocation of containers}{159}{subsection.0.37.1}%
\contentsline {subsection}{\numberline {37.2}The std::array<T,n> <array>}{161}{subsection.0.37.2}%
\contentsline {subsection}{\numberline {37.3}The std::list <list>}{161}{subsection.0.37.3}%
\contentsline {subsection}{\numberline {37.4}Sets set<T, comp> <set>}{161}{subsection.0.37.4}%
\contentsline {subsection}{\numberline {37.5}Maps map<T,T, comp> <map>}{161}{subsection.0.37.5}%
\contentsline {section}{\numberline {38}Variadic Functions in C++ (Ellipsis)}{162}{section.0.38}%
\contentsline {section}{\numberline {39}std::function<type(args)> <functional>}{163}{section.0.39}%
\contentsline {section}{\numberline {40}Initializer List as function parameters}{164}{section.0.40}%
\contentsline {section}{\numberline {41}Functions as parameters}{165}{section.0.41}%
\contentsline {subsection}{\numberline {41.1}Function Pointers:}{165}{subsection.0.41.1}%
\contentsline {subsection}{\numberline {41.2}Regular function pointers}{166}{subsection.0.41.2}%
\contentsline {section}{\numberline {42}Typedefs}{167}{section.0.42}%
\contentsline {subsection}{\numberline {42.1}Basic Typedefs}{167}{subsection.0.42.1}%
\contentsline {subsubsection}{\numberline {42.1.1}Example}{167}{subsubsection.0.42.1.1}%
\contentsline {subsection}{\numberline {42.2}Applications of typedef in C++}{167}{subsection.0.42.2}%
\contentsline {subsection}{\numberline {42.3}Using typedef with arrays}{167}{subsection.0.42.3}%
\contentsline {subsubsection}{\numberline {42.3.1}Example}{167}{subsubsection.0.42.3.1}%
\contentsline {subsection}{\numberline {42.4}Using typedef with pointers}{168}{subsection.0.42.4}%
\contentsline {subsubsection}{\numberline {42.4.1}Example:}{168}{subsubsection.0.42.4.1}%
\contentsline {subsection}{\numberline {42.5}Using typedef with function pointers}{168}{subsection.0.42.5}%
\contentsline {subsubsection}{\numberline {42.5.1}Example}{168}{subsubsection.0.42.5.1}%
\contentsline {section}{\numberline {43}Buffers in C++}{169}{section.0.43}%
\contentsline {subsection}{\numberline {43.1}Types of buffers}{169}{subsection.0.43.1}%
\contentsline {subsubsection}{\numberline {43.1.1}Stack-based buffers}{169}{subsubsection.0.43.1.1}%
\contentsline {subsubsection}{\numberline {43.1.2}Heap-based Buffers}{169}{subsubsection.0.43.1.2}%
\contentsline {subsubsection}{\numberline {43.1.3}Standard Library Containers}{169}{subsubsection.0.43.1.3}%
\contentsline {subsection}{\numberline {43.2}Usage in IO Operations}{170}{subsection.0.43.2}%
\contentsline {subsection}{\numberline {43.3}Buffer Overflow}{170}{subsection.0.43.3}%
\contentsline {subsection}{\numberline {43.4}Buffer operations}{170}{subsection.0.43.4}%
\contentsline {section}{\numberline {44}The Stack, Heap, Code Segment (Text Segment), and Data Segment (static memory)}{171}{section.0.44}%
\contentsline {subsection}{\numberline {44.1}The Stack}{171}{subsection.0.44.1}%
\contentsline {subsubsection}{\numberline {44.1.1}The Call Stack}{171}{subsubsection.0.44.1.1}%
\contentsline {subsection}{\numberline {44.2}How Many Stacks are There Per Program?}{171}{subsection.0.44.2}%
\contentsline {subsection}{\numberline {44.3}Stack Memory Management}{172}{subsection.0.44.3}%
\contentsline {subsection}{\numberline {44.4}Stack Overflow}{172}{subsection.0.44.4}%
\contentsline {subsection}{\numberline {44.5}What Lives on The Stack?}{172}{subsection.0.44.5}%
\contentsline {subsection}{\numberline {44.6}The Heap}{173}{subsection.0.44.6}%
\contentsline {subsubsection}{\numberline {44.6.1}Characteristics of the Heap}{173}{subsubsection.0.44.6.1}%
\contentsline {subsubsection}{\numberline {44.6.2}Usage}{173}{subsubsection.0.44.6.2}%
\contentsline {subsubsection}{\numberline {44.6.3}Heap Allocatinos in Function Bodys}{174}{subsubsection.0.44.6.3}%
\contentsline {subsection}{\numberline {44.7}The Code Segment (Text Segment)}{174}{subsection.0.44.7}%
\contentsline {subsection}{\numberline {44.8}The Data Segment}{174}{subsection.0.44.8}%
\contentsline {subsubsection}{\numberline {44.8.1}Initialized Data Segment}{174}{subsubsection.0.44.8.1}%
\contentsline {subsubsection}{\numberline {44.8.2}Uninitialized Data Segment}{174}{subsubsection.0.44.8.2}%
\contentsline {section}{\numberline {45}More on Dynamic Memory Allocation}{175}{section.0.45}%
\contentsline {subsection}{\numberline {45.1}Before we Begin: Memory Leaks}{175}{subsection.0.45.1}%
\contentsline {subsubsection}{\numberline {45.1.1}How Memory Leaks Occur}{175}{subsubsection.0.45.1.1}%
\contentsline {subsection}{\numberline {45.2}Malloc}{175}{subsection.0.45.2}%
\contentsline {subsubsection}{\numberline {45.2.1}Signature}{175}{subsubsection.0.45.2.1}%
\contentsline {subsubsection}{\numberline {45.2.2}Example}{176}{subsubsection.0.45.2.2}%
\contentsline {subsubsection}{\numberline {45.2.3}Characteristics}{176}{subsubsection.0.45.2.3}%
\contentsline {subsubsection}{\numberline {45.2.4}Considerations}{176}{subsubsection.0.45.2.4}%
\contentsline {subsection}{\numberline {45.3}Calloc}{177}{subsection.0.45.3}%
\contentsline {subsubsection}{\numberline {45.3.1}Signature}{177}{subsubsection.0.45.3.1}%
\contentsline {subsubsection}{\numberline {45.3.2}Example}{177}{subsubsection.0.45.3.2}%
\contentsline {subsubsection}{\numberline {45.3.3}Differences from malloc}{177}{subsubsection.0.45.3.3}%
\contentsline {subsection}{\numberline {45.4}Realloc}{177}{subsection.0.45.4}%
\contentsline {subsubsection}{\numberline {45.4.1}Signature}{178}{subsubsection.0.45.4.1}%
\contentsline {subsubsection}{\numberline {45.4.2}Example}{178}{subsubsection.0.45.4.2}%
\contentsline {subsection}{\numberline {45.5}Free}{178}{subsection.0.45.5}%
\contentsline {subsubsection}{\numberline {45.5.1}Signature}{178}{subsubsection.0.45.5.1}%
\contentsline {subsection}{\numberline {45.6}New}{179}{subsection.0.45.6}%
\contentsline {subsubsection}{\numberline {45.6.1}Syntax}{179}{subsubsection.0.45.6.1}%
\contentsline {subsubsection}{\numberline {45.6.2}Array allocation}{179}{subsubsection.0.45.6.2}%
\contentsline {subsubsection}{\numberline {45.6.3}Custom Constructor Parameters}{179}{subsubsection.0.45.6.3}%
\contentsline {subsubsection}{\numberline {45.6.4}Exception Handling (std::nothrow)}{179}{subsubsection.0.45.6.4}%
\contentsline {subsubsection}{\numberline {45.6.5}Placement New}{180}{subsubsection.0.45.6.5}%
\contentsline {subsection}{\numberline {45.7}Delete}{180}{subsection.0.45.7}%
\contentsline {subsubsection}{\numberline {45.7.1}Syntax}{180}{subsubsection.0.45.7.1}%
\contentsline {subsection}{\numberline {45.8}Dangling Pointers}{181}{subsection.0.45.8}%
\contentsline {subsection}{\numberline {45.9}Overloading new and delete}{182}{subsection.0.45.9}%
\contentsline {subsubsection}{\numberline {45.9.1}Why static?}{182}{subsubsection.0.45.9.1}%
\contentsline {subsubsection}{\numberline {45.9.2}The size\_t parameter in the new overload}{183}{subsubsection.0.45.9.2}%
\contentsline {subsection}{\numberline {45.10}Getting the size of dynamically allocated memory?}{183}{subsection.0.45.10}%
\contentsline {subsection}{\numberline {45.11}Mixing Memory Management Mechanism}{183}{subsection.0.45.11}%
\contentsline {subsubsection}{\numberline {45.11.1}Why Mixing Them is Bad}{183}{subsubsection.0.45.11.1}%
\contentsline {subsection}{\numberline {45.12}Should you be using malloc, calloc, realloc, or free in C++?}{183}{subsection.0.45.12}%
\contentsline {subsubsection}{\numberline {45.12.1}Constructor and Destructor Calls}{184}{subsubsection.0.45.12.1}%
\contentsline {subsubsection}{\numberline {45.12.2}Type Safety}{184}{subsubsection.0.45.12.2}%
\contentsline {subsubsection}{\numberline {45.12.3}Exception Handling}{184}{subsubsection.0.45.12.3}%
\contentsline {section}{\numberline {46}Other Casting Operators}{185}{section.0.46}%
\contentsline {subsection}{\numberline {46.1}dynamic\_cast}{185}{subsection.0.46.1}%
\contentsline {subsubsection}{\numberline {46.1.1}Purpose}{185}{subsubsection.0.46.1.1}%
\contentsline {subsubsection}{\numberline {46.1.2}Syntax}{185}{subsubsection.0.46.1.2}%
\contentsline {subsubsection}{\numberline {46.1.3}Requirements}{185}{subsubsection.0.46.1.3}%
\contentsline {subsubsection}{\numberline {46.1.4}Example}{185}{subsubsection.0.46.1.4}%
\contentsline {subsection}{\numberline {46.2}const\_cast}{186}{subsection.0.46.2}%
\contentsline {subsubsection}{\numberline {46.2.1}Removing const}{186}{subsubsection.0.46.2.1}%
\contentsline {subsubsection}{\numberline {46.2.2}Adding const}{186}{subsubsection.0.46.2.2}%
\contentsline {subsubsection}{\numberline {46.2.3}Use cases}{186}{subsubsection.0.46.2.3}%
\contentsline {subsubsection}{\numberline {46.2.4}Important Points}{187}{subsubsection.0.46.2.4}%
\contentsline {subsubsection}{\numberline {46.2.5}Example}{187}{subsubsection.0.46.2.5}%
\contentsline {subsubsection}{\numberline {46.2.6}When is it unsafe to use}{187}{subsubsection.0.46.2.6}%
\contentsline {subsubsection}{\numberline {46.2.7}The volatile keyword}{187}{subsubsection.0.46.2.7}%
\contentsline {subsubsection}{\numberline {46.2.8}Purpose}{187}{subsubsection.0.46.2.8}%
\contentsline {subsection}{\numberline {46.3}reinterpret\_cast}{188}{subsection.0.46.3}%
\contentsline {subsubsection}{\numberline {46.3.1}Key Characteristics}{188}{subsubsection.0.46.3.1}%
\contentsline {subsubsection}{\numberline {46.3.2}Syntax}{188}{subsubsection.0.46.3.2}%
\contentsline {subsubsection}{\numberline {46.3.3}Example}{188}{subsubsection.0.46.3.3}%
\contentsline {subsubsection}{\numberline {46.3.4}Considerations}{189}{subsubsection.0.46.3.4}%
\contentsline {section}{\numberline {47}Namespaces}{190}{section.0.47}%
\contentsline {subsection}{\numberline {47.1}Syntax}{190}{subsection.0.47.1}%
\contentsline {subsection}{\numberline {47.2}Using Namespaces}{190}{subsection.0.47.2}%
\contentsline {subsection}{\numberline {47.3}Nested Namespaces}{190}{subsection.0.47.3}%
\contentsline {subsection}{\numberline {47.4}Anonymous Namespaces}{191}{subsection.0.47.4}%
\contentsline {section}{\numberline {48}Exceptions}{192}{section.0.48}%
\contentsline {subsection}{\numberline {48.1}Concepts}{192}{subsection.0.48.1}%
\contentsline {subsection}{\numberline {48.2}Syntax}{192}{subsection.0.48.2}%
\contentsline {subsection}{\numberline {48.3}Example}{193}{subsection.0.48.3}%
\contentsline {subsection}{\numberline {48.4}Why does catch take a const reference?}{193}{subsection.0.48.4}%
\contentsline {subsubsection}{\numberline {48.4.1}Safety and Efficiency}{193}{subsubsection.0.48.4.1}%
\contentsline {subsubsection}{\numberline {48.4.2}Const Correctness}{193}{subsubsection.0.48.4.2}%
\contentsline {subsection}{\numberline {48.5}Catching any exception}{194}{subsection.0.48.5}%
\contentsline {subsection}{\numberline {48.6}cerr (standard error)}{194}{subsection.0.48.6}%
\contentsline {subsubsection}{\numberline {48.6.1}Unbuffered Output}{194}{subsubsection.0.48.6.1}%
\contentsline {subsection}{\numberline {48.7}The what() function}{194}{subsection.0.48.7}%
\contentsline {subsubsection}{\numberline {48.7.1}Signature}{194}{subsubsection.0.48.7.1}%
\contentsline {subsection}{\numberline {48.8}What can we throw/catch?}{194}{subsection.0.48.8}%
\contentsline {subsection}{\numberline {48.9}noexcept in function signatures}{195}{subsection.0.48.9}%
\contentsline {subsection}{\numberline {48.10}Syntax and Usage}{195}{subsection.0.48.10}%
\contentsline {subsection}{\numberline {48.11}Benefits}{195}{subsection.0.48.11}%
\contentsline {subsection}{\numberline {48.12}OOP Approach to exceptions (Custom exception class)}{196}{subsection.0.48.12}%
\contentsline {subsection}{\numberline {48.13}Unwinding the stack}{197}{subsection.0.48.13}%
\contentsline {subsection}{\numberline {48.14}More on 'new'}{197}{subsection.0.48.14}%
\contentsline {subsubsection}{\numberline {48.14.1}Handling bad\_alloc}{197}{subsubsection.0.48.14.1}%
\contentsline {subsubsection}{\numberline {48.14.2}nothrow}{197}{subsubsection.0.48.14.2}%
\contentsline {section}{\numberline {49}Templates}{198}{section.0.49}%
\contentsline {subsection}{\numberline {49.1}Function Templates}{198}{subsection.0.49.1}%
\contentsline {subsubsection}{\numberline {49.1.1}Syntax}{198}{subsubsection.0.49.1.1}%
\contentsline {subsubsection}{\numberline {49.1.2}Example}{198}{subsubsection.0.49.1.2}%
\contentsline {subsection}{\numberline {49.2}Class Templates}{199}{subsection.0.49.2}%
\contentsline {subsubsection}{\numberline {49.2.1}Example}{199}{subsubsection.0.49.2.1}%
\contentsline {subsection}{\numberline {49.3}Function Template Specialization}{200}{subsection.0.49.3}%
\contentsline {subsection}{\numberline {49.4}Class/Struct Template Specialization}{200}{subsection.0.49.4}%
\contentsline {subsection}{\numberline {49.5}Template Parameters}{200}{subsection.0.49.5}%
\contentsline {subsection}{\numberline {49.6}Trailing return type}{200}{subsection.0.49.6}%
\contentsline {subsubsection}{\numberline {49.6.1}Syntax}{201}{subsubsection.0.49.6.1}%
\contentsline {subsubsection}{\numberline {49.6.2}Example}{201}{subsubsection.0.49.6.2}%
\contentsline {subsection}{\numberline {49.7}decltype}{201}{subsection.0.49.7}%
\contentsline {subsubsection}{\numberline {49.7.1}Syntax}{201}{subsubsection.0.49.7.1}%
\contentsline {subsubsection}{\numberline {49.7.2}Example}{201}{subsubsection.0.49.7.2}%
\contentsline {subsection}{\numberline {49.8}Template functions with mixed types (Trailing return type)}{201}{subsection.0.49.8}%
\contentsline {subsection}{\numberline {49.9}Template functions with mixed types (Deduced return type)}{203}{subsection.0.49.9}%
\contentsline {subsection}{\numberline {49.10}The use of 'static' in template programming}{203}{subsection.0.49.10}%
\contentsline {subsubsection}{\numberline {49.10.1}Declaring and Defining Static Members in a Template Class}{203}{subsubsection.0.49.10.1}%
\contentsline {subsubsection}{\numberline {49.10.2}Key points}{204}{subsubsection.0.49.10.2}%
\contentsline {subsection}{\numberline {49.11}Non-Type Template Parameters}{204}{subsection.0.49.11}%
\contentsline {subsubsection}{\numberline {49.11.1}Array sizes}{204}{subsubsection.0.49.11.1}%
\contentsline {subsubsection}{\numberline {49.11.2}Compile-Time Calculations}{205}{subsubsection.0.49.11.2}%
\contentsline {section}{\numberline {50}Elementary compile time computations}{206}{section.0.50}%
\contentsline {section}{\numberline {51}Linkage}{207}{section.0.51}%
\contentsline {subsection}{\numberline {51.1}Basics}{207}{subsection.0.51.1}%
\contentsline {subsection}{\numberline {51.2}Declaration vs. Definition}{207}{subsection.0.51.2}%
\contentsline {subsubsection}{\numberline {51.2.1}Variables}{207}{subsubsection.0.51.2.1}%
\contentsline {subsection}{\numberline {51.3}Forward Declaring}{208}{subsection.0.51.3}%
\contentsline {subsubsection}{\numberline {51.3.1}Example}{208}{subsubsection.0.51.3.1}%
\contentsline {subsubsection}{\numberline {51.3.2}Usage Frequency}{208}{subsubsection.0.51.3.2}%
\contentsline {subsection}{\numberline {51.4}Translation Units}{209}{subsection.0.51.4}%
\contentsline {subsection}{\numberline {51.5}Linkage}{209}{subsection.0.51.5}%
\contentsline {subsection}{\numberline {51.6}External Linkage}{209}{subsection.0.51.6}%
\contentsline {subsubsection}{\numberline {51.6.1}Usage}{210}{subsubsection.0.51.6.1}%
\contentsline {subsection}{\numberline {51.7}Internal Linkage}{210}{subsection.0.51.7}%
\contentsline {subsubsection}{\numberline {51.7.1}Example}{211}{subsubsection.0.51.7.1}%
\contentsline {section}{\numberline {52}Extra Information}{212}{section.0.52}%
\contentsline {subsection}{\numberline {52.1}constexpr}{212}{subsection.0.52.1}%
\contentsline {subsection}{\numberline {52.2}consteval}{212}{subsection.0.52.2}%
\contentsline {subsection}{\numberline {52.3}constinit}{212}{subsection.0.52.3}%
\contentsline {subsection}{\numberline {52.4}More on 'inline'}{212}{subsection.0.52.4}%
\contentsline {subsection}{\numberline {52.5}Measuring the speed of C++ programs}{212}{subsection.0.52.5}%
