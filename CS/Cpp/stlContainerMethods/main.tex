\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Stl Container Methods}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Stl Container Methods}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Vectors}
     \bigbreak \noindent 
    \subsection{Nonmodifying Operations}
    \bigbreak \noindent 
\begin{itemize}
    \item \texttt{c.empty()} \\
          Returns whether the container is empty (equivalent to \texttt{size()} == 0 but might be faster).
          
    \item \texttt{c.size()} \\
          Returns the current number of elements.
          
    \item \texttt{c.max\_size()} \\
          Returns the maximum number of elements possible.
          
    \item \texttt{c.capacity()} \\
          Returns the maximum possible number of elements without reallocation.
          
    \item \texttt{c.reserve(num)} \\
          Enlarges capacity, if not enough yet\textsuperscript{6}.
          
    \item \texttt{c.shrink\_to\_fit()} \\
          Requests to reduce capacity to fit the number of elements (since C++11)\textsuperscript{6}.
          
    \item \texttt{c1 == c2} \\
          Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements).
          
    \item \texttt{c1 != c2} \\
          Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1 == c2)}).
          
    \item \texttt{c1 < c2} \\
          Returns whether \texttt{c1} is less than \texttt{c2}.
          
    \item \texttt{c1 > c2} \\
          Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2 < c1}).
          
    \item \texttt{c1 <= c2} \\
          Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2 < c1)}).
          
    \item \texttt{c1 >= c2} \\
          Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1 < c2)}).
\end{itemize}

\pagebreak 
\subsection{Assignments}
\begin{itemize}
    \item \texttt{c = c2} \\
          Assigns all elements of \texttt{c2} to \texttt{c}.
          
    \item \texttt{c = rv} \\
          Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11).
          
    \item \texttt{c = initlist} \\
          Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11).
          
    \item \texttt{c.assign(n, elem)} \\
          Assigns \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{c.assign(beg, end)} \\
          Assigns the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{c.assign(initlist)} \\
          Assigns all the elements of the initializer list \texttt{initlist}.
          
    \item \texttt{c1.swap(c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
          
    \item \texttt{swap(c1, c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
\end{itemize}

\bigbreak \noindent 
\subsection{Element access}
\begin{itemize}
    \item \texttt{c[idx]} \\
          Returns the element with index \texttt{idx} \textit{(no range checking)}.
          
    \item \texttt{c.at(idx)} \\
          Returns the element with index \texttt{idx} \textit{(throws range-error exception if \texttt{idx} is out of range)}.
          
    \item \texttt{c.front()} \\
          Returns the first element \textit{(no check whether a first element exists)}.
          
    \item \texttt{c.back()} \\
          Returns the last element \textit{(no check whether a last element exists)}.
\end{itemize}

\pagebreak 
\subsection{Inserting and Removing Elements}
\begin{itemize}
    \item \texttt{c.push\_back(elem)} \\
          Appends a copy of \texttt{elem} at the end.
          
    \item \texttt{c.pop\_back()} \\
          Removes the last element (does not return it).
    \item \texttt{c.insert(pos, elem)} \\
          Inserts a copy of \texttt{elem} before iterator position \texttt{pos} and returns the position of the new element.
          
    \item \texttt{c.insert(pos, n, elem)} \\
          Inserts \texttt{n} copies of \texttt{elem} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, beg, end)} \\
          Inserts a copy of all elements of the range [\texttt{beg, end}] before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, initlist)} \\
          Inserts a copy of all elements of the initializer list \texttt{initlist} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element; since C++11).
          
    \item \texttt{c.emplace(pos, args...)} \\
          Inserts a copy of an element initialized with \texttt{args} before iterator position \texttt{pos} and returns the position of the new element (since C++11).
          
    \item \texttt{c.emplace\_back(args...)} \\
          Appends a copy of an element initialized with \texttt{args} at the end (returns nothing; since C++11).
          
    \item \texttt{c.erase(pos)} \\
          Removes the element at iterator position \texttt{pos} and returns the position of the next element.
          
    \item \texttt{c.erase(beg, end)} \\
          Removes all elements of the range [\texttt{beg, end}] and returns the position of the next element.
          
    \item \texttt{c.resize(num)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are created by their default constructor).
          
    \item \texttt{c.resize(num, elem)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are copies of \texttt{elem}).
          
    \item \texttt{c.clear()} \\
          Removes all elements (empties the container).
\end{itemize}

\pagebreak 
\unsect{Deque}
\bigbreak \noindent 
    \subsection{Nonmodifying Operations}
    \bigbreak \noindent 
\begin{itemize}
    \item \texttt{c.empty()} \\
          Returns whether the container is empty (equivalent to \texttt{size()} == 0 but might be faster).
          
    \item \texttt{c.size()} \\
          Returns the current number of elements.
          
    \item \texttt{c.max\_size()} \\
          Returns the maximum number of elements possible.
          
    \item \texttt{c.shrink\_to\_fit()} \\
          Requests to reduce capacity to fit the number of elements (since C++11)\textsuperscript{6}.
          
    \item \texttt{c1 == c2} \\
          Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements).
          
    \item \texttt{c1 != c2} \\
          Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1 == c2)}).
          
    \item \texttt{c1 < c2} \\
          Returns whether \texttt{c1} is less than \texttt{c2}.
          
    \item \texttt{c1 > c2} \\
          Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2 < c1}).
          
    \item \texttt{c1 <= c2} \\
          Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2 < c1)}).
          
    \item \texttt{c1 >= c2} \\
          Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1 < c2)}).
\end{itemize}

\pagebreak 
\subsection{Assignments}
\begin{itemize}
    \item \texttt{c = c2} \\
          Assigns all elements of \texttt{c2} to \texttt{c}.
          
    \item \texttt{c = rv} \\
          Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11).
          
    \item \texttt{c = initlist} \\
          Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11).
          
    \item \texttt{c.assign(n, elem)} \\
          Assigns \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{c.assign(beg, end)} \\
          Assigns the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{c.assign(initlist)} \\
          Assigns all the elements of the initializer list \texttt{initlist}.
          
    \item \texttt{c1.swap(c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
          
    \item \texttt{swap(c1, c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
\end{itemize}

\bigbreak \noindent 
\subsection{Element access}
\begin{itemize}
    \item \texttt{c[idx]} \\
          Returns the element with index \texttt{idx} \textit{(no range checking)}.
          
    \item \texttt{c.at(idx)} \\
          Returns the element with index \texttt{idx} \textit{(throws range-error exception if \texttt{idx} is out of range)}.
          
    \item \texttt{c.front()} \\
          Returns the first element \textit{(no check whether a first element exists)}.
          
    \item \texttt{c.back()} \\
          Returns the last element \textit{(no check whether a last element exists)}.
\end{itemize}

\pagebreak 
\subsection{Inserting and Removing Elements}
\begin{itemize}
    \item \texttt{c.push\_back(elem)} \\
          Appends a copy of \texttt{elem} at the end.
          
    \item \texttt{c.pop\_back()} \\
          Removes the last element (does not return it).
          
              
  \item \texttt{c.push\_front()}
                Appends a copy of \texttt{elem} at the front.

  \item \texttt{c.pop\_front()}
        Removes the first element (does not return it).

    \item \texttt{c.insert(pos, elem)} \\
          Inserts a copy of \texttt{elem} before iterator position \texttt{pos} and returns the position of the new element.

          
    \item \texttt{c.insert(pos, n, elem)} \\
          Inserts \texttt{n} copies of \texttt{elem} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, beg, end)} \\
          Inserts a copy of all elements of the range [\texttt{beg, end}] before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, initlist)} \\
          Inserts a copy of all elements of the initializer list \texttt{initlist} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element; since C++11).
          
    \item \texttt{c.emplace(pos, args...)} \\
          Inserts a copy of an element initialized with \texttt{args} before iterator position \texttt{pos} and returns the position of the new element (since C++11).
          
    \item \texttt{c.emplace\_back(args...)} \\
          Appends a copy of an element initialized with \texttt{args} at the end (returns nothing; since C++11).
          
    \item \texttt{c.erase(pos)} \\
          Removes the element at iterator position \texttt{pos} and returns the position of the next element.
          
    \item \texttt{c.erase(beg, end)} \\
          Removes all elements of the range [\texttt{beg, end}] and returns the position of the next element.
          
    \item \texttt{c.resize(num)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are created by their default constructor).
          
    \item \texttt{c.resize(num, elem)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are copies of \texttt{elem}).
          
    \item \texttt{c.clear()} \\
          Removes all elements (empties the container).
\end{itemize}

\pagebreak 
\unsect{Lists}
\bigbreak \noindent 
\subsection{Nonmod}
\begin{itemize}
    \item \texttt{c.empty()} \\
          Returns whether the container is empty (equivalent to \texttt{size()} == 0 but might be faster).
          
    \item \texttt{c.size()} \\
          Returns the current number of elements.
          
    \item \texttt{c.max\_size()} \\
          Returns the maximum number of elements possible.
          
    \item \texttt{c1 == c2} \\
          Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements).
          
    \item \texttt{c1 != c2} \\
          Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1 == c2)}).
          
    \item \texttt{c1 < c2} \\
          Returns whether \texttt{c1} is less than \texttt{c2}.
          
    \item \texttt{c1 > c2} \\
          Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2 < c1}).
          
    \item \texttt{c1 <= c2} \\
          Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2 < c1)}).
          
    \item \texttt{c1 >= c2} \\
          Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1 < c2)}).
      \end{itemize}

      \pagebreak 
      \subsection{Assignment}
\begin{itemize}
    \item \texttt{c = c2} \\
          Assigns all elements of \texttt{c2} to \texttt{c}.
          
    \item \texttt{c = rv} \\
          Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11).
          
    \item \texttt{c = initlist} \\
          Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11).
          
    \item \texttt{c.assign(n, elem)} \\
          Assigns \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{c.assign(beg, end)} \\
          Assigns the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{c.assign(initlist)} \\
          Assigns all the elements of the initializer list \texttt{initlist}.
          
    \item \texttt{c1.swap(c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
          
    \item \texttt{swap(c1, c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
\end{itemize}

\pagebreak 
\subsection{Element access}
\begin{itemize}
    \item \texttt{c.front()}: No check whether the element exists
    \item \texttt{c.back()}: No check whether the element exists
\end{itemize}

\pagebreak 
\subsection{Insert and Remove}
\begin{itemize}
    \item \texttt{c.push\_back(elem)} \\
    Appends a copy of \texttt{elem} at the end.
    
    \item \texttt{c.pop\_back()} \\
    Removes the last element (does not return it).
    
    \item \texttt{c.push\_front(elem)} \\
    Inserts a copy of \texttt{elem} at the beginning.
    
    \item \texttt{c.pop\_front()} \\
    Removes the first element (does not return it).
    
    \item \texttt{c.insert(pos, elem)} \\
    Inserts a copy of \texttt{elem} before iterator position \texttt{pos} and returns the position of the new element.
    
    \item \texttt{c.insert(pos, n, elem)} \\
    Inserts \texttt{n} copies of \texttt{elem} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
    
    \item \texttt{c.insert(pos, beg, end)} \\
    Inserts a copy of all elements of the range \texttt{[beg, end]} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
    
    \item \texttt{c.insert(pos, inilist)} \\
    Inserts a copy of all elements of the initializer list \texttt{inilist} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element; since C++11).
    
    \item \texttt{c.emplace(pos, args...)} \\
    Inserts a copy of an element initialized with \texttt{args} before iterator position \texttt{pos} and returns the position of the new element (since C++11).
    
    \item \texttt{c.emplace\_back(args...)} \\
    Appends a copy of an element initialized with \texttt{args} at the end (returns nothing; since C++11).
    
    \item \texttt{c.emplace\_front(args...)} \\
    Inserts a copy of an element initialized with \texttt{args} at the beginning (returns nothing; since C++11).
    
    \item \texttt{c.erase(pos)} \\
    Removes the element at iterator position \texttt{pos} and returns the position of the next element.
    
    \item \texttt{c.erase(beg, end)} \\
    Removes all elements of the range \texttt{[beg, end]} and returns the position of the next element.
    
    \item \texttt{c.remove(val)} \\
    Removes all elements with value \texttt{val}.
    
    \item \texttt{c.remove\_if(op)} \\
    Removes all elements for which \texttt{op(elem)} yields \texttt{true}.
    
    \item \texttt{c.resize(num)} \\
    Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are created by their default constructor).
    
    \item \texttt{c.resize(num, elem)} \\
    Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are copies of \texttt{elem}).
    
    \item \texttt{c.clear()} \\
    Removes all elements (empties the container).
\end{itemize}

\pagebreak 
\subsection{Special Modifying Operations for Lists}
\begin{itemize}
    \item \texttt{c.unique()} \\
    Removes duplicates of consecutive elements with the same value.
    
    \item \texttt{c.unique(op)} \\
    Removes duplicates of consecutive elements, for which \texttt{op()} yields \texttt{true}.
    
    \item \texttt{c.splice(pos, c2)} \\
    Moves all elements of \texttt{c2} to \texttt{c} in front of the iterator position \texttt{pos}.
    
    \item \texttt{c.splice(pos, c2, c2pos)} \\
    Moves the element at \texttt{c2pos} in \texttt{c2} in front of \texttt{pos} of list \texttt{c} (\texttt{c} and \texttt{c2} may be identical).
    
    \item \texttt{c.splice(pos, c2, c2beg, c2end)} \\
    Moves all elements of the range \texttt{[c2beg, c2end)} in \texttt{c2} in front of \texttt{pos} of list \texttt{c} (\texttt{c} and \texttt{c2} may be identical).
    
    \item \texttt{c.sort()} \\
    Sorts all elements with operator \texttt{<}.
    
    \item \texttt{c.sort(op)} \\
    Sorts all elements with \texttt{op()}.
    
    \item \texttt{c.merge(c2)} \\
    Assuming that both containers contain the elements sorted, moves all elements of \texttt{c2} into \texttt{c} so that all elements are merged and still sorted.
    
    \item \texttt{c.merge(c2, op)} \\
    Assuming that both containers contain the elements sorted due to the sorting criterion \texttt{op()}, moves all elements of \texttt{c2} into \texttt{c} so that all elements are merged and still sorted according to \texttt{op()}.
    
    \item \texttt{c.reverse()} \\
    Reverses the order of all elements.
\end{itemize}

\bigbreak \noindent 
\subsection{Sorting}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{c.sort()}: Sorts the list
\end{itemize}

\pagebreak 
\unsect{Forward\_list}
\bigbreak \noindent 
\subsection{Non Modifying Operations}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{c.empty()} Returns whether the container is empty
    \item \texttt{c.max\_size()} Returns the maximum number of elements possible
    \item \texttt{c1 == c2} Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements)
    \item \texttt{c1 != c2} Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1==c2)})
    \item \texttt{c1 < c2} Returns whether \texttt{c1} is less than \texttt{c2}
    \item \texttt{c1 > c2} Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2<c1})
    \item \texttt{c1 <= c2} Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2<c1)})
    \item \texttt{c1 >= c2} Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1<c2)})
\end{itemize}

\bigbreak \noindent 
\subsection{Assignments}
\begin{itemize}
    \item \texttt{c = c2} Assigns all elements of \texttt{c2} to \texttt{c}
    \item \texttt{c = rv} Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11)
    \item \texttt{c = initlist} Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11)
    \item \texttt{c.assign(n,elem)} Assigns \texttt{n} copies of element \texttt{elem}
    \item \texttt{c.assign(beg,end)} Assigns the elements of the range \texttt{[beg,end)}
    \item \texttt{c.assign(initlist)} Assigns all the elements of the initializer list \texttt{initlist}
    \item \texttt{c1.swap(c2)} Swaps the data of \texttt{c1} and \texttt{c2}
    \item \texttt{swap(c1,c2)} Swaps the data of \texttt{c1} and \texttt{c2}
\end{itemize}
\bigbreak \noindent 
\subsection{Element access}
\begin{itemize}
    \item \textbf{c.front()}: Returns the first element (no check whether a first element exists)
\end{itemize}

\bigbreak \noindent 
\subsection{Iterator functions}
\begin{itemize}
    \item \texttt{c.begin()} Returns a bidirectional iterator for the first element
    \item \texttt{c.end()} Returns a bidirectional iterator for the position after the last element
    \item \texttt{c.cbegin()} Returns a constant bidirectional iterator for the first element (since C++11)
    \item \texttt{c.cend()} Returns a constant bidirectional iterator for the position after the last element (since C++11)
    \item \texttt{c.before\_begin()} Returns a forward iterator for the position before the first element
    \item \texttt{c.cbefore\_begin()} Returns a constant forward iterator for the position before the first element
\end{itemize}

\bigbreak \noindent 
\subsection{Insert and Remove}
\begin{itemize}
    \item \texttt{c.push\_front(elem)} Inserts a copy of \texttt{elem} at the beginning
    \item \texttt{c.pop\_front()} Removes the first element (does not return it)
    \item \texttt{c.insert\_after(pos,elem)} Inserts a copy of \texttt{elem} after iterator position \texttt{pos} and returns the position of the new element
    \item \texttt{c.insert\_after(pos,n,elem)} Inserts \texttt{n} copies of \texttt{elem} after iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element)
    \item \texttt{c.insert\_after(pos,beg,end)} Inserts a copy of all elements of the range \texttt{[beg,end)} after iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element)
    \item \texttt{c.insert\_after(pos,initlist)} Inserts a copy of all elements of the initializer list \texttt{initlist} after iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element)
    \item \texttt{c.emplace\_after(pos,args...)} Inserts a copy of an element initialized with \texttt{args} after iterator position \texttt{pos} and returns the position of the new element (since C++11)
    \item \texttt{c.emplace\_front(args...)} Inserts a copy of an element initialized with \texttt{args} at the beginning (returns nothing; since C++11)
    \item \texttt{c.erase\_after(pos)} Removes the element after iterator position \texttt{pos} (returns nothing)
    \item \texttt{c.erase\_after(beg,end)} Removes all elements of the range \texttt{[beg,end)} (returns nothing)
    \item \texttt{c.remove(val)} Removes all elements with value \texttt{val}
    \item \texttt{c.remove\_if(op)} Removes all elements for which \texttt{op(elem)} yields \texttt{true}
    \item \texttt{c.resize(num)} Changes the number of elements to \texttt{num} (if size grows, new elements are created by their default constructor)
    \item \texttt{c.resize(num,elem)} Changes the number of elements to \texttt{num} (if size grows, new elements are copies of \texttt{elem})
    \item \texttt{c.clear()} Removes all elements (empties the container)
\end{itemize}

\bigbreak \noindent 
\subsection{Special Modifying}
\begin{itemize}
    \item \texttt{c.unique()} Removes duplicates of consecutive elements with the same value
    \item \texttt{c.unique(op)} Removes duplicates of consecutive elements, for which \texttt{op()} yields true
    \item \texttt{c.splice\_after(pos,c2)} Moves all elements of \texttt{c2} to \texttt{c} right behind the iterator position \texttt{pos}
    \item \texttt{c.splice\_after(pos,c2,c2pos)} Moves the element behind \texttt{c2pos} in \texttt{c2} right after \texttt{pos} of forward list \texttt{c} (\texttt{c} and \texttt{c2} may be identical)
    \item \texttt{c.splice\_after(pos,c2,c2beg,c2end)} Moves all elements between \texttt{c2beg} and \texttt{c2end} (both not included) in \texttt{c2} right after \texttt{pos} of forward list \texttt{c} (\texttt{c} and \texttt{c2} may be identical)
    \item \texttt{c.sort()} Sorts all elements with \texttt{operator<}
    \item \texttt{c.sort(op)} Sorts all elements with \texttt{op()}
    \item \texttt{c.merge(c2)} Assuming that both containers contain the elements sorted, moves all elements of \texttt{c2} into \texttt{c} so that all elements are merged and still sorted
    \item \texttt{c.merge(c2,op)} Assuming that both containers contain the elements sorted by the sorting criterion \texttt{op()}, moves all elements of \texttt{c2} into \texttt{c} so that all elements are merged and still sorted according to \texttt{op()}
    \item \texttt{c.reverse()} Reverses the order of all elements
\end{itemize}

\pagebreak 
\unsect{Sets and multisets}
\bigbreak \noindent 
\subsection{Assignments}
\begin{itemize}
    \item \texttt{c = c2} Assigns all elements of \texttt{c2} to \texttt{c}
    \item \texttt{c = rv} Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11)
    \item \texttt{c = initlist} Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11)
    \item \texttt{c1.swap(c2)} Swaps the data of \texttt{c1} and \texttt{c2}
    \item \texttt{swap(c1,c2)} Swaps the data of \texttt{c1} and \texttt{c2}
\end{itemize}


\bigbreak \noindent 
\subsection{Non Modifying}
\begin{itemize}
    \item \texttt{c.key\_comp()} Returns the comparison criterion
    \item \texttt{c.value\_comp()} Returns the comparison criterion for values as a whole (same as \texttt{key\_comp()})
    \item \texttt{c.empty()} Returns whether the container is empty (equivalent to \texttt{size()==0} but might be faster)
    \item \texttt{c.size()} Returns the current number of elements
    \item \texttt{c.max\_size()} Returns the maximum number of elements possible
    \item \texttt{c1 == c2} Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements)
    \item \texttt{c1 != c2} Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1==c2)})
    \item \texttt{c1 < c2} Returns whether \texttt{c1} is less than \texttt{c2}
    \item \texttt{c1 > c2} Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2<c1})
    \item \texttt{c1 <= c2} Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2<c1)})
    \item \texttt{c1 >= c2} Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1<c2)})
\end{itemize}
\bigbreak \noindent 
\subsection{Search operations}
\begin{itemize}
    \item \texttt{c.count(val)} Returns the number of elements with value \texttt{val}
    \item \texttt{c.find(val)} Returns the position of the first element with value \texttt{val} (or \texttt{end()} if none found)
    \item \texttt{c.lower\_bound(val)} Returns the first position where \texttt{val} would get inserted (the first element \texttt{>= val})
    \item \texttt{c.upper\_bound(val)} Returns the last position where \texttt{val} would get inserted (the first element \texttt{> val})
    \item \texttt{c.equal\_range(val)} Returns a range with all elements with a value equal to \texttt{val} (i.e., the first and last position where \texttt{val} would get inserted)
\end{itemize}

\bigbreak \noindent 
\subsection{Iterator functions}
\begin{itemize}
    \item \texttt{c.begin()} Returns a bidirectional iterator for the first element
    \item \texttt{c.end()} Returns a bidirectional iterator for the position after the last element
    \item \texttt{c.cbegin()} Returns a constant bidirectional iterator for the first element (since C++11)
    \item \texttt{c.cend()} Returns a constant bidirectional iterator for the position after the last element (since C++11)
    \item \texttt{c.rbegin()} Returns a reverse iterator for the first element of a reverse iteration
    \item \texttt{c.rend()} Returns a reverse iterator for the position after the last element of a reverse iteration
    \item \texttt{c.crbegin()} Returns a constant reverse iterator for the first element of a reverse iteration (since C++11)
    \item \texttt{c.crend()} Returns a constant reverse iterator for the position after the last element of a reverse iteration (since C++11)
\end{itemize}

\bigbreak \noindent 
\subsection{Search and remove}
\begin{itemize}
    \item \texttt{c.insert(val)} Inserts a copy of \texttt{val} and returns the position of the new element and, for sets, whether it succeeded
    \item \texttt{c.insert(pos,val)} Inserts a copy of \texttt{val} and returns the position of the new element (\texttt{pos} is used as a hint pointing to where the insert should start the search)
    \item \texttt{c.insert(beg,end)} Inserts a copy of all elements of the range \texttt{[beg,end)} (returns nothing)
    \item \texttt{c.insert(initlist)} Inserts a copy of all elements in the initializer list \texttt{initlist} (returns nothing; since C++11)
    \item \texttt{c.emplace(args...)} Inserts a copy of an element initialized with \texttt{args} and returns the position of the new element and, for sets, whether it succeeded (since C++11)
    \item \texttt{c.emplace\_hint(pos,args...)} Inserts a copy of an element initialized with \texttt{args} and returns the position of the new element (\texttt{pos} is used as a hint pointing to where the insert should start the search)
    \item \texttt{c.erase(val)} Removes all elements equal to \texttt{val} and returns the number of removed elements
    \item \texttt{c.erase(pos)} Removes the element at iterator position \texttt{pos} and returns the following position (returned nothing before C++11)
    \item \texttt{c.erase(beg,end)} Removes all elements of the range \texttt{[beg,end)} and returns the following position (returned nothing before C++11)
    \item \texttt{c.clear()} Removes all elements (empties the container)
\end{itemize}

\pagebreak 
\unsect{Maps and multimaps}
\subsection{Assignments}
\begin{itemize}
    \item \texttt{c = c2} Assigns all elements of \texttt{c2} to \texttt{c}
    \item \texttt{c = rv} Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11)
    \item \texttt{c = initlist} Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11)
    \item \texttt{c1.swap(c2)} Swaps the data of \texttt{c1} and \texttt{c2}
    \item \texttt{swap(c1,c2)} Swaps the data of \texttt{c1} and \texttt{c2}
\end{itemize}


\bigbreak \noindent
\subsection{Non Modifying operations}
\begin{itemize}
    \item \texttt{c.key\_comp()} Returns the comparison criterion
    \item \texttt{c.value\_comp()} Returns the comparison criterion for values as a whole (an object that compares the key in a key/value pair)
    \item \texttt{c.empty()} Returns whether the container is empty (equivalent to \texttt{size()==0} but might be faster)
    \item \texttt{c.size()} Returns the current number of elements
    \item \texttt{c.max\_size()} Returns the maximum number of elements possible
    \item \texttt{c1 == c2} Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements)
    \item \texttt{c1 != c2} Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1==c2)})
    \item \texttt{c1 < c2} Returns whether \texttt{c1} is less than \texttt{c2}
    \item \texttt{c1 > c2} Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2<c1})
    \item \texttt{c1 <= c2} Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2<c1)})
    \item \texttt{c1 >= c2} Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1<c2)})
\end{itemize}

\bigbreak \noindent 
\subsection{Search operations}
\begin{itemize}
    \item \texttt{c.count(val)} Returns the number of elements with key \texttt{val}
    \item \texttt{c.find(val)} Returns the position of the first element with key \texttt{val} (or \texttt{end()} if none found)
    \item \texttt{c.lower\_bound(val)} Returns the first position where an element with key \texttt{val} would get inserted (the first element with a key \texttt{>= val})
    \item \texttt{c.upper\_bound(val)} Returns the last position where an element with key \texttt{val} would get inserted (the first element with a key \texttt{> val})
    \item \texttt{c.equal\_range(val)} Returns a range with all elements with a key equal to \texttt{val} (i.e., the first and last positions where an element with key \texttt{val} would get inserted)
\end{itemize}
\bigbreak \noindent 
\subsection{Iterator functions}
\begin{itemize}
    \item \texttt{c.begin()} Returns a bidirectional iterator for the first element
    \item \texttt{c.end()} Returns a bidirectional iterator for the position after the last element
    \item \texttt{c.cbegin()} Returns a constant bidirectional iterator for the first element (since C++11)
    \item \texttt{c.cend()} Returns a constant bidirectional iterator for the position after the last element (since C++11)
    \item \texttt{c.rbegin()} Returns a reverse iterator for the first element of a reverse iteration
    \item \texttt{c.rend()} Returns a reverse iterator for the position after the last element of a reverse iteration
    \item \texttt{c.crbegin()} Returns a constant reverse iterator for the first element of a reverse iteration (since C++11)
    \item \texttt{c.crend()} Returns a constant reverse iterator for the position after the last element of a reverse iteration (since C++11)
\end{itemize}

\bigbreak \noindent 
\subsection{Insert and remove}
\begin{itemize}
    \item \texttt{c.insert(val)} Inserts a copy of \texttt{val} and returns the position of the new element and, for maps, whether it succeeded
    \item \texttt{c.insert(pos,val)} Inserts a copy of \texttt{val} and returns the position of the new element (\texttt{pos} is used as a hint pointing to where the insert should start the search)
    \item \texttt{c.insert(beg,end)} Inserts a copy of all elements of the range \texttt{[beg,end)} (returns nothing)
    \item \texttt{c.insert(initlist)} Inserts a copy of all elements in the initializer list \texttt{initlist} (returns nothing; since C++11)
    \item \texttt{c.emplace(args...)} Inserts a copy of an element initialized with \texttt{args} and returns the position of the new element and, for maps, whether it succeeded (since C++11)
    \item \texttt{c.emplace\_hint(pos,args...)} Inserts a copy of an element initialized with \texttt{args} and returns the position of the new element (\texttt{pos} is used as a hint pointing to where the insert should start the search)
    \item \texttt{c.erase(val)} Removes all elements equal to \texttt{val} and returns the number of removed elements
    \item \texttt{c.erase(pos)} Removes the element at iterator position \texttt{pos} and returns the following position (returned nothing before C++11)
    \item \texttt{c.erase(beg,end)} Removes all elements of the range \texttt{[beg,end)} and returns the following position (returned nothing before C++11)
    \item \texttt{c.clear()} Removes all elements (empties the container)
\end{itemize}

\bigbreak \noindent 
\subsection{Element access}
\begin{itemize}
    \item \texttt{c[key]} Inserts an element with key, if it does not yet exist, and returns a reference to the value of the element with key (only for nonconstant maps)
    \item \texttt{c.at(key)} Returns a reference to the value of the element with key (since C++11)
\end{itemize}



























\end{document}
