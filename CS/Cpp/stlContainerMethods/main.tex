\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Stl Container Methods}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Stl Container Methods}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Vectors}
     \bigbreak \noindent 
    \subsection{Nonmodifying Operations}
    \bigbreak \noindent 
\begin{itemize}
    \item \texttt{c.empty()} \\
          Returns whether the container is empty (equivalent to \texttt{size()} == 0 but might be faster).
          
    \item \texttt{c.size()} \\
          Returns the current number of elements.
          
    \item \texttt{c.max\_size()} \\
          Returns the maximum number of elements possible.
          
    \item \texttt{c.capacity()} \\
          Returns the maximum possible number of elements without reallocation.
          
    \item \texttt{c.reserve(num)} \\
          Enlarges capacity, if not enough yet\textsuperscript{6}.
          
    \item \texttt{c.shrink\_to\_fit()} \\
          Requests to reduce capacity to fit the number of elements (since C++11)\textsuperscript{6}.
          
    \item \texttt{c1 == c2} \\
          Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements).
          
    \item \texttt{c1 != c2} \\
          Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1 == c2)}).
          
    \item \texttt{c1 < c2} \\
          Returns whether \texttt{c1} is less than \texttt{c2}.
          
    \item \texttt{c1 > c2} \\
          Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2 < c1}).
          
    \item \texttt{c1 <= c2} \\
          Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2 < c1)}).
          
    \item \texttt{c1 >= c2} \\
          Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1 < c2)}).
\end{itemize}

\pagebreak 
\subsection{Assignments}
\begin{itemize}
    \item \texttt{c = c2} \\
          Assigns all elements of \texttt{c2} to \texttt{c}.
          
    \item \texttt{c = rv} \\
          Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11).
          
    \item \texttt{c = initlist} \\
          Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11).
          
    \item \texttt{c.assign(n, elem)} \\
          Assigns \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{c.assign(beg, end)} \\
          Assigns the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{c.assign(initlist)} \\
          Assigns all the elements of the initializer list \texttt{initlist}.
          
    \item \texttt{c1.swap(c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
          
    \item \texttt{swap(c1, c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
\end{itemize}

\bigbreak \noindent 
\subsection{Element access}
\begin{itemize}
    \item \texttt{c[idx]} \\
          Returns the element with index \texttt{idx} \textit{(no range checking)}.
          
    \item \texttt{c.at(idx)} \\
          Returns the element with index \texttt{idx} \textit{(throws range-error exception if \texttt{idx} is out of range)}.
          
    \item \texttt{c.front()} \\
          Returns the first element \textit{(no check whether a first element exists)}.
          
    \item \texttt{c.back()} \\
          Returns the last element \textit{(no check whether a last element exists)}.
\end{itemize}

\pagebreak 
\subsection{Inserting and Removing Elements}
\begin{itemize}
    \item \texttt{c.push\_back(elem)} \\
          Appends a copy of \texttt{elem} at the end.
          
    \item \texttt{c.pop\_back()} \\
          Removes the last element (does not return it).
    
  \item \texttt{c.push\_front()}
                Appends a copy of \texttt{elem} at the front.

  \item \texttt{c.pop\_front()}
        Removes the first element (does not return it).

    \item \texttt{c.insert(pos, elem)} \\
          Inserts a copy of \texttt{elem} before iterator position \texttt{pos} and returns the position of the new element.
          
    \item \texttt{c.insert(pos, n, elem)} \\
          Inserts \texttt{n} copies of \texttt{elem} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, beg, end)} \\
          Inserts a copy of all elements of the range [\texttt{beg, end}] before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, initlist)} \\
          Inserts a copy of all elements of the initializer list \texttt{initlist} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element; since C++11).
          
    \item \texttt{c.emplace(pos, args...)} \\
          Inserts a copy of an element initialized with \texttt{args} before iterator position \texttt{pos} and returns the position of the new element (since C++11).
          
    \item \texttt{c.emplace\_back(args...)} \\
          Appends a copy of an element initialized with \texttt{args} at the end (returns nothing; since C++11).
          
    \item \texttt{c.erase(pos)} \\
          Removes the element at iterator position \texttt{pos} and returns the position of the next element.
          
    \item \texttt{c.erase(beg, end)} \\
          Removes all elements of the range [\texttt{beg, end}] and returns the position of the next element.
          
    \item \texttt{c.resize(num)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are created by their default constructor).
          
    \item \texttt{c.resize(num, elem)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are copies of \texttt{elem}).
          
    \item \texttt{c.clear()} \\
          Removes all elements (empties the container).
\end{itemize}

\unsect{Deque}
\bigbreak \noindent 
    \subsection{Nonmodifying Operations}
    \bigbreak \noindent 
\begin{itemize}
    \item \texttt{c.empty()} \\
          Returns whether the container is empty (equivalent to \texttt{size()} == 0 but might be faster).
          
    \item \texttt{c.size()} \\
          Returns the current number of elements.
          
    \item \texttt{c.max\_size()} \\
          Returns the maximum number of elements possible.
          
    \item \texttt{c.shrink\_to\_fit()} \\
          Requests to reduce capacity to fit the number of elements (since C++11)\textsuperscript{6}.
          
    \item \texttt{c1 == c2} \\
          Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements).
          
    \item \texttt{c1 != c2} \\
          Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1 == c2)}).
          
    \item \texttt{c1 < c2} \\
          Returns whether \texttt{c1} is less than \texttt{c2}.
          
    \item \texttt{c1 > c2} \\
          Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2 < c1}).
          
    \item \texttt{c1 <= c2} \\
          Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2 < c1)}).
          
    \item \texttt{c1 >= c2} \\
          Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1 < c2)}).
\end{itemize}

\pagebreak 
\subsection{Assignments}
\begin{itemize}
    \item \texttt{c = c2} \\
          Assigns all elements of \texttt{c2} to \texttt{c}.
          
    \item \texttt{c = rv} \\
          Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11).
          
    \item \texttt{c = initlist} \\
          Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11).
          
    \item \texttt{c.assign(n, elem)} \\
          Assigns \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{c.assign(beg, end)} \\
          Assigns the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{c.assign(initlist)} \\
          Assigns all the elements of the initializer list \texttt{initlist}.
          
    \item \texttt{c1.swap(c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
          
    \item \texttt{swap(c1, c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
\end{itemize}

\bigbreak \noindent 
\subsection{Element access}
\begin{itemize}
    \item \texttt{c[idx]} \\
          Returns the element with index \texttt{idx} \textit{(no range checking)}.
          
    \item \texttt{c.at(idx)} \\
          Returns the element with index \texttt{idx} \textit{(throws range-error exception if \texttt{idx} is out of range)}.
          
    \item \texttt{c.front()} \\
          Returns the first element \textit{(no check whether a first element exists)}.
          
    \item \texttt{c.back()} \\
          Returns the last element \textit{(no check whether a last element exists)}.
\end{itemize}

\pagebreak 
\subsection{Inserting and Removing Elements}
\begin{itemize}
    \item \texttt{c.push\_back(elem)} \\
          Appends a copy of \texttt{elem} at the end.
          
    \item \texttt{c.pop\_back()} \\
          Removes the last element (does not return it).
          
    \item \texttt{c.insert(pos, elem)} \\
          Inserts a copy of \texttt{elem} before iterator position \texttt{pos} and returns the position of the new element.
          
    \item \texttt{c.insert(pos, n, elem)} \\
          Inserts \texttt{n} copies of \texttt{elem} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, beg, end)} \\
          Inserts a copy of all elements of the range [\texttt{beg, end}] before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
          
    \item \texttt{c.insert(pos, initlist)} \\
          Inserts a copy of all elements of the initializer list \texttt{initlist} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element; since C++11).
          
    \item \texttt{c.emplace(pos, args...)} \\
          Inserts a copy of an element initialized with \texttt{args} before iterator position \texttt{pos} and returns the position of the new element (since C++11).
          
    \item \texttt{c.emplace\_back(args...)} \\
          Appends a copy of an element initialized with \texttt{args} at the end (returns nothing; since C++11).
          
    \item \texttt{c.erase(pos)} \\
          Removes the element at iterator position \texttt{pos} and returns the position of the next element.
          
    \item \texttt{c.erase(beg, end)} \\
          Removes all elements of the range [\texttt{beg, end}] and returns the position of the next element.
          
    \item \texttt{c.resize(num)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are created by their default constructor).
          
    \item \texttt{c.resize(num, elem)} \\
          Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are copies of \texttt{elem}).
          
    \item \texttt{c.clear()} \\
          Removes all elements (empties the container).
\end{itemize}

\pagebreak 
\unsect{Lists}
\bigbreak \noindent 
\subsection{Nonmod}
\begin{itemize}
    \item \texttt{c.empty()} \\
          Returns whether the container is empty (equivalent to \texttt{size()} == 0 but might be faster).
          
    \item \texttt{c.size()} \\
          Returns the current number of elements.
          
    \item \texttt{c.max\_size()} \\
          Returns the maximum number of elements possible.
          
    \item \texttt{c1 == c2} \\
          Returns whether \texttt{c1} is equal to \texttt{c2} (calls \texttt{==} for the elements).
          
    \item \texttt{c1 != c2} \\
          Returns whether \texttt{c1} is not equal to \texttt{c2} (equivalent to \texttt{!(c1 == c2)}).
          
    \item \texttt{c1 < c2} \\
          Returns whether \texttt{c1} is less than \texttt{c2}.
          
    \item \texttt{c1 > c2} \\
          Returns whether \texttt{c1} is greater than \texttt{c2} (equivalent to \texttt{c2 < c1}).
          
    \item \texttt{c1 <= c2} \\
          Returns whether \texttt{c1} is less than or equal to \texttt{c2} (equivalent to \texttt{!(c2 < c1)}).
          
    \item \texttt{c1 >= c2} \\
          Returns whether \texttt{c1} is greater than or equal to \texttt{c2} (equivalent to \texttt{!(c1 < c2)}).
      \end{itemize}

      \pagebreak 
      \subsection{Assignment}
\begin{itemize}
    \item \texttt{c = c2} \\
          Assigns all elements of \texttt{c2} to \texttt{c}.
          
    \item \texttt{c = rv} \\
          Move assigns all elements of the rvalue \texttt{rv} to \texttt{c} (since C++11).
          
    \item \texttt{c = initlist} \\
          Assigns all elements of the initializer list \texttt{initlist} to \texttt{c} (since C++11).
          
    \item \texttt{c.assign(n, elem)} \\
          Assigns \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{c.assign(beg, end)} \\
          Assigns the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{c.assign(initlist)} \\
          Assigns all the elements of the initializer list \texttt{initlist}.
          
    \item \texttt{c1.swap(c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
          
    \item \texttt{swap(c1, c2)} \\
          Swaps the data of \texttt{c1} and \texttt{c2}.
\end{itemize}

\pagebreak 
\subsection{Element access}
\begin{itemize}
    \item \texttt{c.front()}: No check whether the element exists
    \item \texttt{c.back()}: No check whether the element exists
\end{itemize}

\pagebreak 
\subsection{Insert and Remove}
\begin{itemize}
    \item \texttt{c.push\_back(elem)} \\
    Appends a copy of \texttt{elem} at the end.
    
    \item \texttt{c.pop\_back()} \\
    Removes the last element (does not return it).
    
    \item \texttt{c.push\_front(elem)} \\
    Inserts a copy of \texttt{elem} at the beginning.
    
    \item \texttt{c.pop\_front()} \\
    Removes the first element (does not return it).
    
    \item \texttt{c.insert(pos, elem)} \\
    Inserts a copy of \texttt{elem} before iterator position \texttt{pos} and returns the position of the new element.
    
    \item \texttt{c.insert(pos, n, elem)} \\
    Inserts \texttt{n} copies of \texttt{elem} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
    
    \item \texttt{c.insert(pos, beg, end)} \\
    Inserts a copy of all elements of the range \texttt{[beg, end]} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element).
    
    \item \texttt{c.insert(pos, inilist)} \\
    Inserts a copy of all elements of the initializer list \texttt{inilist} before iterator position \texttt{pos} and returns the position of the first new element (or \texttt{pos} if there is no new element; since C++11).
    
    \item \texttt{c.emplace(pos, args...)} \\
    Inserts a copy of an element initialized with \texttt{args} before iterator position \texttt{pos} and returns the position of the new element (since C++11).
    
    \item \texttt{c.emplace\_back(args...)} \\
    Appends a copy of an element initialized with \texttt{args} at the end (returns nothing; since C++11).
    
    \item \texttt{c.emplace\_front(args...)} \\
    Inserts a copy of an element initialized with \texttt{args} at the beginning (returns nothing; since C++11).
    
    \item \texttt{c.erase(pos)} \\
    Removes the element at iterator position \texttt{pos} and returns the position of the next element.
    
    \item \texttt{c.erase(beg, end)} \\
    Removes all elements of the range \texttt{[beg, end]} and returns the position of the next element.
    
    \item \texttt{c.remove(val)} \\
    Removes all elements with value \texttt{val}.
    
    \item \texttt{c.remove\_if(op)} \\
    Removes all elements for which \texttt{op(elem)} yields \texttt{true}.
    
    \item \texttt{c.resize(num)} \\
    Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are created by their default constructor).
    
    \item \texttt{c.resize(num, elem)} \\
    Changes the number of elements to \texttt{num} (if \texttt{size()} grows, new elements are copies of \texttt{elem}).
    
    \item \texttt{c.clear()} \\
    Removes all elements (empties the container).
\end{itemize}

\pagebreak 
\subsection{Special Modifying Operations for Lists}
\begin{itemize}
    \item \texttt{c.unique()} \\
    Removes duplicates of consecutive elements with the same value.
    
    \item \texttt{c.unique(op)} \\
    Removes duplicates of consecutive elements, for which \texttt{op()} yields \texttt{true}.
    
    \item \texttt{c.splice(pos, c2)} \\
    Moves all elements of \texttt{c2} to \texttt{c} in front of the iterator position \texttt{pos}.
    
    \item \texttt{c.splice(pos, c2, c2pos)} \\
    Moves the element at \texttt{c2pos} in \texttt{c2} in front of \texttt{pos} of list \texttt{c} (\texttt{c} and \texttt{c2} may be identical).
    
    \item \texttt{c.splice(pos, c2, c2beg, c2end)} \\
    Moves all elements of the range \texttt{[c2beg, c2end)} in \texttt{c2} in front of \texttt{pos} of list \texttt{c} (\texttt{c} and \texttt{c2} may be identical).
    
    \item \texttt{c.sort()} \\
    Sorts all elements with operator \texttt{<}.
    
    \item \texttt{c.sort(op)} \\
    Sorts all elements with \texttt{op()}.
    
    \item \texttt{c.merge(c2)} \\
    Assuming that both containers contain the elements sorted, moves all elements of \texttt{c2} into \texttt{c} so that all elements are merged and still sorted.
    
    \item \texttt{c.merge(c2, op)} \\
    Assuming that both containers contain the elements sorted due to the sorting criterion \texttt{op()}, moves all elements of \texttt{c2} into \texttt{c} so that all elements are merged and still sorted according to \texttt{op()}.
    
    \item \texttt{c.reverse()} \\
    Reverses the order of all elements.
\end{itemize}

\bigbreak \noindent 
\subsection{Sorting}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{c.sort()}: Sorts the list
\end{itemize}

\pagebreak 
\unsect{Forward\_list}















\end{document}
