\contentsline {section}{\numberline {1}STL Containers}{8}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}STL Vectors}{8}{subsection.0.1.1}%
\contentsline {subsubsection}{\numberline {1.1.1}Implementation}{8}{subsubsection.0.1.1.1}%
\contentsline {subsubsection}{\numberline {1.1.2}Performance in operations on the end}{8}{subsubsection.0.1.1.2}%
\contentsline {subsubsection}{\numberline {1.1.3}Size and capacity}{8}{subsubsection.0.1.1.3}%
\contentsline {subsubsection}{\numberline {1.1.4}Constructors}{9}{subsubsection.0.1.1.4}%
\contentsline {subsubsection}{\numberline {1.1.5}Note about at()}{10}{subsubsection.0.1.1.5}%
\contentsline {subsubsection}{\numberline {1.1.6}Iterator methods}{10}{subsubsection.0.1.1.6}%
\contentsline {subsubsection}{\numberline {1.1.7}Using vectors as 2d arrays}{10}{subsubsection.0.1.1.7}%
\contentsline {subsubsection}{\numberline {1.1.8}For those interested}{12}{subsubsection.0.1.1.8}%
\contentsline {paragraph}{\numberline {1.1.8.1}Manual Dynamic Memory Allocation (Using new)}{12}{paragraph.0.1.1.8.1}%
\contentsline {paragraph}{\numberline {1.1.8.2}Using unique pointer}{12}{paragraph.0.1.1.8.2}%
\contentsline {paragraph}{\numberline {1.1.8.3}Recall: Unique pointer for dynamic arry}{13}{paragraph.0.1.1.8.3}%
\contentsline {paragraph}{\numberline {1.1.8.4}If sizes are truly known at compile time}{14}{paragraph.0.1.1.8.4}%
\contentsline {subsection}{\numberline {1.2}STL Deque}{15}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Implementation}{15}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Abilities, performance, uses}{15}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}When to use deques}{15}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}Constructors}{16}{subsubsection.0.1.2.4}%
\contentsline {subsection}{\numberline {1.3}STL Lists}{17}{subsection.0.1.3}%
\contentsline {subsubsection}{\numberline {1.3.1}Implementation}{17}{subsubsection.0.1.3.1}%
\contentsline {subsubsection}{\numberline {1.3.2}Abilities}{17}{subsubsection.0.1.3.2}%
\contentsline {subsubsection}{\numberline {1.3.3}Differencs in the methods}{17}{subsubsection.0.1.3.3}%
\contentsline {subsubsection}{\numberline {1.3.4}Constructors}{18}{subsubsection.0.1.3.4}%
\contentsline {subsubsection}{\numberline {1.3.5}Element access}{18}{subsubsection.0.1.3.5}%
\contentsline {subsubsection}{\numberline {1.3.6}Iterator functions}{18}{subsubsection.0.1.3.6}%
\contentsline {subsubsection}{\numberline {1.3.7}Splice Functions and Functions to Change the Order of Elements}{19}{subsubsection.0.1.3.7}%
\contentsline {subsection}{\numberline {1.4}STL Forward lists}{20}{subsection.0.1.4}%
\contentsline {subsubsection}{\numberline {1.4.1}Implementation}{20}{subsubsection.0.1.4.1}%
\contentsline {subsubsection}{\numberline {1.4.2}Abilities, limitations}{20}{subsubsection.0.1.4.2}%
\contentsline {subsubsection}{\numberline {1.4.3}No size()?}{21}{subsubsection.0.1.4.3}%
\contentsline {subsubsection}{\numberline {1.4.4}Similarities to list}{21}{subsubsection.0.1.4.4}%
\contentsline {subsubsection}{\numberline {1.4.5}Constructors}{22}{subsubsection.0.1.4.5}%
\contentsline {subsection}{\numberline {1.5}STL Sets and multisets}{23}{subsection.0.1.5}%
\contentsline {subsubsection}{\numberline {1.5.1}Implementation}{23}{subsubsection.0.1.5.1}%
\contentsline {subsubsection}{\numberline {1.5.2}Strict weak ordering}{23}{subsubsection.0.1.5.2}%
\contentsline {subsubsection}{\numberline {1.5.3}Abilities}{24}{subsubsection.0.1.5.3}%
\contentsline {subsubsection}{\numberline {1.5.4}Changing elements directly, no direct element access}{24}{subsubsection.0.1.5.4}%
\contentsline {subsubsection}{\numberline {1.5.5}Constructors}{24}{subsubsection.0.1.5.5}%
\contentsline {subsubsection}{\numberline {1.5.6}Types}{25}{subsubsection.0.1.5.6}%
\contentsline {subsubsection}{\numberline {1.5.7}Constructors}{26}{subsubsection.0.1.5.7}%
\contentsline {subsection}{\numberline {1.6}STL Maps and multimaps}{27}{subsection.0.1.6}%
\contentsline {subsubsection}{\numberline {1.6.1}Implementation}{27}{subsubsection.0.1.6.1}%
\contentsline {subsubsection}{\numberline {1.6.2}Template parameters}{27}{subsubsection.0.1.6.2}%
\contentsline {subsubsection}{\numberline {1.6.3}Abilities}{27}{subsubsection.0.1.6.3}%
\contentsline {subsubsection}{\numberline {1.6.4}Constructors and types}{28}{subsubsection.0.1.6.4}%
\contentsline {subsubsection}{\numberline {1.6.5}Using maps as associative arrays}{29}{subsubsection.0.1.6.5}%
\contentsline {subsubsection}{\numberline {1.6.6}Constructors}{29}{subsubsection.0.1.6.6}%
\contentsline {subsection}{\numberline {1.7}Example of bounds and equal range}{31}{subsection.0.1.7}%
\contentsline {subsection}{\numberline {1.8}STL Unordered containers}{32}{subsection.0.1.8}%
\contentsline {subsubsection}{\numberline {1.8.1}Implementation}{32}{subsubsection.0.1.8.1}%
\contentsline {subsubsection}{\numberline {1.8.2}Abilities}{32}{subsubsection.0.1.8.2}%
\contentsline {subsubsection}{\numberline {1.8.3}Disadvantages}{33}{subsubsection.0.1.8.3}%
\contentsline {subsection}{\numberline {1.9}STL Containers: Implementations}{34}{subsection.0.1.9}%
\contentsline {subsection}{\numberline {1.10}STL Containers: Iterator Functions}{35}{subsection.0.1.10}%
\contentsline {subsection}{\numberline {1.11}STL containers: Main concepts, differences, uses}{36}{subsection.0.1.11}%
\contentsline {subsection}{\numberline {1.12}STL Containers: Iterator invalidation}{38}{subsection.0.1.12}%
\contentsline {subsection}{\numberline {1.13}STL Containers: Reallocation}{39}{subsection.0.1.13}%
\contentsline {subsection}{\numberline {1.14}STL Containers: Element access}{40}{subsection.0.1.14}%
\contentsline {subsection}{\numberline {1.15}STL Containers: Uses and advantages}{41}{subsection.0.1.15}%
\contentsline {subsection}{\numberline {1.16}STL Iterators}{42}{subsection.0.1.16}%
\contentsline {subsection}{\numberline {1.17}Complexity of container operations}{46}{subsection.0.1.17}%
\contentsline {section}{\numberline {2}STL Algorithms}{47}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}<algorithm>}{47}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}<numeric>}{48}{subsection.0.2.2}%
\contentsline {subsubsection}{\numberline {2.2.1}transform\_reduce}{48}{subsubsection.0.2.2.1}%
\contentsline {paragraph}{\numberline {2.2.1.1}Unary transform and reduce}{48}{paragraph.0.2.2.1.1}%
\contentsline {paragraph}{\numberline {2.2.1.2}Binary transform and reduce}{49}{paragraph.0.2.2.1.2}%
\contentsline {paragraph}{\numberline {2.2.1.3}std::plus<> and std::multiplies<>}{50}{paragraph.0.2.2.1.3}%
\contentsline {paragraph}{\numberline {2.2.1.4}Other key function objects}{50}{paragraph.0.2.2.1.4}%
\contentsline {section}{\numberline {3}Type traits}{52}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Nonstandard type of types}{52}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}::value, ::type, and ::value\_type}{53}{subsection.0.3.2}%
\contentsline {section}{\numberline {4}Function Objects}{54}{section.0.4}%
\contentsline {paragraph}{\numberline {4.0.0.1}Why?}{54}{paragraph.0.4.0.0.1}%
\contentsline {paragraph}{\numberline {4.0.0.2}Predefined function objects}{55}{paragraph.0.4.0.0.2}%
\contentsline {section}{\numberline {5}Decltype}{55}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}Syntax}{55}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}Example}{56}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}Things to pair with decltype}{56}{subsection.0.5.3}%
\contentsline {section}{\numberline {6}Constexpr}{57}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Variables}{57}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Functions}{57}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Object Constructors}{58}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}constexpr vs const}{58}{subsection.0.6.4}%
\contentsline {section}{\numberline {7}Function pointers and callable parametrs}{59}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Function pointers}{59}{subsection.0.7.1}%
\contentsline {subsubsection}{\numberline {7.1.1}As types}{59}{subsubsection.0.7.1.1}%
\contentsline {subsubsection}{\numberline {7.1.2}As function paramater}{59}{subsubsection.0.7.1.2}%
\contentsline {subsubsection}{\numberline {7.1.3}Function pointers to member functions}{60}{subsubsection.0.7.1.3}%
\contentsline {subsection}{\numberline {7.2}Using std::function}{61}{subsection.0.7.2}%
\contentsline {section}{\numberline {8}std::bind}{62}{section.0.8}%
\contentsline {subsection}{\numberline {8.1}std::placeholders}{62}{subsection.0.8.1}%
\contentsline {subsection}{\numberline {8.2}Using std::ref with bind}{63}{subsection.0.8.2}%
\contentsline {section}{\numberline {9}Templates}{64}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Template Function}{64}{subsection.0.9.1}%
\contentsline {subsection}{\numberline {9.2}Template Class}{65}{subsection.0.9.2}%
\contentsline {subsection}{\numberline {9.3}Class vs typename keyword}{65}{subsection.0.9.3}%
\contentsline {subsection}{\numberline {9.4}Handle friend functions}{65}{subsection.0.9.4}%
\contentsline {subsubsection}{\numberline {9.4.1}Friendship to a Non-Template Function}{65}{subsubsection.0.9.4.1}%
\contentsline {subsubsection}{\numberline {9.4.2}Friendship to a Template Function}{66}{subsubsection.0.9.4.2}%
\contentsline {subsection}{\numberline {9.5}Function Template Specialization}{68}{subsection.0.9.5}%
\contentsline {subsection}{\numberline {9.6}Class/Struct Template Specialization}{68}{subsection.0.9.6}%
\contentsline {subsection}{\numberline {9.7}Template Parameters}{68}{subsection.0.9.7}%
\contentsline {subsection}{\numberline {9.8}Trailing return type}{68}{subsection.0.9.8}%
\contentsline {subsubsection}{\numberline {9.8.1}Syntax}{69}{subsubsection.0.9.8.1}%
\contentsline {subsubsection}{\numberline {9.8.2}Example}{69}{subsubsection.0.9.8.2}%
\contentsline {subsection}{\numberline {9.9}Template functions with mixed types (Trailing return type)}{69}{subsection.0.9.9}%
\contentsline {subsection}{\numberline {9.10}Template functions with mixed types (Deduced return type)}{70}{subsection.0.9.10}%
\contentsline {subsection}{\numberline {9.11}Dependent name resolution}{70}{subsection.0.9.11}%
\contentsline {subsubsection}{\numberline {9.11.1}Dependent names}{70}{subsubsection.0.9.11.1}%
\contentsline {subsubsection}{\numberline {9.11.2}Typename Keyword}{70}{subsubsection.0.9.11.2}%
\contentsline {subsubsection}{\numberline {9.11.3}Nested types}{71}{subsubsection.0.9.11.3}%
\contentsline {subsubsection}{\numberline {9.11.4}Prereq: Using aliases defined in classes}{71}{subsubsection.0.9.11.4}%
\contentsline {subsubsection}{\numberline {9.11.5}Type Aliases}{72}{subsubsection.0.9.11.5}%
\contentsline {subsubsection}{\numberline {9.11.6}Return Types in Template Functions}{73}{subsubsection.0.9.11.6}%
\contentsline {subsubsection}{\numberline {9.11.7}Base Class Members}{73}{subsubsection.0.9.11.7}%
\contentsline {subsubsection}{\numberline {9.11.8}Dependent Types in Expressions}{73}{subsubsection.0.9.11.8}%
\contentsline {subsection}{\numberline {9.12}Variadic templates with functions}{73}{subsection.0.9.12}%
\contentsline {subsection}{\numberline {9.13}Left vs right folds}{77}{subsection.0.9.13}%
\contentsline {subsection}{\numberline {9.14}Parentheses in fold expressions}{78}{subsection.0.9.14}%
\contentsline {subsection}{\numberline {9.15}Pack size}{78}{subsection.0.9.15}%
\contentsline {subsection}{\numberline {9.16}Function calls in fold expressions}{79}{subsection.0.9.16}%
\contentsline {subsection}{\numberline {9.17}Variadic templates with classes}{80}{subsection.0.9.17}%
\contentsline {subsection}{\numberline {9.18}std::forward}{82}{subsection.0.9.18}%
\contentsline {subsubsection}{\numberline {9.18.1}Key Differences Between std::forward and std::move}{82}{subsubsection.0.9.18.1}%
\contentsline {subsection}{\numberline {9.19}Universal reference (forwarding reference)}{84}{subsection.0.9.19}%
\contentsline {section}{\numberline {10}More on the comma operator}{85}{section.0.10}%
\contentsline {section}{\numberline {11}More on Lambdas}{86}{section.0.11}%
\contentsline {subsection}{\numberline {11.1}Auto in lambda args}{86}{subsection.0.11.1}%
\contentsline {subsection}{\numberline {11.2}Template lambdas}{86}{subsection.0.11.2}%
\contentsline {section}{\numberline {12}std::invoke}{87}{section.0.12}%
\contentsline {subsection}{\numberline {12.1}Calling a regular function}{87}{subsection.0.12.1}%
\contentsline {subsection}{\numberline {12.2}Calling a member function}{87}{subsection.0.12.2}%
\contentsline {subsection}{\numberline {12.3}Accessing a member variable}{88}{subsection.0.12.3}%
\contentsline {subsection}{\numberline {12.4}Calling a lambda}{88}{subsection.0.12.4}%
\contentsline {section}{\numberline {13}When initializer lists are required}{89}{section.0.13}%
\contentsline {section}{\numberline {14}Inheritence and Subtype Polymorphism}{90}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}OOP Main Concepts}{90}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}Object Relationships}{90}{subsection.0.14.2}%
\contentsline {subsection}{\numberline {14.3}Ineritance}{91}{subsection.0.14.3}%
\contentsline {subsection}{\numberline {14.4}Inheritance and Member Access}{91}{subsection.0.14.4}%
\contentsline {subsection}{\numberline {14.5}Inheritance Syntax}{92}{subsection.0.14.5}%
\contentsline {subsection}{\numberline {14.6}Upcasting and Downcasting}{93}{subsection.0.14.6}%
\contentsline {subsection}{\numberline {14.7}More on Downcasting}{94}{subsection.0.14.7}%
\contentsline {subsubsection}{\numberline {14.7.1}What Happens Without Virtual Functions}{95}{subsubsection.0.14.7.1}%
\contentsline {subsubsection}{\numberline {14.7.2}Downcasting example}{96}{subsubsection.0.14.7.2}%
\contentsline {subsubsection}{\numberline {14.7.3}Base class pointer example}{97}{subsubsection.0.14.7.3}%
\contentsline {subsection}{\numberline {14.8}Object Slicing}{97}{subsection.0.14.8}%
\contentsline {subsection}{\numberline {14.9}Multiple Inheritance}{99}{subsection.0.14.9}%
\contentsline {subsubsection}{\numberline {14.9.1}Why Use Multiple Inheritance?}{99}{subsubsection.0.14.9.1}%
\contentsline {subsubsection}{\numberline {14.9.2}Example}{99}{subsubsection.0.14.9.2}%
\contentsline {subsubsection}{\numberline {14.9.3}Issues with Multiple Inheritance}{100}{subsubsection.0.14.9.3}%
\contentsline {subsection}{\numberline {14.10}Virtual inheritance}{101}{subsection.0.14.10}%
\contentsline {subsubsection}{\numberline {14.10.1}The Diamond Problem}{101}{subsubsection.0.14.10.1}%
\contentsline {subsubsection}{\numberline {14.10.2}Solution with Virtual Inheritance}{102}{subsubsection.0.14.10.2}%
\contentsline {subsection}{\numberline {14.11}Subtype Polymorphism}{102}{subsection.0.14.11}%
\contentsline {subsection}{\numberline {14.12}Declaring Virtual Member Functions}{103}{subsection.0.14.12}%
\contentsline {subsubsection}{\numberline {14.12.1}The override keyword}{103}{subsubsection.0.14.12.1}%
\contentsline {subsection}{\numberline {14.13}Abstract or Pure virtual Member Functions}{104}{subsection.0.14.13}%
\contentsline {subsection}{\numberline {14.14}Abstract Classes}{104}{subsection.0.14.14}%
\contentsline {subsection}{\numberline {14.15}Interface Inheritance}{105}{subsection.0.14.15}%
\contentsline {section}{\numberline {15}<regex.h> Pattern Matching and String Validation}{106}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}regcomp}{106}{subsection.0.15.1}%
\contentsline {subsubsection}{\numberline {15.1.1}Signature}{106}{subsubsection.0.15.1.1}%
\contentsline {subsubsection}{\numberline {15.1.2}Return value}{106}{subsubsection.0.15.1.2}%
\contentsline {subsubsection}{\numberline {15.1.3}Return errors}{106}{subsubsection.0.15.1.3}%
\contentsline {subsubsection}{\numberline {15.1.4}Flags}{107}{subsubsection.0.15.1.4}%
\contentsline {subsection}{\numberline {15.2}Regexec}{107}{subsection.0.15.2}%
\contentsline {subsubsection}{\numberline {15.2.1}Signature}{108}{subsubsection.0.15.2.1}%
\contentsline {subsubsection}{\numberline {15.2.2}Return value}{108}{subsubsection.0.15.2.2}%
\contentsline {subsection}{\numberline {15.3}Regerror}{108}{subsection.0.15.3}%
\contentsline {subsubsection}{\numberline {15.3.1}Signature}{108}{subsubsection.0.15.3.1}%
\contentsline {subsubsection}{\numberline {15.3.2}Return value}{109}{subsubsection.0.15.3.2}%
\contentsline {subsection}{\numberline {15.4}Regfree}{109}{subsection.0.15.4}%
\contentsline {subsubsection}{\numberline {15.4.1}Signature}{109}{subsubsection.0.15.4.1}%
\contentsline {subsection}{\numberline {15.5}regmatch\_t and pmatch}{110}{subsection.0.15.5}%
\contentsline {subsubsection}{\numberline {15.5.1}regmatch\_t}{110}{subsubsection.0.15.5.1}%
\contentsline {subsubsection}{\numberline {15.5.2}pmatch array}{111}{subsubsection.0.15.5.2}%
\contentsline {subsection}{\numberline {15.6}Regex Example}{111}{subsection.0.15.6}%
\contentsline {section}{\numberline {16}Structured bindings}{114}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}As unpacks}{114}{subsection.0.16.1}%
\contentsline {subsection}{\numberline {16.2}With returning}{114}{subsection.0.16.2}%
\contentsline {subsection}{\numberline {16.3}With structs and classes}{115}{subsection.0.16.3}%
\contentsline {subsection}{\numberline {16.4}With maps}{115}{subsection.0.16.4}%
\contentsline {section}{\numberline {17}Attributes in c++}{116}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}General Attributes}{116}{subsection.0.17.1}%
\contentsline {section}{\numberline {18}Inline functions}{119}{section.0.18}%
