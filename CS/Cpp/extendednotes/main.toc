\contentsline {section}{\numberline {1}STL Containers}{9}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}STL Vectors}{9}{subsection.0.1.1}%
\contentsline {subsubsection}{\numberline {1.1.1}Implementation}{9}{subsubsection.0.1.1.1}%
\contentsline {subsubsection}{\numberline {1.1.2}Performance in operations on the end}{9}{subsubsection.0.1.1.2}%
\contentsline {subsubsection}{\numberline {1.1.3}Size and capacity}{9}{subsubsection.0.1.1.3}%
\contentsline {subsubsection}{\numberline {1.1.4}Constructors}{10}{subsubsection.0.1.1.4}%
\contentsline {subsubsection}{\numberline {1.1.5}Note about at()}{11}{subsubsection.0.1.1.5}%
\contentsline {subsubsection}{\numberline {1.1.6}Iterator methods}{11}{subsubsection.0.1.1.6}%
\contentsline {subsubsection}{\numberline {1.1.7}Using vectors as 2d arrays}{11}{subsubsection.0.1.1.7}%
\contentsline {subsubsection}{\numberline {1.1.8}For those interested}{13}{subsubsection.0.1.1.8}%
\contentsline {paragraph}{\numberline {1.1.8.1}Manual Dynamic Memory Allocation (Using new)}{13}{paragraph.0.1.1.8.1}%
\contentsline {paragraph}{\numberline {1.1.8.2}Using unique pointer}{13}{paragraph.0.1.1.8.2}%
\contentsline {paragraph}{\numberline {1.1.8.3}Recall: Unique pointer for dynamic arry}{14}{paragraph.0.1.1.8.3}%
\contentsline {paragraph}{\numberline {1.1.8.4}If sizes are truly known at compile time}{15}{paragraph.0.1.1.8.4}%
\contentsline {subsection}{\numberline {1.2}STL Deque}{16}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Implementation}{16}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Abilities, performance, uses}{16}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}When to use deques}{16}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}Constructors}{17}{subsubsection.0.1.2.4}%
\contentsline {subsection}{\numberline {1.3}STL Lists}{18}{subsection.0.1.3}%
\contentsline {subsubsection}{\numberline {1.3.1}Implementation}{18}{subsubsection.0.1.3.1}%
\contentsline {subsubsection}{\numberline {1.3.2}Abilities}{18}{subsubsection.0.1.3.2}%
\contentsline {subsubsection}{\numberline {1.3.3}Differencs in the methods}{18}{subsubsection.0.1.3.3}%
\contentsline {subsubsection}{\numberline {1.3.4}Constructors}{19}{subsubsection.0.1.3.4}%
\contentsline {subsubsection}{\numberline {1.3.5}Element access}{19}{subsubsection.0.1.3.5}%
\contentsline {subsubsection}{\numberline {1.3.6}Iterator functions}{19}{subsubsection.0.1.3.6}%
\contentsline {subsubsection}{\numberline {1.3.7}Splice Functions and Functions to Change the Order of Elements}{20}{subsubsection.0.1.3.7}%
\contentsline {subsection}{\numberline {1.4}STL Forward lists}{21}{subsection.0.1.4}%
\contentsline {subsubsection}{\numberline {1.4.1}Implementation}{21}{subsubsection.0.1.4.1}%
\contentsline {subsubsection}{\numberline {1.4.2}Abilities, limitations}{21}{subsubsection.0.1.4.2}%
\contentsline {subsubsection}{\numberline {1.4.3}No size()?}{22}{subsubsection.0.1.4.3}%
\contentsline {subsubsection}{\numberline {1.4.4}Similarities to list}{22}{subsubsection.0.1.4.4}%
\contentsline {subsubsection}{\numberline {1.4.5}Constructors}{23}{subsubsection.0.1.4.5}%
\contentsline {subsection}{\numberline {1.5}STL Sets and multisets}{24}{subsection.0.1.5}%
\contentsline {subsubsection}{\numberline {1.5.1}Implementation}{24}{subsubsection.0.1.5.1}%
\contentsline {subsubsection}{\numberline {1.5.2}Strict weak ordering}{24}{subsubsection.0.1.5.2}%
\contentsline {subsubsection}{\numberline {1.5.3}Abilities}{25}{subsubsection.0.1.5.3}%
\contentsline {subsubsection}{\numberline {1.5.4}Changing elements directly, no direct element access}{25}{subsubsection.0.1.5.4}%
\contentsline {subsubsection}{\numberline {1.5.5}Constructors}{25}{subsubsection.0.1.5.5}%
\contentsline {subsubsection}{\numberline {1.5.6}Types}{26}{subsubsection.0.1.5.6}%
\contentsline {subsubsection}{\numberline {1.5.7}Constructors}{27}{subsubsection.0.1.5.7}%
\contentsline {subsection}{\numberline {1.6}STL Maps and multimaps}{28}{subsection.0.1.6}%
\contentsline {subsubsection}{\numberline {1.6.1}Implementation}{28}{subsubsection.0.1.6.1}%
\contentsline {subsubsection}{\numberline {1.6.2}Template parameters}{28}{subsubsection.0.1.6.2}%
\contentsline {subsubsection}{\numberline {1.6.3}Abilities}{28}{subsubsection.0.1.6.3}%
\contentsline {subsubsection}{\numberline {1.6.4}Constructors and types}{29}{subsubsection.0.1.6.4}%
\contentsline {subsubsection}{\numberline {1.6.5}Using maps as associative arrays}{30}{subsubsection.0.1.6.5}%
\contentsline {subsubsection}{\numberline {1.6.6}Constructors}{30}{subsubsection.0.1.6.6}%
\contentsline {subsection}{\numberline {1.7}Example of bounds and equal range}{32}{subsection.0.1.7}%
\contentsline {subsection}{\numberline {1.8}STL Unordered containers}{33}{subsection.0.1.8}%
\contentsline {subsubsection}{\numberline {1.8.1}Implementation}{33}{subsubsection.0.1.8.1}%
\contentsline {subsubsection}{\numberline {1.8.2}Abilities}{33}{subsubsection.0.1.8.2}%
\contentsline {subsubsection}{\numberline {1.8.3}Disadvantages}{34}{subsubsection.0.1.8.3}%
\contentsline {subsection}{\numberline {1.9}STL Containers: Implementations}{35}{subsection.0.1.9}%
\contentsline {subsection}{\numberline {1.10}STL Containers: Iterator Functions}{36}{subsection.0.1.10}%
\contentsline {subsection}{\numberline {1.11}STL containers: Main concepts, differences, uses}{37}{subsection.0.1.11}%
\contentsline {subsection}{\numberline {1.12}STL Containers: Iterator invalidation}{39}{subsection.0.1.12}%
\contentsline {subsection}{\numberline {1.13}STL Containers: Reallocation}{40}{subsection.0.1.13}%
\contentsline {subsection}{\numberline {1.14}STL Containers: Element access}{41}{subsection.0.1.14}%
\contentsline {subsection}{\numberline {1.15}STL Containers: Uses and advantages}{42}{subsection.0.1.15}%
\contentsline {subsection}{\numberline {1.16}STL Iterators}{43}{subsection.0.1.16}%
\contentsline {subsection}{\numberline {1.17}Complexity of container operations}{47}{subsection.0.1.17}%
\contentsline {section}{\numberline {2}STL Algorithms}{48}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}<algorithm>}{48}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}<numeric>}{49}{subsection.0.2.2}%
\contentsline {subsubsection}{\numberline {2.2.1}transform\_reduce}{49}{subsubsection.0.2.2.1}%
\contentsline {paragraph}{\numberline {2.2.1.1}Unary transform and reduce}{49}{paragraph.0.2.2.1.1}%
\contentsline {paragraph}{\numberline {2.2.1.2}Binary transform and reduce}{50}{paragraph.0.2.2.1.2}%
\contentsline {paragraph}{\numberline {2.2.1.3}std::plus<> and std::multiplies<>}{51}{paragraph.0.2.2.1.3}%
\contentsline {paragraph}{\numberline {2.2.1.4}Other key function objects}{51}{paragraph.0.2.2.1.4}%
\contentsline {section}{\numberline {3}Type traits}{53}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Nonstandard type of types}{53}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}::value, ::type, and ::value\_type}{54}{subsection.0.3.2}%
\contentsline {section}{\numberline {4}Function Objects}{55}{section.0.4}%
\contentsline {paragraph}{\numberline {4.0.0.1}Why?}{55}{paragraph.0.4.0.0.1}%
\contentsline {paragraph}{\numberline {4.0.0.2}Predefined function objects}{56}{paragraph.0.4.0.0.2}%
\contentsline {section}{\numberline {5}Decltype}{56}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}Syntax}{56}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}Example}{57}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}Things to pair with decltype}{57}{subsection.0.5.3}%
\contentsline {section}{\numberline {6}Constexpr}{58}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Variables}{58}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Functions}{58}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Object Constructors}{59}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}constexpr vs const}{59}{subsection.0.6.4}%
\contentsline {section}{\numberline {7}Function pointers and callable parametrs}{60}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Function pointers}{60}{subsection.0.7.1}%
\contentsline {subsubsection}{\numberline {7.1.1}As types}{60}{subsubsection.0.7.1.1}%
\contentsline {subsubsection}{\numberline {7.1.2}As function paramater}{60}{subsubsection.0.7.1.2}%
\contentsline {subsubsection}{\numberline {7.1.3}Function pointers to member functions}{61}{subsubsection.0.7.1.3}%
\contentsline {subsection}{\numberline {7.2}Using std::function}{62}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}With forwarding references}{62}{subsection.0.7.3}%
\contentsline {section}{\numberline {8}Templates}{63}{section.0.8}%
\contentsline {subsection}{\numberline {8.1}Template Function}{63}{subsection.0.8.1}%
\contentsline {subsection}{\numberline {8.2}Template Class}{64}{subsection.0.8.2}%
\contentsline {subsection}{\numberline {8.3}Class vs typename keyword}{64}{subsection.0.8.3}%
\contentsline {subsection}{\numberline {8.4}Handle friend functions}{64}{subsection.0.8.4}%
\contentsline {subsubsection}{\numberline {8.4.1}Friendship to a Non-Template Function}{64}{subsubsection.0.8.4.1}%
\contentsline {subsubsection}{\numberline {8.4.2}Friendship to a Template Function}{65}{subsubsection.0.8.4.2}%
\contentsline {subsection}{\numberline {8.5}Function Template Specialization}{67}{subsection.0.8.5}%
\contentsline {subsection}{\numberline {8.6}Class/Struct Template Specialization}{67}{subsection.0.8.6}%
\contentsline {subsection}{\numberline {8.7}Template Parameters}{67}{subsection.0.8.7}%
\contentsline {subsection}{\numberline {8.8}Trailing return type}{67}{subsection.0.8.8}%
\contentsline {subsubsection}{\numberline {8.8.1}Syntax}{68}{subsubsection.0.8.8.1}%
\contentsline {subsubsection}{\numberline {8.8.2}Example}{68}{subsubsection.0.8.8.2}%
\contentsline {subsection}{\numberline {8.9}Template functions with mixed types (Trailing return type)}{68}{subsection.0.8.9}%
\contentsline {subsection}{\numberline {8.10}Template functions with mixed types (Deduced return type)}{69}{subsection.0.8.10}%
\contentsline {subsection}{\numberline {8.11}Dependent name resolution}{69}{subsection.0.8.11}%
\contentsline {subsubsection}{\numberline {8.11.1}Dependent names}{69}{subsubsection.0.8.11.1}%
\contentsline {subsubsection}{\numberline {8.11.2}Typename Keyword}{69}{subsubsection.0.8.11.2}%
\contentsline {subsubsection}{\numberline {8.11.3}Nested types}{70}{subsubsection.0.8.11.3}%
\contentsline {subsubsection}{\numberline {8.11.4}Prereq: Using aliases defined in classes}{70}{subsubsection.0.8.11.4}%
\contentsline {subsubsection}{\numberline {8.11.5}Type Aliases}{71}{subsubsection.0.8.11.5}%
\contentsline {subsubsection}{\numberline {8.11.6}Return Types in Template Functions}{72}{subsubsection.0.8.11.6}%
\contentsline {subsubsection}{\numberline {8.11.7}Base Class Members}{72}{subsubsection.0.8.11.7}%
\contentsline {subsubsection}{\numberline {8.11.8}Dependent Types in Expressions}{72}{subsubsection.0.8.11.8}%
\contentsline {subsection}{\numberline {8.12}Variadic templates with functions}{72}{subsection.0.8.12}%
\contentsline {subsection}{\numberline {8.13}Left vs right folds}{76}{subsection.0.8.13}%
\contentsline {subsection}{\numberline {8.14}Parentheses in fold expressions}{77}{subsection.0.8.14}%
\contentsline {subsection}{\numberline {8.15}Pack size}{77}{subsection.0.8.15}%
\contentsline {subsection}{\numberline {8.16}Function calls in fold expressions}{78}{subsection.0.8.16}%
\contentsline {subsection}{\numberline {8.17}Variadic templates with classes}{79}{subsection.0.8.17}%
\contentsline {subsection}{\numberline {8.18}std::forward}{81}{subsection.0.8.18}%
\contentsline {subsubsection}{\numberline {8.18.1}Key Differences Between std::forward and std::move}{81}{subsubsection.0.8.18.1}%
\contentsline {subsection}{\numberline {8.19}Universal reference (forwarding reference)}{83}{subsection.0.8.19}%
\contentsline {section}{\numberline {9}More on the comma operator}{84}{section.0.9}%
\contentsline {section}{\numberline {10}More on Lambdas}{85}{section.0.10}%
\contentsline {subsection}{\numberline {10.1}Auto in lambda args}{85}{subsection.0.10.1}%
\contentsline {subsection}{\numberline {10.2}Template lambdas}{85}{subsection.0.10.2}%
\contentsline {subsection}{\numberline {10.3}Recursive lambdas}{86}{subsection.0.10.3}%
\contentsline {section}{\numberline {11}When initializer lists are required}{87}{section.0.11}%
\contentsline {section}{\numberline {12}Inheritence and Subtype Polymorphism}{88}{section.0.12}%
\contentsline {subsection}{\numberline {12.1}OOP Main Concepts}{88}{subsection.0.12.1}%
\contentsline {subsection}{\numberline {12.2}Object Relationships}{88}{subsection.0.12.2}%
\contentsline {subsection}{\numberline {12.3}Ineritance}{89}{subsection.0.12.3}%
\contentsline {subsection}{\numberline {12.4}Inheritance and Member Access}{89}{subsection.0.12.4}%
\contentsline {subsection}{\numberline {12.5}Inheritance Syntax}{90}{subsection.0.12.5}%
\contentsline {subsection}{\numberline {12.6}Upcasting and Downcasting}{91}{subsection.0.12.6}%
\contentsline {subsection}{\numberline {12.7}More on Downcasting}{92}{subsection.0.12.7}%
\contentsline {subsubsection}{\numberline {12.7.1}What Happens Without Virtual Functions}{93}{subsubsection.0.12.7.1}%
\contentsline {subsubsection}{\numberline {12.7.2}Downcasting example}{94}{subsubsection.0.12.7.2}%
\contentsline {subsubsection}{\numberline {12.7.3}Base class pointer example}{95}{subsubsection.0.12.7.3}%
\contentsline {subsection}{\numberline {12.8}Object Slicing}{95}{subsection.0.12.8}%
\contentsline {subsection}{\numberline {12.9}Multiple Inheritance}{97}{subsection.0.12.9}%
\contentsline {subsubsection}{\numberline {12.9.1}Why Use Multiple Inheritance?}{97}{subsubsection.0.12.9.1}%
\contentsline {subsubsection}{\numberline {12.9.2}Example}{97}{subsubsection.0.12.9.2}%
\contentsline {subsubsection}{\numberline {12.9.3}Issues with Multiple Inheritance}{98}{subsubsection.0.12.9.3}%
\contentsline {subsection}{\numberline {12.10}Virtual inheritance}{99}{subsection.0.12.10}%
\contentsline {subsubsection}{\numberline {12.10.1}The Diamond Problem}{99}{subsubsection.0.12.10.1}%
\contentsline {subsubsection}{\numberline {12.10.2}Solution with Virtual Inheritance}{100}{subsubsection.0.12.10.2}%
\contentsline {subsection}{\numberline {12.11}Subtype Polymorphism}{100}{subsection.0.12.11}%
\contentsline {subsection}{\numberline {12.12}Declaring Virtual Member Functions}{101}{subsection.0.12.12}%
\contentsline {subsubsection}{\numberline {12.12.1}The override keyword}{101}{subsubsection.0.12.12.1}%
\contentsline {subsection}{\numberline {12.13}Abstract or Pure virtual Member Functions}{102}{subsection.0.12.13}%
\contentsline {subsection}{\numberline {12.14}Abstract Classes}{102}{subsection.0.12.14}%
\contentsline {subsection}{\numberline {12.15}Interface Inheritance}{103}{subsection.0.12.15}%
\contentsline {section}{\numberline {13}<regex.h> Pattern Matching and String Validation}{104}{section.0.13}%
\contentsline {subsection}{\numberline {13.1}regcomp}{104}{subsection.0.13.1}%
\contentsline {subsubsection}{\numberline {13.1.1}Signature}{104}{subsubsection.0.13.1.1}%
\contentsline {subsubsection}{\numberline {13.1.2}Return value}{104}{subsubsection.0.13.1.2}%
\contentsline {subsubsection}{\numberline {13.1.3}Return errors}{104}{subsubsection.0.13.1.3}%
\contentsline {subsubsection}{\numberline {13.1.4}Flags}{105}{subsubsection.0.13.1.4}%
\contentsline {subsection}{\numberline {13.2}Regexec}{105}{subsection.0.13.2}%
\contentsline {subsubsection}{\numberline {13.2.1}Signature}{106}{subsubsection.0.13.2.1}%
\contentsline {subsubsection}{\numberline {13.2.2}Return value}{106}{subsubsection.0.13.2.2}%
\contentsline {subsection}{\numberline {13.3}Regerror}{106}{subsection.0.13.3}%
\contentsline {subsubsection}{\numberline {13.3.1}Signature}{106}{subsubsection.0.13.3.1}%
\contentsline {subsubsection}{\numberline {13.3.2}Return value}{107}{subsubsection.0.13.3.2}%
\contentsline {subsection}{\numberline {13.4}Regfree}{107}{subsection.0.13.4}%
\contentsline {subsubsection}{\numberline {13.4.1}Signature}{107}{subsubsection.0.13.4.1}%
\contentsline {subsection}{\numberline {13.5}regmatch\_t and pmatch}{108}{subsection.0.13.5}%
\contentsline {subsubsection}{\numberline {13.5.1}regmatch\_t}{108}{subsubsection.0.13.5.1}%
\contentsline {subsubsection}{\numberline {13.5.2}pmatch array}{109}{subsubsection.0.13.5.2}%
\contentsline {subsection}{\numberline {13.6}Regex Example}{109}{subsection.0.13.6}%
\contentsline {section}{\numberline {14}Structured bindings}{112}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}As unpacks}{112}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}With returning}{112}{subsection.0.14.2}%
\contentsline {subsection}{\numberline {14.3}With structs and classes}{113}{subsection.0.14.3}%
\contentsline {subsection}{\numberline {14.4}With maps}{113}{subsection.0.14.4}%
\contentsline {section}{\numberline {15}Attributes in c++}{114}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}General Attributes}{114}{subsection.0.15.1}%
\contentsline {section}{\numberline {16}Inline functions}{117}{section.0.16}%
\contentsline {section}{\numberline {17}Advanced iterator usage}{118}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}base()}{118}{subsection.0.17.1}%
\contentsline {section}{\numberline {18}Regular expressions in c++}{119}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}Basic components}{119}{subsection.0.18.1}%
\contentsline {subsubsection}{\numberline {18.1.1}The regex object}{119}{subsubsection.0.18.1.1}%
\contentsline {subsubsection}{\numberline {18.1.2}The smatch array}{119}{subsubsection.0.18.1.2}%
\contentsline {subsubsection}{\numberline {18.1.3}regex\_match}{120}{subsubsection.0.18.1.3}%
\contentsline {subsubsection}{\numberline {18.1.4}regex\_search}{120}{subsubsection.0.18.1.4}%
\contentsline {subsubsection}{\numberline {18.1.5}regex\_replace}{122}{subsubsection.0.18.1.5}%
\contentsline {subsection}{\numberline {18.2}match\_results}{122}{subsection.0.18.2}%
\contentsline {subsubsection}{\numberline {18.2.1}Methods}{122}{subsubsection.0.18.2.1}%
\contentsline {subsection}{\numberline {18.3}sub\_match}{123}{subsection.0.18.3}%
\contentsline {subsection}{\numberline {18.4}Passing string iterators}{124}{subsection.0.18.4}%
\contentsline {subsubsection}{\numberline {18.4.1}Getting all matches}{124}{subsubsection.0.18.4.1}%
\contentsline {subsection}{\numberline {18.5}smatch prefix and suffix}{125}{subsection.0.18.5}%
\contentsline {section}{\numberline {19}Standard namespace}{127}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}std::bind}{127}{subsection.0.19.1}%
\contentsline {subsubsection}{\numberline {19.1.1}std::placeholders}{127}{subsubsection.0.19.1.1}%
\contentsline {subsubsection}{\numberline {19.1.2}Using std::ref with bind}{128}{subsubsection.0.19.1.2}%
\contentsline {subsection}{\numberline {19.2}std::invoke}{129}{subsection.0.19.2}%
\contentsline {subsubsection}{\numberline {19.2.1}Calling a regular function}{129}{subsubsection.0.19.2.1}%
\contentsline {subsubsection}{\numberline {19.2.2}Calling a member function}{129}{subsubsection.0.19.2.2}%
\contentsline {subsubsection}{\numberline {19.2.3}Accessing a member variable}{130}{subsubsection.0.19.2.3}%
\contentsline {subsubsection}{\numberline {19.2.4}Calling a lambda}{130}{subsubsection.0.19.2.4}%
\contentsline {subsection}{\numberline {19.3}std::exchange}{131}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}std::swap}{132}{subsection.0.19.4}%
\contentsline {subsection}{\numberline {19.5}std::get}{133}{subsection.0.19.5}%
\contentsline {subsection}{\numberline {19.6}std::tuple}{134}{subsection.0.19.6}%
\contentsline {subsubsection}{\numberline {19.6.1}std::tuple and std::make\_tuple}{134}{subsubsection.0.19.6.1}%
\contentsline {subsubsection}{\numberline {19.6.2}Modifying elements}{134}{subsubsection.0.19.6.2}%
\contentsline {subsubsection}{\numberline {19.6.3}std::tuple\_size}{134}{subsubsection.0.19.6.3}%
\contentsline {subsubsection}{\numberline {19.6.4}Unpacking with std::tie}{135}{subsubsection.0.19.6.4}%
\contentsline {subsubsection}{\numberline {19.6.5}std::tie with std::ignore}{135}{subsubsection.0.19.6.5}%
