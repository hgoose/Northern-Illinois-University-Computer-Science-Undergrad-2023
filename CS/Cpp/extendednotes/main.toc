\contentsline {section}{\numberline {1}STL Containers}{6}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}STL Vectors}{6}{subsection.0.1.1}%
\contentsline {subsubsection}{\numberline {1.1.1}Implementation}{6}{subsubsection.0.1.1.1}%
\contentsline {subsubsection}{\numberline {1.1.2}Performance in operations on the end}{6}{subsubsection.0.1.1.2}%
\contentsline {subsubsection}{\numberline {1.1.3}Size and capacity}{6}{subsubsection.0.1.1.3}%
\contentsline {subsubsection}{\numberline {1.1.4}Constructors}{7}{subsubsection.0.1.1.4}%
\contentsline {subsubsection}{\numberline {1.1.5}Note about at()}{8}{subsubsection.0.1.1.5}%
\contentsline {subsubsection}{\numberline {1.1.6}Iterator methods}{8}{subsubsection.0.1.1.6}%
\contentsline {subsubsection}{\numberline {1.1.7}Using vectors as 2d arrays}{8}{subsubsection.0.1.1.7}%
\contentsline {subsubsection}{\numberline {1.1.8}For those interested}{10}{subsubsection.0.1.1.8}%
\contentsline {paragraph}{\numberline {1.1.8.1}Manual Dynamic Memory Allocation (Using new)}{10}{paragraph.0.1.1.8.1}%
\contentsline {paragraph}{\numberline {1.1.8.2}Using unique pointer}{10}{paragraph.0.1.1.8.2}%
\contentsline {paragraph}{\numberline {1.1.8.3}Recall: Unique pointer for dynamic arry}{11}{paragraph.0.1.1.8.3}%
\contentsline {paragraph}{\numberline {1.1.8.4}If sizes are truly known at compile time}{12}{paragraph.0.1.1.8.4}%
\contentsline {subsection}{\numberline {1.2}STL Deque}{13}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Implementation}{13}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Abilities, performance, uses}{13}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}When to use deques}{13}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}Constructors}{14}{subsubsection.0.1.2.4}%
\contentsline {subsection}{\numberline {1.3}STL Lists}{15}{subsection.0.1.3}%
\contentsline {subsubsection}{\numberline {1.3.1}Implementation}{15}{subsubsection.0.1.3.1}%
\contentsline {subsubsection}{\numberline {1.3.2}Abilities}{15}{subsubsection.0.1.3.2}%
\contentsline {subsubsection}{\numberline {1.3.3}Differencs in the methods}{15}{subsubsection.0.1.3.3}%
\contentsline {subsubsection}{\numberline {1.3.4}Constructors}{16}{subsubsection.0.1.3.4}%
\contentsline {subsubsection}{\numberline {1.3.5}Element access}{16}{subsubsection.0.1.3.5}%
\contentsline {subsubsection}{\numberline {1.3.6}Iterator functions}{16}{subsubsection.0.1.3.6}%
\contentsline {subsubsection}{\numberline {1.3.7}Splice Functions and Functions to Change the Order of Elements}{17}{subsubsection.0.1.3.7}%
\contentsline {subsection}{\numberline {1.4}STL Forward lists}{18}{subsection.0.1.4}%
\contentsline {subsubsection}{\numberline {1.4.1}Implementation}{18}{subsubsection.0.1.4.1}%
\contentsline {subsubsection}{\numberline {1.4.2}Abilities, limitations}{18}{subsubsection.0.1.4.2}%
\contentsline {subsubsection}{\numberline {1.4.3}No size()?}{19}{subsubsection.0.1.4.3}%
\contentsline {subsubsection}{\numberline {1.4.4}Similarities to list}{19}{subsubsection.0.1.4.4}%
\contentsline {subsubsection}{\numberline {1.4.5}Constructors}{20}{subsubsection.0.1.4.5}%
\contentsline {subsection}{\numberline {1.5}STL Sets and multisets}{21}{subsection.0.1.5}%
\contentsline {subsubsection}{\numberline {1.5.1}Implementation}{21}{subsubsection.0.1.5.1}%
\contentsline {subsubsection}{\numberline {1.5.2}Strict weak ordering}{21}{subsubsection.0.1.5.2}%
\contentsline {subsubsection}{\numberline {1.5.3}Abilities}{22}{subsubsection.0.1.5.3}%
\contentsline {subsubsection}{\numberline {1.5.4}Changing elements directly, no direct element access}{22}{subsubsection.0.1.5.4}%
\contentsline {subsubsection}{\numberline {1.5.5}Constructors}{22}{subsubsection.0.1.5.5}%
\contentsline {subsubsection}{\numberline {1.5.6}Types}{23}{subsubsection.0.1.5.6}%
\contentsline {subsubsection}{\numberline {1.5.7}Constructors}{24}{subsubsection.0.1.5.7}%
\contentsline {subsection}{\numberline {1.6}STL Maps and multimaps}{25}{subsection.0.1.6}%
\contentsline {subsubsection}{\numberline {1.6.1}Implementation}{25}{subsubsection.0.1.6.1}%
\contentsline {subsubsection}{\numberline {1.6.2}Template parameters}{25}{subsubsection.0.1.6.2}%
\contentsline {subsubsection}{\numberline {1.6.3}Abilities}{25}{subsubsection.0.1.6.3}%
\contentsline {subsubsection}{\numberline {1.6.4}Constructors and types}{26}{subsubsection.0.1.6.4}%
\contentsline {subsubsection}{\numberline {1.6.5}Using maps as associative arrays}{27}{subsubsection.0.1.6.5}%
\contentsline {subsubsection}{\numberline {1.6.6}Constructors}{27}{subsubsection.0.1.6.6}%
\contentsline {subsection}{\numberline {1.7}Example of bounds and equal range}{29}{subsection.0.1.7}%
\contentsline {subsection}{\numberline {1.8}STL Unordered containers}{30}{subsection.0.1.8}%
\contentsline {subsubsection}{\numberline {1.8.1}Implementation}{30}{subsubsection.0.1.8.1}%
\contentsline {subsubsection}{\numberline {1.8.2}Abilities}{30}{subsubsection.0.1.8.2}%
\contentsline {subsubsection}{\numberline {1.8.3}Disadvantages}{31}{subsubsection.0.1.8.3}%
\contentsline {subsection}{\numberline {1.9}STL Containers: Implementations}{32}{subsection.0.1.9}%
\contentsline {subsection}{\numberline {1.10}STL Containers: Iterator Functions}{33}{subsection.0.1.10}%
\contentsline {subsection}{\numberline {1.11}STL containers: Main concepts, differences, uses}{34}{subsection.0.1.11}%
\contentsline {subsection}{\numberline {1.12}STL Containers: Iterator invalidation}{36}{subsection.0.1.12}%
\contentsline {subsection}{\numberline {1.13}STL Containers: Reallocation}{37}{subsection.0.1.13}%
\contentsline {subsection}{\numberline {1.14}STL Containers: Element access}{38}{subsection.0.1.14}%
\contentsline {subsection}{\numberline {1.15}STL Containers: Uses and advantages}{39}{subsection.0.1.15}%
\contentsline {subsection}{\numberline {1.16}STL Iterators}{40}{subsection.0.1.16}%
\contentsline {subsection}{\numberline {1.17}Complexity of container operations}{44}{subsection.0.1.17}%
\contentsline {section}{\numberline {2}STL Algorithms}{45}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}<algorithm>}{45}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}<numeric>}{46}{subsection.0.2.2}%
\contentsline {subsubsection}{\numberline {2.2.1}transform\_reduce}{46}{subsubsection.0.2.2.1}%
\contentsline {paragraph}{\numberline {2.2.1.1}Unary transform and reduce}{46}{paragraph.0.2.2.1.1}%
\contentsline {paragraph}{\numberline {2.2.1.2}Binary transform and reduce}{47}{paragraph.0.2.2.1.2}%
\contentsline {paragraph}{\numberline {2.2.1.3}std::plus<> and std::multiplies<>}{48}{paragraph.0.2.2.1.3}%
\contentsline {paragraph}{\numberline {2.2.1.4}Other key function objects}{48}{paragraph.0.2.2.1.4}%
\contentsline {section}{\numberline {3}Function Objects}{50}{section.0.3}%
\contentsline {paragraph}{\numberline {3.0.0.1}Why?}{50}{paragraph.0.3.0.0.1}%
\contentsline {paragraph}{\numberline {3.0.0.2}Predefined function objects}{51}{paragraph.0.3.0.0.2}%
\contentsline {section}{\numberline {4}Templates}{52}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Template Function}{52}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Template Class}{53}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Class vs typename keyword}{53}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Handle friend functions}{53}{subsection.0.4.4}%
\contentsline {subsubsection}{\numberline {4.4.1}Friendship to a Non-Template Function}{53}{subsubsection.0.4.4.1}%
\contentsline {subsubsection}{\numberline {4.4.2}Friendship to a Template Function}{54}{subsubsection.0.4.4.2}%
\contentsline {subsection}{\numberline {4.5}Function Template Specialization}{56}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Class/Struct Template Specialization}{56}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}Template Parameters}{56}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}Trailing return type}{56}{subsection.0.4.8}%
\contentsline {subsubsection}{\numberline {4.8.1}Syntax}{57}{subsubsection.0.4.8.1}%
\contentsline {subsubsection}{\numberline {4.8.2}Example}{57}{subsubsection.0.4.8.2}%
\contentsline {subsection}{\numberline {4.9}decltype}{57}{subsection.0.4.9}%
\contentsline {subsubsection}{\numberline {4.9.1}Syntax}{57}{subsubsection.0.4.9.1}%
\contentsline {subsubsection}{\numberline {4.9.2}Example}{57}{subsubsection.0.4.9.2}%
\contentsline {subsection}{\numberline {4.10}Template functions with mixed types (Trailing return type)}{58}{subsection.0.4.10}%
\contentsline {subsection}{\numberline {4.11}Template functions with mixed types (Deduced return type)}{59}{subsection.0.4.11}%
\contentsline {subsection}{\numberline {4.12}Dependent name resolution}{59}{subsection.0.4.12}%
\contentsline {subsubsection}{\numberline {4.12.1}Dependent names}{59}{subsubsection.0.4.12.1}%
\contentsline {subsubsection}{\numberline {4.12.2}Typename Keyword}{59}{subsubsection.0.4.12.2}%
\contentsline {subsubsection}{\numberline {4.12.3}Nested types}{60}{subsubsection.0.4.12.3}%
\contentsline {subsubsection}{\numberline {4.12.4}Prereq: Using aliases defined in classes}{60}{subsubsection.0.4.12.4}%
\contentsline {subsubsection}{\numberline {4.12.5}Type Aliases}{61}{subsubsection.0.4.12.5}%
\contentsline {subsubsection}{\numberline {4.12.6}Return Types in Template Functions}{62}{subsubsection.0.4.12.6}%
\contentsline {subsubsection}{\numberline {4.12.7}Base Class Members}{62}{subsubsection.0.4.12.7}%
\contentsline {subsubsection}{\numberline {4.12.8}Dependent Types in Expressions}{62}{subsubsection.0.4.12.8}%
\contentsline {section}{\numberline {5}Lambdas}{63}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}Auto in lambda args}{63}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}Template lambdas}{63}{subsection.0.5.2}%
\contentsline {section}{\numberline {6}When initializer lists are required}{64}{section.0.6}%
\contentsline {section}{\numberline {7}Inheritence and Subtype Polymorphism}{65}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}OOP Main Concepts}{65}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Object Relationships}{65}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}Ineritance}{66}{subsection.0.7.3}%
\contentsline {subsection}{\numberline {7.4}Inheritance and Member Access}{66}{subsection.0.7.4}%
\contentsline {subsection}{\numberline {7.5}Inheritance Syntax}{67}{subsection.0.7.5}%
\contentsline {subsection}{\numberline {7.6}Upcasting and Downcasting}{68}{subsection.0.7.6}%
\contentsline {subsection}{\numberline {7.7}More on Downcasting}{69}{subsection.0.7.7}%
\contentsline {subsubsection}{\numberline {7.7.1}What Happens Without Virtual Functions}{70}{subsubsection.0.7.7.1}%
\contentsline {subsubsection}{\numberline {7.7.2}Downcasting example}{71}{subsubsection.0.7.7.2}%
\contentsline {subsubsection}{\numberline {7.7.3}Base class pointer example}{72}{subsubsection.0.7.7.3}%
\contentsline {subsection}{\numberline {7.8}Object Slicing}{72}{subsection.0.7.8}%
\contentsline {subsection}{\numberline {7.9}Multiple Inheritance}{74}{subsection.0.7.9}%
\contentsline {subsubsection}{\numberline {7.9.1}Why Use Multiple Inheritance?}{74}{subsubsection.0.7.9.1}%
\contentsline {subsubsection}{\numberline {7.9.2}Example}{74}{subsubsection.0.7.9.2}%
\contentsline {subsubsection}{\numberline {7.9.3}Issues with Multiple Inheritance}{75}{subsubsection.0.7.9.3}%
\contentsline {subsection}{\numberline {7.10}Virtual inheritance}{76}{subsection.0.7.10}%
\contentsline {subsubsection}{\numberline {7.10.1}The Diamond Problem}{76}{subsubsection.0.7.10.1}%
\contentsline {subsubsection}{\numberline {7.10.2}Solution with Virtual Inheritance}{77}{subsubsection.0.7.10.2}%
\contentsline {subsection}{\numberline {7.11}Subtype Polymorphism}{77}{subsection.0.7.11}%
\contentsline {subsection}{\numberline {7.12}Declaring Virtual Member Functions}{78}{subsection.0.7.12}%
\contentsline {subsubsection}{\numberline {7.12.1}The override keyword}{78}{subsubsection.0.7.12.1}%
\contentsline {subsection}{\numberline {7.13}Abstract or Pure virtual Member Functions}{79}{subsection.0.7.13}%
\contentsline {subsection}{\numberline {7.14}Abstract Classes}{79}{subsection.0.7.14}%
\contentsline {subsection}{\numberline {7.15}Interface Inheritance}{80}{subsection.0.7.15}%
\contentsline {section}{\numberline {8}<regex.h> Pattern Matching and String Validation}{81}{section.0.8}%
\contentsline {subsection}{\numberline {8.1}regcomp}{81}{subsection.0.8.1}%
\contentsline {subsubsection}{\numberline {8.1.1}Signature}{81}{subsubsection.0.8.1.1}%
\contentsline {subsubsection}{\numberline {8.1.2}Return value}{81}{subsubsection.0.8.1.2}%
\contentsline {subsubsection}{\numberline {8.1.3}Return errors}{81}{subsubsection.0.8.1.3}%
\contentsline {subsubsection}{\numberline {8.1.4}Flags}{82}{subsubsection.0.8.1.4}%
\contentsline {subsection}{\numberline {8.2}Regexec}{82}{subsection.0.8.2}%
\contentsline {subsubsection}{\numberline {8.2.1}Signature}{83}{subsubsection.0.8.2.1}%
\contentsline {subsubsection}{\numberline {8.2.2}Return value}{83}{subsubsection.0.8.2.2}%
\contentsline {subsection}{\numberline {8.3}Regerror}{83}{subsection.0.8.3}%
\contentsline {subsubsection}{\numberline {8.3.1}Signature}{83}{subsubsection.0.8.3.1}%
\contentsline {subsubsection}{\numberline {8.3.2}Return value}{84}{subsubsection.0.8.3.2}%
\contentsline {subsection}{\numberline {8.4}Regfree}{84}{subsection.0.8.4}%
\contentsline {subsubsection}{\numberline {8.4.1}Signature}{84}{subsubsection.0.8.4.1}%
\contentsline {subsection}{\numberline {8.5}regmatch\_t and pmatch}{85}{subsection.0.8.5}%
\contentsline {subsubsection}{\numberline {8.5.1}regmatch_t}{85}{subsubsection.0.8.5.1}%
\contentsline {subsubsection}{\numberline {8.5.2}pmatch array}{86}{subsubsection.0.8.5.2}%
\contentsline {subsection}{\numberline {8.6}Regex Example}{86}{subsection.0.8.6}%
