\contentsline {section}{\numberline {1}The STL}{6}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}STL Vectors}{6}{subsection.0.1.1}%
\contentsline {subsubsection}{\numberline {1.1.1}Implementation}{6}{subsubsection.0.1.1.1}%
\contentsline {subsubsection}{\numberline {1.1.2}Performance in operations on the end}{6}{subsubsection.0.1.1.2}%
\contentsline {subsubsection}{\numberline {1.1.3}Size and capacity}{6}{subsubsection.0.1.1.3}%
\contentsline {subsubsection}{\numberline {1.1.4}Constructors}{7}{subsubsection.0.1.1.4}%
\contentsline {subsubsection}{\numberline {1.1.5}Note about at()}{8}{subsubsection.0.1.1.5}%
\contentsline {subsubsection}{\numberline {1.1.6}Iterator methods}{8}{subsubsection.0.1.1.6}%
\contentsline {subsubsection}{\numberline {1.1.7}Using vectors as 2d arrays}{8}{subsubsection.0.1.1.7}%
\contentsline {subsubsection}{\numberline {1.1.8}For those interested}{10}{subsubsection.0.1.1.8}%
\contentsline {paragraph}{\numberline {1.1.8.1}Manual Dynamic Memory Allocation (Using new)}{10}{paragraph.0.1.1.8.1}%
\contentsline {paragraph}{\numberline {1.1.8.2}Using unique pointer}{10}{paragraph.0.1.1.8.2}%
\contentsline {paragraph}{\numberline {1.1.8.3}Recall: Unique pointer for dynamic arry}{11}{paragraph.0.1.1.8.3}%
\contentsline {paragraph}{\numberline {1.1.8.4}If sizes are truly known at compile time}{12}{paragraph.0.1.1.8.4}%
\contentsline {subsection}{\numberline {1.2}STL Deque}{13}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Implementation}{13}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Abilities, performance, uses}{13}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}When to use deques}{13}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}Constructors}{14}{subsubsection.0.1.2.4}%
\contentsline {subsection}{\numberline {1.3}STL Lists}{15}{subsection.0.1.3}%
\contentsline {subsubsection}{\numberline {1.3.1}Implementation}{15}{subsubsection.0.1.3.1}%
\contentsline {subsubsection}{\numberline {1.3.2}Abilities}{15}{subsubsection.0.1.3.2}%
\contentsline {subsubsection}{\numberline {1.3.3}Differencs in the methods}{15}{subsubsection.0.1.3.3}%
\contentsline {subsubsection}{\numberline {1.3.4}Constructors}{16}{subsubsection.0.1.3.4}%
\contentsline {subsubsection}{\numberline {1.3.5}Element access}{16}{subsubsection.0.1.3.5}%
\contentsline {subsubsection}{\numberline {1.3.6}Iterator functions}{16}{subsubsection.0.1.3.6}%
\contentsline {subsubsection}{\numberline {1.3.7}Splice Functions and Functions to Change the Order of Elements}{17}{subsubsection.0.1.3.7}%
\contentsline {subsection}{\numberline {1.4}STL Forward lists}{18}{subsection.0.1.4}%
\contentsline {subsubsection}{\numberline {1.4.1}Implementation}{18}{subsubsection.0.1.4.1}%
\contentsline {subsubsection}{\numberline {1.4.2}Abilities, limitations}{18}{subsubsection.0.1.4.2}%
\contentsline {subsubsection}{\numberline {1.4.3}No size()?}{19}{subsubsection.0.1.4.3}%
\contentsline {subsubsection}{\numberline {1.4.4}Similarities to list}{19}{subsubsection.0.1.4.4}%
\contentsline {subsubsection}{\numberline {1.4.5}Constructors}{20}{subsubsection.0.1.4.5}%
\contentsline {subsection}{\numberline {1.5}STL Sets and multisets}{21}{subsection.0.1.5}%
\contentsline {subsubsection}{\numberline {1.5.1}Implementation}{21}{subsubsection.0.1.5.1}%
\contentsline {subsubsection}{\numberline {1.5.2}Strict weak ordering}{21}{subsubsection.0.1.5.2}%
\contentsline {subsubsection}{\numberline {1.5.3}Abilities}{22}{subsubsection.0.1.5.3}%
\contentsline {subsubsection}{\numberline {1.5.4}Changing elements directly, no direct element access}{22}{subsubsection.0.1.5.4}%
\contentsline {subsubsection}{\numberline {1.5.5}Constructors}{22}{subsubsection.0.1.5.5}%
\contentsline {subsubsection}{\numberline {1.5.6}Types}{23}{subsubsection.0.1.5.6}%
\contentsline {subsection}{\numberline {1.6}STL Maps and multimaps}{24}{subsection.0.1.6}%
\contentsline {subsubsection}{\numberline {1.6.1}Implementation}{24}{subsubsection.0.1.6.1}%
\contentsline {subsubsection}{\numberline {1.6.2}Template parameters}{24}{subsubsection.0.1.6.2}%
\contentsline {subsubsection}{\numberline {1.6.3}Abilities}{24}{subsubsection.0.1.6.3}%
\contentsline {subsubsection}{\numberline {1.6.4}Constructors and types}{25}{subsubsection.0.1.6.4}%
\contentsline {subsubsection}{\numberline {1.6.5}Using maps as associative arrays}{26}{subsubsection.0.1.6.5}%
\contentsline {subsection}{\numberline {1.7}STL Unordered containers}{27}{subsection.0.1.7}%
\contentsline {subsubsection}{\numberline {1.7.1}Implementation}{27}{subsubsection.0.1.7.1}%
\contentsline {subsubsection}{\numberline {1.7.2}Abilities}{27}{subsubsection.0.1.7.2}%
\contentsline {subsubsection}{\numberline {1.7.3}Disadvantages}{28}{subsubsection.0.1.7.3}%
\contentsline {subsection}{\numberline {1.8}STL Containers: Implementations}{29}{subsection.0.1.8}%
\contentsline {subsection}{\numberline {1.9}STL Containers: Iterator Functions}{30}{subsection.0.1.9}%
\contentsline {subsection}{\numberline {1.10}STL containers: Main concepts, differences, uses}{31}{subsection.0.1.10}%
\contentsline {subsection}{\numberline {1.11}STL Containers: Iterator invalidation}{33}{subsection.0.1.11}%
\contentsline {subsection}{\numberline {1.12}STL Containers: Reallocation}{34}{subsection.0.1.12}%
\contentsline {subsection}{\numberline {1.13}STL Containers: Element access}{35}{subsection.0.1.13}%
\contentsline {subsection}{\numberline {1.14}STL Containers: Uses and advantages}{36}{subsection.0.1.14}%
\contentsline {subsection}{\numberline {1.15}STL Iterators}{37}{subsection.0.1.15}%
\contentsline {subsection}{\numberline {1.16}STL Function Objects}{41}{subsection.0.1.16}%
\contentsline {paragraph}{\numberline {1.16.0.1}Why?}{41}{paragraph.0.1.16.0.1}%
\contentsline {paragraph}{\numberline {1.16.0.2}Predefined function objects}{42}{paragraph.0.1.16.0.2}%
\contentsline {section}{\numberline {2}Templates}{43}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Template Function}{43}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Template Class}{44}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Class vs typename keyword}{44}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Handle friend functions}{44}{subsection.0.2.4}%
\contentsline {subsubsection}{\numberline {2.4.1}Friendship to a Non-Template Function}{44}{subsubsection.0.2.4.1}%
\contentsline {subsubsection}{\numberline {2.4.2}Friendship to a Template Function}{45}{subsubsection.0.2.4.2}%
\contentsline {subsection}{\numberline {2.5}Function Template Specialization}{47}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Class/Struct Template Specialization}{47}{subsection.0.2.6}%
\contentsline {subsection}{\numberline {2.7}Template Parameters}{47}{subsection.0.2.7}%
\contentsline {subsection}{\numberline {2.8}Trailing return type}{47}{subsection.0.2.8}%
\contentsline {subsubsection}{\numberline {2.8.1}Syntax}{48}{subsubsection.0.2.8.1}%
\contentsline {subsubsection}{\numberline {2.8.2}Example}{48}{subsubsection.0.2.8.2}%
\contentsline {subsection}{\numberline {2.9}decltype}{48}{subsection.0.2.9}%
\contentsline {subsubsection}{\numberline {2.9.1}Syntax}{48}{subsubsection.0.2.9.1}%
\contentsline {subsubsection}{\numberline {2.9.2}Example}{48}{subsubsection.0.2.9.2}%
\contentsline {subsection}{\numberline {2.10}Template functions with mixed types (Trailing return type)}{49}{subsection.0.2.10}%
\contentsline {subsection}{\numberline {2.11}Template functions with mixed types (Deduced return type)}{50}{subsection.0.2.11}%
\contentsline {subsection}{\numberline {2.12}Dependent name resolution}{50}{subsection.0.2.12}%
\contentsline {subsubsection}{\numberline {2.12.1}Dependent names}{50}{subsubsection.0.2.12.1}%
\contentsline {subsubsection}{\numberline {2.12.2}Typename Keyword}{50}{subsubsection.0.2.12.2}%
\contentsline {subsubsection}{\numberline {2.12.3}Nested types}{51}{subsubsection.0.2.12.3}%
\contentsline {subsubsection}{\numberline {2.12.4}Prereq: Using aliases defined in classes}{51}{subsubsection.0.2.12.4}%
\contentsline {subsubsection}{\numberline {2.12.5}Type Aliases}{52}{subsubsection.0.2.12.5}%
\contentsline {subsubsection}{\numberline {2.12.6}Return Types in Template Functions}{53}{subsubsection.0.2.12.6}%
\contentsline {subsubsection}{\numberline {2.12.7}Base Class Members}{53}{subsubsection.0.2.12.7}%
\contentsline {subsubsection}{\numberline {2.12.8}Dependent Types in Expressions}{53}{subsubsection.0.2.12.8}%
\contentsline {section}{\numberline {3}When initializer lists are required}{54}{section.0.3}%
\contentsline {section}{\numberline {4}Inheritence and Subtype Polymorphism}{55}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}OOP Main Concepts}{55}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Object Relationships}{55}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Ineritance}{56}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Inheritance and Member Access}{56}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Inheritance Syntax}{57}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Upcasting and Downcasting}{58}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}More on Downcasting}{59}{subsection.0.4.7}%
\contentsline {subsubsection}{\numberline {4.7.1}What Happens Without Virtual Functions}{60}{subsubsection.0.4.7.1}%
\contentsline {subsubsection}{\numberline {4.7.2}Downcasting example}{61}{subsubsection.0.4.7.2}%
\contentsline {subsubsection}{\numberline {4.7.3}Base class pointer example}{62}{subsubsection.0.4.7.3}%
\contentsline {subsection}{\numberline {4.8}Object Slicing}{62}{subsection.0.4.8}%
\contentsline {subsection}{\numberline {4.9}Multiple Inheritance}{64}{subsection.0.4.9}%
\contentsline {subsubsection}{\numberline {4.9.1}Why Use Multiple Inheritance?}{64}{subsubsection.0.4.9.1}%
\contentsline {subsubsection}{\numberline {4.9.2}Example}{64}{subsubsection.0.4.9.2}%
\contentsline {subsubsection}{\numberline {4.9.3}Issues with Multiple Inheritance}{65}{subsubsection.0.4.9.3}%
\contentsline {subsection}{\numberline {4.10}Virtual inheritance}{66}{subsection.0.4.10}%
\contentsline {subsubsection}{\numberline {4.10.1}The Diamond Problem}{66}{subsubsection.0.4.10.1}%
\contentsline {subsubsection}{\numberline {4.10.2}Solution with Virtual Inheritance}{67}{subsubsection.0.4.10.2}%
\contentsline {subsection}{\numberline {4.11}Subtype Polymorphism}{67}{subsection.0.4.11}%
\contentsline {subsection}{\numberline {4.12}Declaring Virtual Member Functions}{68}{subsection.0.4.12}%
\contentsline {subsubsection}{\numberline {4.12.1}The override keyword}{68}{subsubsection.0.4.12.1}%
\contentsline {subsection}{\numberline {4.13}Abstract or Pure virtual Member Functions}{69}{subsection.0.4.13}%
\contentsline {subsection}{\numberline {4.14}Abstract Classes}{69}{subsection.0.4.14}%
\contentsline {subsection}{\numberline {4.15}Interface Inheritance}{70}{subsection.0.4.15}%
\contentsline {section}{\numberline {5}<regex.h> Pattern Matching and String Validation}{71}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}regcomp}{71}{subsection.0.5.1}%
\contentsline {subsubsection}{\numberline {5.1.1}Signature}{71}{subsubsection.0.5.1.1}%
\contentsline {subsubsection}{\numberline {5.1.2}Return value}{71}{subsubsection.0.5.1.2}%
\contentsline {subsubsection}{\numberline {5.1.3}Return errors}{71}{subsubsection.0.5.1.3}%
\contentsline {subsubsection}{\numberline {5.1.4}Flags}{72}{subsubsection.0.5.1.4}%
\contentsline {subsection}{\numberline {5.2}Regexec}{72}{subsection.0.5.2}%
\contentsline {subsubsection}{\numberline {5.2.1}Signature}{73}{subsubsection.0.5.2.1}%
\contentsline {subsubsection}{\numberline {5.2.2}Return value}{73}{subsubsection.0.5.2.2}%
\contentsline {subsection}{\numberline {5.3}Regerror}{73}{subsection.0.5.3}%
\contentsline {subsubsection}{\numberline {5.3.1}Signature}{73}{subsubsection.0.5.3.1}%
\contentsline {subsubsection}{\numberline {5.3.2}Return value}{73}{subsubsection.0.5.3.2}%
\contentsline {subsection}{\numberline {5.4}Regfree}{74}{subsection.0.5.4}%
\contentsline {subsubsection}{\numberline {5.4.1}Signature}{74}{subsubsection.0.5.4.1}%
\contentsline {subsection}{\numberline {5.5}regmatch\_t and pmatch}{75}{subsection.0.5.5}%
\contentsline {subsubsection}{\numberline {5.5.1}regmatch\_t}{75}{subsubsection.0.5.5.1}%
\contentsline {subsubsection}{\numberline {5.5.2}pmatch array}{76}{subsubsection.0.5.5.2}%
\contentsline {subsection}{\numberline {5.6}Regex Example}{76}{subsection.0.5.6}%
