\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Second Cpp Notes}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Extended CPP Notes}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           April 17, 2024 \\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
   \pagebreak 
   \unsect{STL Containers}
   \subsection{STL Vectors}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent 
   A vector models a dynamic array. Thus, a vector is an abstraction that manages its elements with a dynamic C-style arra
   \bigbreak \noindent 
   A vector copies its elements into its internal dynamic array. The elements always have a certain order. Thus, a vector is a kind of ordered collection. A vector provides random access. Thus, you can access every element directly in constant time, provided that you know its position. The iterators are random-access iterators, so you can use any algorithm of the STL.

   \bigbreak \noindent 
   \subsubsection{Performance in operations on the end}
   \bigbreak \noindent 
   Vectors provide good performance if you append or delete elements at the end. If you insert or
   delete in the middle or at the beginning, performance gets worse. This is because every element
   behind has to be moved to another position. In fact, the assignment operator would be called for
   every following element.

   \bigbreak \noindent 
   \subsubsection{Size and capacity}
   \bigbreak \noindent 
   Part of the way in which vectors give good performance is by allocating more memory than they
   need to contain all their elements. To use vectors effectively and correctly, you should understand
   how size and capacity cooperate in a vector.
   \bigbreak \noindent 
   Vectors provide the usual size operations size(), empty(), and max\_size(). An additional “size” operation is the capacity() function, which returns the number of
   elements a vector could contain in its actual memory. If you exceed the capacity(), the vector has
   to reallocate its internal memory.
   \bigbreak \noindent 
   The capacity of a vector is important for two reasons:
   \begin{enumerate}
       \item Reallocation invalidates all references, pointers, and iterators for elements of the vector
       \item Reallocation takes time.
   \end{enumerate}
   Thus, if a program manages pointers, references, or iterators into a vector, or if speed is a goal, it is
   important to take the capacity into account
   \bigbreak \noindent 
   To avoid reallocation, you can use reserve() to ensure a certain capacity before you really need
it. In this way, you can ensure that references remain valid as long as the capacity is not exceeded:
\bigbreak \noindent 
Another way to avoid reallocation is to initialize a vector with enough elements by passing additional
arguments to the constructor. For example, if you pass a numeric value as parameter, it is taken as
the starting size of the vector:
\bigbreak \noindent 
\begin{cppcode}
    std::vector<T> v(5);
\end{cppcode}
\bigbreak \noindent 
\textbf{Note:} If the only reason for initialization is to reserve memory, you should use reserve()
\bigbreak \noindent 
Unlike for strings, it is not possible to call reserve() for vectors to shrink the capacity. Calling reserve() with an argument that is less than the current capacity is a no-op
\bigbreak \noindent 
Because the capacity of vectors never shrinks, it is guaranteed that references, pointers, and
iterators remain valid even when elements are deleted, provided that they refer to a position before
the manipulated elements. However, insertions invalidate all references, pointers, and iterators when
the capacity gets exceeded

\bigbreak \noindent 
\subsubsection{Constructors}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{vector<Elem> c} \\
          Default constructor; creates an empty vector without any elements.
          
    \item \texttt{vector<Elem> c(c2)} \\
          Copy constructor; creates a new vector as a copy of \texttt{c2} (all elements are copied).
          
    \item \texttt{vector<Elem> c = c2} \\
          Copy constructor; creates a new vector as a copy of \texttt{c2} (all elements are copied).
          
    \item \texttt{vector<Elem> c(rv)} \\
          Move constructor; creates a new vector, taking the contents of the rvalue \texttt{rv} (since C++11).
          
    \item \texttt{vector<Elem> c = rv} \\
          Move constructor; creates a new vector, taking the contents of the rvalue \texttt{rv} (since C++11).
          
    \item \texttt{vector<Elem> c(n)} \\
          Creates a vector with \texttt{n} elements created by the default constructor.
          
    \item \texttt{vector<Elem> c(n, elem)} \\
          Creates a vector initialized with \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{vector<Elem> c(beg, end)} \\
          Creates a vector initialized with the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{vector<Elem> c\{initlist\}} \\
          Creates a vector initialized with the elements of the initializer list \texttt{initlist} (since C++11).
          
    \item \texttt{vector<Elem> c = \{initlist\}} \\
        Creates a vector initialized with the elements of the initializer list \texttt{initlist} (since C++11).

    \item \texttt{c.~vector()} \\
        Destroys all elements and frees the memory.
\end{itemize}

\subsubsection{Note about at()}
\bigbreak \noindent 
Out of all the element access operators and methods: [], at(), front(), back(), only at() performs range checking. If the index is out of range, at() throws an out\_of\_range
\bigbreak \noindent 
All other functions do not check. A range error results in
undefined behavior. Calling operator [ ], front(), and back() for an empty container always
results in undefined behavior:

\bigbreak \noindent 
\subsubsection{Iterator methods}
\bigbreak \noindent 
We have
\begin{itemize}
    \item begin()
    \item end()
    \item rbegin()
    \item cbegin()
    \item cend()
    \item crbegin()
    \item crend()
\end{itemize}

    \bigbreak \noindent 
    \subsubsection{Using vectors as 2d arrays}
    \bigbreak \noindent 
    There is an issue that comes up when trying to use 2D arrays, when the size of the matrix is not known at compile time.
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int nrows, int ncols) {
            int arr[nrows][ncols]
        }

        int main() {
            f(5,6);
            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    The problem with this code is that the array arr inside the function f is declared with dimensions nrows and ncols, which are non-constant variables. In C++, standard arrays require their sizes to be constant at compile time, but in your code, the array dimensions are determined by function parameters, which are only known at runtime.
    \bigbreak \noindent 
    This means int arr[nrows][ncols] is not valid because the array size is determined at runtime, not compile time.
    \pagebreak \bigbreak \noindent 
    The most common and modern way to handle dynamic arrays in C++ is by using std::vector.
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int r, int c) {
            vector<vector<int>> m;
            m.resize(r);

            for (int i=0; i<c; ++i) {
                m[i].resize(c);
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    Or simply
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int nrows, int ncols) {
            // Create a vector of vectors (2D array)
            std::vector<std::vector<int>> arr(nrows, std::vector<int>(ncols));

            // Access elements like arr[i][j]
            for (int i = 0; i < nrows; ++i) {
                for (int j = 0; j < ncols; ++j) {
                    arr[i][j] = i * ncols + j;  // Example of initializing elements
                }
            }
        }

        int main() {
            f(5, 6);
            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    the constructor of std::vector is designed to accept an element initializer. In this case, the std::vector<int>(ncols) argument is used to initialize each element of the outer std::vector<std::vector<int>>. The constructor in question is 
    \bigbreak \noindent 
    \begin{cppcode}
        vector(size_type count, const T& value);
    \end{cppcode}
    \bigbreak \noindent 
    Where size\_type in this context is a typedef for size\_t.

    \pagebreak 
    \subsubsection{For those interested}
    \bigbreak \noindent 
    There are some other ways to solve this issue.
    \bigbreak \noindent 
    \paragraph{Manual Dynamic Memory Allocation (Using new)}
    \bigbreak \noindent \bigbreak \noindent 
    If for some reason you cannot use std::vector and need to manually allocate dynamic memory, you can use new to create a 2D array. This approach gives you control over memory allocation, but you must manually free the memory to avoid memory leaks.
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int r, int c) {
            int** arr = new int*[r];

            for (int i=0; i<r; ++i) {
                arr[i] = new int[c];
            }

            // Access elements like arr[i][j]
            int count=0;
            for (int i = 0; i < r; ++i) {
                for (int j = 0; j < c; ++j) {
                    arr[i][j] = count++;
                    cout << arr[i][j] << endl;
                }
            }

            // Free the memory when done
            for (int i = 0; i < r; ++i) {
                delete[] arr[i];  // Free each row
            }
            delete[] arr;  // Free the array of pointers
        }
    \end{cppcode}
    \bigbreak \noindent 
    \nt{heap allocation using new in C++ happens at runtime.}

    \bigbreak \noindent 
    \paragraph{Using unique pointer}
    \bigbreak \noindent \bigbreak \noindent 
    If you need more control over memory allocation but want to avoid the risk of memory leaks, you can use std::unique\_ptr to automatically manage memory
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int nrows, int ncols) {
            // Allocate memory for a 2D array using std::unique_ptr
            std::unique_ptr<std::unique_ptr<int[]>[]> arr = std::make_unique<std::unique_ptr<int[]>[]>(nrows);
            for (int i = 0; i < nrows; ++i) {
                arr[i] = std::make_unique<int[]>(ncols);  // Allocate each row
            }

            // Access elements like arr[i][j]
            for (int i = 0; i < nrows; ++i) {
                for (int j = 0; j < ncols; ++j) {
                    arr[i][j] = i * ncols + j;  // Example of initializing elements
                }
            }
            // No need to manually free memory; std::unique_ptr handles it automatically
        }
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{How it works:}
    \begin{enumerate}
        \item \textbf{std::unique\_ptr<std::unique\_ptr<int[]>[]>}: is a unique pointer to an array of unique pointers, where each unique pointer in the array manages a dynamically allocated array of integers.
        \item \textbf{std::make\_unique<std::unique\_ptr<int[]>[]>(r)}: allocates an array of r unique pointers, each of which will eventually point to a row of integers.
    \end{enumerate}

    \bigbreak \noindent 
    \paragraph{Recall: Unique pointer for dynamic arry}
    \bigbreak \noindent 
    \bigbreak \noindent 
    \bigbreak \noindent 
    \begin{cppcode}
    #include <memory>
    using std::unique_ptr;
    using std::make_unique;
    int main() {
        unique_ptr<int[]> arr = make_unique<int[]>(size) // Which is the same as int* arr = new int[size]

        return 0;
}
    \end{cppcode}

    \pagebreak \bigbreak \noindent 
    \paragraph{If sizes are truly known at compile time}
    \bigbreak \noindent \bigbreak \noindent 
    If the dimensions are truly known at compile time, you can pass them as template arguments:
    \bigbreak \noindent 
    \begin{cppcode}
        template <int r, int c>
        void f() {
            int arr[r][c];  // Valid because r and c are compile-time constants
            // Initialize and print the array (for demonstration)
            for (int i = 0; i < r; ++i) {
                for (int j = 0; j < c; ++j) {
                    arr[i][j] = i * c + j;
                    std::cout << arr[i][j] << " ";
                }
                std::cout << std::endl;
            }
        }

        int main() {
            constexpr int r = 5;
            constexpr int c = 6;
            f<r, c>();  // Call function with compile-time constant dimensions
            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    The reason this code works when using template parameters is that the template parameters r and c are compile-time constants. In C++, when you use template parameters like this, the values of r and c are determined at compile time, allowing the array sizes to be known by the compiler ahead of time









    \pagebreak 
    \subsection{STL Deque}
    \bigbreak \noindent 
    \subsubsection{Implementation}
    \bigbreak \noindent 
    A deque (pronounced “deck”) is very similar to a vector. It manages its elements with a dynamic
    array, provides random access, and has almost the same interface as a vector. The difference is
    that with a deque, the dynamic array is open at both ends. Thus, a deque is fast for insertions and
    deletions at both the end and the beginning
    \bigbreak \noindent 
    To provide this ability, the deque is typically implemented as a bunch of individual blocks, with the
    first block growing in one direction and the last block growing in the opposite direction

    \subsubsection{Abilities, performance, uses}
    \bigbreak \noindent 
    The abilities of deques differ from those of vectors as follows:
    \begin{itemize}
        \item Inserting and removing elements is fast at both the beginning and the end (for vectors, it is fast only at the end). These operations are done in amortized constant time.
        \item The internal structure has one more indirection to access the elements, so with deques, element access and iterator movement are usually a bit slower.
        \item Iterators must be smart pointers of a special type rather than ordinary pointers because they must jump between different blocks.
        \item In systems that have size limitations for blocks of memory (for example, some PC systems), a deque might contain more elements because it uses more than one block of memory. Thus, max\_size() might be larger for deques.
        \item Deques provide no support to control the capacity and the moment of reallocation. In particular, any insertion or deletion of elements other than at the beginning or end invalidates all pointers, references, and iterators that refer to elements of the deque. However, reallocation may perform better than for vectors because according to their typical internal structure, deques don’t have to copy all elements on reallocation.
        \item Blocks of memory might get freed when they are no longer used, so the memory size of a deque might shrink (however, whether and how this happens is implementation specific).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{When to use deques}
    \begin{itemize}
        \item You insert and remove elements at both ends (this is the classic case for a queue).
        \item You don’t refer to elements of the container.
        \item It is important that the container frees memory when it is no longer used (however, the standard does not guarantee that this happens).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Constructors}
    \begin{itemize}
    \item \texttt{deque<Elem> c} \\
        Default constructor; creates an empty deque without any elements.
    \item \texttt{deque<Elem> c(c2)} \\
        Copy constructor; creates a new deque as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{deque<Elem> c = c2} \\
        Copy assignment operator; creates a new deque as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{deque<Elem> c(rv)} \\
        Move constructor; creates a new deque, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{deque<Elem> c = rv} \\
        Move assignment operator; creates a new deque, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{deque<Elem> c(n)} \\
        Creates a deque with \texttt{n} elements created by the default constructor.
    \item \texttt{deque<Elem> c(n, elem)} \\
        Creates a deque initialized with \texttt{n} copies of element \texttt{elem}.
    \item \texttt{deque<Elem> c(beg, end)} \\
        Creates a deque initialized with the elements of the range \texttt{[beg, end]}.
    \item \texttt{deque<Elem> c \{inilist\}} \\
        Creates a deque initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{deque<Elem> c = \{inilist\}} \\
        Creates a deque initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{c.\textasciitilde deque()} \\
        Destroys all elements and frees the memory.
\end{itemize}
\bigbreak \noindent 
Deque operations differ from vector operations in only two ways:
\begin{enumerate}
    \item Deques do not provide the functions for capacity (capacity() and reserve()).
    \item Deques do provide direct functions to insert and to delete the first element (push\_front() and pop\_front()).
\end{enumerate}




   \pagebreak 
   \subsection{STL Lists}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent 
   Manages its elements as a doubly linked list. As usual, the C++ standard library does not specify the kind of the implementation, but it follows from the list’s name, constraints, and specifications.
   \bigbreak \noindent 
   \subsubsection{Abilities}
   \bigbreak \noindent 
   The internal structure of a list is totally different from that of an array, a vector, or a deque. The list
object itself provides two pointers, the so-called anchors, which refer to the first and last elements.
Each element has pointers to the previous and next elements (or back to the anchor). To insert a new
element, you just manipulate the corresponding pointers
\bigbreak \noindent 
Thus, a list differs in several major ways from arrays, vectors, and deques:
\begin{itemize}
    \item A list does not provide random access. For example, to access the fifth element, you must navigate the first four elements, following the chain of links. Thus, accessing an arbitrary element using a list is slow. However, you can navigate through the list from both end. So accessing both the first and the last elements is fast.
    \item Inserting and removing elements is fast at each position (provided you are there), and not only at one or both ends. You can always insert and delete an element in constant time, because no other elements have to be moved. Internally, only some pointer values are manipulated.
    \item Inserting and deleting elements does not invalidate pointers, references, and iterators to other elements.
    \item A list supports exception handling in such a way that almost every operation succeeds or is a no-op. Thus, you can’t get into an intermediate state in which only half of the operation is complete.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Differencs in the methods}
\bigbreak \noindent 
The member functions provided for lists reflect these differences from arrays, vectors, and deques as follows:
\begin{itemize}
    \item Lists provide front(), push\_front(), and pop\_front(), as well as back(), push\_back(), and pop\_back().
    \item Lists provide neither a subscript operator nor at(), because no random access is provided.
\item Lists don’t provide operations for capacity or reallocation, because neither is needed. Each element has its own memory that stays valid until the element is deleted.
\item Lists provide many special member functions for moving and removing elements. These member functions are faster versions of general algorithms that have the same names. They are faster because they only redirect pointers rather than copy and move the values.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Constructors}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{list<Elem> c} \\
        Default constructor; creates an empty list without any elements.
    \item \texttt{list<Elem> c(c2)} \\
        Copy constructor; creates a new list as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{list<Elem> c = c2} \\
        Copy assignment operator; creates a new list as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{list<Elem> c(rv)} \\
        Move constructor; creates a new list, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{list<Elem> c = rv} \\
        Move assignment operator; creates a new list, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{list<Elem> c(n)} \\
        Creates a list with \texttt{n} elements created by the default constructor.
    \item \texttt{list<Elem> c(n, elem)} \\
        Creates a list initialized with \texttt{n} copies of element \texttt{elem}.
    \item \texttt{list<Elem> c(beg, end)} \\
        Creates a list initialized with the elements of the range \texttt{[beg, end]}.
    \item \texttt{list<Elem> c\{inilist\}} \\
        Creates a list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{list<Elem> c = \{inilist\}} \\
        Creates a list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{c.\~list()} \\
        Destroys all elements and frees the memory.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Element access}
\bigbreak \noindent 
With lists, we only have front and back methods. However, these methods do not check for existence. Calling these methods on empty containers results in undefined behavior
\bigbreak \noindent 
Thus, the caller must ensure that the container contains at least one element

\bigbreak \noindent 
\subsubsection{Iterator functions}
\bigbreak \noindent 
To access all elements of a list, you must use iterators. Lists provide the usual iterator functions. However, because a list has no random access, these iterators are only bidirectional.
Thus, you can’t call algorithms that require random-access iterators. All algorithms that manipulate
the order of elements a lot, especially sorting algorithms, are in this category. However, for sorting
the elements, lists provide the special member function sort()

\bigbreak \noindent 
\subsubsection{Splice Functions and Functions to Change the Order of Elements}
\bigbreak \noindent 
Linked lists have the advantage that you can remove and insert elements at any position in constant
time. If you move elements from one container to another, this advantage doubles in that you need
only redirect some internal pointers
\bigbreak \noindent 
To support this ability, lists provide not only remove() but also additional modifying member
functions to change the order of and relink elements and ranges.




   \pagebreak 
   \subsection{STL Forward lists}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent 
   \bigbreak \noindent 
   A forward list (an instance of the container class forward\_list<>), which was introduced with C++11, manages its elements as a singly linked list
   \bigbreak \noindent 
   Conceptionally, a forward list is a list (object of class list<>) restricted such that it is not able to iterate backward. It provides no functionality that is not also provided by lists. As benefits, it uses less memory and provides slightly better runtime behavior. The standard states: “It is intended that forward\_list have zero space or time overhead relative to a hand-written C-style singly linked list. Features that would conflict with that goal have been omitted.

   \bigbreak \noindent 
   \subsubsection{Abilities, limitations}
   \bigbreak \noindent \bigbreak \noindent 
   Forward lists have the following limitations compared to lists:
   \begin{itemize}
       \item A forward list provides only forward iterators, not bidirectional iterators. As a consequence, no reverse iterator support is provided, which means that types, such as reverse\_iterator, and member functions, such as rbegin(), rend(), crbegin(), and crend(), are not provided.
       \item A forward list does not provide a size() member function. This is a consequence of omitting features that create time or space overhead relative to a handwritten singly linked list.
       \item The anchor of a forward list has no pointer to the last element. For this reason, a forward list does not provide the special member functions to deal with the last element, back(), push\_back(), and pop\_back().
       \item For all member functions that modify forward lists in a way that elements are inserted or deleted at a specific position, special versions for forward lists are provided. The reason is that you have to pass the position of the element before the first element that gets manipulated, because there you have to assign a new successor element. Because you can’t navigate backwards (at least not in constant time), for all these member functions you have to pass the position of the preceding element. Because of this difference, these member functions have a \_after suffix in their name. For example, instead of insert(), insert\_after() is provided, which inserts new elements after the element passed as first argument; that is, it appends an element at that position.
       \item For this reason, forward lists provide before\_begin() and cbefore\_begin(), which yield the position of a virtual element before the first element (technically speaking, the anchor of the linked list), which can be used to let built-in algorithms ending with \_after exchange even the first element.
   \end{itemize}

   \bigbreak \noindent 
   \subsubsection{No size()?}
   \bigbreak \noindent \bigbreak \noindent 
   The decision not to provide size() might be especially surprising because size() is one of the operations required for all STL containers. Here, you can see the consequences of the design goal to have “zero space or time overhead relative to a hand-written Cstyle singly linked list.” The alternative would have been either to compute the size each time size() is called, which would have linear complexity, or to provide an additional field in the forward\_list object for the size, which is updated with each and every operation that changes the number of elements. As the design paper for the forward list, “It’s a cost that all users would have to pay for, whether they need this feature or not.” So, if you need the size, either track it outside the forward\_list or use a list instead.
   \bigbreak \noindent 
   If you have to compute the number of elements, you can use distance()
   \bigbreak \noindent 
   \begin{cppcode}
   #include <forward_list>
   #include <iterator>

   std::forward_list<int> l;
   std::cout << "Size: " << std::distance(l.begin(), l.end()) << std::endl;
   \end{cppcode}

   \bigbreak \noindent 
   \subsubsection{Similarities to list}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{itemize}
       \item A forward list does not provide random access. For example, to access the fifth element, you
       \item must navigate the first four elements, following the chain of links. Thus, using a forward list to access an arbitrary element is slow.
       \item Inserting and removing elements is fast at each position, if you are there. You can always insert and delete an element in constant time, because no other elements have to be moved. Internally, only some pointer values are manipulated.
       \item Inserting and deleting elements does not invalidate iterators, references, and pointers to other elements.
       \item A forward list supports exception handling in such a way that almost every operation succeeds or is a no-op. Thus, you can’t get into an intermediate state in which only half of the operation is complete.
       \item Forward lists provide many special member functions for moving and removing elements. These member functions are faster versions of general algorithms, because they only redirect pointers rather than copy and move the values. However, when element positions are involved, you have to pass the preceding position, and the member function has the suffix \_after in its name.
   \end{itemize}

   \bigbreak \noindent 
   \subsubsection{Constructors}
   \bigbreak \noindent 
   \bigbreak \noindent 
   \begin{itemize}
    \item \texttt{forward\_list<Elem> c} \\
    Default constructor; creates an empty forward list without any elements.
    
    \item \texttt{forward\_list<Elem> c(c2)} \\
    Copy constructor; creates a new forward list as a copy of \texttt{c2} (all elements are copied).
    
    \item \texttt{forward\_list<Elem> c = c2} \\
    Copy assignment operator; creates a new forward list as a copy of \texttt{c2} (all elements are copied).
    
    \item \texttt{forward\_list<Elem> c(rv)} \\
    Move constructor; creates a new forward list, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{forward\_list<Elem> c = rv} \\
    Move assignment operator; creates a new forward list, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{forward\_list<Elem> c(n)} \\
    Creates a forward list with \texttt{n} elements created by the default constructor.
    
    \item \texttt{forward\_list<Elem> c(n, elem)} \\
    Creates a forward list initialized with \texttt{n} copies of element \texttt{elem}.
    
    \item \texttt{forward\_list<Elem> c(beg, end)} \\
    Creates a forward list initialized with the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{forward\_list<Elem> c\{inilist\}} \\
    Creates a forward list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{forward\_list<Elem> c = \{inilist\}} \\
    Creates a forward list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{c.\~forward\_list()} \\
    Destroys all elements and frees the memory.
\end{itemize}




   \pagebreak 
   \subsection{STL Sets and multisets}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent \bigbreak \noindent 
   Sets and multisets are implemented as height balanced binary search trees. (red-black trees)
   \bigbreak \noindent 
   Set and multiset containers sort their elements automatically according to a certain sorting criterion. The difference between the two types of containers is that multisets allow duplicates, whereas sets do not
   \bigbreak \noindent 
   The elements of a set or a multiset may have any type T that is comparable according to the sorting criterion. The optional second template argument defines the sorting criterion. If a special sorting criterion is not passed, the default criterion less is used. The function object less sorts the elements by comparing them with operator $<$
   \bigbreak \noindent 
   The optional third template parameter defines the memory model. The default memory model is the model allocator, which is provided by the C++ standard library.
   \bigbreak \noindent 
   \subsubsection{Strict weak ordering}
   \bigbreak \noindent \bigbreak \noindent 
   The sorting criterion must define strict weak ordering, which is defined by the following four properties:
   \begin{enumerate}
       \item It has to be \textbf{antisymmetric}.
           \begin{itemize}
               \item This means that for operator \texttt{<}: If $x < y$ is true, then $y < x$ is false.
               \item This means that for a predicate \texttt{op()}: If \texttt{op(x, y)} is true, then \texttt{op(y, x)} is false.
           \end{itemize}

       \item It has to be \textbf{transitive}.
           \begin{itemize}
               \item This means that for operator \texttt{<}: If $x < y$ is true and $y < z$ is true, then $x < z$ is true.
               \item This means that for a predicate \texttt{op()}: If \texttt{op(x, y)} is true and \texttt{op(y, z)} is true, then \texttt{op(x, z)} is true.
           \end{itemize}

       \item It has to be \textbf{irreflexive}.
           \begin{itemize}
               \item This means that for operator \texttt{<}: $x < x$ is always false.
               \item This means that for a predicate \texttt{op()}: \texttt{op(x, x)} is always false.
           \end{itemize}

       \item It has to have \textbf{transitivity of equivalence}, which means roughly: If $a$ is equivalent to $b$ and $b$ is equivalent to $c$, then $a$ is equivalent to $c$.
           \begin{itemize}
               \item This means that for operator \texttt{<}: If !$(a < b)$ \&\& !$(b < a)$ is true and !$(b < c)$ \&\& !$(c < b)$ is true, then !$(a < c)$ \&\& !$(c < a)$ is true.
               \item This means that for a predicate \texttt{op()}: If \texttt{op(a, b)}, \texttt{op(b, a)}, \texttt{op(b, c)}, and \texttt{op(c, b)} all yield false, then \texttt{op(a, c)} and \texttt{op(c, a)} yield false.
           \end{itemize}
   \end{enumerate}
   \bigbreak \noindent 
   \textbf{Note}: Note that this means that you have to distinguish between less and equal. A criterion such as operator \texttt{<=} does not fulfill this requirement.
   \bigbreak \noindent 
   Based on these properties, the sorting criterion is also used to check equivalence. That is, two elements are considered to be duplicates if neither is less than the other (or if both \texttt{op(x, y)} and \texttt{op(y, x)} are false).
   \bigbreak \noindent 
   For multisets, the order of equivalent elements is random but stable. Thus, insertions and erasures preserve the relative ordering of equivalent elements (guaranteed since C++11).
   \bigbreak \noindent 
   \subsubsection{Abilities}
   \bigbreak \noindent \bigbreak \noindent 
   Like all standardized associative container classes, sets and multisets are usually implemented as balanced binary trees
   \bigbreak \noindent 
   The major advantage of automatic sorting is that a binary tree performs well when elements with
a certain value are searched. In fact, search functions have logarithmic complexity. For example, to
search for an element in a set or a multiset of 1,000 elements, a tree search performed by a member
function needs, on average, one-fiftieth of the comparisons of a linear search

\bigbreak \noindent 
\subsubsection{Changing elements directly, no direct element access}
\bigbreak \noindent 
Automatic sorting also imposes an important constraint on sets and multisets: You may
not change the value of an element directly
\bigbreak \noindent 
Therefore, to modify the value of an element, you must remove the element having the old value and
insert a new element that has the new value. The interface reflects this behavior:
\begin{itemize}
    \item Sets and multisets don’t provide operations for direct element access.
    \item Indirect access via iterators has the constraint that, from the iterator’s point of view, the element value is constant.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Constructors}
\bigbreak \noindent \bigbreak \noindent 
\begin{itemize}
    \item \texttt{set c} \\
    Default constructor; creates an empty set/multiset without any elements.
    
    \item \texttt{set c(op)} \\
    Creates an empty set/multiset that uses \texttt{op} as the sorting criterion.
    
    \item \texttt{set c(c2)} \\
    Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied).
    
    \item \texttt{set c = c2} \\
    Copy assignment operator; creates a copy of another set/multiset of the same type (all elements are copied).
    
    \item \texttt{set c(rv)} \\
    Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{set c = rv} \\
    Move assignment operator; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{set c(beg, end)} \\
    Creates a set/multiset initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{set c(beg, end, op)} \\
    Creates a set/multiset with the sorting criterion \texttt{op} initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{set c\{inilist\}} \\
    Creates a set/multiset initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{set c = \{inilist\}} \\
    Creates a set/multiset initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{c.\~set()} \\
    Destroys all elements and frees the memory.
\end{itemize}


\bigbreak \noindent 
\subsubsection{Types}
\bigbreak \noindent \bigbreak \noindent 
\begin{itemize}
    \item \texttt{set<Elem>} \\
    A set that by default sorts with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{set<Elem, Op>} \\
    A set that by default sorts with \texttt{Op}.
    
    \item \texttt{multiset<Elem>} \\
    A multiset that by default sorts with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{multiset<Elem, Op>} \\
    A multiset that by default sorts with \texttt{Op}.
\end{itemize}
\pagebreak 
\subsubsection{Constructors}
\begin{itemize}
    \item \texttt{set c} Default constructor; creates an empty set/multiset without any elements
    \item \texttt{set c(op)} Creates an empty set/multiset that uses \texttt{op} as the sorting criterion
    \item \texttt{set c(c2)} Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied)
    \item \texttt{set c = c2} Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied)
    \item \texttt{set c(rv)} Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{set c = rv} Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{set c(beg,end)} Creates a set/multiset initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{set c(beg,end,op)} Creates a set/multiset with the sorting criterion \texttt{op}, initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{set c(initlist)} Creates a set/multiset initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{set c = initlist} Creates a set/multiset initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{c.\~{}set()} Destroys all elements and frees the memory
\end{itemize}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{set<Elem>} A set that by default sorts with \texttt{less<>} (\texttt{operator <})
    \item \texttt{set<Elem,Op>} A set that by default sorts with \texttt{Op}
    \item \texttt{multiset<Elem>} A multiset that by default sorts with \texttt{less<>} (\texttt{operator <})
    \item \texttt{multiset<Elem,Op>} A multiset that by default sorts with \texttt{Op}
\end{itemize}









   \pagebreak 
   \subsection{STL Maps and multimaps}
   \bigbreak \noindent 
   Maps and multimaps are containers that manage key/value pairs as elements. These containers sort
   their elements automatically, according to a certain sorting criterion that is used for the key. The
   difference between the two is that multimaps allow duplicates, whereas maps do not
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent \bigbreak \noindent 
   Maps and multimaps are implemented the same as sets and multisets, height balanced binary search trees (red-black trees).

   \bigbreak \noindent 
   \subsubsection{Template parameters}
   \bigbreak \noindent \bigbreak \noindent 
   The first template parameter is the type of the element’s key, and the second template parameter is
the type of the element’s associated value. The elements of a map or a multimap may have any types
Key and T that meet the following two requirements:
\begin{enumerate}
    \item Both key and value must be copyable or movable.
    \item The key must be comparable with the sorting criterion.
\end{enumerate}
\bigbreak \noindent 
The optional third template parameter defines the sorting criterion. As for sets, this sorting criterion must define a “strict weak ordering” The elements are sorted according to their keys, so the value doesn’t matter for the order of the elements. The sorting criterion is also used to check for equivalence; that is, two elements are equal if neither key is less than the other.
\bigbreak \noindent 
If a special sorting criterion is not passed, the default criterion less<> is used. The function object
less<> sorts the elements by comparing them with operator <
\bigbreak \noindent 
\subsubsection{Abilities}
\bigbreak \noindent \bigbreak \noindent 
Sets, multisets, maps, and multimaps
typically use the same internal data type. So, you could consider sets and multisets as special maps
and multimaps, respectively, for which the value and the key of the elements are the same objects.
Thus, maps and multimaps have all the abilities and operations of sets and multisets. Some minor
differences exist, however. First, their elements are key/value pairs. In addition, maps can be used
as associative arrays.
\bigbreak \noindent 
Maps and multimaps sort their elements automatically, according to the element’s keys, and so have
good performance when searching for elements that have a certain key. Searching for elements that
have a certain value promotes bad performance. Automatic sorting imposes an important constraint
on maps and multimaps: You may not change the key of an element directly, because doing so might
compromise the correct order. To modify the key of an element, you must remove the element that
has the old key and insert a new element that has the new key and the old value. As a consequence, from the iterator’s point of view, the element’s key is
constant. However, a direct modification of the value of the element is still possible, provided that
the type of the value is not constant.

\bigbreak \noindent 
\subsubsection{Constructors and types}
\bigbreak \noindent \bigbreak \noindent 
\begin{itemize}
    \item \texttt{map c} \\
    Default constructor; creates an empty map/multimap without any elements.
    
    \item \texttt{map c(op)} \\
    Creates an empty map/multimap that uses \texttt{op} as the sorting criterion.
    
    \item \texttt{map c(c2)} \\
    Copy constructor; creates a copy of another map/multimap of the same type (all elements are copied).
    
    \item \texttt{map c = c2} \\
    Copy assignment operator; creates a copy of another map/multimap of the same type (all elements are copied).
    
    \item \texttt{map c(rv)} \\
    Move constructor; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{map c = rv} \\
    Move assignment operator; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{map c(beg, end)} \\
    Creates a map/multimap initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{map c(beg, end, op)} \\
    Creates a map/multimap with the sorting criterion \texttt{op} initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{map c\{inilist\}} \\
    Creates a map/multimap initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{map c = \{inilist\}} \\
    Creates a map/multimap initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{c.\~map()} \\
    Destroys all elements and frees the memory.
\end{itemize}
\textbf{Here, map may be one of the following types:}
\begin{itemize}
    \item \texttt{map<Key, Val>} \\
    A map that by default sorts keys with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{map<Key, Val, Op>} \\
    A map that by default sorts keys with \texttt{Op}.
    
    \item \texttt{multimap<Key, Val>} \\
    A multimap that by default sorts keys with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{multimap<Key, Val, Op>} \\
    A multimap that by default sorts keys with \texttt{Op}.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Using maps as associative arrays}
\bigbreak \noindent 
Associative containers don’t typically provide abilities for direct element access. Instead, you must
use iterators. For maps, as well as for unordered maps, however, there is an exception to this rule. Nonconstant maps provide a subscript operator for direct element access. In addition, since C++11, a corresponding member function at() is provided for constant and
nonconstant maps 
\bigbreak \noindent 
at() yields the value of the element with the passed key and throws an exception object of type
out\_of\_range if no such element is present
\bigbreak \noindent 
For operator [ ], the index also is the key that is used to identify the element. This means that
for operator [ ], the index may have any type rather than only an integral type. Such an interface is
the interface of a so-called associative array.
\bigbreak \noindent 
For operator [ ], the type of the index is not the only difference from ordinary arrays. In addition,
you can’t have a wrong index. If you use a key as the index for which no element yet exists, a new
element gets inserted into the map automatically. The value of the new element is initialized by the
default constructor of its type. Thus, to use this feature, you can’t use a value type that has no default
constructor. Note that the fundamental data types provide a default constructor that initializes their
values to zero

\bigbreak \noindent 
\subsubsection{Constructors}
\begin{itemize}
    \item \texttt{map c} Default constructor; creates an empty map/multimap without any elements
    \item \texttt{map c(op)} Creates an empty map/multimap that uses \texttt{op} as the sorting criterion
    \item \texttt{map c(c2)} Copy constructor; creates a copy of another map/multimap of the same type (all elements are copied)
    \item \texttt{map c = c2} Copy constructor; creates a copy of another map/multimap of the same type (all elements are copied)
    \item \texttt{map c(rv)} Move constructor; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{map c = rv} Move constructor; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{map c(beg,end)} Creates a map/multimap initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{map c(beg,end,op)} Creates a map/multimap with the sorting criterion \texttt{op}, initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{map c(initlist)} Creates a map/multimap initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{map c = initlist} Creates a map/multimap initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{c.\~{}map()} Destroys all elements and frees the memory
\end{itemize}
\bigbreak \noindent
\begin{itemize}
    \item \texttt{map<Key,Val>} A map that by default sorts keys with \texttt{less<>} (\texttt{operator <})
    \item \texttt{map<Key,Val,Op>} A map that by default sorts keys with \texttt{Op}
    \item \texttt{multimap<Key,Val>} A multimap that by default sorts keys with \texttt{less<>} (\texttt{operator <})
    \item \texttt{multimap<Key,Val,Op>} A multimap that by default sorts keys with \texttt{Op}
\end{itemize}

\pagebreak 
\subsection{Example of bounds and equal range}








   \pagebreak 
   \subsection{STL Unordered containers}
   \bigbreak \noindent 
   Strictly speaking, the C++ standard library calls unordered containers “unordered associative
containers.” However, I will just use “unordered containers” when I refer to them. With “associative
containers,” I still refer to the “old” associative containers, which are provided since C++98 and
implemented as binary trees (set, multiset, map, and multimap).
\bigbreak \noindent 
Conceptionally, unordered containers contain all the elements you insert in an arbitrary order . That is, you can consider the container to be a bag: you can put in elements,
but when you open the bag to do something with all the elements, you access them in a random
order. So, in contrast with (multi)sets and (multi)maps, there is no sorting criterion; in contrast with
sequence containers, you have no semantics to put an element into a specific position.
\bigbreak \noindent 
\subsubsection{Implementation}
\bigbreak \noindent 
All standardized unordered container classes are implemented as hash tables, which nonetheless still have a variety of implementation options.
\bigbreak \noindent 
\subsubsection{Abilities}
\bigbreak \noindent 
\begin{enumerate}
    \item The hash tables use the “chaining” approach, whereby a hash code is associated with a linked list. (This technique, also called “open hashing” or “closed addressing,” should not be confused with “open addressing” or “closed hashing.”)
    \item Whether these linked lists are singly or doubly linked is open to the implementers. For this reason, the standard guarantees only that the iterators are “at least” forward iterators.
    \item Various implementation strategies are possible for rehashing:
        \begin{itemize}
            \item With the traditional approach, a complete reorganization of the internal data happens from time to time as a result of a single insert or erase operation.
            \item With incremental hashing, a resizing of the number of bucket or slots is performed gradually, which is especially useful in real-time environments, where the price of enlarging a hash table all at once can be too high.
        \end{itemize}
    \item Unordered containers allow both strategies and give no guarantee that conflicts with either of them.

\end{enumerate}
\bigbreak \noindent 
y. For each value to store, the hash function maps it to a
bucket (slot) in the hash table. Each bucket manages a singly linked list containing all the elements
for which the hash function yields the same value.
\bigbreak \noindent 
The major advantage of using a hash table internally is its incredible running-time behavior.
Assuming that the hashing strategy is well chosen and well implemented, you can guarantee amortized constant time for insertions, deletions, and element search (“amortized” because the occasional
rehashing happens that occurs can be a large operation with a linear complexity).
\bigbreak \noindent 
The expected behavior of nearly all the operations on unordered containers, including copy construction and assignment, element insertion and lookup, and equivalence comparison, depends on
the quality of the hash function. If the hash function generates equal values for different elements, which also happens if an unordered container that allows duplicates is populated with equivalent
values or keys, any hash table operation results in poor runtime performance. This is a fault not so
much of the data structure itself but rather of its use by unenlightened clients

\bigbreak \noindent 
\subsubsection{Disadvantages}
\begin{itemize}
    \item Unordered containers don’t provide operators $<$, $>$, $<=$, and $>=$ to order multiple instances of these containers. However, == and != are provided (since C++11).
    \item lower\_bound() and upper\_bound() are not provided.
    \item Because the iterators are guaranteed only to be forward iterators, reverse iterators, including rbegin(), rend(), crbegin(), and crend(), are not supported, and you can’t use algorithms that require bidirectional iterators, or at least this is not portable
\end{itemize}
\bigbreak \noindent 
Because the (key) value of an element specifies its position — in this case, its bucket entry — you
are not allowed to modify the (key) value of an element directly. Therefore, much as with associative
containers, to modify the value of an element, you must remove the element that has the old value
and insert a new element that has the new value
\bigbreak \noindent 
\begin{itemize}
    \item Unordered containers don’t provide operations for direct element access.
    \item Indirect access via iterators has the constraint that, from the iterator’s point of view, the element’s (key) value is constant.
\end{itemize}

   \pagebreak 
    \subsection{STL Containers: Implementations}
\begin{itemize}
    \item \textbf{std::vector}
    \begin{itemize}
        \item Implemented as a dynamically resizable array with contiguous memory.
    \end{itemize}

    \item \textbf{std::deque}
    \begin{itemize}
        \item Implemented as a sequence of dynamically allocated arrays (blocks) for efficient insertion/removal at both ends.
    \end{itemize}

    \item \textbf{std::list}
    \begin{itemize}
        \item Implemented as a doubly linked list, where each node contains pointers to the previous and next nodes.
    \end{itemize}

    \item \textbf{std::forward\_list}
    \begin{itemize}
        \item Implemented as a singly linked list, where each node contains a pointer to the next node.
    \end{itemize}

    \item \textbf{std::set} / \textbf{std::multiset}
    \begin{itemize}
        \item Implemented as a self-balancing binary search tree (typically Red-Black Tree).
    \end{itemize}

    \item \textbf{std::unordered\_set} / \textbf{std::unordered\_multiset}
    \begin{itemize}
        \item Implemented as a hash table with separate chaining or open addressing for collision resolution.
    \end{itemize}

    \item \textbf{std::map} / \textbf{std::multimap}
    \begin{itemize}
        \item Implemented as a self-balancing binary search tree (typically Red-Black Tree) for sorted key-value pairs.
    \end{itemize}

    \item \textbf{std::unordered\_map} / \textbf{std::unordered\_multimap}
    \begin{itemize}
        \item Implemented as a hash table with separate chaining or open addressing for key-value pairs.
    \end{itemize}
\end{itemize}


\pagebreak 
\subsection{STL Containers: Iterator Functions}
\begin{itemize}
    \item \textbf{Containers with all the iterator functions (begin(), end(), cbegin(), cend(), rbegin(), rend(), crbegin(), crend())}: 
        \begin{enumerate}
            \item Vector
            \item Deque
            \item List
            \item Set 
            \item Muliset
            \item Map
            \item Mulimap
            \item Unordered set
            \item unordered multiset
            \item unordered map
            \item unordered multimap
        \end{enumerate}
    \item \textbf{Containers with limited iterator support:}
        \begin{enumerate}
            \item \textbf{Forward\_list}: Only supports forward iterators (begin(), end(), cbegin(), cend()).
        \end{enumerate}
\end{itemize}


   \pagebreak 
   \subsection{STL containers: Main concepts, differences, uses}
   \begin{itemize}
       \item \textbf{Vectors}: 
           \begin{itemize}
               \item Dynamic array, automatic resizing. 
               \item We have access to capacity and reserve methods. 
               \item Fast at end operations. 
               \item Contiguous memory, random access. 
               \item at() method to index with error checking.
           \end{itemize}

        \item \textbf{Deque}: 
            \begin{itemize}
                \item Multiple blocks / Dynamic arrays to give access to both ends. 
                \item Fast at both ends. 
                \item Front and back operations. 
                \item Slower iterator access compared to vectors. 
                \item Iterators are smart pointers. 
                \item No capacity access
            \end{itemize}
        \item \textbf{List:}
            \begin{itemize}
                \item Doubly-linked list
                \item Insertion and removing is fast
                \item Access at any element thats not the first or last is slow.
                \item NO random access
                \item Member method to sort
                \item Splice
                \item Unique
                \item Merge
            \end{itemize}
        \item \textbf{Forward\_list}
            \begin{itemize}
                \item Singly linked list
                \item No size method
                \item No reverse iterators
                \item No pointer to last element, no back(), push\_back(), or pop\_back() methods
                \item For all member functions that modify forward lists in a way that elements are inserted or deleted at a specific position, special versions for forward lists are provided. The reason is that you have to pass the position of the element before the first element that gets manipulated, because there you have to assign a new successor element. Because you can’t navigate backwards (at least not in constant time), for all these member functions you have to pass the position of the preceding element. Because of this difference, these member functions have a after suffix in their name. For example, instead of insert(), insert\_after() is provided, which inserts new elements after the element passed as first argument; that is, it appends an element at that position.
                    \bigbreak \noindent 
                    For this reason, forward lists provide before\_begin() and cbefore\_begin(), which yield the position of a virtual element before the first element (technically speaking, the anchor of the linked list), which can be used to let built-in algorithms ending with after exchange even the first element
            \end{itemize}
        \item \textbf{Sets and multisets}
            \begin{itemize}
                \item Height balanced bst
                \item No duplicates in set, can have duplicates in multiset
                \item logarithmic searching
                \item logarithmic insertion and deletion
                \item Automatic sorting
                \item Can't change elements directly
                \item No direct element access
                \item Constant iterators
            \end{itemize}
   \end{itemize}
   

   \pagebreak 
   \subsection{STL Containers: Iterator invalidation}
   \begin{itemize}
       \item \textbf{Vectors:} 
           \begin{itemize}
               \item \textbf{Insertion:} All iterators are invalidated if a reallocation occurs; otherwise, only iterators at or after the point of insertion are invalidated.
               \item \textbf{Deletion:} Iterators at or after the point of deletion are invalidated.
           \end{itemize}
        \item \textbf{Deque}: 
            \begin{itemize}
                \item \textbf{Insertion/Deletion:} At beginning or end, no invalidation unless reallocation occurs. Inserting or deleting in the middle invalidates all iterators.
            \end{itemize}
        \item \textbf{List}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{Forward list}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{Set/multiset}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{unordered set/unordered multiset}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation unless rehashing occurs.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
                \item \textbf{Rehashing:} All iterators are invalidated.
            \end{itemize}
        \item \textbf{Map/Multimap}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{Unordered map/unordered multimap}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation unless rehashing occurs.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
                \item \textbf{Rehashing:} All iterators are invalidated.
            \end{itemize}
   \end{itemize}

   \pagebreak 
   \subsection{STL Containers: Reallocation}
   \begin{itemize}
       \item \textbf{Vectors}: Reallocation occurs when inserting elements exceeds the current capacity.
       \item \textbf{Deque}: Reallocation occurs when inserting elements requires more blocks (typically at both ends, but can happen internally).
        \item \textbf{List, forward list}: No reallocation occurs, as they allocate nodes dynamically and do not store elements contiguously.
        \item \textbf{set, multiset, map, multimap}: No reallocation occurs, as they use balanced trees, and elements are not stored contiguously.
        \item \textbf{unordered set, unordered multiset, unordered map, unordered multimap}:  Reallocation occurs when the load factor exceeds a threshold, triggering a rehash to a larger bucket array.
   \end{itemize}

   \pagebreak 
   \subsection{STL Containers: Element access}
\begin{itemize}
    \item \textbf{std::vector}
    \begin{itemize}
        \item Direct access via index: \texttt{v[i]}, \texttt{v.at(i)}
        \item Front element: \texttt{v.front()}
        \item Back element: \texttt{v.back()}
    \end{itemize}
    
    \item \textbf{std::deque}
    \begin{itemize}
        \item Direct access via index: \texttt{d[i]}, \texttt{d.at(i)}
        \item Front element: \texttt{d.front()}
        \item Back element: \texttt{d.back()}
    \end{itemize}
    
    \item \textbf{std::list}
    \begin{itemize}
        \item No direct access via index.
        \item Front element: \texttt{l.front()}
        \item Back element: \texttt{l.back()}
    \end{itemize}
    
    \item \textbf{std::forward\_list}
    \begin{itemize}
        \item No direct access via index.
        \item Front element: \texttt{fl.front()}
    \end{itemize}
    
    \item \textbf{std::set} / \textbf{std::multiset}
    \begin{itemize}
        \item No direct access via index.
        \item Access via iterator or functions like \texttt{find()}, \texttt{lower\_bound()}, \texttt{upper\_bound()}.
    \end{itemize}
    
    \item \textbf{std::unordered\_set} / \textbf{std::unordered\_multiset}
    \begin{itemize}
        \item No direct access via index.
        \item Access via iterator or \texttt{find()}.
    \end{itemize}
    
    \item \textbf{std::map} / \textbf{std::multimap}
    \begin{itemize}
        \item Access by key: \texttt{m[key]} (for \texttt{std::map} only, not \texttt{std::multimap}).
        \item Access via iterator or functions like \texttt{find()}, \texttt{lower\_bound()}, \texttt{upper\_bound()}.
    \end{itemize}
    
    \item \textbf{std::unordered\_map} / \textbf{std::unordered\_multimap}
    \begin{itemize}
        \item Access by key: \texttt{um[key]} (for \texttt{std::unordered\_map} only, not \texttt{std::unordered\_multimap}).
        \item Access via iterator or \texttt{find()}.
    \end{itemize}
\end{itemize}



   \pagebreak 
   \subsection{STL Containers: Uses and advantages}
   \begin{itemize}
    \item \textbf{std::vector}
    \begin{itemize}
        \item Advantages: Fast random access, contiguous memory, efficient for dynamic arrays.
        \item Uses: When frequent random access and dynamic resizing are needed.
    \end{itemize}
    
    \item \textbf{std::deque}
    \begin{itemize}
        \item Advantages: Fast insertion/removal at both ends, efficient dynamic array.
        \item Uses: Double-ended queue operations, efficient at both front and back.
    \end{itemize}
    
    \item \textbf{std::list}
    \begin{itemize}
        \item Advantages: Constant time insertion/removal anywhere, no reallocation.
        \item Uses: When frequent insertions/removals in the middle are needed.
    \end{itemize}
    
    \item \textbf{std::forward\_list}
    \begin{itemize}
        \item Advantages: Singly linked list, smaller memory overhead, constant time insertion/removal.
        \item Uses: Memory-constrained environments, where only forward traversal is needed.
    \end{itemize}
    
    \item \textbf{std::set} / \textbf{std::multiset}
    \begin{itemize}
        \item Advantages: Sorted elements, fast lookup (logarithmic time).
        \item Uses: When you need a sorted collection with unique or non-unique elements.
    \end{itemize}
    
    \item \textbf{std::unordered\_set} / \textbf{std::unordered\_multiset}
    \begin{itemize}
        \item Advantages: Fast average-time lookup (constant time), no sorting.
        \item Uses: When fast lookup is needed without element ordering.
    \end{itemize}
    
    \item \textbf{std::map} / \textbf{std::multimap}
    \begin{itemize}
        \item Advantages: Sorted key-value pairs, fast lookup (logarithmic time).
        \item Uses: Key-value pairs where keys must remain sorted.
    \end{itemize}
    
    \item \textbf{std::unordered\_map} / \textbf{std::unordered\_multimap}
    \begin{itemize}
        \item Advantages: Fast average-time lookup (constant time), no sorting.
        \item Uses: Key-value pairs where fast lookup is needed without ordering.
    \end{itemize}
\end{itemize}






   \pagebreak 
   \subsection{STL Iterators}
    An object that iterates/navigates over elements in the container. They are essentially an abstraction of pointer
   \begin{itemize}
       \item \textbf{Some notes about iterators}: 
           \begin{enumerate}
               \item each container provides its own iterator
               \item interfaces of iterators of different containers are largely the same
               \item internal behaviors depend on the data structure of the container
           \end{enumerate}
       \item \textbf{Operations}: 
            \begin{enumerate}
                \item operator * returns the element of the current positions
                \item operator -> access a member of the element
                \item operator ++ step forward
                \item operator -- step backward
                \item operator == and != whether two iterators represent the same position
                \item operator = assign an iterator
            \end{enumerate}
        \item \textbf{Important iterators}:
            \begin{enumerate}
                \item begin() gets you the beginning of a container
                \item end() gets you just past the end
            \end{enumerate}
        \item \textbf{Iterator types}
            \begin{itemize}
                \item \textbf{iterator}
                \item \textbf{reverse\_iterator}
                \item \textbf{const\_iterator}
                \item \textbf{const\_reverse\_iterator}
            \end{itemize}
        \item \textbf{Iterator categories}
            \begin{enumerate}
                \item \textbf{Input Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose:} Read-only access to elements in a single-pass manner.
                        \item \textbf{Operations:} Can be incremented (++), compared for equality (==), and dereferenced (*) to access elements.
                    \end{itemize}
                \item \textbf{Output Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose:} Write-only access to elements in a single-pass manner.
                        \item \textbf{Operations:} Can be incremented (++) and dereferenced (*) to assign values.
                    \end{itemize}
                \item \textbf{Forward Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose:} Read and write access to elements; can traverse the container in a single direction.
                        \item \textbf{Operations:} Can be incremented (++), compared for equality (==), and dereferenced (*).
                    \end{itemize}
                \item \textbf{Bidirectional iterator}:
                    \begin{itemize}
                        \item \textbf{Purpose:} Read and write access to elements; can traverse the container in both directions.
                        \item \textbf{Operations:} Supports both increment (++) and decrement (--) operations.
                    \end{itemize}
                    \pagebreak 
                \item \textbf{Random Access Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose}: Read and write access with the ability to jump to any element in constant time.
                        \item \textbf{Operations:} Supports all operations of bidirectional iterators plus direct arithmetic operations like addition (+), subtraction (-), and subscript ([]).
                    \end{itemize}
            \end{enumerate}
        \item \textbf{Containers and their iterators}:
            \begin{enumerate}
                \item \textbf{Vector}: Random access iterator
                \item \textbf{Deque}: Random access iterator
                \item \textbf{List}: Bidirectional iterator
                \item \textbf{Forward\_list}: Forward iterator
                \item \textbf{Set}: Bidirectional iterator
                \item \textbf{Multiset}: Bidirectional iterator
                \item \textbf{Map}: Bidirectional iterator
                \item \textbf{Multimap}: Bidirectional iterator
                \item \textbf{Unordered\_map}: Forward iterator
            \end{enumerate}
        \item \textbf{Insert iterators}: Insert iterators in C++ are special types of iterators that allow you to insert elements into a container at specific positions rather than overwriting existing elements. There are three primary types of insert iterators provided by the C++ Standard Library:
            \bigbreak \noindent 
            if a container has an insert method, you can and often should use it directly when inserting elements, especially if you want to insert a single element or a specific range of elements into the container.
            \bigbreak \noindent 
            Containers that have an insert method are: vector, deque, list, forward list, set, multiset, unordered set, unordered multiset,map, multimap, unordered map, unordered multi map.
            \bigbreak \noindent 
            Insert iterators (std::back\_inserter, std::front\_inserter, and std::inserter) should be used when working with algorithms or situations where automatic insertion logic simplifies your code.
            \bigbreak \noindent 
            Some things in <algorithm> require these inserters
            \begin{enumerate}
                \item \textbf{std::front\_inserter}: Inserts elements at the front of a container. Calls the container's push\_front method to add elements to the front. Used with containers that support push\_front 
                    \bigbreak \noindent 
                    \begin{cppcode}
                        #include <list>
                        #include <algorithm>
                        #include <iterator>

                        int main() {
                            std::list<int> lst = {1, 2, 3};
                            std::list<int> to_add = {4, 5, 6};

                            // Insert elements at the front of lst
                            std::copy(to_add.begin(), to_add.end(), std::front_inserter(lst));

                            // lst now contains: 6, 5, 4, 1, 2, 3
                        }
                    \end{cppcode}
                \item \textbf{std::back\_inserter}: Inserts elements at the end of a container. Inserts elements at the end of a container. Used with containers that support push\_back 
                    \bigbreak \noindent 
                    \begin{cppcode}
                        #include <vector>
                        #include <algorithm>
                        #include <iterator>

                        int main() {
                            std::vector<int> vec = {1, 2, 3};
                            std::vector<int> to_add = {4, 5, 6};

                            // Insert elements at the end of vec
                            std::copy(to_add.begin(), to_add.end(), std::back_inserter(vec));

                            // vec now contains: 1, 2, 3, 4, 5, 6
                        }
                    \end{cppcode}
                \item \textbf{std::inserter}: Inserts elements at a specific position in a container.  Takes an iterator indicating the insertion position and calls the container's insert method. Used with containers that support insertion at arbitrary positions
                    \bigbreak \noindent 
                    \begin{cppcode}
                        #include <vector>
                        #include <algorithm>
                        #include <iterator>

                        int main() {
                            std::vector<int> vec = {1, 2, 3};
                            std::vector<int> to_add = {4, 5, 6};

                            // Insert elements starting at the second position (before 2)
                            std::copy(to_add.begin(), to_add.end(), std::inserter(vec, vec.begin() + 1));

                            // vec now contains: 1, 4, 5, 6, 2, 3
                        }
                    \end{cppcode}
            \end{enumerate} 
    \end{itemize}

    \pagebreak 
    \subsection{Complexity of container operations}
    \begin{center}
        \begin{tabular}{|>{\raggedright}m{4cm}|>{\centering}m{2.5cm}|>{\centering}m{2.5cm}|>{\centering}m{3cm}|>{\centering\arraybackslash}m{3cm}|}
            \hline
            \textbf{Container} & \textbf{Access} & \textbf{Search} & \textbf{Insertion} & \textbf{Deletion} \\ \hline
            \texttt{vector} & O(1) & O(n) & O(n) (amortized O(1) at end) & O(n) \\ \hline
            \texttt{deque} & O(1) & O(n) & O(n) (amortized O(1) at ends) & O(n) \\ \hline
            \texttt{list} & O(n) & O(n) & O(1) (if position known), O(n) (worst case) & O(1) (if position known), O(n) (worst case) \\ \hline
            \texttt{forward\_list} & O(n) & O(n) & O(1) (if position known), O(n) (worst case) & O(1) (if position known), O(n) (worst case) \\ \hline
            \texttt{set} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{multiset} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{map} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{multimap} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{unordered\_set} & O(n) & O(n) & O(n) & O(n) \\ \hline
            \texttt{unordered\_multiset} & O(n) & O(n) & O(n) & O(n) \\ \hline
            \texttt{unordered\_map} & O(n) & O(n) & O(n) & O(n) \\ \hline
            \texttt{unordered\_multimap} & O(n) & O(n) & O(n) & O(n) \\ \hline
        \end{tabular}
   \end{center}
   \bigbreak \noindent 
   Unordered container operations are for the most part constant time operations, but worst case they are linear.











   % \subsection{The Basics of STL containers}
   % \bigbreak \noindent 
   % The STL is a generic library that manages collections of data with efficient algorithms. It has template classes, functions, parameters. The idea is to have the same/single implementation works for many data types
   % \bigbreak \noindent 
   % \textbf{Components:}
   % \begin{enumerate}
   %     \item \textbf{Containers}: manage collections of data
   %         \begin{itemize}
   %             \item \textbf{sequence containers e.g. vector, list, deque}: Sequence containers store elements in a linear sequence, where the order of elements is strictly maintained. They allow for sequential access to elements
   %             \item \textbf{associative containers e.g. set, map}: Associative containers store elements in a way that allows for fast retrieval based on keys. They automatically order elements based on their keys or some criterion.
   %                 \bigbreak \noindent 
   %                 \textbf{Note:} Sets in C++ are considered associative containers because they store elements in a way that allows for efficient retrieval based on the value of the elements themselves. This differs fundamentally from sequence containers, which maintain elements in a specific order based on the sequence of insertion.
   %         \end{itemize}
   %     \item \textbf{Iterators}: Step through elements in an container
   %     \item \textbf{Algorithms}: Procedures that process the elements of collections
   % \end{enumerate}
   % \bigbreak \noindent 
   % \textbf{Global algorithms for all containers in the <algorithm> header}:
   % \begin{itemize}
   %     \item \textbf{copy}: Copies elements from one range to another.
   %     \item \textbf{transform}: Applies a function to each element in a range and stores the result in another range.
   %     \item \textbf{find}: Searches for the first occurrence of a value in a range.
   %     \item \textbf{search}: Searches for a subsequence within a range.
   %     \item \textbf{mismatch}: Finds the first position where two ranges differ.
   %     \item \textbf{fill}: Assigns a value to each element in a range.
   %     \item \textbf{replace}: Replaces occurrences of a value in a range with another value.
   %     \item \textbf{sort}: Sorts elements in a range.
   % \end{itemize}
   % \pagebreak \bigbreak \noindent 
   % \textbf{Signatures}:
   % \begin{cppcode}
   %     template <class InputIterator, class OutputIterator>
   %     OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);
   %
   %     template <class InputIterator, class OutputIterator, class UnaryOperation>
   %     OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);
   %
   %     template <class InputIterator, class T>
   %     InputIterator find(InputIterator first, InputIterator last, const T& value);
   %
   %     template <class ForwardIterator1, class ForwardIterator2>
   %     ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);
   %
   %
   %     template <class InputIterator1, class InputIterator2>
   %     std::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
   % \end{cppcode}
   %
   % \pagebreak 
   % \begin{cppcode}
   %     template <class ForwardIterator, class T>
   %     void fill(ForwardIterator first, ForwardIterator last, const T& value);
   %
   %     template <class ForwardIterator, class T>
   %     void replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);
   %
   %     template <class RandomAccessIterator>
   %     void sort(RandomAccessIterator first, RandomAccessIterator last);
   % \end{cppcode}
   % \bigbreak \noindent 
   % \textbf{Note:} This is not an exhaustive list of signatures for these procedures
   % \bigbreak \noindent 
   % \textbf{Vectors}: One of the sequence containers
   % \begin{itemize}
   %  \item \textbf{Properties of vectors}:
   %      \begin{enumerate}
   %          \item The order of elements in the container depends on the time/space of the insertion(s) of the elements. This means that the elements in a std::vector are stored in the order in which they are inserted.
   %          \item dynamic array
   %          \item random access
   %          \item adding/removing elements at the end is fast
   %          \item inserting/removing in the middle/beginning is slow 
   %      \end{enumerate}
   %  \item \textbf{Vector constructors}
   %      \begin{enumerate}
   %          \item default constructor
   %          \item copy constructor
   %          \item constructor with given range from another (type of) container, with an array, from standard input, type may be even different provided automatic conversion
   %      \end{enumerate}
   %  \item \textbf{Vector destructor}: When dealing with vectors, destructors automatically call the destructor of each element stored in the vector in reverse order of their insertion. After destroying each element, the vector's destructor releases the internal memory used by the vector itself.
   %  \item \textbf{Vector methods}:
   %      \begin{enumerate}
   %          \item size - the actual number of elements in the vector
   %          \item empty - whether the vector is empty or not
   %          \item max\_size - the maximum number of elements a container may contain. - a constraint from the system or library implementation. this is different from capacity().
   %          \item capacity - the number of elements a vector could contain in its actual memory.
   %          \item resize - resize the vector. in case of larger size, fill the rest with a certain value. - different from reserve().
   %          \item reserve - change the capacity of the vector. exception is thrown if not successful.
   %      \end{enumerate}
   %  \item \textbf{Element access methods}:
   %      \begin{enumerate}
   %          \item operator[ ] - access the element at a certain position. it does not check the valid range.
   %          \item at() – similar to [ ]. it checks range, and throws exception.
   %          \item front() – returns a reference to the first element
   %          \item back() – returns a reference to the last element
   %      \end{enumerate}
   %  \item \textbf{assignments and assignment methods}
   %      \begin{enumerate}
   %          \item operator= - copy from another vector containing the same type
   %          \item assign() - assigns new content to the current vector. overloaded.
   %          \item swap() - exchange two vectors.
   %      \end{enumerate}
   %  \item \textbf{Insertion methods}
   %      \begin{enumerate}
   %          \item insert() - insert new element in front of a specified position
   %          \item push\_back() - append a new element to the end of the vector
   %          \item emplace\_back() - construct a new element in-place at the end, used if inserting objects that need to be constructed
   %      \end{enumerate}
   %  \item \textbf{Removal methods}
   %      \begin{enumerate}
   %          \item erase - remove an element or a range of elements
   %          \item pop\_back - remove the last element
   %          \item resize - change the number of elements
   %          \item clear - remove all elements from the vector
   %      \end{enumerate}
   %  \item \textbf{what operations may cause reallocation of the internal array?}:
   %      \begin{enumerate}
   %          \item reserve
   %          \item push\_back, emplace\_back
   %          \item insert, emplace
   %      \end{enumerate}
   %      \bigbreak \noindent 
   %      \textbf{Note:} Note that pop\_back, erase, clear do not cause reallocation
   %      \bigbreak \noindent 
   %      When reallocation happens, all references, pointers, and iterators referring to elements of the original vector become invalidated.
   %  \item \textbf{what if do want to reduce memory size for unused positions?}
   %      \begin{enumerate}
   %          \item shrink\_to\_fit() - reduce memory usage by freeing unused memory
   %      \end{enumerate}
   %  \item \textbf{Time complexity of the operations}:
   %      \begin{enumerate}
   %          \item \textbf{Linear time O(n):} clear, insert, erase, assign, resize, destructor, operator=, copy constructor, constructor with a given rang
   %              \bigbreak \noindent 
   %              \textbf{Note:} push\_back and emplace\_back are O(n) because in the worst case, the vector needs to be resized in order to fit the new elements.
   %          \item \textbf{linear time o(n):} clear, insert, erase, assign, resize, destructor, operator=, copy constructor, constructor with a given rang
   %      \end{enumerate}
   %
   % \end{itemize}
   %
   % \pagebreak 
   % \bigbreak \noindent 
   % \textbf{Deque (Double ended queue)}: Another sequence container <deque>. Involves dynamic arrays, similar to vectors, but involves multiple ararys. Random access to its elements but a little slower than vectors, because of the multiple arrays.
   % \bigbreak \noindent 
   %   almost the same interface as vector
   % \begin{itemize}
   %     \item \textbf{different from vector:} deque has two open ends
   %      \item fast for adding/removing at both ends
   %      \item \textbf{Capacity stuff}: 
   %          \begin{enumerate}
   %              \item capacity() and reserve() are not available for deque
   %              \item capacity and allocation are completely automatically managed for deque, no user suppor
   %          \end{enumerate}
   %      \item \textbf{Extra modifiers}: In deques, we have 
   %          \begin{enumerate}
   %              \item \textbf{push\_front()}
   %              \item \textbf{pop\_front()}
   %              \item \textbf{emplace\_front()}
   %          \end{enumerate}
   %          Along with the back stuff that vectors have.
   %      \item \textbf{Internal memory}: internal memory is not contiguous (split into multiple arrays). Although we can use random access is if it were. element access and iterator movement involves more calculation comparing to vector
   %          \bigbreak \noindent 
   %          Iterators may need to jump between different memory blocks. max\_size may be larger because a deque may occupy multiple blocks of memory
   %      \item \textbf{Adding at front or end}:  All iterators are invalidated; references are not invalidated
   %          \bigbreak \noindent 
   %      \item \textbf{Removing from front or end}: Iterators and references of other positions are not invalidated. end() is invalidated
   %      \item \textbf{adding or removing anywhere other than two ends}: All iterators and references are invalidated
   %      \item \textbf{Advantages of deques}:
   %          \begin{enumerate}
   %              \item fast adding/removing at both ends (though still slow inadding/removing in the middle)
   %              \item possiblely larger max\_size
   %              \item massive reallocations are avoided
   %          \end{enumerate}
   % \end{itemize}
   %
   % \pagebreak \bigbreak \noindent 
   % \textbf{List}: (doubly linked list) Another sequence container <list>
   % \begin{itemize}
   %     \item \textbf{Properties}:
   %         \begin{enumerate}
   %             \item Doubly-linked list
   %              \item No random access of elements
   %              \item Adding or removing \textbf{anywhere} is fast, as long as you have reference to the location where you want to add/remove, otherwise you need to traverse the list to reach the location
   %              \item adding/removing does not invalidate pointers, references, and iterators to other elements
   %              \item there is no reallocation
   %         \end{enumerate}
   %      \item \textbf{Capacity stuff}: Capacity and reserve are not available for lists, each element of the list has its own memory. Elements occupy non-contiguous memory.
   %      \item \textbf{Element access}: No [], no at().
   %      \item \textbf{Operations on lists}:
   %          \begin{enumerate}
   %              \item remove( ): remove all elements with a certain value
   %              \item remove\_if( ): remove all elements that satisfy certain criterion.
   %              \item erase( ): remove an element with a specified iterator (note that erase here returns an iterator for next pos.)
   %              \item unique( ): remove duplicates of consecutive elements
   %              \item splice( ): move elements from one list to another
   %              \item sort( ): sort all elements with $<$ or defined comparison
   %              \item merge( ): merge two sorted lists
   %              \item reverse( ): reverse the order of all elements
   %              \item many above methods are overloaded
   %          \end{enumerate}
   %      \item \textbf{Splicing (splice method)}: We pass iterator for position of insertion, list object to take elements from, begin, end range of source list
   % \end{itemize}
   %
   % \pagebreak 
   % \bigbreak \noindent 
   % \textbf{forward\_list}: Another sequence container <forward\_list>. Internally implemented by singly linked list. No random access of elements
   % \bigbreak \noindent 
   % Adding/removing does not invalidate pointers, references, and iterators to other elements. there is no reallocation
   % \begin{itemize}
   %     \item Only support forward iterators. (no -- operation), only forward traversal
   %      \item forward lists are more memory efficient than lists in some cases
   %      \item \textbf{Adding / removing properties}
   %          \begin{enumerate}
   %              \ite madding/removing at begin of a list is fast
   %              \item adding/removing at the next position of a given element is fast
   %      \item adding/removing anywhere requires traversal from head
   %          \end{enumerate}
   % \end{itemize}
   %
   % \pagebreak \bigbreak \noindent 
   % \textbf{Associative containers}
   % \begin{itemize}
   %     \item \textbf{Sorted}: Elements (or keys) are sorted. Internally height balanced binary search tree. 
   %         \bigbreak \noindent 
   %         orted according to a certain sorting criterion, by default its the < operator. You can provide you own criteria
   %         \bigbreak \noindent 
   %         Order of insertion does not matter
   %         \begin{enumerate}
   %             \item \textbf{Set:} Elements are sorted according to their own values. Each element only occurs once
   %             \item \textbf{multiset}: Set that allows duplicates
   %             \item \textbf{map}: each element is a key/value pair. Key is used for sorting elements. Each key occurs only once
   %             \item \textbf{multimap}: similar to map, except that it allows duplicates 
   %         \end{enumerate}
   %      \item \textbf{Unsorted}: Not sorted, internally organized as hash table
   %          \begin{enumerate}
   %              \item unordered set
   %              \item unordered multiset
   %              \item unordered map
   %              \item unordered multimap
   %          \end{enumerate}
   % \end{itemize}
   %
   % \bigbreak \noindent 
   % \textbf{Set and multiset}: When an element is added to a set, it’s automatically placed in a position to maintain the sorting status.
   % \bigbreak \noindent 
   % One cannot change an element value directly Otherwise the new value may break the correct order
   % \begin{itemize}
   %     \item No direct element access
   %     \item Elements referenced by iterators are constants
   % \end{itemize}
   % \bigbreak \noindent 
   % In order to change value, one needs to remove the element with the old value, add the new element with the new value
   % \bigbreak \noindent 
   % Sets and multisets are efficient for searching.
   % \bigbreak \noindent 
   % \textbf{Special search operations}
   % \begin{itemize}
   %     \item \textbf{count(elem)} : the number of elements with the value elem
   %     \item \textbf{find(elem)} : the position of the first element with value elem Note that it’s different from find() in <algorithm>
   %     \item \textbf{lower\_bound(elem)} : the position of first element $>=$ elem
   %     \item \textbf{upper\_bound(elem)} : the position of first element $>$ elem
   %     \item \textbf{equal\_range(elem)} : the range of elements == elem. The return value is a pair<iterator, iterator>
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Inserting and removing elements}
   % \begin{itemize}
   %     \item \textbf{insert( elem )}: Returns pair<iterator, bool>. The second field indicates the insertion is successful or not (since an element may already exists)
   %      \item \textbf{insert( pos, elem)}:
   %      \item \textbf{insert(begin, end)}:
   %      \item \textbf{erase(element)}:
   %      \item \textbf{erase(pos)}:
   %      \item \textbf{erase(begin, end)}
   %      \item \textbf{clear()}
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{size related operations}:
   % \begin{itemize}
   %     \item \textbf{size()}
   %      \item \textbf{empty()}
   %      \item \textbf{max\_size()}
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Assignments}
   % \begin{itemize}
   %     \item \textbf{operator=}
   %      \item \textbf{swap()}
   % \end{itemize}
   %
   % \pagebreak 
   % \bigbreak \noindent 
   % \textbf{map \& multimap}: Manage key/value pairs as elements
   % \bigbreak \noindent 
   % Multimap allows duplicate, while map does not. Elements are automatically sorted based on keys according to a certain sorting criterion
   % \bigbreak \noindent 
   % \textbf{Properties}
   % \begin{itemize}
   %     \item \textbf{Automatic sorting}: When a key/value pair is added to a map, it’s automatically placed in a position to maintain the sorting status based on the key
   %     \item \textbf{One cannot change the key of an element directly}: Otherwise the new value may break the correct order based on keys The keys of elements referenced by iterators are constants
   %      \item \textbf{In order to change a key, one needs to}: Remove the element with the old key, add the new element with the new key.
   %      \item \textbf{Efficient for searching based on keys}: Not efficient for searching based on values of elements
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Note:} One can still modify the value of an element directly
   % \bigbreak \noindent 
   % \textbf{Search operations}: 
   % \begin{itemize}
   %     \item \textbf{count(key)} : the number of elements with the key
   %     \item  \textbf{find(key)} : the position of the first element with the key
   %     \item \textbf{lower\_bound(key)} : the position of first element whose key $>=$ key
   %     \item \textbf{upper\_bound(key)} : the position of first element whose key $>$ key
   %     \item \textbf{equal\_range(key)} : the range of elements whose key == key. The return value is a pair
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Inserting and removing elements}
   % \begin{itemize}
   %     \item \textbf{insert( elem )}: The return type for map is pair<iterator, bool> The second field indicates the insertion is successful or not (since an element may already exists)
   %     \item \textbf{insert( pos, elem)}:
   %     \item \textbf{insert( beg, end )}:
   %     \item \textbf{erase(elem )}:
   %     \item \textbf{erase( pos )}: Note that in sequence containers, erase returns the position after the removed element, but in associative containers, erase does not return such position because it needs to traverse to find successor.
   %     \item \textbf{erase( beg, end )}:
   %     \item \textbf{clear()}:
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Size related operations}
   % \begin{itemize}
   %     \item \textbf{size()}:
   %      \item \textbf{empty()}:
   %      \item \textbf{max\_size()}:
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Assignments}
   % \begin{itemize}
   %     \item \textbf{operator=}:
   %      \item \textbf{sawp}:
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Return of [] operator}
   % \begin{itemize}
   %     \item \textbf{m[k]}: Returns a reference to the value of the element with key k. Inserts an element with k if it does not yet exist
   % \end{itemize}
   %
   %
   %
   %
   %
   %
   % \pagebreak \bigbreak \noindent 

   \pagebreak 
   \unsect{STL Algorithms}
   \subsection{<algorithm>}

   \pagebreak 
   \subsection{<numeric>}
   \bigbreak \noindent 
   \subsubsection{transform\_reduce}
   \bigbreak \noindent
   std::transform\_reduce is a function introduced in C++17 as part of the <numeric> header. It combines the functionality of both std::transform and std::reduce (also known as std::accumulate in earlier C++ standards). This algorithm applies a transformation to elements from one or two ranges and then reduces (aggregates) the results of that transformation using a specified binary operation.
   \bigbreak \noindent 
   The signature of std::transform\_reduce has several overloads, but it can be summarized in two forms:
   \bigbreak \noindent 
   \paragraph{Unary transform and reduce}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{cppcode}
    template <typename InputIt, typename T, typename BinaryOp1, typename UnaryOp>
    T transform_reduce(InputIt first, InputIt last, T init, BinaryOp1 binary_op, UnaryOp unary_op);
   \end{cppcode}
   \bigbreak \noindent 
   \begin{itemize}
       \item \textbf{first, last:} Input range [first, last).
       \item \textbf{init:} Initial value for the reduction.
       \item \textbf{binary\_op:} Binary operation to reduce the transformed values (e.g., std::plus<>() for summation).
       \item \textbf{unary\_op:} Unary operation to transform each element before reducing
   \end{itemize}
   \bigbreak \noindent 
   This version is for a single input range, where each element is transformed and then the transformed results are reduced.
   \bigbreak \noindent 
   Example
   \bigbreak \noindent 
   \begin{cppcode}
       #include <numeric>
       #include <vector>
       #include <iostream>

       int main() {
           std::vector<int> v = {1, 2, 3, 4, 5};
           int result = std::transform_reduce(v.begin(), v.end(), 0, std::plus<>(), [](int x) { return x * x; });
           std::cout << "Sum of squares: " << result << std::endl;
       }

   \end{cppcode}
   \begin{itemize}
       \item The unary\_op is the lambda function, which squares each element.
       \item The binary\_op is std::plus<>, which adds the squares together.
       \item The result will be $1^{2} + 2^{2} + 3^{2} + 4^{2} + 5^{2} = 55$.
   \end{itemize}

   \bigbreak \noindent 
   \paragraph{Binary transform and reduce}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{cppcode}
    template <typename InputIt1, typename InputIt2, typename T, typename BinaryOp1, typename BinaryOp2>
    T transform_reduce(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init, BinaryOp1 binary_op, BinaryOp2 binary_transform_op);
   \end{cppcode}
   \begin{itemize}
       \item \textbf{first1, last1:} First input range [first1, last1).
       \item \textbf{first2}: Second input range, assumed to have at least the same length as the first.
       \item \textbf{init:} Initial value for the reduction.
       \item \textbf{binary\_op:} Binary operation to reduce the transformed values.
       \item \textbf{binary\_transform\_op:} Binary operation to transform elements from both ranges before reducing.
   \end{itemize}
   \bigbreak \noindent 
   This version is for two input ranges, where pairs of elements from both ranges are transformed and then the transformed results are reduced.

   \bigbreak \noindent 
   Example
   \bigbreak \noindent 
   \begin{cppcode}
       #include <numeric>
       #include <vector>
       #include <iostream>

       int main() {
           std::vector<int> v1 = {1, 2, 3};
           std::vector<int> v2 = {4, 5, 6};
           int result = std::transform_reduce(v1.begin(), v1.end(), v2.begin(), 0, std::plus<>(), std::multiplies<>());
           std::cout << "Dot product: " << result << std::endl;
       }
   \end{cppcode}

   \pagebreak \bigbreak \noindent 
   \paragraph{std::plus<> and std::multiplies<>}
   \bigbreak \noindent \bigbreak \noindent 
   std::plus<> and std::multiplies<> are implemented as function objects
   \bigbreak \noindent 
   \begin{cppcode}
   template<typename T=void>
   struct plus {
       constexpr operator()(const T& lhs, const T& rhs) const {
           return lhs + rhs;
       }
   };

   template<typename T=void>
   struct multiplies {
       constexpr operator()(const T& lhs, const T& rhs) const {
           return lhs * rhs;
       }
   };
   \end{cppcode}
   \bigbreak \noindent 
   The \texttt{T = void} in function objects like std::plus and std::multiplies allows for more flexibility and generic usage.
   \bigbreak \noindent 
   The T = void part enables a more generic specialization for void, which allows the function object to work with mixed types (as long as the types support the required operation) or automatically deduce the argument types
   \bigbreak \noindent 
   By specializing for void, the compiler can automatically deduce the types of lhs and rhs. This means that you don’t have to explicitly specify a type when you use std::multiplies<>. For example, you can apply std::multiplies<> to two arguments of different types (e.g., int and float), and it will work as long as the multiplication operator (*) is defined for them.

   \bigbreak \noindent 
   \paragraph{Other key function objects}
   \bigbreak \noindent  \bigbreak \noindent 
   \begin{itemize}
       \item \texttt{std::plus}
       \item \texttt{std::minus}
       \item \texttt{std::multiplies}
       \item \texttt{std::divides}
       \item \texttt{std::modulus}
       \item \texttt{std::negate}
       \item \texttt{std::equal\_to}
       \item \texttt{std::not\_equal\_to}
       \item \texttt{std::greater}
       \item \texttt{std::less}
       \item \texttt{std::greater\_equal}
       \item \texttt{std::less\_equal}
       \item \texttt{std::logical\_and}
       \item \texttt{std::logical\_or}
       \item \texttt{std::logical\_not}
   \end{itemize}


   \pagebreak 
   \unsect{Type traits}
   \bigbreak \noindent 
   Type traits are a collection of template-based utilities that allow you to perform compile-time introspection and manipulation of types. They are part of the Standard Template Library (STL) and are available through the header <type\_traits>. These utilities help you gather information about types (e.g., whether a type is an integer or floating-point, whether it is const-qualified, etc.) and perform transformations on them (e.g., remove const, add reference, etc.).
   \begin{itemize}
       \item \textbf{Type Properties:} These allow you to query certain properties of a type
       \item \textbf{Type Modifications}: These traits allow you to modify types, like adding or removing qualifiers
        \item \textbf{Conditional Typing:} These help you select types conditionally:
        \item \textbf{Transformation Traits:} These are useful when you need to change a type in a generic way:
   \end{itemize}

   \bigbreak \noindent 
   \subsection{Nonstandard type of types}
   \bigbreak \noindent 
   \begin{itemize}
       \item \textbf{Fundamental:} Includes basic types like int, float, char, void, and nullptr\_t. They are built-in types in the language.
       \item \textbf{Arithmetic:} Includes all integral types (like int, char) and floating-point types (like float, double).
       \item \textbf{Scalar:} Includes arithmetic types, pointers, and nullptr\_t. Essentially, types that hold a single value.
       \item \textbf{Object:} Any type that can hold data in memory, including scalar types, arrays, and classes/structs.
       \item \textbf{Compound:} Any type built from other types, such as arrays, pointers, references, classes, or unions.
       \item \textbf{Trivial:} A type that has a trivial constructor, destructor, and copy/move operations. It means they can be easily copied or constructed without any custom behavior.
       \item \textbf{Trivially copyable:} A type that can be copied using simple memory operations, such as memcpy, without needing any special handling.
       \item \textbf{Polymorphic:} A class type that contains at least one virtual function, enabling runtime polymorphism through inheritance.
       \item \textbf{Abstract:} A class type with at least one pure virtual function, making it impossible to instantiate directly.
       \item \textbf{Final:} A class or virtual function marked as final cannot be derived from or overridden further.
       \item \textbf{Aggregate:} A simple class or struct with no private or protected members, no constructors, and no virtual functions, allowing it to be initialized with a brace-enclosed initializer list.
   \end{itemize}


   \bigbreak \noindent 
   \subsection{::value, ::type, and ::value\_type}
   \bigbreak \noindent 
   ::value, ::type, and ::value\_type are commonly seen in template metaprogramming, especially with traits and type manipulation.
   \begin{itemize}
       \item \textbf{::value}: Used in type traits to access a constant value. Typically, this is a static constexpr or enum that holds an integral value. 
           \bigbreak \noindent 
           \begin{cppcode}
           std::is_integral<int>::value  // true (1)
           \end{cppcode}
        \item \textbf{::type}: Refers to a type alias or typedef within a template. It is commonly used in type traits to represent the result of a type transformation or query.
            \bigbreak \noindent 
            \begin{cppcode}
            std::remove_const<const int>::type  // int (removes const qualifier)
            \end{cppcode}
        \item \textbf{::value\_type}: A member type that typically represents the type of elements stored in a container. Found in STL containers like std::vector or custom types.
            \bigbreak \noindent 
            \begin{cppcode}
            std::vector<int>::value_type  // int
            \end{cppcode}

   \end{itemize}

   \pagebreak 
   \unsect{Function Objects}
   \bigbreak \noindent 
   Functional arguments for algorithms don’t have to be functions. As seen with lambdas, functional arguments can be objects that behave like functions. Such an object is called a function object, or functor. Instead of using a lambda, you can define a function object as an object of a class that provides a function call operator
   \bigbreak \noindent 
   Function objects are another example of the power of generic programming and the concept of pure
   abstraction. You could say that anything that behaves like a function is a function. So, if you define
   an object that behaves as a function, it can be used like a function.
   \bigbreak \noindent 
   So, what is the behavior of a function? A functional behavior is something that you can call by
   using parentheses and passing arguments
   \bigbreak \noindent 
   All you have to do is define operator () with the appropriate parameter types:
   \bigbreak \noindent 
   \begin{cppcode}
       class c {
           public:
           void operator() (int x) {
               cout << "The value is: " << x << endl;
           }
       };

       c c1;
       c1(2); // Call the object as a function

       vector<int> v({1,2,3});
       std::for_each(b(v), e(v), c()); // Use function object for algorithms
   \end{cppcode}

   \bigbreak \noindent 
   \paragraph{Why?}
   \bigbreak \noindent \bigbreak \noindent 
   You may be wondering what all this is good for. You might even think that function objects look
   strange, nasty, or nonsensical. It is true that they do complicate code. However, function objects are
   more than functions, and they have some advantages:
   \begin{enumerate}
       \item Function objects are “functions with state.” Objects that behave like pointers are smart pointers. This is similarly true for objects that behave like functions: They can be “smart functions” because they may have abilities beyond operator (). Function objects may have other member functions and attributes. This means that function objects have a state. In fact, the same functionality, represented by two different function objects of the same type, may have different states at the same time. This is not possible for ordinary functions. Another advantage of function objects is that you can initialize them at runtime before you use/call them.
       \item Each function object has its own type. Ordinary functions have different types only when their signatures differ. However, function objects can have different types even when their signatures are the same. In fact, each functional behavior defined by a function object has its own type. This is a significant improvement for generic programming using templates because you can pass functional behavior as a template parameter. Doing so enables containers of different types to use the same kind of function object as a sorting criterion, ensuring that you don’t assign, combine, or compare collections that have different sorting criteria. You can even design hierarchies of function objects so that you can, for example, have different, special kinds of one general criterion.
       \item Function objects are usually faster than ordinary functions. The concept of templates usually allows better optimization because more details are defined at compile time. Thus, passing function objects instead of ordinary functions often results in better performance.
   \end{enumerate}

   \bigbreak \noindent 
   \paragraph{Predefined function objects}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{itemize}
       \item LESS<T>
       \item GREATER<T>
    \end{itemize}
   We can use these for example, in constructor of set:
   \bigbreak \noindent 
   \begin{cppcode}
       set<ELEM> C // A SET THAT SORTS WITH LESS<>
        set<ELEM, OPERATION> C // A SET THAT SORTS WITH OP
   \end{cppcode}
   \bigbreak \noindent 
     Examples:
   \begin{itemize}
       \item SET<INT> S1; // INTEGERS ARE SORTED BY <
       \item SET<INT, GREATER<INT> > S2; // INTEGERS ARE SORTED BY >
   \end{itemize}

   \bigbreak \noindent 
   \unsect{Decltype}
   \bigbreak \noindent 
   \begin{concept}
       \textbf{decltype} is a keyword in C++ introduced in C++11, which stands for "declared type". It is used to query the type of an expression without actually evaluating that expression. This can be particularly useful in template programming and type deduction, where the type of an expression might not be known until compile time.
   \end{concept}
   \bigbreak \noindent 
   \subsection{Syntax}
   \bigbreak \noindent 
   \begin{cppcode}
       decltype(expression) variable_name;
   \end{cppcode}
   \bigbreak \noindent 
   Here, \textbf{variable\_name} will have the same type as the type of \textbf{expression}. It's important to note that \textbf{expression} is not evaluated; \textbf{decltype} only deduces its type.
   \bigbreak \noindent 
   \subsection{Example}
   \bigbreak \noindent 
   \begin{cppcode}
       int a = 5;
       decltype(a) b = 5;

       cout << typeid(b).name() << endl; // Output: i
   \end{cppcode}

   \bigbreak \noindent 
   \subsection{Things to pair with decltype}
   \begin{itemize}
       \item \textbf{std::decay\_t} is commonly used with decltype to remove references and qualifiers from a type. It transforms types to their "decayed" forms, similar to what happens when passing an argument to a function.
           \bigbreak \noindent 
           \begin{cppcode}
               auto var = someFunction();
               using DecayedType = std::decay_t<decltype(var)>;
           \end{cppcode}
        \item \textbf{std::remove\_reference / std::remove\_const / std::remove\_cv:}: These traits can be used to strip references, const, and volatile qualifiers from the type deduced by decltype.
            \bigbreak \noindent 
            \begin{cppcode}
            using NonConstType = std::remove_const_t<decltype(someVar)>;
            \end{cppcode}
        \item \textbf{std::is\_same}: Useful when you want to compare the type deduced by decltype with some other type to perform type-checking in templates.
            \bigbreak \noindent 
            \begin{cppcode}
            static_assert(std::is_same_v<decltype(var), int>, "Type must be int");
            \end{cppcode}
        \item \textbf{std::common\_type:} It computes the common type between two or more types, which is useful when you want to get a type that can hold the result of an expression involving multiple types deduced by decltype.
            \bigbreak \noindent 
            \begin{cppcode}
            using CommonType = std::common_type_t<decltype(a), decltype(b)>;
            \end{cppcode}
        \item \textbf{std::conditional}: This allows for conditional type selection based on a compile-time boolean value, often paired with decltype to determine types based on some logic.
            \bigbreak \noindent 
            \begin{cppcode}
            using ConditionalType = std::conditional_t<some_condition, decltype(a), decltype(b)>;
            \end{cppcode}
            \bigbreak \noindent 
            $a$ if true, $b$ if false. A compile-time boolean value is a value that is determined during the compilation phase, rather than at runtime. You typically get these compile-time boolean values from type traits or constexpr values
   \end{itemize}

   Where $\_t$ is shorthand for $::type$ and $\_v$ is shorthand for $::value$

   \pagebreak 
   \unsect{Constexpr}
   \bigbreak \noindent 
   In C++, constexpr is a keyword that allows you to declare that a variable or function can be evaluated at compile time if its inputs are known during compilation. It is used to define constant expressions, which are expressions that can be computed at compile time, leading to potential performance improvements and safer code by ensuring certain values are computed early.
   \bigbreak \noindent 
   \subsection{Variables}
   \bigbreak \noindent 
   A constexpr variable is guaranteed to have a constant value, and that value is computed at compile time. This is useful for things like array sizes or any situation where you need a compile-time constant.
   \bigbreak \noindent 
   \begin{cppcode}
       constexpr int size = 10;  // size is computed at compile time
       int arr[size];            // Valid because size is constant
   \end{cppcode}

   \bigbreak \noindent 
   \subsection{Functions}
   \bigbreak \noindent 
   A constexpr function can be evaluated at compile time if its arguments are known at compile time. If the arguments are not known until runtime, it will behave like a regular function and be evaluated at runtime.
   \bigbreak \noindent 
   constexpr functions must have a single return statement, or all branches must return a value.
   \bigbreak \noindent 
   \begin{cppcode}
       constexpr int square(int x) {
           return x * x;
       }

       constexpr int result = square(5);  // This will be computed at compile time
   \end{cppcode}

   \pagebreak 
   \subsection{Object Constructors}
   \bigbreak \noindent 
   You can also mark constructors as constexpr, meaning you can create objects that are initialized at compile time
   \bigbreak \noindent 
   \begin{cppcode}
       struct Point {
           constexpr Point(int x, int y) : x(x), y(y) {}
           int x, y;
       };

       constexpr Point p(3, 4);  // Object created at compile time
   \end{cppcode}

   \bigbreak \noindent 
   \subsection{constexpr vs const}
   \bigbreak \noindent 
   const variables are constant at runtime but not necessarily at compile time. You can initialize const with runtime values.
   \bigbreak \noindent 
    constexpr implies const but guarantees that the value or function result is computed at compile time if possible.


    \pagebreak 
    \unsect{Function pointers and callable parametrs}
    \bigbreak \noindent 
    \subsection{Function pointers}
    \bigbreak \noindent 
    Function pointers are variables that store the address of a function. They can be passed as parameters to other functions, allowing the called function to invoke the pointed-to function.
    \bigbreak \noindent 
    \subsubsection{As types}
    \bigbreak \noindent 
    \begin{cppcode}
        void fn(unsigned short a) {
            cout << "Arg is: " << a << '\n';
        }

        void (*f)(unsigned short) = &fn;
        void (*f)(unsigned short) = fn;
        f(20);
    \end{cppcode}
    Here $f$ is a pointer to function that takes an unsigned short and returns void. You may notice that we can omit the address of operator. In C++, function names can implicitly convert to pointers to those functions. This behavior is similar to how array names decay to pointers to their first elements.
    \bigbreak \noindent 
    \bigbreak \noindent 
    \subsubsection{As function paramater}
    \begin{cppcode}
        void fn(unsigned short a) {
            cout << "Arg is: " << a << '\n';
        }

        void fun(void (*f)(unsigned short), int n) {
            f(n);
        }

        void (*f)(unsigned short) = &fn;
        fun(f, 12);
    \end{cppcode}
    \bigbreak \noindent 
    Here, fun is a function that has two parameters, a pointer a function that takes an unsigned short and returns void, and an integer n.
    \pagebreak \bigbreak \noindent 
    We can also pass lambdas.
    \bigbreak \noindent 
    \begin{cppcode}
        void fun(void (*f)(unsigned short), unsigned short x) {
            f(x);
        }

        auto lambda = [] (unsigned short n) -> void {
            cout << n << endl;
        };

        fun(lambda, 12);
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Function pointers to member functions}
    \bigbreak \noindent 
    Function pointers to member functions in C++ are a way to refer to non-static member functions of a class. They differ from regular function pointers because member functions implicitly take a this pointer to operate on a specific instance of the class.
    \bigbreak \noindent 
    To declare a pointer to a member function of a class ClassName with a signature ReturnType(ClassName::*)(Arguments)
    \bigbreak \noindent 
    \begin{cppcode}
        ReturnType (ClassName::*pointerName)(Arguments);
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            void print() {
                cout << "Hello world" << endl;
            }
        };

        void (foo::*f)() = &foo::print;
        foo f1;
        (f1.*f)();

        foo* fptr = &f1; // Through a ptr
        (fptr->*f)();
    \end{cppcode}

    \pagebreak \bigbreak \noindent 
    \subsection{Using std::function}
    \bigbreak \noindent 
    We can also define function types with std::function.
    \bigbreak \noindent 
    \begin{cppcode}
        void fn(unsigned short a) {
            cout << "Arg is: " << a << '\n';
        }

        void fun(std::function<void(unsigned short)> f, int x) {
            f(x);
        }

        fun(fn, 12);

        std::function<void(unsigned short)> f = [] (unsigned short a) -> void {
            cout << a << endl;
        };

        fun(f, 13);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{With forwarding references}
    \bigbreak \noindent 
    F\&\& in a template context allows you to accept any callable (function, lambda, functor) while preserving its lvalue/rvalue nature. This is a common pattern for writing generic functions that can accept various types of arguments and forward them to other functions without losing efficiency.
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename F>
    void fn(F&& fun) {
        std::invoke(std::forward<F>(fun));
    }
    \end{cppcode}
    \bigbreak \noindent 
    We used std::forward<F>(fun) instead of just fun. This ensures that if fun is an rvalue, it gets forwarded correctly as an rvalue; if it's an lvalue, it stays an lvalue. This is part of perfect forwarding.
    






    \pagebreak 
    \unsect{Templates}
    \bigbreak \noindent 
    Templates in C++ are a powerful feature that allows writing generic and reusable code. They enable functions and classes to operate with different data types without being rewritten for each specific type.
    \bigbreak \noindent 
    \subsection{Template Function}
    \bigbreak \noindent 
    A template function defines a family of functions that work with different data types. Here's how to write and use a template function:
    \bigbreak \noindent 
    \begin{cppcode}
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add<int>(3, 4) << std::endl; // Instantiates add<int>
    std::cout << add<double>(2.5, 3.1) << std::endl; // Instantiates add<double>
    return 0;
}
    \end{cppcode}

    \bigbreak \noindent 
    \pagebreak 
    \subsection{Template Class}
    \bigbreak \noindent 
    \begin{cppcode}
template <typename T>
class Stack {
    std::vector<T> data;

public:
    void push(T value) {
        data.push_back(value);
    }
    void pop() {
        data.pop_back();
    }
    T top() const {
        return data.back();
    }
    bool empty() const {
        return data.empty();
    }
};

int main() {
    Stack<int> intStack; // Instantiates Stack<int>
    intStack.push(10);
    intStack.push(20);
    std::cout << intStack.top() << std::endl;

    Stack<double> doubleStack; // Instantiates Stack<double>
    doubleStack.push(1.1);
    doubleStack.push(2.2);
    std::cout << doubleStack.top() << std::endl;
    return 0;
}
    \end{cppcode}










    \bigbreak \noindent 
    \subsection{Class vs typename keyword}
    \bigbreak \noindent 
    The choice between using \textbf{class} and \textbf{typename} in template declarations in C++ is largely a matter of style and historical context, as both keywords serve the same purpose

    \bigbreak \noindent 
    \subsection{Handle friend functions}
    \bigbreak \noindent 

    \subsubsection{Friendship to a Non-Template Function}
    \bigbreak \noindent 
    This is straightforward. You directly declare a non-template function as a friend inside your template class. This grants that specific function access to all instances of the template class, regardless of the type parameter.
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        class MyClass {
            friend void someFunction(MyClass<T>&);
        };
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{Friendship to a Template Function}
    \bigbreak \noindent 
    More commonly, you want a template function to be a friend to a template class. This allows each instantiation of the function template to access the corresponding instantiation of the class template.To achieve this, you need to forward declare the function template and then declare it as a friend inside your class template. The tricky part is that the syntax for declaring a template function as a friend inside a template class can vary based on what you're trying to achieve:
     \bigbreak \noindent 
    \textbf{How to forward declare:}
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    class myclass;

    template<typename T>
    void foo(myclass<T>&); 


    template<typename T>
    class myclass {

    public:
        friend void foo <T>(const myclass<T>& obj);
    };

template <typename T>
void foo(myclass<T>& obj) {
    // Define
}
    \end{cppcode}
    \pagebreak 
    \textbf{Different types:}
    \begin{itemize}
        \item More general form used when you want the friendship to apply to all instantiations of the function template
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    friend void someFunction<>(MyClass<T>&); // Specific instantiation
                };
            \end{cppcode}
        \item All instantiations of the function template are friends:
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    template <typename U>
                    friend void someFunction(MyClass<U>&); // All instantiations
                };
            \end{cppcode}
        \item This form ties the friendship to the specific template instantiation of both MyClass and someFunction using the same template argument T. The function template that takes the same template parameters:
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    friend void someFunction<T>(MyClass<T>&); // Matched instantiation
                };
            \end{cppcode}
    \end{itemize}

    \pagebreak 
    \subsection{Function Template Specialization}
    \bigbreak \noindent 
    \begin{concept}
        \textbf{Template specialization} allows you to define a different implementation for a particular data type.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
    template <typename T>
    T min(T x, T y) {
        return (x < y) ? x : y;
    }

    template <>
    const char* min(const char* x, const char* y) {
        return (strcmp(x, y) < 0) ? x : y;
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Class/Struct Template Specialization}
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    struct foo {
        T x = 20;
    };

    template<>
    struct foo<char> {
        char x = 'z';
    };
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Template Parameters}
    \bigbreak \noindent 
    \begin{concept}
        Templates can have more than one parameter, including non-type parameters.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T, int size>
        class FixedArray {
            private:
            T arr[size];
            // implementation
        };
    \end{cppcode}

     \bigbreak \noindent 
    \subsection{Trailing return type}
    \bigbreak \noindent 
    In traditional C++, the return type of a function is declared at the beginning of the function declaration. However, C++11 introduced a new syntax that allows the return type to be specified after the parameter list, using auto at the beginning and -> Type after the parameter list.
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \bigbreak \noindent 
    \begin{cppcode}
    auto functionName(parameters) -> returnType {
        // function body
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    auto foo(int a, int b) -> int {
        return a + b;
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Template functions with mixed types (Trailing return type)}
    \bigbreak \noindent 
    \begin{concept}
        To address the challenge of determining the return type for a template function that accepts two different types, we can utilize a strategy involving \textbf{auto} and a \textbf{trailing return type} with \textbf{decltype}. This approach effectively resolves the ambiguity of the return type in such template functions.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        auto add(T t, U u) -> decltype(t + u) {
            return t + u;
        }
    \end{cppcode}

    \pagebreak 
    \subsection{Template functions with mixed types (Deduced return type)}
    Alternatively, C++14 introduced the concept \textbf{deduced return type}. Which provides a simpler way to handle the situation described above
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        decltype(auto) foo(T a, U b)  {
            return a + b;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Dependent name resolution}
    \bigbreak \noindent 
    Suppose we have the code
    \begin{cppcode}
    template <typename T>
    void showcont(const T& cont) {
        typename T::iterator it;
        for (it = cont.begin(); it! = cont.end(); ++it) 
            cout << *it << endl;
    }
    \end{cppcode}
    \bigbreak \noindent 
    Why do we need the word "\texttt{typename}" before the iterator \texttt{it} is declared?
    \bigbreak \noindent 
    This concept is called "\textbf{dependent name resolution}" in C++. Specifically, it falls under the broader topic of dependent types and dependent names in template programming.
    \bigbreak \noindent 
    \subsubsection{Dependent names}
    \bigbreak \noindent 
    In templates, a dependent name is any name that depends on a template parameter. For example, \texttt{T::iterator} in the code above depends on the template parameter \texttt{T}. The compiler cannot determine the exact meaning of T::iterator until the template is instantiated with a concrete type.
    \bigbreak \noindent 
    \subsubsection{Typename Keyword}
    \bigbreak \noindent 
     In C++, the typename keyword is used to indicate that a dependent name refers to a type. Without typename, the compiler might interpret T::iterator as something else, such as a static member variable or a constant. Using typename helps disambiguate and ensures the compiler treats T::iterator as a type.
     \bigbreak \noindent 
     \textit{Dependent name resolution} is the process by which the compiler determines the meaning of dependent names during template instantiation. When the template is instantiated with a specific type, the compiler resolves T::iterator to the actual nested type within T.
     \bigbreak \noindent 
     C++ uses a two-phase name lookup process for templates. In the first phase, the compiler parses the template without knowing the actual template arguments. In the second phase, the compiler instantiates the template with the provided arguments. Since T::iterator cannot be resolved in the first phase (before knowing what T actually is), typename is required to instruct the compiler that iterator is indeed a type
     \bigbreak \noindent 
     \subsubsection{Nested types}
     \bigbreak \noindent 
     Any nested type within a template parameter requires the typename keyword. For example:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         void foo() {
             typename T::value_type val; // T::value_type is a nested type within T
         }
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Prereq: Using aliases defined in classes}
     \bigbreak \noindent 
     We can define aliases inside classes, but then we need to reference them outside the class by using the \textit{scope resolution operator}
     \bigbreak \noindent 
     \begin{cppcode}
        class foo {
        public:
            alias ll = long long;
            ll b = 10;
         };

         int main() {
             foo::ll a = 5;
             return 0;
         }
     \end{cppcode}
     \bigbreak \noindent 
     This also applies to typedefs...
    \bigbreak \noindent 
    \begin{cppcode}
        class foo {
        public:
            typedef long long ll;
        }

        int main() {
            foo::ll a = 10;
            return 0;
        }
    \end{cppcode}

     \bigbreak \noindent 
     \nt{We can define aliases inside functions, but we can't use them outside the function they are defined in}

     \bigbreak \noindent 
     \subsubsection{Type Aliases}
     \bigbreak \noindent 
     If a class template has a type alias defined inside it, you need to use typename when referring to that alias in another template. For example:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         class Wrapper {
             public:
             using PointerType = T*; // A type alias within Wrapper
         };

         template <typename T>
         void bar() {
             typename Wrapper<T>::PointerType ptr; // typename is required here
         }
     \end{cppcode}

     \pagebreak 
     \subsubsection{Return Types in Template Functions}
     \bigbreak \noindent 
     When using a dependent type as a return type for a function within a template, typename is necessary:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         typename T::value_type getValue(const T& container) {
             return *container.begin();
         }
     \end{cppcode}
     \bigbreak \noindent 
     \subsubsection{Base Class Members}
     \bigbreak \noindent 
     When accessing a member of a base class that is a dependent type, typename is required. 
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         class foo {
         public:
             typedef T* tp;
         };

         template <typename T>
         class bar : public foo<T> {
         public:
             typename foo<T>::tp a;
         };
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Dependent Types in Expressions}
     \bigbreak \noindent 
     If you use a dependent type within an expression, you must indicate it with typename:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         void example(const T& cont) {
             typename T::size_type size = cont.size(); // typename required here
         }
     \end{cppcode}
     \bigbreak \noindent 
     Where size\_type is a type alias defined inside the class or container type T. In this context, size\_type typically represents an unsigned integer type used to express sizes and counts of elements in the container.

     \bigbreak \noindent 
     \subsection{Variadic templates with functions}
     \bigbreak \noindent 
     Variadic templates in C++ allow you to write functions or classes that can take an arbitrary number of template arguments
     \bigbreak \noindent 
     A variadic template is defined by using an ellipsis (...) both in the template parameter list and in the function arguments. 
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename... Args>
         void print(Args... args) {
             // function body
         }
     \end{cppcode}
     \bigbreak \noindent 
     \begin{itemize}
         \item \textbf{typename...} Args declares a parameter pack named Args, which can hold zero or more template arguments.
         \item \textbf{Args...} args is another parameter pack that holds the function parameters of arbitrary types and numbers.
     \end{itemize}
     \bigbreak \noindent 
     A parameter pack in C++ is a feature of variadic templates that represents zero or more template parameters or function arguments. It allows functions or classes to handle an arbitrary number of arguments.
     \bigbreak \noindent 
     To process the elements of the parameter pack, you can use a technique called pack expansion. A common way to do this is by recursively calling the variadic function. 
     \bigbreak \noindent 
     \begin{cppcode}
         #include <iostream>

         void print() {
             std::cout << std::endl;
         }

         template<typename T, typename... Args>
         void print(T first, Args... args) {
             std::cout << first << " ";
             print(args...);  // recursive call with remaining arguments
         }

         int main() {
             print(1, 2.5, "Hello", 'A');
             return 0;
        }
     \end{cppcode}
     \bigbreak \noindent 
     In C++17, fold expressions simplify handling variadic templates by eliminating the need for recursion. You can apply an operation over the entire parameter pack in a single expression
     \bigbreak \noindent 
     \begin{cppcode}
         #include <iostream>

         template<typename... Args>
         void print(Args... a) {
             ((std::cout << a << std::endl) , ...); // Right fold
              (..., (std::cout << a << endl)); // Left fold
              // Both folds output the same, more on this later
         }

         int main() {
             print(1, 2.5, "Hello", 'A');
             return 0;
         }
     \end{cppcode}
     \bigbreak \noindent 
     The ellipsis ... is part of the fold expression syntax, and here it’s applied to the entire operation inside the parentheses: (cout << a << endl). This means the expression cout << a << endl will be expanded for each argument a in the parameter pack.
     \bigbreak \noindent 
     The comma operator (operator,) allows multiple expressions to be evaluated in sequence. It guarantees that for each a, the expression cout << a << endl will be executed. This effectively prints each argument followed by a newline.
     \bigbreak \noindent 
     \bigbreak \noindent 
     The expanded form of ((cout << a << endl), ...) would look something like:
     \bigbreak \noindent 
     \begin{cppcode}
         (cout << arg1 << endl, cout << arg2 << endl, cout << arg3 << endl, ...);
     \end{cppcode}
     \bigbreak \noindent 
     To exapand upon this...
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename ... args>
         void fn(args ... a) {
             ((std::cout << a << endl) , ...);
         }

         void f(int a, int b, int c) {
             cout << a << endl, cout << b << endl, cout << c << endl;
         }

         fn(1,2,3);
         cout << endl;
         f(1,2,3);
     \end{cppcode}
     \bigbreak \noindent 
     Both functions have the same output.
     \bigbreak \noindent 
     In the example above we are using the comma operator, but it could be any operator
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename T, typename... Args>
         T fn(Args ... a) {
             int sum = 0;
             sum = (sum + ... + a); // Expand: sum = (0 + a_1 + a_2 + ... + a_n);
             (sum += ... += a); // Expand: sum += a_1 += a_2 += a_3 += ... += a_n
             sum += (... + a); // Expand: sum += (a-1 + ... + a_n)
             return sum;
         }
     \end{cppcode}
     \bigbreak \noindent
     Recall, assignment operators in c++ are right to left

     \pagebreak \bigbreak \noindent 
     \subsection{Left vs right folds}
     \bigbreak \noindent 
     A left fold applies the operator from left to right.
     \bigbreak \noindent 
     \begin{cppcode}
         (... op pack)
     \end{cppcode}
     \bigbreak \noindent 
     The operator op is applied between the leftmost elements first, and then successively to the rest of the elements.
     \bigbreak \noindent 
     A right fold applies the operator from right to left.
     \bigbreak \noindent 
     \begin{cppcode}
     pack op ...
     \end{cppcode}
     \bigbreak \noindent 
     The operator op is applied between the rightmost elements first, and then successively to the remaining elements.

     \pagebreak \bigbreak \noindent 
     \subsection{Parentheses in fold expressions}
     \bigbreak \noindent 
     The parentheses in fold expressions in C++ are used to ensure correct grouping and to determine how the fold expression expands over the parameter pack. They help dictate the precedence and associativity of the operation being applied to the elements of the parameter pack, ensuring the operator is applied in the desired order.
     \bigbreak \noindent 
     Parentheses are necessary to group the fold expression correctly, especially when using operators like +, -, +=, etc., which need to be explicitly applied across the elements of a parameter pack.
     \bigbreak \noindent 
     The parentheses ensure that the fold applies the operator across the entire parameter pack and handles the result correctly.
     \bigbreak \noindent 
     \begin{cppcode}
     (sum += ... + args);
     \end{cppcode}
     \bigbreak \noindent 
     Here, the parentheses ensure that the += is applied between sum and the result of the left fold ... + args.
     \bigbreak \noindent 
     Without parentheses, operator precedence could cause the fold expression to be parsed incorrectly by the compiler, leading to syntax errors or unintended behavior.

     \bigbreak \noindent 
     \subsection{Pack size}
     \bigbreak \noindent 
     sizeof...(Args) (also called "pack size") is a compile-time operator that gives you the number of template arguments in the parameter pack Args.... It works for both types and non-type template parameter packs. This can be helpful in function calls, especially when you're dealing with variadic templates and need to know the size of the pack for controlling logic or iteration.
     \bigbreak \noindent 
     \begin{cppcode}
         // Function template using sizeof... to count the number of arguments
         template<typename... Args>
         void countArguments(Args... args) {
             std::cout << "Number of arguments: " << sizeof...(Args) << std::endl;
         }
     \end{cppcode}

     \pagebreak 
     \subsection{Function calls in fold expressions}
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename T>
         void print(T t) {
             cout << t << endl;
         }

         template<typename... args>
         void f(args...a) {
             (print(a),...);
             (..., print(a)); // Does the same
         }

     \end{cppcode}

     


     \pagebreak \bigbreak \noindent 
     \subsection{Variadic templates with classes}
     \bigbreak \noindent 
     A variadic class template is defined in much the same way as a variadic function template, but it applies to classes. You use typename... (or class...) to declare a parameter pack in the class definition, which allows the class to accept multiple template arguments.
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename... Args>
         class MyClass {
             // Use Args... in the class definition
         };
     \end{cppcode}
     \bigbreak \noindent 
     In this example, Args... is a parameter pack that can hold any number of types.
     \bigbreak \noindent 
     \begin{cppcode}
         // Variadic class template
         template<typename... Args>
         class MyClass {};

         // Specialization for one type argument
         template<typename T>
         class MyClass<T> {
             public:
             void display() {
                 std::cout << "One template argument: " << typeid(T).name() << std::endl;
             }
         };

         // Specialization for two type arguments
         template<typename T1, typename T2>
         class MyClass<T1, T2> {
             public:
             void display() {
                 std::cout << "Two template arguments: "
                 << typeid(T1).name() << " and " << typeid(T2).name() << std::endl;
             }
         };

         // Specialization for more than two arguments
         template<typename T, typename... Rest>
         class MyClass<T, Rest...> {
             public:
             void display() {
                 std::cout << "First argument: " << typeid(T).name() << std::endl;
                 std::cout << "Number of remaining arguments: " << sizeof...(Rest) << std::endl;
             }
         };
     \end{cppcode}
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename...Args>
         struct foo {

             void printargs(Args...args) {
                 ((cout << args << endl), ...);
             }
         };

         foo<int,string,double> a;
         a.printargs(1,"foo",3.14f);
     \end{cppcode}


     \pagebreak 
     \subsection{std::forward}
     \bigbreak \noindent 
     std::forward is a utility function in C++ that is used primarily in template functions to enable perfect forwarding. It is part of the C++ Standard Library and is typically used to forward arguments while preserving their value category (whether they are lvalues or rvalues).
     \bigbreak \noindent 
     In generic template code, when you want to pass arguments to another function or callable, you need to preserve whether those arguments were passed as lvalues (references to existing objects) or rvalues (temporary objects). std::forward allows you to forward arguments while ensuring that their value category is preserved.
     \bigbreak \noindent 
     Without std::forward, arguments passed to template functions would often lose their original value category, especially when working with rvalues
     \bigbreak \noindent 
     \begin{cppcode}
         template< class T >
         T&& forward( typename std::remove_reference<T>::type\& arg ) noexcept;
     \end{cppcode}
     \bigbreak \noindent 
     If the argument is an rvalue std::forward will cast it to an rvalue (i.e., T\&\&), allowing the function to move the argument if appropriate (typically used in move semantics).
     \bigbreak \noindent 
     If the argument is an lvalue std::forward will cast it to an lvalue reference (T\&), ensuring that the original object is used and not moved or copied unnecessarily.
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         void wrapper(T&& arg) {
             func(std::forward<T>(arg));  // Perfectly forward arg, preserving its value category
         }
     \end{cppcode}
     \bigbreak \noindent 
     Now, std::forward<T>(arg) ensures that if arg was originally passed as an rvalue, it remains an rvalue when forwarded to func, enabling func to take advantage of move semantics. Similarly, if arg was an lvalue, it is passed as an lvalue.
     \bigbreak \noindent 
     \subsubsection{Key Differences Between std::forward and std::move}
     \bigbreak \noindent 
     std::move Unconditionally casts the argument to an rvalue, suggesting that it can be "moved from" (even if it was originally an lvalue). It doesn't preserve the original value category but rather forces the argument to be treated as an rvalue.
     \bigbreak \noindent 
     std::forward Conditionally casts the argument, preserving its value category. It is only used in template code and requires knowledge of whether the argument was an lvalue or rvalue (via the type deduction)

     \pagebreak \bigbreak \noindent 
     \begin{cppcode}
         #include <iostream>
         #include <utility>

         void process(const std::string& s) {
             std::cout << "Lvalue: " << s << '\n';
         }

         void process(std::string&& s) {
             std::cout << "Rvalue: " << s << '\n';
         }

         template <typename T>
         void wrapper(T&& arg) {
             process(std::forward<T>(arg));  // Forward arg to process
         }

         int main() {
             std::string str = "Hello";

             wrapper(str);            // Lvalue is forwarded, calls process(const std::string&)
             wrapper(std::move(str)); // Rvalue is forwarded, calls process(std::string&&)
         }

     \end{cppcode}

     \pagebreak 
     \subsection{Universal reference (forwarding reference)}
     \bigbreak \noindent 
     Universal references (also called forwarding references) in C++ are template parameters declared as T\&\& that can bind to both lvalues and rvalues. The behavior of a universal reference depends on the type of the argument passed:
     \bigbreak \noindent 
     If an lvalue is passed, T\&\& becomes an lvalue reference (T\&).
    If an rvalue is passed, T\&\& remains an rvalue reference (T\&\&).
    \bigbreak \noindent 
    Universal references are typically used with perfect forwarding, allowing you to forward arguments to other functions while preserving their value category (lvalue or rvalue).
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    void bar(T&& x) {
        cout << x << '\n';
    }

    template<typename T>
    void foo(T&& x) {
        bar(std::forward<T>(x));
    }

    template<typename T>
    void fn(T&& x) {
        cout << x << endl;
    }

    int x = 20;
    decltype(x)& y = x;
    fn(std::forward<decltype(y)>(y));
    \end{cppcode}










     \pagebreak 
     \unsect{More on the comma operator}
     \bigbreak \noindent 
     The comma acts as both a separator and an operator, depending on the context.
     \bigbreak \noindent 
     As a separator, The comma separates elements in lists, such as function arguments, initializer lists, or variables in declarations. This much is trivial
     \bigbreak \noindent 
     As an Operator, the comma operator (when used in expressions) evaluates two or more expressions from left to right, and the result of the entire comma expression is the result of the right-most expression.
     \bigbreak \noindent 
     \begin{cppcode}
     int a = (1, 2);  // a gets the value of 2
     \end{cppcode}
     \bigbreak \noindent 
     In this case, 1 is evaluated first, then 2 is evaluated, and the result of the entire expression is 2.
     \bigbreak \noindent 
     In loops, 
     \bigbreak \noindent 
     \begin{cppcode}
         for (int i = 0, j = 10; i < j; ++i, --j) {
             // Do something
         }
     \end{cppcode}
     \bigbreak \noindent 
     Here, the comma separates the initialization of $i$ and $j$ as well as the increment and decrement operations in the loop.









     \pagebreak 
     \unsect{More on Lambdas}
     \bigbreak \noindent 
     \subsection{Auto in lambda args}
     \bigbreak \noindent 
     In C++, the auto keyword is used in lambda expressions to infer the type of the parameters or the return type. It helps make lambda functions more flexible and convenient to use without explicitly specifying types, especially when types are complex or unknown at compile time.
     \bigbreak \noindent 
     \begin{cppcode}
         struct foo {
             int x = 0, y = 0;

             foo() = default;
             foo(int a, int b) : x(a), y(b) {}

             friend std::ostream& operator<<(std::ostream& os, foo f);
         };

         std::ostream& operator<<(std::ostream& os, foo f) {
             os << "x: " << f.x << endl << "y: " << f.y << endl;
             return os;
         }

         foo f1(1,2), f2(3,4);

         auto fn = [] (const auto& a, const auto& b) -> auto {
             cout << a << endl << b;
         };

         fn(f1,f2);
     \end{cppcode}
     \bigbreak \noindent 
     It should be noted that you cannot do this with regular functions
     \bigbreak \noindent 
     \begin{cppcode}
         // Not allowed!
         void fn(const auto& a, const auto& b) { 
             cout << a << endl << b;
         }
     \end{cppcode}


     \subsection{Template lambdas}
     \bigbreak \noindent 
     Since C++20, we can make template lambdas.
     \bigbreak \noindent 
     \begin{cppcode}
         auto fn = []<typename T>(const T& a, const T& b) -> auto{
             cout << a << endl << b;
         };
         fn(f1,f2); // No need for <> notation, auto deduced
     \end{cppcode}
     

     \pagebreak 
     \subsection{Recursive lambdas}
     \bigbreak \noindent 
     In C++, you cannot use auto to declare a recursive lambda directly because lambdas do not have a name. Since they are anonymous, you can't directly reference the lambda within its own body. For recursion, a function needs to call itself, but without a name, the lambda cannot do that.
     \bigbreak \noindent 
     As a side note, we also must capture the lambda by reference.
     \bigbreak \noindent 
     \begin{cppcode}
         auto lambda = [&lambda](int x, int n) { // ERROR 
             if (n == 0) return 1;

             return x * lambda(x,n-1);
        };
     \end{cppcode}
     \bigbreak \noindent 
     This code gives the error "Variable 'lambda' declared with deduced type 'auto' cannot appear in its own initializer".
     \bigbreak \noindent 
     We can use std::function to explicitly define the type of the lambda. This works because std::function provides a way to store callable objects with a known signature.
     \bigbreak \noindent 
     \begin{cppcode}
         std::function<int(int,int)> lambda = [&lambda](int x, int n) { // Works
             if (n == 0) return 1;

             return x * lambda(x,n-1);
         };
     \end{cppcode}






    \pagebreak 
    \unsect{When initializer lists are required}
    \bigbreak \noindent 
    Using initialization lists to initialize data members in a constructor can be convenient if you don't need to do any error-checking on the constructor arguments. There are also several instances in C++ where the use of an initializer list to initialize a data member is actually required:

    \begin{itemize}
        \item Data members that are const but not static must be initialized using an initialization list.
        \item Data members that are references must be initialized using an initialization list.
        \item An initialization list can be used to explicitly call a constructor that takes arguments for a data member that is an object of another class (see the employee constructor example above).
        \item In a derived class constructor, an initialization list can be used to explicitly call a base class constructor that takes arguments.
    \end{itemize}

    \pagebreak 
    \unsect{Inheritence and Subtype Polymorphism}
    \bigbreak \noindent 
    \subsection{OOP Main Concepts}
    \bigbreak \noindent 
    An \textbf{object} is a software bundle of related state (data members or properties) and behavior (member functions or methods). Software objects are often used to model the real-world objects that you find in everyday life.
    \bigbreak \noindent 
    A \textbf{class} is a blueprint or prototype from which objects are created. A class is an abstract definition that is made concrete at run-time when objects based upon the class are created.
    \bigbreak \noindent 
    \textbf{Encapsulation}, also known as data hiding, is the act of concealing the functionality of a class so that the internal operations are hidden, and irrelevant, to the programmer. With correct encapsulation, the developer does not need to understand how the class actually operates in order to communicate with it via its publicly available member functions and data members, known as its public interface. Encapsulation is essential to creating maintainable object-oriented programs. When the interaction with an object uses only the publicly available interface of member functions and properties, the class of the object becomes a correctly isolated unit. This unit can then be replaced independently to fix bugs, to change internal behavior or to improve functionality or performance. Encapsulation also promotes data integrity by allowing public "set" member functions to validate new values that are to be assigned to private data members.
    \bigbreak \noindent 
    \textbf{Message passing}, also known as interfacing, describes the communication between objects using their public interfaces. The primary way of passing a message to an object in C++ is to call a member function for that object.
    \bigbreak \noindent 
    \textbf{Abstraction} is the process of representing simplified versions of real-world objects in your classes and objects. A car class does not describe every possible detail of a car, only the relevant parts for the system being developed. Modeling software around real-world objects can vastly reduce the time required to understand a solution and be able to develop and maintain it.
    \bigbreak \noindent 
    \subsection{Object Relationships}
    \bigbreak \noindent 
    Objects can work together in many ways within a system. In some situations, classes and objects can be tightly coupled together to provide more complex functionality. This "has-a" relationship is known as composition. For example, modeling a car might involve creating individual classes such as wheel, engine, and transmission. The car class could then contain objects of these classes as data members, since a car "has" an engine, wheels, and a transmission. The internal workings of each class are not important due to encapsulation as the communication between the objects is still via passing messages to their public interfaces.
    \bigbreak \noindent 
    Other types of relationships may be modeled. A class may simply "use" an object of another class (perhaps creating the object as a local variable in one of its member functions). A class may also "know" about an object of another class without owning it (in C++, this association relationship might be modeled using a pointer or reference to the object).
    \bigbreak \noindent 
    Inheritance is an object-oriented programming concept used to model an "is-a" relationship between two classes. It allows one class (the derived class or subclass) to be based upon another (the base class or superclass) and inherit all of its functionality automatically. Additional code may then be added to create a more specialized version of the base class.

    \bigbreak \noindent 
    \subsection{Ineritance}
    \bigbreak \noindent 
    A \textbf{derived class} is more specific than its base class and represents a smaller group of objects.
    \bigbreak \noindent 
    A \textbf{direct base class} is the base class from which a derived class explicitly inherits. An indirect base class is inherited from two or more levels up the class hierarchy.
    \bigbreak \noindent 
    In the case of single inheritance, a class is derived from one base class. C++ also supports multiple inheritance, in which a derived class inherits from multiple (possibly unrelated) classes. Single inheritance is straightforward. Multiple inheritance can be complex and error prone.
    \bigbreak \noindent 
    Single-inheritance relationships form tree-like hierarchical structures - a base class exists in a hierarchical relationship with its derived classes.
    \bigbreak \noindent 
    C++ offers three kinds of inheritance - public, protected, and private. public inheritance in C++ is used to model "is a" relationships. Every object of a derived class is also an object of that derived class's base class. However, base-class objects are not objects of their derived classes. For example, all car objects are also vehicle objects, but not all vehicle objects are car objects.
    \bigbreak \noindent 
    With public inheritance, a derived class may
    \begin{itemize}
        \item add new data members
        \item add new member functions
        \item override member functions defined in the base class
    \end{itemize}
    private and protected inheritance do not model "is-a" relationships and are not used as frequently.

    \bigbreak \noindent 
    \subsection{Inheritance and Member Access}
    \bigbreak \noindent 
    \begin{center}
        \begin{tabular}{c|c|c|c}
            Base class modifier	& public Inheritance	& protected Inheritance	& private Inheritance \\
            \hline
            public	&public 	&protected 	&Hidden  \\
            protected &	protected 	&protected 	&Hidden  \\
            private	&Hidden 	&Hidden 	&Hidden 
        \end{tabular}

    \end{center}
    \bigbreak \noindent 
    A base class's public members are accessible anywhere that the program has a "handle" to an object (an object name or a pointer or reference to an object) of the base class or to an object of one of that base class's derived classes. Derived class member functions can access public base class data members directly.
    \bigbreak \noindent 
    A base class's private members are "hidden" - they are accessible only within the definition of that base class or from a friend of that class. A derived class cannot access the private members of its base class directly; allowing this would violate the encapsulation of the base class. A derived class can only access private base-class members through non-private member functions defined in the base class and inherited by the derived class.
    \bigbreak \noindent 
    A base class's protected members have an intermediate level of protection between public and private access. A base class's protected members can be directly accessed by member functions of that base class, by a friend of that base class, by member functions of a class derived from that base class, and by a friend of a class derived from that base class.
    \bigbreak \noindent 
    The use of protected data members allows for a slight increase in performance, because we avoid incurring the overhead of a call to a "set" or "get" member function. Unfortunately, protected data members often yield two major problems. First, the derived class object does not have to use a "set" member function to change the value of the base class's protected data. A derived class object can easily assign an illegal value to a protected data member. Second, derived class member functions are more likely to depend on base class implementation details. Changes to the base class may require changes to some or all of the derived classes of that base class.
    \bigbreak \noindent 
    Declaring data members private, while providing non-private member functions to manipulate and perform validation checking on this data, enforces good software engineering. The programmer should be able to change the base class implementation freely, while still providing the same services to the derived class. The performance increases gained by using protected data members are often negligible compared to the optimizations that compilers can perform. It is appropriate to use the protected access modifier when a base class should provide a service (i.e., a member function) only to its derived classes and should not provide the service to other clients.
    \bigbreak \noindent 
    When a base class member function is inappropriate for a derived class, that member function can be redefined in the derived class with an appropriate implementation. This is called overriding the base class member function.
    \bigbreak \noindent 
    When a derived class member function overrides a base class member function, the base class member function can still be accessed from the derived class by preceding the base class member function name with the base class name and the scope resolution operator (::).
    \bigbreak \noindent 
    When an object of a derived class is created, the base class's constructor is called immediately (either explicitly or implicitly) to initialize the base class data members in the derived class object (before the derived class data members are initialized). Explicitly calling a base class constructor requires using the same special "member initialization list syntax" used with composition and const data members.
    \bigbreak \noindent 
    When a derived class object is destroyed, the destructors are called in the reverse order of the constructors - first the derived class destructor is called, then the base class destructor is called.
    \bigbreak \noindent 
    \bigbreak \noindent 

    \subsection{Inheritance Syntax}
    \bigbreak \noindent 
    To declare a derived class:
    \bigbreak \noindent 
    \begin{cppcode}
        // car is a derived class of vehicle.
        class car : public vehicle
        {
            // Car data members and member functions
        };
    \end{cppcode}
    \bigbreak \noindent 
    A constructor initialization list can be used to pass arguments from a derived class constructor to a base class constructor:
    \bigbreak \noindent 
    \begin{cppcode}
        // Pass the string color to the base class vehicle constructor.
        car::car(const string& color, int num_doors) : vehicle(color)
        {
            this->num_doors = num_doors;
        }
    \end{cppcode}
    \bigbreak \noindent 
    A derived class member function that overrides a base class member function can call the base class version of the function to do part of its work:
    \begin{cppcode}
        void car::print() const
        {
            vehicle::print();   // Call the vehicle version of print() to print the car's color.
            cout << num_doors;
        }
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Upcasting and Downcasting}
    \bigbreak \noindent 
    \textbf{Upcasting} is converting a derived class pointer (or reference) to a pointer (or reference) of the derived class's base class. In other words, upcasting allows us to treat a derived type as though it were its base type. It is always allowed for public inheritance, without an explicit type cast. This is a result of the "is-a" relationship between the base and derived classes. For example, if car is a class derived from vehicle, the following code is legal:
    \bigbreak \noindent 
    \begin{cppcode}
        vehicle* vptr = new car();
    \end{cppcode}
    \bigbreak \noindent 
    The car object does not actually become a vehicle object as a result of this type cast (in a sense, it already is one). However, the vehicle pointer can only be used to access parts of the car object that are defined in the vehicle class. For example, you can only call member functions that are defined in the vehicle class. The car object is treated like any other vehicle, and its car-specific data members and member functions are unavailable.
    \bigbreak \noindent 
    \begin{cppcode}
        vehicle* vptr = (vehicle*) new car();
        vehicle* vptr = dynamic_cast<vehicle*>(new car()); // Using c++ casting
        vehicle* vptr = static_cast<vehicle*>(new car()); // Using c++ casting
    \end{cppcode}
    \bigbreak \noindent 
    The opposite process, converting a base class pointer (or reference) to a derived class pointer (or reference) is called \textbf{downcasting}. Downcasting is not allowed without an explicit type cast. The reason for this restriction is that the "is-a" relationship is not always symmetric. A car is a vehicle, but a vehicle may or may not be a car. For example:
    \bigbreak \noindent 
    \begin{cppcode}
        car c1;

        vehicle* vptr = &c1;          // Upcast - no type cast required.

        car* car_ptr = (car*) vptr;   // Downcast - type cast required.
    \end{cppcode}
    \bigbreak \noindent 
    The code shown above works, because the object pointed to by vptr actually is a car object. If it wasn't, the results could lead to an unsafe operation.
    \bigbreak \noindent 
    \begin{cppcode}
        bus b1;                       // Assume bus is also a derived class of vehicle.

        vehicle* vptr = &b1;          // Upcast - no type cast required.

        car* car_ptr = (car*) vptr;   // Downcast - type cast required. Fails because vptr
                                        // points to a bus, not a car.
    \end{cppcode}
    \bigbreak \noindent 
    C++ provides a special explicit cast called \textbf{dynamic\_cast} that allows for safe downcasting. If the type cast fails, it will return nullptr rather than crashing your program:
    \bigbreak \noindent 
    \begin{cppcode}
        car* carptr = dynamic_cast<car*>(vptr);
        if (carptr != nullptr)
        {
            // Type cast succeeded, vptr was pointing to a car object
            // Can now safely call car-specific member functions using carptr
        }
    \end{cppcode}
        \bigbreak \noindent 
    \subsection{More on Downcasting}
    \bigbreak \noindent 
    Downcasting is the process of converting a base class pointer or reference to a derived class pointer or reference
    \begin{itemize}
        \item Downcasting is potentially unsafe, so it requires an explicit cast.
        \item dynamic\_cast should be used for safe downcasting to check if the cast is valid at runtime.
        \item Downcasting typically requires polymorphic classes with virtual functions to enable dynamic\_cast.
    \end{itemize}

    \bigbreak \noindent 
    In C++, the dynamic\_cast operator, used for safe downcasting, requires that the base class has at least one virtual function. This is because dynamic\_cast relies on runtime type information (RTTI), which is only available for polymorphic classes.
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{RTTI Availability:}
            \begin{itemize}
                \item RTTI is used to store type information at runtime, which dynamic\_cast uses to determine the exact type of the object being cast.
                \item RTTI is only generated by the compiler for polymorphic classes, which are classes that have at least one virtual function.
            \end{itemize}
        \item \textbf{Polymorphic Behavior:} Virtual functions enable polymorphic behavior, allowing derived classes to override base class functions. This is the essence of polymorphism, which dynamic\_cast utilizes to ensure safe downcasting.
        \item \textbf{Checking Actual Type:} The type information stored in RTTI allows dynamic\_cast to check if the object being cast is indeed of the target derived type. If not, it returns nullptr (for pointers) or throws a std::bad\_cast exception (for references).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{What Happens Without Virtual Functions}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{No RTTI:} If the base class has no virtual functions, it is not polymorphic, and the compiler doesn't generate RTTI for it. Without RTTI, dynamic\_cast cannot validate types at runtime.
        \item \textbf{Compile-Time Error:} Attempting to use dynamic\_cast on a class without virtual functions will lead to a compile-time error indicating that the class type is not polymorphic.

    \end{itemize}

    \pagebreak 
    \subsubsection{Downcasting example}
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Base {
            public:
            virtual ~Base() = default; // Make the class polymorphic
        };

        class Derived1 : public Base {
            public:
            void func1() {
                std::cout << "Derived1 Function\n";
            }
        };

        class Derived2 : public Base {
            public:
            void func2() {
                std::cout << "Derived2 Function\n";
            }
        };

        int main() {
            // Case 1: Valid downcast, will not get nullptr
            Base* basePtr1 = new Derived1(); // Base pointer to Derived1
            Derived1* derived1Ptr = dynamic_cast<Derived1*>(basePtr1);
            if (derived1Ptr) {
                derived1Ptr->func1(); // This will execute correctly
            } else {
                std::cout << "Downcast to Derived1 failed\n";
            }

            // Case 2: Invalid downcast, will get nullptr
            Base* basePtr2 = new Derived2(); // Base pointer to Derived2
            Derived1* derived1PtrInvalid = dynamic_cast<Derived1*>(basePtr2);
            if (derived1PtrInvalid) {
                derived1PtrInvalid->func1(); // This will not execute
            } else {
                std::cout << "Downcast to Derived1 failed\n"; // This will be printed
            }

            // Clean up
            delete basePtr1;
            delete basePtr2;

            return 0;
        }
    \end{cppcode}

    \pagebreak 
    \nt{When a Base* points to a Base object and we attempt to downcast it to a derived type using dynamic\_cast, the cast will fail and return nullptr. This is because the actual type of the object being pointed to is Base, not the derived type.}

    \bigbreak \noindent 
    \subsubsection{Base class pointer example}
    \bigbreak \noindent 
    \begin{cppcode}
class base {

public:
    virtual void print() const {
        cout << "Base class" << endl;
    }

};


class derived : public base {
    void print() const override {
        cout << "Child class" << endl;
    }
};


int main(int argc, char* argv[]) {

    base* bptr = new derived();

    bptr->print(); // Child class
    bptr->base::print(); // Base class

    return EXIT_SUCCESS;
}
    \end{cppcode}
    \bigbreak \noindent 
    \nt{Notice we are able to call the private method, this is because the virtual function mechanism directs the call to the most derived method.}

    \bigbreak \noindent 
    \subsection{Object Slicing}
    \bigbreak \noindent 
    Object slicing occurs when a derived class object is assigned or copied to a base class object, causing the derived class's specific members to be "sliced off."
    \bigbreak \noindent 
    \begin{cppcode}
    base b1 = base();
    derived d1 = derived();

    b1 = d1; // Slicing
    d1 = b1; // Does not work
    \end{cppcode}

        \pagebreak 
    \subsection{Multiple Inheritance}
    \bigbreak \noindent 
    Multiple inheritance is a feature in C++ that allows a derived class to inherit from more than one base class.
    \bigbreak \noindent 
    \subsubsection{Why Use Multiple Inheritance?}
    \begin{itemize}
        \item \textbf{Combining Functionality:} When a derived class needs to combine the functionalities of multiple base classes.
        \item \textbf{Mixins:} Allows implementing mixins, which are small base classes that provide specific functionalities to derived classes.
        \item \textbf{Interface Implementation:} Multiple inheritance can also be used to implement interfaces (abstract base classes) in C++.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
#include <iostream>

class Base1 {
public:
    void func1() {
        std::cout << "Base1 Function" << std::endl;
    }
};

class Base2 {
public:
    void func2() {
        std::cout << "Base2 Function" << std::endl;
    }
};

class Derived : public Base1, public Base2 {
    // Derived class inherits from both Base1 and Base2
public:
    void func3() {
        std::cout << "Derived Function" << std::endl;
    }
};

int main() {
    Derived d;
    d.func1(); // Inherited from Base1
    d.func2(); // Inherited from Base2
    d.func3(); // Own function

    return 0;
}
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Issues with Multiple Inheritance}
    \begin{enumerate}
        \item \textbf{Ambiguity:}
        \begin{itemize}
            \item If two base classes have the same method or attribute name, calling it from the derived class can cause ambiguity.
            \item This can be resolved using the scope resolution operator :: to specify which base class method to call.
        \end{itemize}
    \item \textbf{Diamond Problem:}
        \begin{itemize}
            \item If two base classes inherit from the same class and a derived class inherits from both base classes, it leads to ambiguity in the derived class about which base class's implementation to use.
            \item This can be addressed using virtual inheritance to ensure only one copy of the shared base class exists.
        \end{itemize}
    \end{enumerate}
    \pagebreak 
    \subsection{Virtual inheritance}
    \bigbreak \noindent 
    Virtual inheritance in C++ is a mechanism to prevent multiple "copies" of a base class when using multiple inheritance. It ensures that the derived class has only one shared instance of the base class, thus preventing ambiguity and redundant base class objects.
    \bigbreak \noindent 
    \subsubsection{The Diamond Problem}
    \bigbreak \noindent 
    The diamond problem occurs when two classes inherit from the same base class and another class inherits from those two classes. This results in ambiguity and multiple copies of the shared base class.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Base {
            public:
            int data;
            Base() : data(0) {}
        };

        class Derived1 : public Base {};

        class Derived2 : public Base {};

        class FinalDerived : public Derived1, public Derived2 {};

        int main() {
            FinalDerived obj;

            // Error: Ambiguity, which Base::data to access?
            // obj.data = 10;
            // Explicit resolution:
            obj.Derived1::data = 10;
            obj.Derived2::data = 20;

            std::cout << obj.Derived1::data << ", " << obj.Derived2::data << std::endl;

            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    There are two separate instances of the Base class, one inherited through Derived1 and one through Derived2 This leads to ambiguity and multiple instances.
    \pagebreak 
    \subsubsection{Solution with Virtual Inheritance}
    \bigbreak \noindent 
    Virtual inheritance addresses this problem by ensuring that the shared base class is inherited virtually. This makes the derived class have a single, shared instance of the base class.
    \bigbreak \noindent 
    \begin{cppcode}
#include <iostream>
class Base {
public:
    int data;
    Base() : data(0) {}
};

class Derived1 : virtual public Base {};

class Derived2 : virtual public Base {};

class FinalDerived : public Derived1, public Derived2 {};

int main() {
    FinalDerived obj;

    // No ambiguity, only one instance of Base exists
    obj.data = 10;

    std::cout << obj.data << std::endl;

    return 0;
}
    \end{cppcode}


    \bigbreak \noindent 
    \subsection{Subtype Polymorphism}
    \bigbreak \noindent 
    The term binding means matching a function or member function call to a function or member function definition.
    \bigbreak \noindent 
    In C++, binding normally takes place when the program is compiled and linked. This is referred to as early binding or static binding.
    \bigbreak \noindent 
    In object-oriented programming, subtype polymorphism refers to the ability of objects belonging to different types to respond to member function calls of the same name, each one according to an appropriate type-specific behavior. The calling code does not have to know the exact type of the called object; which member function definition is called is determined at run-time (this is called late binding or dynamic binding).
    \bigbreak \noindent 
    In order for dynamic binding to take place in C++, several conditions must be met:
    \bigbreak \noindent 
    \begin{enumerate}
        \item The call must be to a member function, not a standalone function. Function calls in C++ always use static binding.
        \item The member function must have been declared using the keyword virtual. Calls to non-virtual member functions always use static binding.
        \item The member function must be called through a pointer or reference to an object, not an object name. All calls to member functions (including those to virtual member functions) through object names use static binding.
    \end{enumerate}
    \bigbreak \noindent 
    With dynamic binding, C++ distinguishes between a static type and a dynamic type of a variable. The static type is determined at compile time. It's the type specified in the pointer declaration. For example, the static type of vptr is vehicle*. However, the dynamic type of the pointer is determined by the type of object to which it actually points: car* in this case. When a virtual member function is called using vptr, C++ resolves the dynamic type of vptr and ensures that the appropriate version of the member function is invoked, a process referred to as virtual dispatch.
    \bigbreak \noindent 
    Dynamic binding exacts a toll. Resolving the dynamic type of an object takes place at runtime and therefore incurs performance overhead. However, this penalty is negligible in most cases.
    \bigbreak \noindent 
    One of the most common runtime techniques for implementing virtual dispatch is a virtual member function table, or v-table. A v-table is simply an array of pointers to member functions. Each class that contains virtual member functions has a v-table. Each object that is an instance of a class with virtual member functions contains, as a hidden field, a pointer to the class's v-table. The compiler encodes a member function call as an offset into a v-table, and the appropriate v-table is used with that offset at runtime to access the correct member function.
    \bigbreak \noindent 
    \subsection{Declaring Virtual Member Functions}
    \bigbreak \noindent 
    Declaring Virtual Member Functions
    \bigbreak \noindent 
    \begin{cppcode}
        virtual void print() const;
    \end{cppcode}
    \bigbreak \noindent 
    \nt{A member function in a derived class that overrides a virtual member function in a base class is automatically virtual as well.
        \bigbreak \noindent 
        Destructors may also be virtual. You should make the destructor for your class virtual if it contains any virtual member functions.
    }
    \bigbreak \noindent 
    In C++, when you overload a virtual function from a base class in a derived class, you do not necessarily need to mark the function in the derived class as virtual again for it to behave as a virtual function. It will still be virtual in any further derived classes. However, explicitly marking it as virtual in the derived class can improve code readability and make the class's design intentions clearer.
    \bigbreak \noindent 
    \subsubsection{The override keyword}
    \bigbreak \noindent 
    Using override: Instead of (or in addition to) marking functions as virtual in derived classes, C++11 introduced the override specifier. This ensures that the function is intended to override a virtual function in a base class. Using override helps catch errors at compile-time where the function signature does not match any virtual function in the base class, thus preventing unintended behavior.
    \bigbreak \noindent 
    \begin{cppcode}
        class Base {
            public:
            virtual void foo() { /* implementation */ }
        };

        class Derived : public Base {
            public:
            virtual void foo() override { /* new implementation */ }  // Using 'virtual' and 'override' for clarity
            void foo() override; // Better approach... no need for another virtual keyword
        };
        void Base::foo() {
            // Base class definition
        }
        void Derived::foo() {
            // Derived class definition
        }
    \end{cppcode}


    \bigbreak \noindent 
    \subsection{Abstract or Pure virtual Member Functions}
    \bigbreak \noindent 
    An abstract member function is a member function that has a special prototype, but no definition. C++ refers to abstract member functions as pure virtual member functions. The prototype for a pure virtual member function ends with = 0, like this:
    \bigbreak \noindent 
    \begin{cppcode}
        virtual void earnings() const = 0;
    \end{cppcode}
    \bigbreak \noindent 
    \nt{Since a pure virtual member function has no definition, you can't really call it. However, if a base class contains a pure virtual member function, a derived class is allowed to override the member function and provide a definition.}
    \bigbreak \noindent 
    \subsection{Abstract Classes}
    \bigbreak \noindent 
    A class that contains one or more pure virtual member functions is called an abstract class (as opposed to a concrete class that provides definitions for all of its member functions).
    \bigbreak \noindent 
    You cannot create an object of an abstract class. However, an abstract class can be used as a base class for inheritance purposes. A class derived from an abstract class must provide definitions for any pure virtual member functions that it inherits, or it is also an abstract class.
    \bigbreak \noindent 
    You can also declare a pointer (or a reference) of an abstract class type. Such a pointer (or reference) would typically be used to point to a derived class object.
    \bigbreak \noindent 
    \subsection{Interface Inheritance}
    \bigbreak \noindent 
    \textbf{Interface inheritance} allows a derived class to inherit a base class's data type (which can be useful for subtype polymorphism) without actually inheriting any of the base class's implementation (member function definitions, etc.).
    \bigbreak \noindent 
        An interface can be defined in C++ as an abstract class that contains only pure virtual member functions and symbolic constants (public data members that are static and const).






    \pagebreak 
    \unsect{<regex.h> Pattern Matching and String Validation}
    \bigbreak \noindent 
    \subsection{regcomp}
    \bigbreak \noindent 
    \begin{concept}
        Compiles a regular expression into a format that the \textbf{regexec()} function can use to perform pattern matching.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
       int regcomp(regex_t *preg, const char *regex, int cflags) 
    \end{cppcode}
    \begin{itemize}
        \item \textbf{preg:} A pointer to a regex\_t structure that will store the compiled regular expression.
        \item \textbf{regex:} The regular expression to compile.
        \item \textbf{cflags:} Compilation flags that modify the behavior of the compilation. Common flags include REG\_EXTENDED (use extended regular expression syntax), REG\_ICASE (ignore case in match), REG\_NOSUB (don't report the match), and REG\_NEWLINE (newline-sensitive matching).
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Return value}
    \bigbreak \noindent 
    Upon successful completion, the regcomp() function shall return 0. Otherwise, it shall return an integer value indicating an error as described in <regex.h>, and the content of preg is undefined.

    \bigbreak \noindent 
    \subsubsection{Return errors}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{REG\_NOMATCH}: regexec() failed to match.
        \item \textbf{REG\_BADPAT}: Invalid regular expression.
        \item \textbf{REG\_ECOLLATE}: Invalid collating element referenced.
        \item \textbf{REG\_ECTYPE}: Invalid character class type referenced.
        \item \textbf{REG\_EESCAPE}: Trailing '\textbackslash' in pattern.
        \item \textbf{REG\_ESUBREG}: Number in "\textbackslash digit" invalid or in error.
        \item \textbf{REG\_EBRACK}: "$[]$" imbalance.
        \item \textbf{REG\_EPAREN}: "\textbackslash(\textbackslash)" or "()" imbalance.
        \item \textbf{REG\_EBRACE}: "\textbackslash\{\textbackslash\}" imbalance.
        \item \textbf{REG\_BADBR}: Content of "\textbackslash\{\textbackslash\}" invalid: not a number, number too large, more than two numbers, first larger than second.
        \item \textbf{REG\_ERANGE}: Invalid endpoint in range expression.
        \item \textbf{REG\_ESPACE}: Out of memory.
        \item \textbf{REG\_BADRPT}: '?', '*', or '+' not preceded by valid regular expression.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Flags}
    \begin{itemize}
        \item \textbf{REG\_EXTENDED:} Enables the use of Extended Regular Expressions (ERE) rather than Basic Regular Expressions (BRE). EREs allow a broader set of regex features, such as more flexible quantifiers and additional metacharacters without needing to escape them.
        \item \textbf{REG\_ICASE:} Makes the pattern matching case-insensitive. This means that characters will match regardless of being in upper or lower case. For example, using REG\_ICASE, the pattern "a" would match both 'a' and 'A'.
        \item \textbf{REG\_NOSUB:} Disables the reporting of the position of matches. This flag is useful when you only need to know if a match occurred but not where it occurred. It can lead to performance improvements because the regex engine does not need to track and store the match positions.
        \item \textbf{REG\_NEWLINE:} Alters the handling of newline characters in the text. Specifically, it:
            \begin{itemize}
                \item Prevents the match from spanning multiple lines. The $\land$ and \$ metacharacters will match the start and end of the input string but not the start or end of a line within the string.
                \item Causes the dot . metacharacter to stop matching at a newline, which it normally would match.
                \item Treats newline characters in the input as a boundary that cannot be crossed by the quantifiers $*$, $+$, ?, and $\{n\}$ unless explicitly included in a character class.
            \end{itemize}
        \item \textbf{REG\_NOTBOL and REG\_NOTEOL:}
            \begin{itemize}
                \item \textbf{REG\_NOTBOL (Not Beginning Of Line):} Tells the regex engine that the beginning of the provided string should not be treated as the beginning of the line. This affects how the $\land$ anchor (which normally matches the start of the string) behaves. Use this if the string is a substring that does not start at the beginning of a new line.
                \item \textbf{REG\_NOTEOL (Not End Of Line):} Indicates that the end of the provided string should not be treated as the end of the line. This affects how the \$ anchor (which normally matches the end of the string) behaves. Use this if the string is a substring that does not end at the end of a line.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Regexec}
    \bigbreak \noindent 
    \begin{concept}
        After compiling a regular expression, we can use regexec to match against strings.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
         int regexec(const regex\_t *preg, const char *string, size\_t nmatch, regmatch\_t pmatch[], int eflags)
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{preg:} The compiled regular expression.
        \item \textbf{string:} The string to match against the regular expression.
        \item \textbf{nmatch:} The maximum number of matches and submatches to find.
        \item \textbf{pmatch:} An array of regmatch\_t structures that will hold the offsets of matches and submatches.
        \item \textbf{eflags:} Execution flags that modify the behavior of the match. A common flag is REG\_NOTBOL which indicates that the beginning of the specified string is not the beginning of a line.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Return value}
    \bigbreak \noindent 
    Upon successful completion, the regexec() function shall return 0. Otherwise, it shall return REG\_NOMATCH to indicate no match.

    \bigbreak \noindent 
    \subsection{Regerror}
    \bigbreak \noindent 
    \begin{concept}
        This function translates error codes from regcomp() and regexec() into human-readable messages.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
        size_t regerror(int errcode, const regex\_t *preg, char *errbuf, size\_t errbuf\_size)
    \end{cppcode}
    \begin{itemize}
        \item \textbf{errcode:} The error code returned by regcomp() or regexec().
        \item \textbf{preg:} The compiled regular expression (if the error is related to regexec()).
        \item \textbf{errbuf:} The buffer where the error message will be stored.
        \item \textbf{errbuf\_size:} The size of the buffer.
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Return value}
    \bigbreak \noindent 
    Upon successful completion, the regerror() function shall return the number of bytes needed to hold the entire generated string, including the null termination. If the return value is greater than errbuf\_size, the string returned in the buffer pointed to by errbuf has been truncated.

    \bigbreak \noindent 
    \subsection{Regfree}
    \bigbreak \noindent 
    \begin{concept}
        Frees the memory allocated to the compiled regular expression.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
        void regfree(regex_t *preg)
    \end{cppcode}
    \begin{itemize}
        \item \textbf{preg:} The compiled regular expression to free.
    \end{itemize}
    \bigbreak \noindent 

    \pagebreak 
    \subsection{regmatch\_t and pmatch}
    \bigbreak \noindent 
    \subsubsection{regmatch\_t}
    \bigbreak \noindent 
    regmatch\_t is a structure used to describe a single match (or submatch) found by regexec(). It contains at least the following two fields:
    \begin{itemize}
        \item \textbf{rm\_eo:} This is the end offset of the match, which is one more than the index of the last character of the match. In other words, rm\_eo - rm\_so gives the length of the match.
        \item \textbf{rm\_so:} This is the start offset of the match, relative to the beginning of the string passed to regexec(). If the match is successful, rm\_so will be the index of the first character of the match.
    \end{itemize}
    \pagebreak 
    \subsubsection{pmatch array}
    \bigbreak \noindent 
    When you call regexec(), you can pass it an array of regmatch\_t structures as the pmatch argument. This array is where regexec() will store information about the matches (and submatches) it finds. The size of this array (nmatch) determines how many matches regexec() will look for and fill in. The zeroth element of this array corresponds to the entire pattern's match, and the subsequent elements correspond to parenthesized subexpressions (submatches) within the regular expression, in the order they appear.

    \bigbreak \noindent 
    \subsection{Regex Example}
    \bigbreak \noindent 
    \begin{cppcode}
        regex_t regex;
        int reti;
        char msgbuf[100];
        regmatch_t pmatch[1]; // Array to store the match positions
        const char* search = "abc";

        // Compile regular expression
        reti = regcomp(&regex, "^a[[:alnum:]]", REG_EXTENDED);
        if (reti) {
            fprintf(stderr, "Could not compile regex\n");
            exit(EXIT_FAILURE);
        }

        // Execute regular expression
        // Note: Changed the third argument to 1 to indicate we want to capture up to 1 match
        // and the fourth argument to pmatch to store the match position.
        reti = regexec(&regex, search, 1, pmatch, 0);
        if (!reti) {
            printf("Match\n");
            // If you want to use the match information, you can do so here.
            // For example, to print the start and end positions of the match:
            printf("Match at position %d to %d\n", (int)pmatch[0].rm_so, (int)pmatch[0].rm_eo - 1);
        }
        else if (reti == REG_NOMATCH) {
            printf("No match\n");
        }
        else {
            regerror(reti, &regex, msgbuf, sizeof(msgbuf));
            fprintf(stderr, "Regex match failed: %s\n", msgbuf);
            exit(EXIT_FAILURE);
        }regex_t regex;
    int reti;
    char msgbuf[100];
    regmatch_t pmatch[1]; // Array to store the match positions

    // Compile regular expression
    reti = regcomp(&regex, "^a[[:alnum:]]", REG_EXTENDED);
    if (reti) {
        fprintf(stderr, "Could not compile regex\n");
        exit(EXIT_FAILURE);
    }
    \end{cppcode}

    \pagebreak 
    \begin{cppcode}
    // Execute regular expression
    // Note: Changed the third argument to 1 to indicate we want to capture up to 1 match
    // and the fourth argument to pmatch to store the match position.
    reti = regexec(&regex, "abc", 1, pmatch, 0);
    if (!reti) {
        printf("Match\n");
        // If you want to use the match information, you can do so here.
        // For example, to print the start and end positions of the match:
        printf("Match at position %d to %d\n", (int)pmatch[0].rm_so, (int)pmatch[0].rm_eo - 1);
    }
    else if (reti == REG_NOMATCH) {
        printf("No match\n");
    }
    else {
        regerror(reti, &regex, msgbuf, sizeof(msgbuf));
        fprintf(stderr, "Regex match failed: %s\n", msgbuf);
        exit(EXIT_FAILURE);
    }

    // Free the compiled regular expression
    regfree(&regex);

        for (int i=(int)pmatch[0].rm_so; i<=(int)pmatch[0].rm_eo; ++i) {
            cout << search[i];
        }
        cout << endl;

        regfree(&regex);
    \end{cppcode}


    \pagebreak 
    \unsect{Structured bindings}
    \bigbreak \noindent 
    Structured bindings in C++ (introduced in C++17) allow you to unpack or "decompose" tuples, pairs, or other structured objects into separate variables in a concise way. This makes it easier to work with multiple return values or complex data structures.
    \bigbreak \noindent 
    \subsection{As unpacks}
    \bigbreak \noindent 
    \begin{cppcode}
        int arr[3] = {1,2,3};
        auto [x,y,z] = arr;

        cout << x << '\n' << y << '\n' << z;
        // 1
        // 2 
        // 3
    \end{cppcode}
    \bigbreak \noindent 
    This works for a number of containers
    \begin{itemize}
        \item std::Tuple
        \item std::Pairs
        \item Fixed-sized arrays
        \item std::Array
        \item Structs/Classes
    \end{itemize}

    \bigbreak \noindent 
    \subsection{With returning}
    \bigbreak \noindent 
    \begin{cppcode}
        std::pair<int,int> foo() {
            std::pair<int,int> p = {1,2};
            return p;
        }

        auto [a,b] = foo();
        cout << a << endl << b << endl;
        // 1
        // 2
    \end{cppcode}

    \pagebreak \bigbreak \noindent 
    \subsection{With structs and classes}
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            int x;
            int y;
            int z;
        };

        foo f1{1,2,3};

        auto [a,b,c] = f1;

        cout << a << endl << b << endl << c << endl;
        // 1
        // 2
        // 3
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{With maps}
    \bigbreak \noindent 
    Since we can unpack std::pairs, we can use structured bindings in map range-based loops
    \bigbreak \noindent 
    \begin{cppcode}
        map<int, int> a = {{0,1}, {1,2}};

        for (const auto& [key,value] : a) {
            cout << key << " " << value << endl;
        }
    \end{cppcode}

    \pagebreak 
    \unsect{Attributes in c++}
    \bigbreak \noindent 
    In C++, attributes are a way to provide additional information or hints to the compiler without affecting the actual logic of the program. They can be used to optimize the program, check for potential issues, or control specific aspects of how the compiler processes the code. Attributes are written inside double square brackets ([[ ... ]]) and can be attached to various elements of the code, such as functions, variables, types, and control structures
    \bigbreak \noindent 
    \begin{cppcode}
        [[attribute-name]]
        [[attribute-name(arg1, arg2, ...)]]
    \end{cppcode}
    \bigbreak \noindent 
    Attributes can be placed in various locations:
    \begin{itemize}
        \item Before a function or variable declaration
        \item Before a class or struct declaration
        \item In the middle of a function, such as on a statement in a switch case
    \end{itemize}

    \bigbreak \noindent 
    \subsection{General Attributes}
    \bigbreak \noindent 
    These attributes are part of the standard C++ specification and are supported across most modern compilers.
    \begin{itemize}
        \item \textbf{[[nodiscard]]:} Ensures that the return value of a function is not ignored.
            \bigbreak \noindent 
            \begin{cppcode}
                [[nodiscard]] int calculate() { return 42; }
                int main() {
                    calculate(); // Compiler warning: return value ignored
                }
            \end{cppcode}
        \item \textbf{[[deprecated]]:} Marks code elements like functions or variables as deprecated. Using them will generate a warning, helping to phase out old or unsafe functionality.
            \bigbreak \noindent 
            \begin{cppcode}
                [[deprecated("Use newFunction() instead")]]
                void oldFunction() {}
            \end{cppcode}
        \item \textbf{[[maybe\_unused]]:} Suppresses compiler warnings for unused variables or parameters, often useful in code that will vary between different builds (e.g., debug vs release builds)
            \begin{cppcode}
                void fn([[maybe\_unused]] int a);
                [[maybe\_unused]] int x = 5;
            \end{cppcode}
        \item \textbf{[[fallthrough]]}: Used in switch statements to indicate that a case is intentionally falling through to the next one, preventing warnings from the compiler in such cases.
            \bigbreak \noindent 
            \begin{cppcode}
                switch (value) {
                    case 1:
                        // Some code
                        [[fallthrough]];  // Intentional fallthrough to the next case
                    case 2:
                        // More code
                        break;
                }
            \end{cppcode}
        \item \textbf{[[likely]] and [[unlikely]]}: (since C++20): Provide hints to the compiler about the likelihood of branches in if or switch statements. These hints allow the compiler to optimize for the most likely or unlikely branches.
            \bigbreak \noindent 
            \begin{cppcode}
                if ([[likely]] condition) {
                    // Optimized assuming this is more likely
                }
            \end{cppcode}
        \item \textbf{[[alignas(n)]]:} Specifies the memory alignment for a variable or type. It ensures that the object is aligned on a boundary of n bytes.
            \bigbreak \noindent 
            \begin{cppcode}
                alignas(16) int alignedInt;  // Ensures the integer is aligned on a 16-byte boundary
            \end{cppcode}
        \item \textbf{[[no\_unique\_address]]}: (since C++20): Allows the compiler to optimize the memory layout of a class or struct by not requiring a unique address for certain members (e.g., empty classes).
            \bigbreak \noindent 
            \begin{cppcode}
                struct Empty {};
                struct S {
                    [[no_unique_address]] Empty e;
                    int x;
                };
            \end{cppcode}
        \item \textbf{[[noreturn]]:} Marks a function as one that will never return to the caller (e.g., functions that throw exceptions or terminate the program).
            \bigbreak \noindent 
            \begin{cppcode}
            [[noreturn]] void fatalError() {
                throw std::runtime_error("Critical error!");
            }
        \end{cppcode}
    \item \textbf{[[gnu::always\_inline]]:} Forces the compiler to inline the function, even when optimizations are disabled. This attribute is specific to certain compilers like GCC or Clang.
        \bigbreak \noindent 
        \begin{cppcode}
            [[gnu::always_inline]] void inlineFunction() {
                // The function will always be inlined
            }

            \end{cppcode}
        \item \textbf{[[gnu::pure]]:} Marks a function as "pure," meaning its return value depends only on its parameters and has no side effects, allowing the compiler to perform certain optimizations.
            \bigbreak \noindent 
            \begin{cppcode}
                [[gnu::pure]] int square(int x) {
                    return x * x;
                }

            \end{cppcode}
    \end{itemize}

    \pagebreak 
    \unsect{Inline functions}
    \bigbreak \noindent 
    In C++, an inline function is a function where the compiler attempts to replace the function call with the actual function code itself (i.e., inline expansion) rather than generating a normal function call. The goal of inlining is to reduce the overhead of function calls, especially for small functions, and potentially improve performance.
    \bigbreak \noindent 
    However, inline is a request or hint to the compiler, not a command. The compiler may ignore the request to inline the function, particularly if the function is too complex or if it would increase the code size too much.
    \bigbreak \noindent 
    To declare a function as inline, you use the inline keyword in its declaration or definition:
    \bigbreak \noindent 
    \begin{cppcode}
        inline int add(int a, int b) {
            return a + b;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Consider the following example
    \bigbreak \noindent 
    \begin{cppcode}
        inline int square(int x) {
            return x * x;
        }

        int main() {
            int result = square(5);
        }
    \end{cppcode}
    \bigbreak \noindent 
    Without inline, the function call square(5) would generate assembly code that jumps to the function definition, executes it, and returns the result. With inline, the compiler might replace the square(5) call directly with 5 * 5 in the code, eliminating the need for a function call.

    \pagebreak 
    \unsect{Standard namespace}
    \bigbreak \noindent 
    \subsection{std::bind}
    \bigbreak \noindent 
    \subsubsection{std::placeholders}
    \bigbreak \noindent 
    Before we get into std::bind, we must discuss std::placeholders
    \bigbreak \noindent 
    std::placeholders is a namespace in C++ that provides placeholder objects like std::placeholders::\_1, std::placeholders::\_2, and so on, which are used in conjunction with std::bind. These placeholders represent arguments that will be supplied when the resulting callable object (created by std::bind) is invoked.
    \bigbreak \noindent 
    Each placeholder corresponds to a positional argument that the function object will expect at the time of calling. For example:
    \begin{itemize}
        \item std::placeholders::\_1 represents the first argument.
        \item std::placeholders::\_2 represents the second argument, and so on.
    \end{itemize}

    \bigbreak \noindent 
    std::bind in C++ is used to create a function object (or a callable) by binding specific arguments to a function or member function, essentially "fixing" some of its arguments ahead of time. This allows the resulting function object to be called later with fewer arguments, as some are already provided.
    \bigbreak \noindent 
    \begin{cppcode}
        int add(int a, int b) {
            return a + b;
        }

        auto addtwo = std::bind(add, 2, std::placeholders::_1);
        cout << addtwo(4) << '\n'; // 6
    \end{cppcode}
    \bigbreak \noindent 
    Here, std::bind(add, 2, std::placeholders::\_1) binds 2 as the first argument of add, leaving the second argument to be provided later. The placeholder \_1 indicates where future arguments should be inserted.

    \pagebreak 
    \subsubsection{Using std::ref with bind}
    \bigbreak \noindent 
    std::ref is a utility in C++ that allows you to create reference wrappers for objects. It's commonly used when you need to pass objects by reference to functions that usually take arguments by value, such as when using function objects or lambdas with standard algorithms (like std::for\_each or std::thread).
    \bigbreak \noindent 
    It provides a way to pass a reference to an object where an argument would otherwise be copied.
    \bigbreak \noindent 
    It’s especially useful when the function you're working with doesn’t explicitly accept references but you want to pass one anyway.
    \bigbreak \noindent 
    \begin{cppcode}
        void add(int& a) {
            ++a;
        }

        int local = 0;

        auto f = std::bind(add, local);
        f();
        f();
        cout << local << endl; // Outputs zero

        auto f = std::bind(add, std::ref(local)); // Outputs two
        f();
        f();
        cout << local << endl;
    \end{cppcode}

    \bigbreak \noindent 
    \textbf{Note:} std::ref makes a std::reference\_wrapper<Type>...
    \bigbreak \noindent 
    \begin{cppcode}
        int local = 0;
        std::reference_wrapper<int> rlocal = local; 

        auto f = std::bind(add, rlocal); // Outputs two
    \end{cppcode}

     \pagebreak 
     \subsection{std::invoke}
     \bigbreak \noindent 
     std::invoke is a utility function in C++ (introduced in C++17) that allows you to invoke a callable object in a uniform way, regardless of whether the callable is a regular function, a member function, or a function object (like a lambda or std::function). The main benefit of std::invoke is that it simplifies calling different types of callable objects without needing to worry about the specific calling syntax.
     \bigbreak \noindent 
     \begin{cppcode}
         template< class F, class... Args >
         decltype(auto) invoke(F&& f, Args&&... args);
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Calling a regular function}
     \bigbreak \noindent 
     \begin{cppcode}
         int add(int a, int b) {
             return a + b;
         }

         int result = std::invoke(add, 2, 3);  // Calls add(2, 3)
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Calling a member function}
     \bigbreak \noindent 
     \begin{cppcode}
         struct MyClass {
             int multiply(int x) { return x * 2; }
         };

         MyClass obj;
         int result = std::invoke(&MyClass::multiply, obj, 5);  // Calls obj.multiply(5)
     \end{cppcode}
     \pagebreak \bigbreak \noindent 
     \subsubsection{Accessing a member variable}
     \bigbreak \noindent 
     \begin{cppcode}
         struct MyClass {
             int value;
         };

         MyClass obj{42};
         int value = std::invoke(&MyClass::value, obj);  // Accesses obj.value
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Calling a lambda}
     \bigbreak \noindent 
     \begin{cppcode}
         auto lambda = [](int a, int b) { return a + b; };
         int result = std::invoke(lambda, 2, 3);  // Calls lambda(2, 3)
     \end{cppcode}

     \pagebreak 
     \subsection{std::exchange}
     \bigbreak \noindent 
     std::exchange is a utility function in the C++ Standard Library that is used to replace the value of an object with a new value and return the old value. This can be very handy for implementing things like move operations, resetting variables, or swapping values efficiently.
     \bigbreak \noindent 
     \begin{cppcode}
         template< class T, class U = T >
         T exchange( T& obj, U&& new_value );
     \end{cppcode}
     \bigbreak \noindent 
     It takes a reference to an object obj and replaces it with a new value new\_value. It returns the original value of the object before the replacement.
     \bigbreak \noindent 
     \begin{cppcode}
         int a = 5;
        int b = std::exchange(a, 10); // a becomes 10, b takes the old value of a, which was 5
     \end{cppcode}

     \pagebreak 
     \subsection{std::swap}
     \bigbreak \noindent 
     Swap exchanges the values of two objects
     \bigbreak \noindent 
     \begin{cppcode}
         template< class T >
         void swap( T& a, T& b );
     \end{cppcode}
     \bigbreak \noindent 
     \begin{cppcode}
     int x=5, y=10;
     std::swap(x,y);

     // Swaps the values of x and y
     \end{cppcode}

     \pagebreak 
     \subsection{std::get}
     \bigbreak \noindent 
     Allows access to elements from containers like std::tuple, std::pair, std::array, and std::variant either by index or type.
     \bigbreak \noindent 
     Tuple has no .at() method or subscript operator, so this utility function can be very useful to retrieve things from tuples.

     \bigbreak \noindent 
     \begin{cppcode}
         std::tuple<int, string> v{1, "abc"};

         cout << std::get<string>(v); // "abc"
         cout << std::get<1>(v); // "abc"
         cout << std::get<int>(v); // 1
         cout << std::get<0>(v); // 1
     \end{cppcode}

















    
\end{document}
