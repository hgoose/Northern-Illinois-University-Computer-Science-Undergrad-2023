\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Systems Programming in C++}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Systems Programming in C++} \\
           CS330
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           March 29, 2024 \\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{C Library Functions}
    \bigbreak \noindent 
    \subsection{cstdlib utils}
    \bigbreak \noindent 
    \subsection{getenv}
    \bigbreak \noindent 
    \begin{concept}
        The \textbf{getenv} function is a standard library function that provides access to the environment variables of the process. Environment variables are dynamic-named values that affect the processes running on a computer. They can be used to configure system settings, pass configuration data to applications, and enable communication between different parts of an operating system or between different programs.
        \bigbreak \noindent 
        \textbf{Signature}
        \begin{cppcode}
            char* getenv(const char* name);
        \end{cppcode}
        \bigbreak \noindent 
        Where name is a a C-string (const char*) representing the name of the environment variable whose value is being requested.
        \bigbreak \noindent 
        \textbf{Return Value}
        \bigbreak \noindent 
        If the environment variable is found, getenv returns a pointer to a C-string containing the value of the variable.
        \bigbreak \noindent 
        If the environment variable is not found, it returns a null pointer (NULL in C, nullptr in C++).
        \bigbreak \noindent 
        \textbf{Example} 
        \bigbreak \noindent 
        \begin{cppcode}
            #include <cstdlib>
            #include <iostream>

            int main() {
                // Attempt to retrieve the PATH environment variable
                const char* path = getenv("PATH");
                if (path != nullptr) {
                    std::cout << "PATH: " << path << std::endl;
                } else {
                    std::cout << "PATH environment variable not found." << std::endl;
                }
                return 0;
            }
        \end{cppcode}
    \end{concept}

    \pagebreak 
    \subsection{exit}
    \bigbreak \noindent 
    \textbf{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
    void exit(int status)
    \end{cppcode}
    \bigbreak \noindent 
    The exit function is quite simple, it terminates the calling process
    \bigbreak \noindent 
    Zero for a successful termination, anything else is unsuccessful termination.
    \bigbreak \noindent 

    \bigbreak \noindent 
    \subsection{system}
    \bigbreak \noindent 
    \textbf{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
    int system(const char* command)
    \end{cppcode}
    \bigbreak \noindent 
    The system command allows us to run shell commands. It invokes the command processor to execute a comamnd. The function returns the exit status of the command.
    \bigbreak \noindent 
    \textbf{Note:} If command is a nullptr, the function only checks if a command processor is available. 
    \bigbreak \noindent 
    \textbf{Example}
    \bigbreak \noindent 
    \begin{cppcode}
        int main(int argc, const char* argv[]) {
            int rs;
            if (!system(NULL)) {
                exit(EXIT_FAILURE);
            }
            cout << system("ls -la");

            return EXIT_SUCCSESS;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Perror}
    \bigbreak \noindent 
    \begin{concept}
       The perror function in C is a standard library function that prints a descriptive error message to the standard error stream (stderr). The message corresponds to the current value of the global variable errno, which is set by system calls and some library functions in the event of an error to indicate what went wrong. 
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
    void void perror(const char *s);
    \end{cppcode}
    \begin{itemize}
        \item \textbf{s:} A C string containing a custom message to be printed before the error message itself. If this argument is not NULL, the string pointed to by s is printed first, followed by a colon (:) and a space. If s is an empty string or NULL, only the error message is printed.        
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Behavior}
    \bigbreak \noindent 
    \textbf{perror} produces a message on the standard error output, describing the last error encountered during a call to a system or library function. The actual error message printed by perror is system-dependent but generally reflects the error state represented by errno.
    \bigbreak \noindent 
    \subsubsection{Setting errno manually}
    \bigbreak \noindent 
    You can set errno simply by assigning it a value. First, you need to include the errno.h header to ensure that you have access to the errno variable and the standard error codes.
    \bigbreak \noindent 
    \begin{cppcode}
    #include <errno.h>

    errno = ENOENT; // No such file or directory
    \end{cppcode}


    


    \pagebreak 
    \unsect{Posix regex API <regex.h>}
    \bigbreak \noindent 
    \subsection{regcomp}
    \bigbreak \noindent 
    \begin{concept}
        Compiles a regular expression into a format that the \textbf{regexec()} function can use to perform pattern matching.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
       int regcomp(regex_t *preg, const char *regex, int cflags) 
    \end{cppcode}
    \begin{itemize}
        \item \textbf{preg:} A pointer to a regex\_t structure that will store the compiled regular expression.
        \item \textbf{regex:} The regular expression to compile.
        \item \textbf{cflags:} Compilation flags that modify the behavior of the compilation. Common flags include REG\_EXTENDED (use extended regular expression syntax), REG\_ICASE (ignore case in match), REG\_NOSUB (don't report the match), and REG\_NEWLINE (newline-sensitive matching).
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Regexec}
    \bigbreak \noindent 
    \begin{concept}
        After compiling a regular expression, we can use regexec to match against strings.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
         int regexec(const regex\_t *preg, const char *string, size\_t nmatch, regmatch\_t pmatch[], int eflags)
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{preg:} The compiled regular expression.
        \item \textbf{string:} The string to match against the regular expression.
        \item \textbf{nmatch:} The maximum number of matches and submatches to find.
        \item \textbf{pmatch:} An array of regmatch\_t structures that will hold the offsets of matches and submatches.
        \item \textbf{eflags:} Execution flags that modify the behavior of the match. A common flag is REG\_NOTBOL which indicates that the beginning of the specified string is not the beginning of a line.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Regerror}
    \bigbreak \noindent 
    \begin{concept}
        This function translates error codes from regcomp() and regexec() into human-readable messages.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
        size_t regerror(int errcode, const regex\_t *preg, char *errbuf, size\_t errbuf\_size)
    \end{cppcode}
    \begin{itemize}
        \item \textbf{errcode:} The error code returned by regcomp() or regexec().
        \item \textbf{preg:} The compiled regular expression (if the error is related to regexec()).
        \item \textbf{errbuf:} The buffer where the error message will be stored.
        \item \textbf{errbuf\_size:} The size of the buffer.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Regfree}
    \bigbreak \noindent 
    \begin{concept}
        Frees the memory allocated to the compiled regular expression.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
        void regfree(regex\_t *preg)
    \end{cppcode}
    \begin{itemize}
        \item \textbf{preg:} The compiled regular expression to free.
    \end{itemize}

    \pagebreak 
    \subsection{regmatch\_t and pmatch}
    \bigbreak \noindent 
    \subsubsection{regmatch\_t}
    \bigbreak \noindent 
    regmatch\_t is a structure used to describe a single match (or submatch) found by regexec(). It contains at least the following two fields:
    \begin{itemize}
        \item \textbf{rm\_eo:} This is the end offset of the match, which is one more than the index of the last character of the match. In other words, rm\_eo - rm\_so gives the length of the match.
        \item \textbf{rm\_so:} This is the start offset of the match, relative to the beginning of the string passed to regexec(). If the match is successful, rm\_so will be the index of the first character of the match.
    \end{itemize}
    \pagebreak 
    \subsubsection{pmatch array}
    \bigbreak \noindent 
    When you call regexec(), you can pass it an array of regmatch\_t structures as the pmatch argument. This array is where regexec() will store information about the matches (and submatches) it finds. The size of this array (nmatch) determines how many matches regexec() will look for and fill in. The zeroth element of this array corresponds to the entire pattern's match, and the subsequent elements correspond to parenthesized subexpressions (submatches) within the regular expression, in the order they appear.

    \bigbreak \noindent 
    \subsection{Regex Example}
    \bigbreak \noindent 
    \begin{cppcode}
        regex_t regex;
        int reti;
        char msgbuf[100];
        regmatch_t pmatch[1]; // Array to store the match positions
        const char* search = "abc";

        // Compile regular expression
        reti = regcomp(&regex, "^a[[:alnum:]]", REG_EXTENDED);
        if (reti) {
            fprintf(stderr, "Could not compile regex\n");
            exit(EXIT_FAILURE);
        }

        // Execute regular expression
        // Note: Changed the third argument to 1 to indicate we want to capture up to 1 match
        // and the fourth argument to pmatch to store the match position.
        reti = regexec(&regex, search, 1, pmatch, 0);
        if (!reti) {
            printf("Match\n");
            // If you want to use the match information, you can do so here.
            // For example, to print the start and end positions of the match:
            printf("Match at position %d to %d\n", (int)pmatch[0].rm_so, (int)pmatch[0].rm_eo - 1);
        }
        else if (reti == REG_NOMATCH) {
            printf("No match\n");
        }
        else {
            regerror(reti, &regex, msgbuf, sizeof(msgbuf));
            fprintf(stderr, "Regex match failed: %s\n", msgbuf);
            exit(EXIT_FAILURE);
        }regex_t regex;
    int reti;
    char msgbuf[100];
    regmatch_t pmatch[1]; // Array to store the match positions

    // Compile regular expression
    reti = regcomp(&regex, "^a[[:alnum:]]", REG_EXTENDED);
    if (reti) {
        fprintf(stderr, "Could not compile regex\n");
        exit(EXIT_FAILURE);
    }
    \end{cppcode}

    \pagebreak 
    \begin{cppcode}
    // Execute regular expression
    // Note: Changed the third argument to 1 to indicate we want to capture up to 1 match
    // and the fourth argument to pmatch to store the match position.
    reti = regexec(&regex, "abc", 1, pmatch, 0);
    if (!reti) {
        printf("Match\n");
        // If you want to use the match information, you can do so here.
        // For example, to print the start and end positions of the match:
        printf("Match at position %d to %d\n", (int)pmatch[0].rm_so, (int)pmatch[0].rm_eo - 1);
    }
    else if (reti == REG_NOMATCH) {
        printf("No match\n");
    }
    else {
        regerror(reti, &regex, msgbuf, sizeof(msgbuf));
        fprintf(stderr, "Regex match failed: %s\n", msgbuf);
        exit(EXIT_FAILURE);
    }

    // Free the compiled regular expression
    regfree(&regex);

        for (int i=(int)pmatch[0].rm_so; i<=(int)pmatch[0].rm_eo; ++i) {
            cout << search[i];
        }
        cout << endl;

        regfree(&regex);
    \end{cppcode}

    \pagebreak 
    \unsect{Directory Input/Output <dirent.h>}
    \bigbreak \noindent 
    \subsection{Functions}
    \begin{itemize}
        \item \textbf{chdir(const char *path)} $\mapsto$ \texttt{int}: Changes the current working directory of the calling process to the directory specified in \texttt{path}. Returns zero on success, and -1 on failure, setting \texttt{errno} to indicate the error.
        \item \textbf{getcwd(char *buf, size\_t size)} $\mapsto$ \texttt{char*}: Copies an absolute pathname of the current working directory to the array pointed to by \texttt{buf}, which is of length \texttt{size}. If \texttt{size} is large enough, returns \texttt{buf}; if \texttt{size} is too small, NULL is returned, and \texttt{errno} is set to \texttt{ERANGE}; on other errors, NULL is returned, and \texttt{errno} is set appropriately.
        \item \textbf{opendir(const char *name)} $\mapsto$ \texttt{DIR*}: Opens a directory stream corresponding to the directory name, and returns a pointer to the directory stream. The stream is positioned at the first entry in the directory. Returns NULL if an error occurs, setting \texttt{errno} to indicate the error.
        \item \textbf{readdir(DIR *dirp)} $\mapsto$ \texttt{struct dirent*}: Reads the next directory entry from the directory stream pointed to by \texttt{dirp}. Returns a pointer to a \texttt{struct dirent} representing the next directory entry, or NULL when reaching the end of the directory stream or if an error occurs.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{The DIR type}
    \bigbreak \noindent 
    The DIR type is an opaque data type that represents a directory stream. A directory stream is an ordered sequence of all the directory entries in a particular directory. Directory entries include files, subdirectories, and other types of file system objects contained in the directory.
    \bigbreak \noindent 
    You cannot see the structure of DIR directly, as it is hidden (opaque) to provide abstraction and portability across different operating systems and filesystems. This means you interact with directory streams using pointer variables of type DIR *, and you manipulate these streams through the functions provided by <dirent.h>, such as opendir(), readdir(), and closedir().
    \bigbreak \noindent 
    \subsection{dirent Structure}
    \bigbreak \noindent 
    The struct dirent structure represents an individual directory entry, which could be a file, a subdirectory, or another type of file system object. The exact contents of this structure can vary between different operating systems, but it generally includes the following members:

    \begin{itemize}
        \item \textbf{d\_ino:} The inode number of the directory entry. The inode number is a unique identifier within a filesystem.
        \item \textbf{d\_name:} A character array (string) containing the name of the directory entry. This name is not the full path, but just the filename or directory name.
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    DIR* d;
    struct dirent* dir;
    d = opendir("."); // Open the current directory
    
    if (d) {
        while ((dir = readdir(d)) != NULL) {
            printf("%s\n", dir->d_name); // Print the name of each directory entry
        }
        closedir(d); // Close the directory stream
    }

    return 0;

    \end{cppcode}

    \pagebreak 
    \unsect{Unix System Calls <sys/stat.h>}
    \bigbreak \noindent 
    \begin{concept}
       A system call is how a program requests services from the operating system. System calls execute code in the kernel and makes direct use of facilities provided by the kernel. Verus a library function which is linked to the executable, hence it becomes part of the executable.
    \end{concept}
    \bigbreak \noindent 
    \subsection{System Call Categories}
    \bigbreak \noindent 
    \subsubsection{File management}
    \begin{itemize}
        \item Create/delete file, open/close, read/write, get/set attributes 
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Process Control}
    \begin{itemize}
        \item Create/terminate process, wait/signal event, allocate/free memory
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Communication}
    \begin{itemize}
        \item Create/delete connection, send/recieve messages, remote devices
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Device management}
    \begin{itemize}
        \item Attach/request/release/detach device, read/write/position
    \end{itemize}

    \bigbreak \noindent 
    \subsection{System Call Invocation}
    \begin{itemize}
        \item Declare system call via appropriate C header file
        \item Prepare parametrs using basic C data types
        \item Prepare suitable return value variable
    \end{itemize}
    \bigbreak \noindent 
    Then we call like any other function.

    \pagebreak 
    \unsect{File Management}
    \begin{itemize}
        \item \textbf{Open}: Open a file
        \item \textbf{Read}: Read data from a file
        \item \textbf{Write}: Write data to a file
        \item \textbf{Close}: Close a file
        \item \textbf{creat}:  Make a new file
    \end{itemize}
    \bigbreak \noindent 
    \nt{All calls share file descriptor, ie number to identify file}

    \bigbreak \noindent 
    \subsection{Open}
    \bigbreak \noindent 
    \begin{cppcode}
    int open(const char* pathname, int flags)
    \end{cppcode}
    \begin{itemize}
        \item Opens file specified as \textbf{pathname} for access
        \item Flags determine access type
            \begin{itemize}
                \item \textbf{O\_RDONLY}: Read only
                \item \textbf{O\_WRONLY}: Write only
                \item \textbf{O\_RDWR}: Read and write
            \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    \nt{Returns file descriptor, to be used in read/write/close, returns -1 on error}
    \bigbreak \noindent 
    \subsubsection{Additonal flags, used with O\_WRONlY}
    \begin{itemize}
        \item \textbf{O\_APPEND}: To append to an existing file
        \item \textbf{O\_TRUNC}: existing file will be overwritten (Default)
        \item \textbf{O\_CREAT}: Creates file, if file does not exist
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Example:}
    \bigbreak \noindent 
    \begin{cppcode}
    O_WRONLY | O_TRUNC 
    O_WRONLY | O_APPEND 
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Open with mode}
    \bigbreak \noindent 
    \begin{cppcode}
    int open(const char* pathname, int flags, mode_t mode)
    \end{cppcode}
    \bigbreak \noindent 
    The parameter \textbf{mode} is used to specify permissions of type mode\_t
    \begin{itemize}
        \item \textbf{S\_IRWXU (00700)}: User has read, write, and execute permissions
        \item \textbf{S\_IRUSR (00400)}: User has read permissions
        \item \textbf{S\_IWUSR (00200)}: User has read, write, and execute permissions
        \item \textbf{S\_IXUSR (00100)}: User has write permissions
        \item \textbf{S\_IRWXG (00070)}: User has execute permissions
        \item \textbf{S\_IRWXO (00007)}: Others have read, write, and execute permissions
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    open("ex.txt", O_WRONLY | O_APPEND | O_CREAT, 00666)
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Read}
    \bigbreak \noindent 
    \begin{cppcode}
    ssize_t read(int fd, void* buf, size_t count)
    \end{cppcode}
    \begin{itemize}
        \item Attempts to read \textbf{count} bytes from file descriptor \textbf{fd} into the buffer starting at \textbf{buf}
            \begin{itemize}
                \item \textbf{Note:} ssize\_t is like size\_t can also be -1
            \end{itemize}
        \item Returns the number of bytes read
            \begin{itemize}
                \item May be smaller than count, zero indicates end of file
                \item file position is advanced by this number
            \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    \nt{Returns -1 on error}

    \bigbreak \noindent 
    \subsection{Close}
    \bigbreak \noindent 
    \begin{cppcode}
    int close(int fd)
    \end{cppcode}
    \begin{itemize}
        \item Closes file specified by \textbf{fd} file descriptor, makes file descriptor available
    \end{itemize}
    \bigbreak \noindent 
    \nt{Returns 0 on success}

    \bigbreak \noindent 
    \subsection{Write}
    \bigbreak \noindent 
    \begin{cppcode}
        ssize_t write(int fd, const void* buf, size_t count)
    \end{cppcode}
    \begin{itemize}
        \item Writes up to \textbf{count} bytes from buffer starting at \textbf{buf} to the file referred to by file descriptor \textbf{fd}
        \item \textbf{Returns the number of bytes written}
    \end{itemize}
    \bigbreak \noindent 
    \nt{Returns -1 on error}

    \bigbreak \noindent 
    \subsection{Creat}
    \bigbreak \noindent 
    \begin{cppcode}
    int creat(const char* pathname, mode_t mode)
    \end{cppcode}
    \begin{itemize}
        \item Creates new file specified as pathname and opens file for write access
        \item \textbf{mode} specifies permissions of type mode\_t
        \item returns file descriptor
    \end{itemize}
    \bigbreak \noindent 
    \nt{Returns -1 on error}

    \pagebreak 
    \unsect{I/O Management}
    \begin{itemize}
        \item \textbf{unlink}: Remove file
        \item \textbf{dup}: Duplicate file descriptor
        \item \textbf{stat}: Get file information
        \item \textbf{chmod}: Change permissions
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Unlink}
    \bigbreak \noindent 
    \begin{cppcode}
    int unlink(const char* pathname)
    \end{cppcode}
    \begin{itemize}
        \item Removes a \textbf{pathname} from the file system
        \item If \textbf{pathname} was the last link to a file, then it is deleted
        \item If \textbf{pathname} refers to a symbolic link, then it is removed
        \item Returns zero on success
    \end{itemize}
    \nt{Returns -1 on error}

    \bigbreak \noindent 
    \subsection{Dup}
    \bigbreak \noindent 
    \begin{cppcode}
    int dup(int oldfd)
    \end{cppcode}
    \begin{itemize}
        \item Creates a copy of file descriptor \textbf{oldfd}
        \item Uses lowest-numbered unused descriptor
        \item Returns a new file descriptor
    \end{itemize}
    \bigbreak \noindent 
    \nt{Returns -1 on error}

    \bigbreak \noindent 
    \subsection{Stat}
    \begin{concept}
        Family of system calls to inquire about a file
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
    int stat(const char* path, struct stat* buf) // Takes pathname
    int fstat(int fd, struct stat* buf) // Takes file descriptor
    int lstat(const char* path, struct stat* buf) // Reports on symbolic link as is
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        struct stat  {
            dev_t       st_dev;         /* ID of device containing file */ 
            ino_t       st_ino;         /* inode number */ 
            mode_t      st_mode;        /* file mode: contains permissions */ 
            nlink_t     st_nlink;       /* number of hard links  * /
            uid_t       st_uid;         /* user ID of owner */ 
            gid_t       st_gid;         /* group ID of owner  * /
            dev_t       st_rdev;        /* device ID (if special file) */ 
            off_t       st_size;        /* total size, in bytes */ 
            blksize_t   st_blksize;     /* blocksize for file system I/O */ 
            blkcnt_t    st_blocks;      /* number of blocks allocated */ 
            time_t      st_atime;       /* time of last access */ 
            time_t      st_mtime;       /* time of last modification */
            time_t      st_otime;       /* time of last status change */ 
        };
        \end{cppcode}

        \bigbreak \noindent 
        \subsubsection{stat structure st\_mode field}
        \bigbreak \noindent 
        This contains the file mode, including permissions
        \bigbreak \noindent 
        To check permissions:
        \begin{itemize}
            \item \textbf{st\_mode \& S\_IRUSR}: User has read permissions
            \item \textbf{st\_mode \& S\_IWUSR}: User has write permissions
            \item \textbf{st\_mode \& S\_IXUSR}: User has execute permissions
        \end{itemize}
        \bigbreak \noindent 
        To check file type:
        \begin{itemize}
            \item \textbf{S\_ISREG(st\_mode)}: It is a regular file
            \item \textbf{S\_ISDIR(st\_mode)}: It is a directory
            \item \textbf{S\_IFLNK(st\_mode)}: It is a symbolic link
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Chmod}
        \bigbreak \noindent 
        \begin{cppcode}
        int chmod(const char* path, mode_t mode)
        \end{cppcode}
        \begin{itemize}
            \item Change permission settings for file given in \textbf{path} string
            \item new file permissions are specified in \textbf{mode}
            \item Returns zero on success, or -1 on error
        \end{itemize}
        \bigbreak \noindent 
        \nt{Must be called by owner of file, or superuser, returns -1 on error}

        \bigbreak \noindent 
        \subsection{Fchmod}
        \bigbreak \noindent 
        \begin{cppcode}
        int fchmod(int fd, mode_t mode)
        \end{cppcode}
        \begin{itemize}
            \item Change permission settings for file given in \textbf{fd}
            \item new file permissions are specified in \textbf{mode}
            \item Returns zero, or -1 on error
        \end{itemize}
        \bigbreak \noindent 
        \nt{Must be called by owner of file, or superuser, returns -1 on error}
        \bigbreak \noindent 
        \subsubsection{Permission modes}
        \bigbreak \noindent 
        \fig{1}{./figures/1.png}

    





    
    

    
\end{document}
