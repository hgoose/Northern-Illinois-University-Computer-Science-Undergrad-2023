\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Formal DSA in C++}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Formal DSA in C++}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Linked lists}
    \bigbreak \noindent 
    \subsection{Singly-linked lists}
    \bigbreak \noindent 
    If a node contains a data member that is a pointer to another node, then many nodes
    can be strung together using only one variable to access the entire sequence of nodes.
    Such a sequence of nodes is the most frequently used implementation of a linked list,
    which is a data structure composed of nodes, each node holding some information
    and a pointer to another node in the list. If a node has a link only to its successor in
    this sequence, the list is called a singly linked list
    \bigbreak \noindent 
    Each node resides on the heap
    \bigbreak \noindent 
    Linked lists can easily grow and shrink in size without reallocating memory or moving elements. Adding or removing nodes (especially at the beginning or middle) is more efficient compared to arrays, as no shifting of elements is required. Memory is allocated as needed, avoiding wasted space typical in arrays with fixed sizes.
    \bigbreak \noindent 
    However, each node requires extra memory for the pointer to the next node. Accessing elements requires traversal from the head, making lookups slower (O(n)) compared to arrays, which offer O(1) access via indexing.  Nodes are scattered in memory, leading to poor cache performance compared to arrays, which have contiguous memory locations.



    \bigbreak \noindent 
    \subsubsection{Structure of the node}
    \bigbreak \noindent 
    The node structure is typically implemented in the following way
    \bigbreak \noindent 
    \begin{cppcode}
        struct node {
            node* next = nullptr;
            T data = 0; 

            node() = default;
            node(data) : data(data) {}
            node(next, data) : next(next), data(data) {}
        }
    \end{cppcode}
    \bigbreak \noindent 
    A node includes two data members: info and next. The info member is used
    to store information, and this member is important to the user. The next member is
    used to link nodes to form a linked list. It is an auxiliary data member used to maintain the linked list. It is indispensable for implementation of the linked list, but less
    important (if at all) from the user’s perspective. Note that node is defined
    in terms of itself because one data member, next, is a pointer to a node of the same
    type that is just being defined. Objects that include such a data member are called
    self-referential objects.

    \bigbreak \noindent 
    \subsubsection{The list class/struct}
    \bigbreak \noindent 
    We also implement the list structure as a class or struct.
    \bigbreak \noindent 
    \begin{cppcode}
        class single_list {
            node* head = nullptr;
        public:
            ...
        };
    \end{cppcode}


    \bigbreak \noindent 
    \subsubsection{Interface of a singly linked list stack}
    \bigbreak \noindent 
    The interface typically includes the following operations:
    \begin{enumerate}
        \item \textbf{Insert:} Add a node at the beginning, end, or a specific position in the list.
        \item \textbf{Delete:} Remove a node from the beginning, end, or a specific position.
        \item \textbf{Search:} Find a node with a given value.
        \item \textbf{Traverse:} Iterate through the list to access or print each node's data.
        \item \textbf{IsEmpty:} Check if the list is empty.
        \item \textbf{Size:} Return the number of nodes in the list. The first node is called the head, and the last node points to nullptr (indicating the end of the list).
    \end{enumerate}

    \pagebreak 
    \subsubsection{Traversing}
    \bigbreak \noindent 
    Traversing a list is simple.
    \bigbreak \noindent 
    \begin{cppcode}
    node* curr = head;

    while (curr) {
        curr = curr->next;
        ...
    }
    \end{cppcode}

    \pagebreak 
    \subsubsection{Printing}
    \bigbreak \noindent 
    Now that we can traverse, we can print each node
    \bigbreak \noindent 
    \begin{cppcode}
    node* curr = head;
    while (curr) {
        cout << curr->data;
        curr=curr->next;
    }
    \end{cppcode}

    \pagebreak 
    \subsubsection{Printing in reverse}
    \bigbreak \noindent 
    Printing in reverse requires creating a stack.
    \bigbreak \noindent 
    \begin{cppcode}
    if (!head) return; // noop, dont even bother creating a vector.

    vector<node*> stack;
    node* curr = head;

    while (curr) {
        stack.push_back(curr);
        curr=curr->next;
    }

    for (int i=(int)stack.size()-1; i>=0; --i) {
        cout << stack[i]->data << " ";
    }
    cout << endl;
    \end{cppcode}

    \pagebreak 
    \subsubsection{Getting the length}
    \bigbreak \noindent 
    While we traverse, just increment a counter.
    \bigbreak \noindent 
    \begin{cppcode}
        size_t len() {
            size_t len = 0;
            for (node* curr = head; curr; curr=curr->next, ++len);
            return len;
        }
    \end{cppcode}

    \pagebreak 
    \subsubsection{Clearing}
    \bigbreak \noindent 
    \begin{cppcode}
        void clear() {
            node* curr=head, *prev=nullptr;

            while (curr) {
                prev=curr;
                curr=curr->next;
                delete prev;
            }
            head = nullptr;
        }
    \end{cppcode}

    \pagebreak 
    \subsubsection{Reversing}
    \bigbreak \noindent 
    Reversing is pretty straight forward
    \bigbreak \noindent 
    \begin{cppcode}
        void reverse() {
            node* prev=nullptr, *curr=head, *next=nullptr;

            while(curr) {
                next=curr->next;
                curr->next = prev;
                prev = curr;
                curr=next;
            }

            head = prev;
        }
    \end{cppcode}
    \bigbreak \noindent 
    In each iteration, next temporarily holds the next node so you don’t lose track of it when reversing the link.
    \bigbreak \noindent 
    The curr->next pointer is set to prev, effectively reversing the link.
    \bigbreak \noindent 
    Prev is then updated to curr, and curr is updated to next to continue the process.


    \pagebreak 
    \subsubsection{Pushing}
    \bigbreak \noindent 
    \begin{cppcode}
        void push(int element) {
            if (!head) {
                head = new node(element);
                return;
            }

            node* curr = head;
            while (curr->next) {
                curr=curr->next;
            }
            curr->next = new node(element);
        }
    \end{cppcode}

    \pagebreak 
    \subsubsection{Inserting}
    \bigbreak \noindent 
    \begin{cppcode}
        void insert(int pos, int element) {
            if (!head || pos == 0) {
                node* new_node = new node(element);
                new_node->next = head;
                head = new_node;
                return;
            }
            node* curr = head;

            int count=0;
            while (count != pos-1 && curr->next) {
                curr=curr->next;
                ++count;
            }
            node* new_node = new node(element);

            new_node->next = curr->next;
            curr->next = new_node;
        }
    \end{cppcode}
    \bigbreak \noindent 
    \begin{enumerate}
        \item \textbf{Check if the list is empty or inserting at the head (position 0):}
            \begin{itemize}
                \item If head is nullptr (meaning the list is empty) or pos == 0 (you want to insert at the beginning), a new node is created with the given element.
                \item The new node's next pointer is set to the current head (which could be nullptr if the list is empty), and then head is updated to point to this new node.
                \item This handles the case where the new node becomes the first node in the list.
            \end{itemize}
        \item \textbf{Traverse to the correct position:}
            \begin{itemize}
                \item If you are inserting somewhere other than the head, the function uses a loop to find the node just before the desired position (pos - 1).
                \item It starts at the head and moves along the list until it reaches the node right before where the new node will be inserted.
            \end{itemize}
        \item \textbf{Insert the new node:}
            \begin{itemize}
                \item Once the loop finds the right place (curr points to the node before the insertion position), a new node is created.
                \item The new node’s next pointer is set to curr->next (the node currently in the target position).
                \item Then, curr->next is updated to point to the new node, effectively inserting the new node into the list.
            \end{itemize}

    \end{enumerate}


    \pagebreak 
    \subsubsection{Popping}
    \bigbreak \noindent 
    \begin{cppcode}
        void pop() {
            if (!head) return;
            if (!head->next) {
                delete head;
                head=nullptr;
                return;
            }

            node* prev=nullptr, *curr = head;
            while (curr->next) {
                prev=curr;
                curr=curr->next;
            }
            delete curr;
            prev->next=nullptr;
        }
    \end{cppcode}
    \bigbreak \noindent 
    \begin{enumerate}
        \item \textbf{Empty List Check:} If the list is empty (head == nullptr), it does nothing.
        \item \textbf{Single Node Case:} If the list has only one node, it deletes the head and sets head to nullptr.
        \item \textbf{Multiple Nodes:} It traverses to the last node using two pointers (prev and curr), deletes the last node (curr), and sets the second-to-last node's next pointer (prev->next) to nullptr to mark the new end of the list.
    \end{enumerate}

    \pagebreak 
    \subsubsection{Erasing}
    \bigbreak \noindent 
    \begin{cppcode}
        void erase(int element) {
            if (!head) return;

            while (head->data == element) {
                if (head->next && head->data == element) {
                    node* tmp = head;
                    head = head->next;
                    delete tmp;
                }
            }

            node* prev=nullptr, *curr=head;

            while (curr) {
                if (curr->data == element) {
                    node* tmp = curr;
                    prev->next = curr->next;
                    curr=curr->next;
                    delete tmp;
                } else {
                    prev=curr;
                    curr=curr->next;
                }
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    This erase function removes all nodes with a specific value (element) from the list:
    \begin{itemize}
        \item \textbf{Empty List Check:} If the list is empty (head == nullptr), it returns immediately.
        \item \textbf{Head Node Deletion:} If the head contains the target value, it deletes the head and updates it to the next node. We keep doing this until the head node no longer contains the data we want to remove
        \item \textbf{Traverse and Delete:} It iterates through the list, and for each node with the target value, it removes the node by adjusting the next pointer of the previous node and deleting the current node.
    \end{itemize}


    \pagebreak 
    \subsubsection{Searching}
    \bigbreak \noindent 
    \begin{cppcode}
        node* search(int element) {
            node* curr = head;
            while (curr) {
                if (curr->data == element) {
                    return curr;
                }
            }
            return nullptr;
        }
    \end{cppcode}




    \pagebreak 
    \unsect{Recursion}
    \bigbreak \noindent 
    \subsection{Recursion vs iteration}
    \bigbreak \noindent 
    In theory, any problem that can be solved recursively can be solved iteratively. This also means that any problem that can be solved iteratively can also be solved recursively.
    \bigbreak \noindent 
    The question is, for any problem that can be solved, which method can be used such that the problem is easier to solve.

    \pagebreak \bigbreak \noindent 
    \subsection{Elementary recursion}
    \bigbreak \noindent 
    A recursive definition consists of two parts. In the first part, called the anchor or
    the ground case, the basic elements that are the building blocks of all other elements
    of the set are listed. In the second part, rules are given that allow for the construction
    of new objects out of basic elements or objects that have already been constructed.
    These rules are applied again and again to generate new objects. For example, to construct the set of natural numbers, one basic element, 0, is singled out, and the operation of incrementing by 1 is given as:
    \begin{enumerate}
        \item $0 \in \mathbb{N}$
        \item If $n\in \mathbb{N},\ then (n+1) \in \mathbb{N}$
        \item There are no other objects in the set $\mathbb{N}$
    \end{enumerate}
    It is more convenient to use the following definition, which encompasses the whole range of Arabic numeric heritage:
    \begin{enumerate}
        \item $0, 1,2,3,4,5,6,7,8,9 \in \mathbb{N} $
        \item If $n\in \mathbb{N}$, then $n0, n1,n2,n3,n4,n5,n6,n7,n8,n9 \in \mathbb{N}$
        \item These are the only natural numbers
    \end{enumerate}
    \bigbreak \noindent 
    Recursive definitions serve two purposes: generating new elements, as already
    indicated, and testing whether an element belongs to a set. In the case of testing, the
    problem is solved by reducing it to a simpler problem, and if the simpler problem is
    still too complex it is reduced to an even simpler problem, and so on, until it is reduced to a problem indicated in the anchor

    \bigbreak \noindent 
    \subsection{Base cases}
    \bigbreak \noindent 
    In recursion, a base case is a condition that stops further recursive calls and provides a direct answer without further recursion
    \bigbreak \noindent 
    If there were no base case, there would be nothing to stop the recursion. Thus, it would go on until the program crashes. For this reason, all recursive functions must have at least one base case.
    \bigbreak \noindent 
    If a base case in a recursive function returns a value, then every recursive call leading up to that base case should also return a value. This is necessary to ensure that the result of the recursion is propagated back up the call stack.
    \bigbreak \noindent 
    In a recursive function, the base case stops the recursion, and if the base case returns something (e.g., a node pointer, integer, etc.), the recursive calls that occur before reaching the base case need to return that result so it can propagate back to the original caller.

    \bigbreak \noindent 
    \subsubsection{Factorials}
    \bigbreak \noindent 
    \begin{align*}
        n! = 
        \begin{cases}
            1 & \text{if } n = 0 \\
            n(n-1)! & \text{if } n \ne 0
        \end{cases}
    .\end{align*}
    \bigbreak \noindent 
    \begin{cppcode}
        int factorial(int n) {
            if (n == 0) return 1;
            return n * factorial(n-1);

            // Expands to 
            // n * n-1 * n-2 * ... * 1
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Powers}
    \bigbreak \noindent 
    Consider the recursive definition for a power of $x$
    \bigbreak \noindent 
    \begin{align*}
        x^{n} = 
        \begin{cases}
            1 & \text{if } n=0 \\\
            x\cdot x^{n-1} &\text{if } n>0
        \end{cases}
    .\end{align*}
    \bigbreak \noindent 
    \begin{cppcode}
        constexpr int power(int x, int n) {
            if (n == 0) return 1;
            return x * power(x,n-1);
        }
    \end{cppcode}
    \bigbreak \noindent 
    \bigbreak \noindent 
    The function power() can be implemented differently, without using any recursion, as in the following loop:
    \bigbreak \noindent 
    \begin{cppcode}
        int power2(int x, int n) {
            int res = 1;

            for (res = x; n > 1; --n) {
                res*=x;
            }
            return res;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Do we gain anything by using recursion instead of a loop? The recursive version
seems to be more intuitive because it is similar to the original definition of the power
function. The definition is simply expressed in C++ without losing the original structure of the definition. The recursive version increases program readability, improves
self-documentation, and simplifies coding. In our example, the code of the nonrecursive
version is not substantially larger than in the recursive version, but for most recursive
implementations, the code is shorter than it is in the nonrecursive implementations

    \pagebreak 
    \subsection{Tail recursion}
    \bigbreak \noindent 
    Tail recursion is a type of recursion where the recursive call is the last thing the function does before returning a result. This means there are no more computations or operations to perform after the recursive call.
    \bigbreak \noindent 
    Because of this, tail recursion can be optimized by some compilers or interpreters to avoid adding new frames to the call stack, making it more memory-efficient than regular recursion.
    \bigbreak \noindent 
    In simple terms, if a recursive function calls itself, and after that call there’s nothing left to do, it's tail recursion. This allows the function to reuse the same memory space, preventing stack overflow in cases with deep recursion.
    \bigbreak \noindent 
    the recursive call is not only the last statement but there are no earlier recursive calls, direct or indirect. For example, the function tail() defined as
    \bigbreak \noindent 
    \begin{cppcode}
        void tail(int i) {
            if (i > 0) {
                cout << i << '';
                tail(i-1);
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    Is an example of a function with tail recursion, whereas the function nonTail() defined as
    \bigbreak \noindent 
    \begin{cppcode}
        void nonTail(int i) {
            if (i > 0) {
                nonTail(i-1);
                cout << i << '';
                nonTail(i-1);
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    Is not. Tail recursion is simply a glorified loop and can be easily replaced by one. In this example, it is replaced by substituting a loop for the if statement and decrementing the variable i in accordance with the level of recursive call. In this way, tail() can be expressed by an iterative function:
    \bigbreak \noindent 
    \begin{cppcode}
        void iterativeEquivalentOfTail(int i) {
            for ( ; i > 0; i--)
            cout << i << '';
        }
    \end{cppcode}
    \bigbreak \noindent 
    Is there any advantage in using tail recursion over iteration? For languages such as C++, there may be no compelling advantage, but in a language such as Prolog, which has no explicit loop construct (loops are simulated by recursion), tail recursion acquires a much greater weight. In languages endowed with a loop or its equivalents, such as an if statement combined with a goto statement, tail recursion should not be used.
    \bigbreak \noindent 
    Another problem that can be implemented in recursion is printing an input line in reverse order. Here is a simple recursive implementation:
    \bigbreak \noindent 
    \begin{cppcode}
        void reverse() {
            char ch;
            cin.get(ch);
            if (ch != '\n') {
                reverse();
                cout.put(ch); 
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    Compare the recursive implementation with a nonrecursive version of the same function:
    \bigbreak \noindent 
    \begin{cppcode}
        void simpleIterativeReverse() {
            char stack[80];
            int top = 0;
            cin.getline(stack,80);
            for (top = strlen(stack) - 1; top >= 0; cout.put(stack[top--]));
        }
    \end{cppcode}
    \bigbreak \noindent 
    functions like strlen() and
    getline() from the standard C++ library can be used. If we are not supplied with
    such functions, then our iterative function has to be implemented differently:
    \bigbreak \noindent 
    \begin{cppcode}
        void iterativeReverse() {
            char stack[80];

            register int top = 0;
            cin.get(stack[top]);

            while(stack[top]!='\n') {
                cin.get(stack[++top]);
            }
            for (top -= 2; top >= 0; cout.put(stack[top--]));
        }
    \end{cppcode}

    \pagebreak 
    \subsection{Indirect Recursion}
    \bigbreak \noindent 
    The preceding sections discussed only direct recursion, where a function $f()$ called itself. However, $f()$ can call itself indirectly via a chain of other calls. For example, $f()$ can call $g()$, and $g()$ can call $f()$. This is the simplest case of indirect recursion. The chain of intermediate calls can be of an arbitrary length, as in:
    \begin{align*}
        f() \to f_{1}() \to f_{2}() \to ... \to f_{n}() \to f()
    .\end{align*}
    \bigbreak \noindent 
    There is also the situation when $f()$ can call itself indirectly through different chains. Thus, in addition to the chain just given, another chain might also be possible. For instance
    \begin{align*}
        f() \to g_{1}() \to g_{2}() \to ... \to g_{m}() \to f()
    .\end{align*}
    \bigbreak \noindent 
    This situation can be exemplified by three functions used for decoding information. receive() stores the incoming information in a buffer, decode() converts it into legible form, and store() stores it in a file. receive() fills the buffer and calls decode(), which in turn, after finishing its job, submits the buffer with decoded information to store(). After store() accomplishes its tasks, it calls receive() to intercept more encoded information using the same buffer. Therefore, we have the chain of calls
    \begin{align*}
        \text{recieve}() \to \text{decode}() \to \text{store}() \to \text{recieve}() \to \text{decode}() \to ...
    .\end{align*}
    \bigbreak \noindent 
    \pagebreak 
    \subsection{Nested Recursion}
    \bigbreak \noindent 
    A more complicated case of recursion is found in definitions in which a function is
    not only defined in terms of itself, but also is used as one of the parameters. The following definition is an example of such a nesting
    \begin{align*}
        h(n) = 
        \begin{cases}
            0 & \text{if } n = 0 \\
            n & \text{if } n > 4 \\
            h(2 + h(n)) & \text{if } n \leq 4
        \end{cases}
    .\end{align*}
    \bigbreak \noindent 
    \subsection{Excessive Recursion}
    \bigbreak \noindent 
    Logical simplicity and readability are used as an argument supporting the use of recursion. The price for using recursion is slowing down execution time and storing on
    the run-time stack more things than required in a nonrecursive approach. If recursion is too deep (for example, computing $5.6^{100,000}$), then we can run out of space on
the stack and our program crashes. But usually, the number of recursive calls is much
smaller than 100,000, so the danger of overflowing the stack may not be imminent
\bigbreak \noindent 
However, if some recursive function repeats the computations for some parameters, the run time can be prohibitively long even for very simple cases
\bigbreak \noindent 
Consider Fibonacci numbers. A sequence of Fibonacci numbers is defined as follows:
\begin{align*}
    \text{Fib}(n) =
    \begin{cases}
        n & \text{if } n < 2  \\
        \text{Fib}(n-2) + \text{Fib}(n-1) & \text{otherwise}
    \end{cases}
.\end{align*}
\bigbreak \noindent 
The definition states that if the first two numbers are 0 and 1, then any number in the
sequence is the sum of its two predecessors. But these predecessors are in turn sums
of their predecessors, and so on, to the beginning of the sequence. 
\bigbreak \noindent 
How can this definition be implemented in C++? It takes almost term-by-term
translation to have a recursive version, which is
\bigbreak \noindent 
\begin{cppcode}
constexpr unsigned long fib(int n) {
    if (n < 2) return n;
    return fib(n-2) + fib(n-1);
}
\end{cppcode}
\bigbreak \noindent 
The function is simple and easy to understand but extremely inefficient. To see
it, compute Fib(6), the seventh number of the sequence, which is 8. Based on the
definition, the computation runs as follows:
\begin{align*}
    Fib(6)	&= Fib(4) + Fib(5) \\
            &= Fib(2) 	+ 	Fib(3) 	+ Fib(5) \\
            &= Fib(0)+Fib(1) 	+ 	Fib(3) 	+ Fib(5) \\
            &= 0 + 1 	+ 	Fib(3) 	+ Fib(5) \\
            &= 1 	+ Fib(1)+ Fib(2) 	+ Fib(5) \\
            &= 1 	+ Fib(1)+Fib(0)+Fib(1)	+ Fib(5)   
.\end{align*}
Etc... The source of
this inefficiency is the repetition of the same calculations because the system forgets
what has already been calculated. For example, Fib() is called eight times with parameter n = 1 to decide that 1 can be returned. For each number of the sequence, the
function computes all its predecessors without taking into account that it suffices to do
this only once.
\bigbreak \noindent 
It takes almost a quarter of a million calls to find the twenty-sixth Fibonacci
number, and nearly 3 million calls to determine the thirty-first! This is too heavy a
price for the simplicity of the recursive algorithm. As the number of calls and the run
time grow exponentially with n, the algorithm has to be abandoned except for very
small numbers
\bigbreak \noindent 
An iterative algorithm may be produced rather easily as follows:
\bigbreak \noindent 
\begin{cppcode}
    unsigned long iterativeFib(unsigned long n) {
        if (n < 2)
        return n;
        else {
            register long i = 2, tmp, current = 1, last = 0;
            for ( ; i <= n; ++i) {
                tmp = current;
                current += last;
                last = tmp;
            }
            return current;
        }
    }
\end{cppcode}
\bigbreak \noindent 
However, there is another, numerical method for computing Fib(n), using a formula discovered by Abraham de Moivre:
\begin{align*}
    \text{Fib}(n) =  \frac{\phi^{n} - \hat{\phi}^{n}}{\sqrt{5}}
.\end{align*}
Where $\phi = \frac{1}{2}(1+\sqrt{5})$, and $\hat{\phi} = 1-\phi = \frac{1}{2}(1-\sqrt{5}) $. $\hat{\phi}$ becomes very small when $n$ grows, thus it can be omitted. 
\begin{align*}
    \text{Fib}(n) =\frac{\phi^{n}}{\sqrt{5}}
.\end{align*}
Approximated to the nearest integer
\bigbreak \noindent 
\begin{cppcode}
    unsigned long deMoivreFib(unsigned long n) {
        return ceil(exp(n*log(1.6180339897) - log(2.2360679775)) - .5);
    }
\end{cppcode}
\pagebreak 
\subsection{Backtracking}
\bigbreak \noindent 
In solving some problems, a situation arises where there are different ways leading
from a given position, none of them known to lead to a solution. After trying one path
unsuccessfully, we return to this crossroads and try to find a solution using another
path. However, we must ensure that such a return is possible and that all paths can
be tried. This technique is called backtracking, and it allows us to systematically try
all available avenues from a certain point after some of them lead to nowhere. Using
backtracking, we can always return to a position that offers other possibilities for successfully solving the problem. This technique is used in artificial intelligence, and one
of the problems in which backtracking is very useful is the eight queens problem.
\bigbreak \noindent 
The eight queens problem attempts to place eight queens on a chessboard in
such a way that no queen is attacking any other To solve this problem, we try to put the first
queen on the board, then the second so that it cannot take the first, then the third so
that it is not in conflict with the two already placed, and so on, until all of the queens
are placed. What happens if, for instance, the sixth queen cannot be placed in a nonconflicting position? We choose another position for the fifth queen and try again
with the sixth. If this does not work, the fifth queen is moved again. If all the possible
positions for the fifth queen have been tried, the fourth queen is moved and then the process restarts. This process requires a great deal of effort, most of which is spent
backtracking to the first crossroads offering some untried avenues. In terms of code,
however, the process is rather simple due to the power of recursion, which is a natural implementation of backtracking
\bigbreak \noindent 
\begin{cppcode}
    putQueen(row)
        for every position col on the same row
            if position col is available
                place the next queen in position col;
                if (row < 8)
                    putQueen(row+1);
                else success;
                remove the queen from position col;
\end{cppcode}
\bigbreak \noindent 
This algorithm finds all possible solutions without regard to the fact that some of
them are symmetrical.

\pagebreak 
\subsection{Recursion in singly linked lists}
\bigbreak \noindent 
\subsubsection{Traversing}
\bigbreak \noindent 
To traverse a linked list using recursion, you need to define a recursive function that processes the current node and then calls itself with the next node until the list is fully traversed (i.e., until the current node is nullptr).
\bigbreak \noindent 
\begin{cppcode}
    void TraverseList(node* head) {
        if (!head) {
            return;
        }
        TraverseList(head->next);

        // ...
    }
\end{cppcode}
\bigbreak \noindent 
\subsubsection{Printing}
\bigbreak \noindent \bigbreak \noindent 
We can use this, for example, to print each nodes data member
\bigbreak \noindent 
\begin{cppcode}
    void PrintList(node* head) {
        if (!head) return;

        cout << head->data << " ";
        PrintList(head->next);
    }
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Printing in reverse}
\bigbreak \noindent \bigbreak \noindent 
We a slight alter in the print example, we can reverse print the list. 
\bigbreak \noindent 
\begin{cppcode}
    void PrintListReverse(node* head) {
        if (!head) return;

        PrintListReverse(head->next);
        cout << head->data << " ";
    }
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Getting the length}
\bigbreak \noindent 


\bigbreak \noindent 
\subsubsection{Clearing}
\bigbreak \noindent \bigbreak \noindent 
We can also use this to clear the list
\bigbreak \noindent 
\begin{cppcode}
    void clear() {
        std::function<void(node*)> r_clear = [&] (node* p) = {
            if (!head) return;

            r_clear(head->next);
            delete head;
        } 
        r_clear(head);
        head=nullptr;
        size=0;
    }
\end{cppcode}


\pagebreak 
\subsubsection{Reversing}
\bigbreak \noindent 
Let's first take a look at the reverse code
\bigbreak \noindent 
\begin{cppcode}
    void reverse() {
        std::function<void(node*)> r_reverse = [&] (node* p) -> void {
            if (!p->next) {
                head = p;
                return;
            }

            r_reverse(p->next);
            node* q = p->next;
            q->next = p;
            p->next = nullptr;

        };
        r_reverse(head);
    }
\end{cppcode}
\bigbreak \noindent 
The base case is that we are at the end, in this case we set head to this position. Head is now at the end of the list.
\bigbreak \noindent 
Once the base case is triggered and the head is set to the last node in the list, we will be sent back to the n-1 node call.
\bigbreak \noindent 
To get the intuition for linked list logic, we must examine a diagram of the list.
\bigbreak \noindent 
\begin{figure}[ht]
    \centering
    \incfig{diag}
    \label{fig:diag}
\end{figure}
\bigbreak \noindent 
This figure shows the three operations done after each recursive call. In the figure above, we are at the node after the call that set the end to head. We
\begin{enumerate}
    \item Get a pointer to the node ahead of the current $(q)$. 
    \item This allows us to severe its old next pointer and reverse its direction.
    \item Then, set $p$ next to nullptr (set up for next return).
\end{enumerate}
When the callstack returns to the first call, and does its operations, the list will be reversed

\bigbreak \noindent 
It is also a good idea to examine the iterative method.
\bigbreak \noindent 
\begin{cppcode}
    void Itreverse() {
        node* prev=nullptr, *curr=head, *next=nullptr;

        while (curr) {
            next=curr->next; // Move next to the next node
            curr->next=prev; // Change the direction of current nodes next pointer

            prev=curr; // Advance prev
            curr=next; // Advance curr
        }
        head=prev; // Prev is last node, set head to end
    }
\end{cppcode}

\pagebreak 
\subsubsection{Pushing}
\bigbreak \noindent 
\begin{cppcode}
    void push(int data) {
        if (!head) {
            head = new node(nullptr, data);
            return;
        }
        std::function<void(node*, int)> r_push = [&] (node* curr, int data) -> void {

            if (!curr->next) {
                curr->next = new node(nullptr, data);
                ++size;
                return;
            }
            r_push(curr->next, data);
        };
        r_push(head, data);
    }
\end{cppcode}
\bigbreak \noindent 
Base case:
\begin{enumerate}
    \item \textbf{Empty list}: No recursion, make head the new node
\end{enumerate}
\bigbreak \noindent 
Otherwise, recurse from the head until we get to the last node, simply set last nodes next pointer to new node and return

\pagebreak 
\subsubsection{Inserting}
\bigbreak \noindent 
\begin{cppcode}
    void insert(unsigned pos, int element) {
        std::function<void(node*&, unsigned)> r_insert = [&] (node*& p, unsigned curr_pos) {
            if (curr_pos == 0) {
                node* new_node = new node(nullptr, element);
                new_node->next = p;
                p = new_node;
                return;
            }
            r_insert(p->next,  curr_pos-1);
        };
        r_insert(head, pos);
    }
\end{cppcode}
\bigbreak \noindent 
Base case
\begin{enumerate}
    \item \textbf{Recursed the same number of times as the \texttt{pos} arg}: In this case, make a new node, set next to current node in the recursive traversal, set current node to new node.
\end{enumerate}
\bigbreak \noindent 
Otherwise, keep recursing, subtracting one from the curr\_pos.

\pagebreak 
\subsubsection{Popping}
\bigbreak \noindent 
\begin{cppcode}
    void pop() {
        if (!head) return;

        if (!head->next) {
            delete head;
            head=nullptr;
            return;
        }

        std::function<void(node*)> r_pop = [&] (node* p) -> void {
            if (!p->next->next) {
                delete p->next;
                p->next = nullptr;
                --size;
                return;
            }
            r_pop(p->next);
        };
        r_pop(head);
    }
\end{cppcode}
\bigbreak \noindent 
Base cases:
\begin{enumerate}
    \item \textbf{Empty list}: Noop
    \item \textbf{One node (head)}: Delete then reset head
\end{enumerate}
Otherwise, recurse until we are at the second to last node. Then, delete the second to last nodes next node, which is the last node. Set second to last nodes next pointer to nullptr.

\pagebreak 
\subsubsection{Erasing}
\bigbreak \noindent 
\begin{cppcode}
    void erase(int element) {
        std::function<void(node*&)> r_erase = [&] (node*& p) -> void {
            if (p == nullptr) {
                return;
            }

            r_erase(p->next);

            if (p->data == element) {
                node* tmp = p;
                p = p->next;
                delete tmp;
            }
        };
        r_erase(head);
    }
\end{cppcode}
\bigbreak \noindent 
Base case:
\begin{enumerate}
    \item \textbf{Reached the end}: Return, start unwinding
\end{enumerate}
\bigbreak \noindent 
We traverse to the end of the list recursively, once we reach the end the recursion stops and we start unwinding the call stack, going backwards in the list.
\bigbreak \noindent 
For each node, we check if its data is equal to the element, if it is we set this node equal to its next node, then delete.

\pagebreak 
\subsubsection{Searching}
\bigbreak \noindent 
\begin{cppcode}
    node* search(int element) {
        std::function<node*(node*)> r_search = [&] (node* p) -> node* {
            if (p == nullptr)  {
                return nullptr;
            }
            if (p->data == element) {
                return p;
            }
            return r_search(p->next);
        };
        return r_search(head);
    }
\end{cppcode}
\bigbreak \noindent 
Base cases:
\begin{enumerate}
    \item \textbf{Reached the end of the list}: Element is not in list, return nullptr
    \item \textbf{Found the first node with the element}: Return the node
\end{enumerate}
\bigbreak \noindent 
Otherwise, recurse through the nodes until we hit one of the base cases.


\pagebreak 
\unsect{Binary trees}
\bigbreak \noindent 
\subsection{Terminology}
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{Node:} The basic unit of a binary tree, containing data and references to left and right children.
    \item \textbf{Root:} The topmost node in a tree.
    \item \textbf{Child:} A node directly connected to another node when moving away from the root.
    \item \textbf{Descendants}: The descendants of a node are all nodes that come after a given node.
    \item \textbf{Parent:} The node directly above a child node.
    \item \textbf{Grandparents}: The grandparents of a node is all nodes above the parent up to the root.
    \item \textbf{Ancestors}: The ancestors of a node are all the nodes above a node up to the root
    \item \textbf{Leaf:} A node with no children.
    \item \textbf{Branch node}: A non-leaf node is called a branch node
    \item \textbf{Internal Node:} A branch node, a node with at least one child.
    \item \textbf{Subtree:} A tree consisting of a node and its descendants.
    \item \textbf{Height of a node:} The number of edges on the longest path from a node to a leaf.
    \item \textbf{Height of a tree:} The height of the tree is the height of the root
    \item \textbf{Depth:} The number of edges from the root to a node.
    \item \textbf{Depth of a tree}: The depth of a tree is the depth of the deepest node
    \item \textbf{Degree of a node}: The number of subtrees of a node is called the degree of the node. In a binary tree, all nodes have degree 0, 1, or 2.
    \item \textbf{Degree of a binary tree}:   The degree of a tree is the maximum degree of a node in the tree. A binary tree is degree 2.
\end{itemize}

\pagebreak 
\subsection{Type of binary trees}
\begin{itemize}
    \item \textbf{Full Binary Tree:} Every internal node has two children, all leaf nodes have zero children. Thus, all nodes are either zero or two, never one. 
    \item \textbf{Complete Binary Tree:} All levels, except possibly the last, are fully filled, and all nodes are as far left as possible.
    \item \textbf{Perfect Binary Tree:} A binary tree where all internal nodes have exactly 2 children, and all leaf nodes are at the same level.
    \item \textbf{Balanced Binary Tree:} A binary tree where the height of the left and right subtrees of every node differs by at most one.
    \item \textbf{Degenerate (or pathological) Tree:} A tree where each parent node has only one child, essentially forming a linked list.
    \item \textbf{Skewed Tree:} A special case of a degenerate tree, where all nodes are skewed to the left or right, forming a linear structure.
\end{itemize}

\pagebreak 
\subsection{Maximum height of a binary tree}
\bigbreak \noindent 
The maximum height of a binary tree with $n$ nodes can be as large as $n−1$ (in the case of a degenerate or skewed tree where each node has only one child). This is true for any binary tree:
\begin{align*}
    h_{\text{max}} = n - 1
.\end{align*}
\bigbreak \noindent 
Which occurs for degenerate trees.

\bigbreak \noindent 
\subsubsection{Minimum height of a binary tree}
\bigbreak \noindent 
The minimum height (best case) for a binary tree with $n$ nodes is achieved when the tree is perfectly balanced:
\begin{align*}
    h_{\text{min}} = \lfloor\log_{2}(n)\rfloor
.\end{align*}
\bigbreak \noindent 
This is because the tree would need to spread nodes evenly across levels

\bigbreak \noindent 
\subsubsection{Number of Leaves in a Binary Tree}
\bigbreak \noindent 
For any binary tree with $n$ nodes, the number of leaves $l$ satisfies the following relationship:
\begin{align*}
    l \leq \frac{n+1}{2}
.\end{align*}
\bigbreak \noindent 
This formula gives the maximum number of leaves, assuming that the tree is full (every internal node has 2 children).

\bigbreak \noindent 
\subsubsection{Relationship Between Internal Nodes and Leaves:}
\bigbreak \noindent 
In any binary tree, the number of internal nodes $i$ (nodes with at least one child) and the number of leaves $l$ are related as follows:
\begin{align*}
    i \leq l-1
.\end{align*}

\bigbreak \noindent 
\subsubsection{Maximum Number of Nodes at Height h}
\bigbreak \noindent 
The maximum number of nodes possible at a given height $h$ (where the height is counted from the root as level 0) in a binary tree is:
\begin{align*}
    \text{Max nodes at height $h$} = 2^{h}
.\end{align*}

\pagebreak 
\subsubsection{Number of Edges in a Binary Tree:}
\bigbreak \noindent 
For any binary tree with $n$ nodes, the number of edges $e$ is always
\begin{align*}
    e = n-1
.\end{align*}
\bigbreak \noindent 
This holds because every node (except the root) is connected to exactly one parent, so there are $n−1$ edges in the tree.

\pagebreak 
\subsection{Full trees}
\bigbreak \noindent 
A full tree is a tree where all internal nodes are degree two, and all leaf nodes are degree zero. Observe
\bigbreak \noindent 
\begin{figure}[ht]
    \centering
    \incfig{fulltree1}
    \label{fig:fulltree1}
\end{figure}
\bigbreak \noindent 
The next three subsections refer to the \textit{full binary tree theorem}, which states for a nonempty, full tree $T$ 
\bigbreak \noindent 
\subsubsection{Number of leaves}
\bigbreak \noindent 
If $T$ has $I$ internal nodes, the number of leaves is given by
\begin{align*}
   L = I + 1 
.\end{align*}
\bigbreak \noindent 
If $T$ has a total of $N$ nodes, the number of leaves is 
\begin{align*}
    L = \frac{N+1}{2}
.\end{align*}
\pagebreak 
\subsubsection{Number of nodes}
\bigbreak \noindent 
If $T$ has $I$ internal nodes, the total number of nodes is 
\begin{align*}
    N = 2I + 1
.\end{align*}
\bigbreak \noindent 
If $T$ has $L$ leaves, the total number of nodes is 
\begin{align*}
    N = 2L - 1
.\end{align*}
\bigbreak \noindent 
\subsubsection{Number of internal nodes}
\bigbreak \noindent 
If $T$ has a total of $N$ nodes, the number of internal nodes is 
\begin{align*}
    I = \frac{N-1}{2}
.\end{align*}
\bigbreak \noindent 
If $T$ has $L$ leaves, the number of internal nodes is 
\begin{align*}
    I = L - 1
.\end{align*}

\pagebreak 
\subsection{Complete Binary Tree}
\bigbreak \noindent 
A complete binary tree has a specific structure defined by how the nodes are filled level by level.
\begin{enumerate}
    \item \textbf{All levels, except possibly the last, are fully filled:}
        \begin{itemize}
            In a complete binary tree, every level up to the second-to-last (penultimate) level must be completely filled with nodes.
            This means that if the tree has height $h$, levels $0$ through $h - 1$ (from the root to the second-to-last level) will have the maximum possible number of nodes for that level.
        \end{itemize}
        \item \textbf{All nodes are as far left as possible:}
            \begin{itemize}
                \item On the last level, the nodes don't need to completely fill the level, but the nodes must be positioned as far to the left as possible.
                \item For example, if some nodes are missing from the last level, they will always be missing from the right side, not from the left.
            \end{itemize}
\end{enumerate}
\bigbreak \noindent 
\textbf{Notes:} The tree is balanced in terms of node distribution, with all the levels except possibly the last fully filled.
\bigbreak \noindent 
Nodes on the last level are always added from the leftmost position first.

\bigbreak \noindent 
\subsubsection{Number of nodes}
\bigbreak \noindent 
The height $h$ of a complete binary tree is defined as the number of edges on the longest path from the root to a leaf node.
\bigbreak \noindent 
The total number of nodes in a complete binary tree is given by
\begin{align*}
    n = 2^{h+1} - 1
.\end{align*}
\bigbreak \noindent 
\subsubsection{Height}
\bigbreak \noindent 
The height $h$ of a complete binary tree with $n$ nodes can be derived as:
\begin{align*}
   h = \lfloor \log_{2}(n) \rfloor
.\end{align*}

\bigbreak \noindent 
\subsubsection{Number of Leaf Nodes (L) in a Complete Binary Tree}
\bigbreak \noindent 
The number of leaf nodes in a complete binary tree can be calculated based on the number of internal nodes or the height of the tree
\begin{align*}
    L = \lceil \frac{n}{2} \rceil
.\end{align*}
\bigbreak \noindent 
\subsubsection{Number of internal nodes}
\bigbreak \noindent 
The number of internal nodes (non-leaf nodes) in a complete binary tree can be calculated as:
\begin{align*}
    I &= N - L \\
    I &= \lfloor \frac{n}{2} \rfloor
.\end{align*}

\bigbreak \noindent 
\subsubsection{Parent and Child Relationships in a Complete Binary Tree}
\bigbreak \noindent 
Parent of node at index $i$ (1-based index):
\[
\text{Parent}(i) = \left\lfloor \frac{i}{2} \right\rfloor
\]
Left child of node at index $i$:
\[
\text{Left child}(i) = 2i
\]
Right child of node at index $i$:
\[
\text{Right child}(i) = 2i + 1
\]
These relationships assume a 1-based indexing system for the nodes in the tree (common in heaps or array-based representations).

\pagebreak 
\subsection{Perfect binary tree}
\bigbreak \noindent 
\subsubsection{Number of Nodes}
\bigbreak \noindent 
\begin{align*}
    N = 2^{h+1} - 1
.\end{align*}

\bigbreak \noindent 
\subsubsection{Number of Leaf Nodes}
\bigbreak \noindent 
\begin{align*}
 L = 2^h
.\end{align*}

\bigbreak \noindent 
\subsubsection{Height of the Tree}
\bigbreak \noindent 
\begin{align*}
    h = \log_2(N+1) - 1
.\end{align*}


\bigbreak \noindent 
\subsubsection{Number of Internal Nodes}
\bigbreak \noindent 
\begin{align*}
    I = N - L = 2^h - 1
.\end{align*}

\bigbreak \noindent 
\subsubsection{Depth}
\bigbreak \noindent 
\begin{align*}
    d = h
.\end{align*}

\pagebreak 
\unsect{Applications of binary trees}
\bigbreak \noindent 
\subsection{Binary search trees}
\bigbreak \noindent 
A binary search tree (BST) is a binary tree in which each node has at most two children and follows these properties:
\begin{itemize}
    \item \textbf{Left Subtree Property:} The value of each node in the left subtree is less than the value of the node itself.
    \item \textbf{Right Subtree Property:} The value of each node in the right subtree is greater than the value of the node itself.
    \item Both left and right subtrees must also be binary search trees.
\end{itemize}
\bigbreak \noindent 
\subsubsection{Interface}
\bigbreak \noindent 
The interface of a Binary Search Tree (BST) typically includes a set of operations for managing and accessing the tree’s nodes.
\begin{itemize}
    \item \textbf{Insert(value):} Inserts a new value into the BST while maintaining its properties.
    \item \textbf{Remove(value):} Removes a value from the BST, adjusting the structure to maintain its properties.
    \item \textbf{Predecessor(node)}: Finds the predecessor of a node
    \item \textbf{Succesor(node)}: Finds the successor of a node
    \item \textbf{Find(value):} Searches for a value in the BST and returns the node containing it or null if not found.
    \item \textbf{FindMin():} Returns the node with the smallest value in the BST.
    \item \textbf{FindMax():} Returns the node with the largest value in the BST.
    \item \textbf{IsEmpty():} Checks if the BST is empty.
    \item \textbf{Traverse(order):} Traverses the tree in a specific order (e.g., in-order, pre-order, post-order).
    \item \textbf{Height():} Returns the height of the BST.
    \item \textbf{Clear():} Removes all nodes from the tree, making it empty
\end{itemize}

\pagebreak 
\subsubsection{Traversals}
\bigbreak \noindent 
We can traverse BST's in one of four ways
\begin{itemize}
    \item Level order
    \item Preorder
    \item Inorder
    \item Postorder
\end{itemize}
\bigbreak \noindent 
\paragraph{Level order}
\bigbreak \noindent \bigbreak \noindent 
Level-order traversal is a way of visiting all the nodes in a binary tree by levels, from top to bottom. It starts at the root and visits nodes level by level, left to right, for each level.
\begin{itemize}
    \item Start with the root node (the topmost node).
    \item Visit all the nodes on the next level (children of the root) from left to right.
    \item Then, visit all nodes on the level below that (grandchildren of the root) from left to right, and so on.
\end{itemize}
A queue is often used to implement level-order traversal, as it helps keep track of nodes to visit in the correct order.
\bigbreak \noindent 
\begin{cppcode}
    void levelorderPrint() {
        if (!root) return; // noop for empty tree

        queue<node*> q;
        q.push(root);

        while (!q.empty()) {
            node* curr = q.front();
            q.pop();

            cout << curr->data << endl;
            if (curr->left) {
                q.push(curr->left);
            }
            if (curr->right) {
                q.push(curr->right);
            }
        }
    }
\end{cppcode}
\begin{enumerate}
    \item If the list is nonempty, construct a queue and push the root node.
    \item While the queue is nonempty, grab the front, process the front, pop the front.
    \item Push left and right nodes to queue, if they exist.
\end{enumerate}

\bigbreak \noindent 
\pagebreak \bigbreak \noindent 
\paragraph{Preorder}
\bigbreak \noindent \bigbreak \noindent 
Pre-order traversal is a way of visiting nodes in a binary tree where you:
\begin{enumerate}
    \item Visit the root node first.
    \item Recursively visit the left subtree.
    \item Recursively visit the right subtree.
\end{enumerate}
To explain simply:
\begin{enumerate}
    \item Start with the root node.
    \item Go as far left as possible, visiting each node along the way.
    \item Once you've reached the end of the left subtree, backtrack and visit the right subtree.
\end{enumerate}
\bigbreak \noindent 
\begin{cppcode}
    void preorderPrint() {
        std::function<void(node*)> r_preorderPrint = [&] (node* p) {
            if (p == nullptr) return;

            cout << p->data << endl;
            r_preorderPrint(p->left);
            r_preorderPrint(p->right);
        };
        r_preorderPrint(root);
    }
\end{cppcode}

\bigbreak \noindent 
\paragraph{Inorder}
\bigbreak \noindent\bigbreak \noindent  
in-order traversal is a way of visiting nodes in a binary tree where you:
\begin{enumerate}
    \item Recursively visit the left subtree first.
    \item Visit the root node.
    \item Recursively visit the right subtree.
\end{enumerate}
To explain simply:
\begin{enumerate}
    \item Start by going all the way to the left, visiting nodes along the way.
    \item Once you reach the leftmost node, visit it, then move up to its parent (the root).
    \item After visiting the root, visit the right subtree.
\end{enumerate}
\bigbreak \noindent 
For a BST, printing the tree with an inorder traversal yields a sorted sequence.
\bigbreak \noindent 
\begin{cppcode}
    void inorderPrint() {
        std::function<void(node*)> r_inorderPrint = [&] (node* p) -> void {
            if (!p) return;

            r_inorderPrint(p->left);
            cout << p->data << endl;
            r_inorderPrint(p->right);
        };
        r_inorderPrint(root);
    }
\end{cppcode}

\pagebreak 
\paragraph{Postorder}
\bigbreak \noindent \bigbreak \noindent 
Post-order traversal is a way of visiting nodes in a binary tree where you:
\begin{enumerate}
    \item Recursively visit the left subtree first.
    \item Recursively visit the right subtree.
    \item Finally, visit the root node.
\end{enumerate}
To explain simply:
\begin{enumerate}
    \item Start by going to the leftmost node, but don't visit it yet.
    \item Then, go to the right subtree and process it.
    \item After both subtrees have been visited, visit the root.
\end{enumerate}
\bigbreak \noindent 
\begin{cppcode}
    void postorderPrint() {
        std::function<void(node*)> r_postorderPrint = [&] (node* p) -> void {
            if (!p) return;

            r_postorderPrint(p->left);
            r_postorderPrint(p->right);
            cout << p->data << endl;
        };
        r_postorderPrint(root);
    }
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Successor of a node}
\bigbreak \noindent 
The successor of a node is defined mathematically as
\begin{align*}
    \text{succ}(X) = \text{min}\{A:\ A > X\}
.\end{align*}
\bigbreak \noindent 
thus, we find the set of all nodes that have values greater than that of $X$, then find the minimum in that set.
\bigbreak \noindent 
By properties of binary search trees we find the successor of a node $X$ by 
\begin{enumerate}
    \item \textbf{If $X$ has a right child:} The successor is the leftmost node in the right subtree of $X$ (the smallest node in the right subtree).
    \item \textbf{If $X$ has no right child}:
        \begin{itemize}
            \item If the node is the left child of its parent, then the parent is its successor.
            \item If the node is the right child of its parent, you move upward until you find a node that is the left child of its parent, and that parent is the successor.
        \end{itemize}
\end{enumerate}

\pagebreak 
\subsubsection{Predecessor}
\bigbreak \noindent 
The predecessor of a node $X$ is defined as
\begin{align*}
    \text{pred}(X) = \text{max}\{A:\ A < X\}
.\end{align*}
\bigbreak \noindent 
In other words it is the largest node that is less than $X$. To find the predecessor:
\begin{enumerate}
    \item \textbf{If $X$ has a left child}: The predecssor is the rightmost node in the left subtree
    \item \textbf{If $X$ has no left child}: The predecessor is the nearest ancestor for which the node is in the right subtree.
\end{enumerate}

\bigbreak \noindent 
\subsubsection{The node}
\bigbreak \noindent 
The node is similar to a linked list node, but instead of a single next pointer, it has two. A left pointer and a right pointer.
\bigbreak \noindent 
\begin{cppcode}
    struct node{
        node* left = nullptr;
        node* right = nullptr;
        int data = 0;

        node() = default;
        node(int data) : data(data) {}
        node(node* left, node* right, int data) : left(left), right(right), data(data) {}
    };
\end{cppcode}

\bigbreak \noindent 
\subsubsection{The class}
\bigbreak \noindent 
For simplicity, we often define the Binary Search Tree (BST) as a class. This allows each instance of the class to hold its own root node, along with other data members such as the size of the tree, that we may need. \bigbreak \noindent If it were not a class, then each function would need to take the root node as an argument and return the (potentially modified) root node to maintain the structure."
\bigbreak \noindent 
If it were not a class, than each function would have to take as an argument a root node, and return the root node to maintain the structure
\bigbreak \noindent 
\begin{cppcode}
    class BST {
    private:
        node* root;
        ...
    public:
        ...
    };
\end{cppcode}

\pagebreak 
\subsubsection{Recursive Insertion}
\bigbreak \noindent 
Because of the nature of  BSt's, we often use recursion to define the needed operations.
\bigbreak \noindent 
\begin{cppcode}
    void insert(int element)  {
        // If the tree is empty, insert new element as root
        if (!root) {
            root = new node(element);
            return;
        }

        std::function<void(node*)> r_insert = [&](node* p) -> void {

            // If the element is less than current node, and p->left exists, go left
            if (element < p->data && p->left) {
                r_insert(p->left);

                // If the element is greater than current node, and p->right exists, go right
            } else if (element > p->data && p->right) {
                r_insert(p->right);
            }

            // If the element is less than current node, and p->left doesn't exist, insert node as current nodes left child
            if (element < p->data && !p->left) {
                p->left = new node(element);
                return;

                // If the element is greater than current node, and p->right doesn't exist, insert node as current nodes right child
            } else if (element > p->data && !p->right) {
                p->right = new node(element);
                return;
            }
        };
        // Start recursion from the root
        r_insert(root);
    }
\end{cppcode}
\bigbreak \noindent 
If the tree is empty, it creates a new root node with the given element.
\bigbreak \noindent 
Otherwise, it uses a recursive lambda function (r\_insert) to:
\begin{itemize}
    \item Traverse the tree: going left if the element is smaller, or right if the element is larger.
    \item Once it finds an appropriate spot (where a left or right child doesn't exist), it inserts the new node as a left or right child accordingly.
\end{itemize}
The process starts from the root and recursively finds the right place to insert the new element.

\pagebreak 
\subsubsection{Iterative insert}
\bigbreak \noindent 
\begin{cppcode}
    void insertB(int element) {
        if (!root) {
            root = new node(element);
            return;
        }

        node* p = root, *trail = nullptr;
        bool left;

        while (p) {
            trail = p;
            if (element < p->data) {
                p=p->left;
                left=true;
            } else if (element > p->data) {
                p=p->right;
                left=false;
            } else {
                return; // noop if already exists
            }
        }
        if (left) {
            trail->left = new node(element);
        } else {
            trail->right = new node(element);
        }
    }
\end{cppcode}
\bigbreak \noindent 
If the tree is empty, it creates a new root node with the element.
\bigbreak \noindent 
It then iteratively traverses the tree starting from the root:
\begin{itemize}
    \item Moves left if the element is smaller than the current node's data.
    \item Moves right if the element is larger.
    \item If the element already exists, it does nothing and returns.
\end{itemize}
Once it finds an empty spot (either left or right child is nullptr), it inserts the new node as the left or right child of the parent node (trail), depending on the comparison.

\pagebreak 
\subsubsection{Recursive removing}
\bigbreak \noindent 
To remove a node with a given value from a BST, there are three cases
\begin{enumerate}
    \item Node has no children
    \item Node has one child
    \item Noe has two children
\end{enumerate}
For case I, we can simply set the nodes parent to nullptr, and then delete the node.
\bigbreak \noindent 
For case II, we must divert the connection from the nodes parent to the nodes child, and then free the node.
\bigbreak \noindent 
Case III is more involved, we first must find the successor of the node. Once we find the successor, we replace the nodes data value with its successor. Then, instead of deleting the node, we delete its successor. Since to be in this case the node must have exactly two children, the successor is found in the simple way.
\begin{enumerate}
    \item Go right once
    \item Go as far left as possible.
\end{enumerate}
Once we have the successor node, it will either have no children, or exactly one child (a right child), if it were to have a left child, it would not be the true successor because we would have not gone as far left as possible.
\pagebreak \bigbreak \noindent 
\begin{cppcode}
    void remove(int element) {
        if (!root) return; // Noop for empty tree

        std::function<void(node*&, node*&)> r_remove = [&] (node*& p, node*& last) -> void {
            if (!p) return; // Not found in tree

            if (element < p->data) {
                r_remove(p->left, p);
            } else if (element > p->data) {
                r_remove(p->right, p);
            } else { // Found
                // Case I: Node has zero children 
                if (!p->left && !p->right) {
                    node* tmp = p;
                    p=nullptr;
                    delete tmp;
                    // Case II: Node has one child
                } else if (!p->left || !p->right) {
                    node* tmp = p;
                    p = (p->left ? p->left : p->right);
                    delete tmp;
                    // Case III: Two children
                } else {    
                    node* successor = p->right;
                    node* successorParent = p;

                    // Find the in-order successor 
                    while (successor->left) {
                        successorParent = successor;
                        successor = successor->left;
                    }

                    // Replace nodes value with successor value
                    p->data = successor->data;

                    // Now we need to delete the successor node
                    // The successor is a leaf or has a right child
                    if (successorParent->left == successor) {
                        successorParent->left = successor->right; 
                    } else {
                        successorParent->right = successor->right; 
                    }
                    delete successor;
                }
            }
        };
        r_remove(root,root);
    }
\end{cppcode}












\end{document}
