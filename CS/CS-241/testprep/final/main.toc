\contentsline {section}{\numberline {1}Linked Lists}{4}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Advantages}{4}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Disadvantages}{4}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}ADTs}{4}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Stack ADT}{5}{subsection.0.2.1}%
\contentsline {subsubsection}{\numberline {2.1.1}Principle}{5}{subsubsection.0.2.1.1}%
\contentsline {subsubsection}{\numberline {2.1.2}Data Members}{5}{subsubsection.0.2.1.2}%
\contentsline {subsubsection}{\numberline {2.1.3}Member functions}{5}{subsubsection.0.2.1.3}%
\contentsline {subsection}{\numberline {2.2}Queue ADT}{5}{subsection.0.2.2}%
\contentsline {subsubsection}{\numberline {2.2.1}Principle}{6}{subsubsection.0.2.2.1}%
\contentsline {subsubsection}{\numberline {2.2.2}Data Members}{6}{subsubsection.0.2.2.2}%
\contentsline {subsubsection}{\numberline {2.2.3}Member functions}{6}{subsubsection.0.2.2.3}%
\contentsline {subsection}{\numberline {2.3}Member Functions}{6}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Common errors in the stack and queue}{7}{subsection.0.2.4}%
\contentsline {subsubsection}{\numberline {2.4.1}Underflow}{7}{subsubsection.0.2.4.1}%
\contentsline {subsubsection}{\numberline {2.4.2}Access Errors on Empty Structures}{7}{subsubsection.0.2.4.2}%
\contentsline {subsection}{\numberline {2.5}Deque ADT}{7}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Doubly-linked list deque}{9}{subsection.0.2.6}%
\contentsline {section}{\numberline {3}Templates}{12}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Template Function}{12}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}Template Class}{13}{subsection.0.3.2}%
\contentsline {subsection}{\numberline {3.3}Class vs typename keyword}{13}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Handle friend functions}{13}{subsection.0.3.4}%
\contentsline {subsubsection}{\numberline {3.4.1}Friendship to a Non-Template Function}{13}{subsubsection.0.3.4.1}%
\contentsline {subsubsection}{\numberline {3.4.2}Friendship to a Template Function}{14}{subsubsection.0.3.4.2}%
\contentsline {subsection}{\numberline {3.5}Function Template Specialization}{16}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}Class/Struct Template Specialization}{16}{subsection.0.3.6}%
\contentsline {subsection}{\numberline {3.7}Template Parameters}{16}{subsection.0.3.7}%
\contentsline {subsection}{\numberline {3.8}Trailing return type}{16}{subsection.0.3.8}%
\contentsline {subsubsection}{\numberline {3.8.1}Syntax}{17}{subsubsection.0.3.8.1}%
\contentsline {subsubsection}{\numberline {3.8.2}Example}{17}{subsubsection.0.3.8.2}%
\contentsline {subsection}{\numberline {3.9}decltype}{17}{subsection.0.3.9}%
\contentsline {subsubsection}{\numberline {3.9.1}Syntax}{17}{subsubsection.0.3.9.1}%
\contentsline {subsubsection}{\numberline {3.9.2}Example}{17}{subsubsection.0.3.9.2}%
\contentsline {subsection}{\numberline {3.10}Template functions with mixed types (Trailing return type)}{17}{subsection.0.3.10}%
\contentsline {subsection}{\numberline {3.11}Template functions with mixed types (Deduced return type)}{18}{subsection.0.3.11}%
\contentsline {section}{\numberline {4}Recursion}{19}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Recursion to count nodes in a linked list}{19}{subsection.0.4.1}%
\contentsline {section}{\numberline {5}Inheritance}{20}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}Order of constructors and destructors}{21}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}Constructors}{21}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}Destructors}{21}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}advantages and disadvantages of making data members protected versus making them private and accessing them using set and get methods.}{21}{subsection.0.5.4}%
\contentsline {subsection}{\numberline {5.5}Overloading vs Overriding}{21}{subsection.0.5.5}%
\contentsline {subsection}{\numberline {5.6}Upcasting}{22}{subsection.0.5.6}%
\contentsline {subsection}{\numberline {5.7}Downcasting}{22}{subsection.0.5.7}%
\contentsline {subsubsection}{\numberline {5.7.1}What Happens Without Virtual Functions}{22}{subsubsection.0.5.7.1}%
\contentsline {subsubsection}{\numberline {5.7.2}Downcasting example}{23}{subsubsection.0.5.7.2}%
\contentsline {subsubsection}{\numberline {5.7.3}Base class pointer example}{24}{subsubsection.0.5.7.3}%
\contentsline {subsection}{\numberline {5.8}Object Slicing}{24}{subsection.0.5.8}%
\contentsline {subsection}{\numberline {5.9}Multiple Inheritance}{26}{subsection.0.5.9}%
\contentsline {subsubsection}{\numberline {5.9.1}Why Use Multiple Inheritance?}{26}{subsubsection.0.5.9.1}%
\contentsline {subsubsection}{\numberline {5.9.2}Example}{26}{subsubsection.0.5.9.2}%
\contentsline {subsubsection}{\numberline {5.9.3}Issues with Multiple Inheritance}{27}{subsubsection.0.5.9.3}%
\contentsline {subsection}{\numberline {5.10}Virtual inheritance}{28}{subsection.0.5.10}%
\contentsline {subsubsection}{\numberline {5.10.1}The Diamond Problem}{28}{subsubsection.0.5.10.1}%
\contentsline {subsubsection}{\numberline {5.10.2}Solution with Virtual Inheritance}{29}{subsubsection.0.5.10.2}%
\contentsline {section}{\numberline {6}Polymorphism}{30}{section.0.6}%
