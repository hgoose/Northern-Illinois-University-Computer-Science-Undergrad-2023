\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Final Test Prep}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Final Test Prep}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Linked Lists}
    \bigbreak \noindent 
    \subsection{Advantages}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Dynamic Size:} Unlike arrays, linked lists don't need to have a predetermined size, making them flexible in terms of storage requirements.
        \item \textbf{Efficient Insertions/Deletions:} Inserting and deleting nodes in a linked list is more efficient than in an array, especially for data structures that require frequent additions/removals. Inserting or deleting at the beginning or end of the list (or at any arbitrary position, given the node reference) can be done in constant time $O(1)$.
        \item \textbf{Memory Utilization:} Memory is allocated as needed for each node, avoiding wasted space.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Disadvantages}
    \begin{itemize}
        \item \textbf{Access Time:} Accessing an element in a linked list takes linear time $O(n)$, as you need to traverse from the head node sequentially to the desired node. In contrast, arrays provide constant time $O(1)$ access.
        \item \textbf{Extra Memory Usage:} Each node in a linked list requires additional memory to store a pointer to the next node, or to both previous and next nodes in a doubly linked list.
        \item \textbf{Cache Performance:} Arrays have better cache locality due to contiguous memory allocation, which can result in better performance when iterating through the data sequentially.
    \end{itemize}

    \bigbreak \noindent 
    \pagebreak 
     \unsect{ADTs}
     \bigbreak \noindent 
     \subsection{Stack ADT}
     \bigbreak \noindent 
     \subsubsection{Principle}
     \bigbreak \noindent 
     The array based stack follows the LIFO (last in first out) principle. This means that items are inserted at the top of the stack and removed from the top of the stack.
     \bigbreak \noindent 
     \subsubsection{Data Members}
     \begin{itemize}
         \item \textbf{stk\_array} - Stack array pointer. A pointer to the data type of the items stored in the stack; points to the first element of a dynamically-allocated array.
         \item \textbf{stk\_capacity} - Stack capacity. The number of elements in the stack array.
         \item \textbf{stk\_size} - Stack size. The number of items currently stored in the stack. The top item in the stack is always located at subscript stk\_size - 1. Member Functions
     \end{itemize}
     \bigbreak \noindent 
     \subsubsection{Member functions}
     \begin{itemize}
         \item \textbf{Default constructor:} Sets stack to initial empty state. The stack capacity and stack size should be set to 0. The stack array pointer should be set to nullptr.
         \item \textbf{size()} Returns the stack size.
         \item \textbf{capacity()} Returns the stack capacity.
         \item \textbf{empty()} Returns true if the stack size is 0; otherwise, false.
         \item \textbf{clear()} Sets the stack size back to 0. Does not deallocate any dynamic storage.
         \item \textbf{top()} Returns the top item of the stack (stk\_array[stk\_size - 1]).
         \item \textbf{push()} Inserts a new item at the top of the stack.
         \item \textbf{pop()} Removes the top item from the stack.
         \item \textbf{Copy constructor} Similar to the copy constructor for the example Vector class in the notes on dynamic storage allocation.
         \item \textbf{Copy assignment operator} Similar to the copy assignment operator for the example Vector class in the notes on dynamic storage allocation.
         \item \textbf{Destructor} Deletes the stack array.
         \item \textbf{reserve()} Reserves additional storage for the stack array.
     \end{itemize}

     \bigbreak \noindent 
     \subsection{Queue ADT}
     \bigbreak \noindent 
     \subsubsection{Principle}
     \bigbreak \noindent 
     The queue follows the FIFO (first in first out) principle. This means items are inserted at the back of the queue and removed from the front.
     \bigbreak \noindent 
     \subsubsection{Data Members}
     \begin{itemize}
        \item \textbf{q\_array} - Queue array pointer. A pointer to the data type of the items stored in the queue; points to the first element of a dynamically-allocated array.
        \item \textbf{q\_capacity} - Queue capacity. The number of elements in the queue array.
        \item \textbf{q\_size} - Queue size. The number of items currently stored in the queue.
        \item \textbf{q\_front} - Queue front. The subscript of the front (or head) item in the queue.
        \item \textbf{q\_back} - Queue back. The subscript of the back (or rear or tail) item in the queue.
    \end{itemize}
     \bigbreak \noindent 
     \subsubsection{Member functions}
\subsection{Member Functions}
    \begin{itemize}
        \item \textbf{Default constructor} Sets queue to initial empty state. The queue capacity and queue size should be set to 0. The queue array pointer should be set to nullptr. q\_front should be set to 0, while q\_back is set to q\_capacity - 1.
        \item \textbf{size()} Returns the queue size.
        \item \textbf{capacity()} Returns the queue capacity.
        \item \textbf{empty()} Returns true if the queue size is 0; otherwise, false.
        \item \textbf{clear()} Sets the queue size back to 0 and resets q\_front and q\_back to their initial values. Does not deallocate any dynamic storage or change the queue capacity.
        \item \textbf{front()} Returns the front item of the queue (q\_array[q\_front]).
        \item \textbf{back()} Returns the back item of the queue (q\_array[q\_back]).
        \item \textbf{push()} Inserts a new item at the back of the queue.
        \item \textbf{pop()} Removes the front item from the queue.
        \item \textbf{Copy constructor Similar} to the copy constructor for the example Vector class in the notes on dynamic storage allocation. A key difference is that we cannot assume that the items in the queue are stored in elements 0 to q\_size - 1 the way we can in the Vector or an array-based stack. It is therefore necessary to copy the entire queue array.
        \item \textbf{Copy assignment operator} Similar to the copy assignment operator for the example Vector class in the notes on dynamic storage allocation. A key difference is that we cannot assume that the items in the queue are stored in elements 0 to q\_size - 1 the way we can in the Vector or an array-based stack. It is therefore necessary to copy the entire queue array.
        \item \textbf{Destructor} Deletes the queue array.
        \item \textbf{reserve()} Reserves additional storage for the queue array. The process of copying the original array contents into the new, larger array is complicated by the fact that the exact locations of the queue items within the queue array are unknown and that there is no guarantee that q\_front is less than q\_back.
    \end{itemize}


     \bigbreak \noindent 
     \subsection{Common errors in the stack and queue}
     \bigbreak \noindent 
     \subsubsection{Underflow}
     \begin{itemize}
         \item \textbf{Stack Underflow:} This happens when calling pop() or top() on an empty stack. The pop() function tries to remove the top element of the stack, and top() tries to access the top element without removing it. If the stack is empty, there's no top element to access or remove, leading to an underflow condition.
         \item \textbf{Queue Underflow:} Similar to stack underflow, this occurs when calling pop() or front() on an empty queue. The pop() function (or dequeue() in some implementations) attempts to remove the front element, and front() tries to access the front element. If the queue is empty, these operations cannot be completed, resulting in underflow.
     \end{itemize}
     \bigbreak \noindent 
     \nt{Stack underflow happens when we try to pop (remove) an item from the stack, when nothing is actually there to remove. This will raise an alarm of sorts in the computer because we told it to do something that cannot be done.}

     \bigbreak \noindent 
     \subsubsection{Access Errors on Empty Structures}
     \bigbreak \noindent 
     While not always classified separately from underflow errors, trying to access the front or back of an empty queue, or the top of an empty stack, without removing elements, can also lead to errors. These are specific cases of underflow where the error is due to an attempt to read from an empty structure rather than to modify it.
     \begin{itemize}
         \item \textbf{Accessing the Top of an Empty Stack:} Invoking top() on an empty stack does not modify the stack but still results in an error because there's no element to return.
         \item \textbf{Accessing the Front or Back of an Empty Queue:} Similarly, calling front() or back() on an empty queue tries to access elements that do not exist, leading to errors.        
     \end{itemize}

     \bigbreak \noindent 
     \subsection{Deque ADT}
     \bigbreak \noindent 
         The changes that must be made to turn the queue from the section above into a deque, is to have
    \begin{enumerate}
        \item \textbf{push\_front}: Add item at the front of the queue
        \item \textbf{push\_back}: Add item at the back of the queue
        \item \textbf{pop\_front}: Remove item from the front of the queue
        \item \textbf{pop\_back}: Remove item from the back of the queue
    \end{enumerate}
    \bigbreak \noindent 
    As opposed to the standard queue where we only have \textbf{push()} and \textbf{pop()} methods (pushing to the back and popping from the front).

    \bigbreak \noindent 
    \begin{cppcode}
    void push_back(int value) {
        if (m_size == m_capacity) {
            reserve((m_capacity > 0 ? m_capacity * 2 : 1));
        }

        m_back = (m_back + 1) % m_capacity;
        arr[m_back] = value;
        ++m_size;
    }

    void push_front(int value) {
        if (m_size == m_capacity) {
            reserve((m_capacity > 0 ? m_capacity * 2 : 1));
        }

        m_front = (m_front - 1 + m_capacity) % m_capacity;
        arr[m_front] = value;
        ++m_size;
    }

    void pop_front() {
        if (!empty()) {
            m_front = (m_front + 1) % m_capacity;
            --m_size;
        }
    }

    void pop_back() {
        if (!empty()) {
            m_back = (m_back - 1 + m_capacity) % m_capacity;
            --m_size;
        }
    }
    \end{cppcode}

    \pagebreak 
    \subsection{Doubly-linked list deque}
    \bigbreak \noindent 
    To modify the singly linked list queue into a doubly-ended queue (deque), you'll need to:
    \begin{itemize}
        \item \textbf{Modify the node Structure:} Add a prev pointer to allow traversal in both directions.
        \item \textbf{Implement push\_front:} Add a function to insert elements at the front of the deque.
        \item \textbf{Implement push\_back:} Add a function to insert elements at the back of the deque.
        \item \textbf{Implement pop\_front:} Add a function to remove elements from the front of the deque.
        \item \textbf{Implement pop\_back:} Add a function to remove elements from the back of the deque.
    \end{itemize}
    \bigbreak \noindent 
    \nt{In order to make a linked-list deque, the linked list \textbf{must} be doubly}

    \bigbreak \noindent 
    \begin{cppcode}
    void push_back(int value) {
        node* new_node = new node(nullptr, m_back, value);

        if (empty()) {
            m_front = new_node;
        } else {
            m_back->next = new_node;
        }

        m_back = new_node;
        ++m_size;
    }

    void push_front(int value) {
        node* new_node = new node(m_front, nullptr, value);

        if (empty()) {
            m_back = new_node;
        } else {
            m_front->prev = new_node;
        }

        m_front = new_node;
        ++m_size;
    }

    void pop_front() {
        if (m_front == nullptr) return;

        node* del = m_front;
        m_front = m_front->next;

        if (m_front == nullptr) {
            m_back = nullptr;
        } else {
            m_front->prev = nullptr;
        }

        delete del;
        --m_size;
    }
    \end{cppcode}

    \pagebreak 
    \begin{cppcode}
    void pop_back() {
        if (m_back == nullptr) return;

        node* del = m_back;
        m_back = m_back->prev;

        if (m_back == nullptr) {
            m_front = nullptr;
        } else {
            m_back->next = nullptr;
        }

        delete del;
        --m_size;
    }
    \end{cppcode}

    \pagebreak 
    \unsect{Templates}
    \bigbreak \noindent 
    Templates in C++ are a powerful feature that allows writing generic and reusable code. They enable functions and classes to operate with different data types without being rewritten for each specific type.
    \bigbreak \noindent 
    \subsection{Template Function}
    \bigbreak \noindent 
    A template function defines a family of functions that work with different data types. Here's how to write and use a template function:
    \bigbreak \noindent 
    \begin{cppcode}
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add<int>(3, 4) << std::endl; // Instantiates add<int>
    std::cout << add<double>(2.5, 3.1) << std::endl; // Instantiates add<double>
    return 0;
}
    \end{cppcode}

    \bigbreak \noindent 
    \pagebreak 
    \subsection{Template Class}
    \bigbreak \noindent 
    \begin{cppcode}
template <typename T>
class Stack {
    std::vector<T> data;

public:
    void push(T value) {
        data.push_back(value);
    }
    void pop() {
        data.pop_back();
    }
    T top() const {
        return data.back();
    }
    bool empty() const {
        return data.empty();
    }
};

int main() {
    Stack<int> intStack; // Instantiates Stack<int>
    intStack.push(10);
    intStack.push(20);
    std::cout << intStack.top() << std::endl;

    Stack<double> doubleStack; // Instantiates Stack<double>
    doubleStack.push(1.1);
    doubleStack.push(2.2);
    std::cout << doubleStack.top() << std::endl;
    return 0;
}
    \end{cppcode}










    \bigbreak \noindent 
    \subsection{Class vs typename keyword}
    \bigbreak \noindent 
    The choice between using \textbf{class} and \textbf{typename} in template declarations in C++ is largely a matter of style and historical context, as both keywords serve the same purpose

    \bigbreak \noindent 
    \subsection{Handle friend functions}
    \bigbreak \noindent 

    \subsubsection{Friendship to a Non-Template Function}
    \bigbreak \noindent 
    This is straightforward. You directly declare a non-template function as a friend inside your template class. This grants that specific function access to all instances of the template class, regardless of the type parameter.
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        class MyClass {
            friend void someFunction(MyClass<T>&);
        };
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{Friendship to a Template Function}
    \bigbreak \noindent 
    More commonly, you want a template function to be a friend to a template class. This allows each instantiation of the function template to access the corresponding instantiation of the class template.To achieve this, you need to forward declare the function template and then declare it as a friend inside your class template. The tricky part is that the syntax for declaring a template function as a friend inside a template class can vary based on what you're trying to achieve:
     \bigbreak \noindent 
    \textbf{How to forward declare:}
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    class myclass;

    template<typename T>
    void foo(myclass<T>&); 


    template<typename T>
    class myclass {

    public:
        friend void foo <T>(const myclass<T>& obj);
    };

template <typename T>
void foo(myclass<T>& obj) {
    // Define
}
    \end{cppcode}
    \pagebreak 
    \textbf{Different types:}
    \begin{itemize}
        \item More general form used when you want the friendship to apply to all instantiations of the function template
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    friend void someFunction<>(MyClass<T>&); // Specific instantiation
                };
            \end{cppcode}
        \item All instantiations of the function template are friends:
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    template <typename U>
                    friend void someFunction(MyClass<U>&); // All instantiations
                };
            \end{cppcode}
        \item This form ties the friendship to the specific template instantiation of both MyClass and someFunction using the same template argument T. The function template that takes the same template parameters:
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    friend void someFunction<T>(MyClass<T>&); // Matched instantiation
                };
            \end{cppcode}
    \end{itemize}

    \pagebreak 
    \subsection{Function Template Specialization}
    \bigbreak \noindent 
    \begin{concept}
        \textbf{Template specialization} allows you to define a different implementation for a particular data type.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
    template <typename T>
    T min(T x, T y) {
        return (x < y) ? x : y;
    }

    template <>
    const char* min(const char* x, const char* y) {
        return (strcmp(x, y) < 0) ? x : y;
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Class/Struct Template Specialization}
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    struct foo {
        T x = 20;
    };

    template<>
    struct foo<char> {
        char x = 'z';
    };
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Template Parameters}
    \bigbreak \noindent 
    \begin{concept}
        Templates can have more than one parameter, including non-type parameters.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T, int size>
        class FixedArray {
            private:
            T arr[size];
            // implementation
        };
    \end{cppcode}

     \bigbreak \noindent 
    \subsection{Trailing return type}
    \bigbreak \noindent 
    In traditional C++, the return type of a function is declared at the beginning of the function declaration. However, C++11 introduced a new syntax that allows the return type to be specified after the parameter list, using auto at the beginning and -> Type after the parameter list.
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \bigbreak \noindent 
    \begin{cppcode}
    auto functionName(parameters) -> returnType {
        // function body
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    auto foo(int a, int b) -> int {
        return a + b;
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{decltype}

    \bigbreak \noindent 
    \begin{concept}
        \textbf{decltype} is a keyword in C++ introduced in C++11, which stands for "declared type". It is used to query the type of an expression without actually evaluating that expression. This can be particularly useful in template programming and type deduction, where the type of an expression might not be known until compile time.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \bigbreak \noindent 
    \begin{cppcode}
        decltype(expression) variable_name;
    \end{cppcode}
    \bigbreak \noindent 
    Here, \textbf{variable\_name} will have the same type as the type of \textbf{expression}. It's important to note that \textbf{expression} is not evaluated; \textbf{decltype} only deduces its type.
    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    int a = 5;
    decltype(a) b = 5;

    cout << typeid(b).name() << endl; // Output: i
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Template functions with mixed types (Trailing return type)}
    \bigbreak \noindent 
    \begin{concept}
        To address the challenge of determining the return type for a template function that accepts two different types, we can utilize a strategy involving \textbf{auto} and a \textbf{trailing return type} with \textbf{decltype}. This approach effectively resolves the ambiguity of the return type in such template functions.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        auto add(T t, U u) -> decltype(t + u) {
            return t + u;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Template functions with mixed types (Deduced return type)}
    Alternatively, C++14 introduced the concept \textbf{deduced return type}. Which provides a simpler way to handle the situation described above
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        decltype(auto) foo(T a, U b)  {
            return a + b;
        }
    \end{cppcode}

    \pagebreak 
    \unsect{Recursion}
    \bigbreak \noindent 
    \begin{itemize}
        \item Recursion is a technique where the solution to a problem depends on solutions to smaller instances of the problem.
        \item A recursive function or method calls itself.
        \item A recursive call is always conditional – there must be some case (called the base case) where recursion does not take place. A recursive call should make progress towards the base case.
        \item Recursion is never required in C++. A recursive algorithm may always be rewritten with either a loop or a loop and a stack.
        \item In C++, a recursive algorithm is often less efficient in terms of memory usage and speed than the equivalent non-recursive algorithm. However, the recursive version may be shorter and easier to code.
        \item You should be able to write a simple recursive function or method to do something (like counting the nodes in a linked list).
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Recursion to count nodes in a linked list}
    \bigbreak \noindent 
    \begin{cppcode}
        size_t countNodes(node* p) {
            if (p == nullptr) {
                return 0;
            }
            return 1 + countNodes(p->next);
        }
    \end{cppcode}

    \pagebreak 
    \unsect{Inheritance}
    \bigbreak \noindent 
    Inheritance is a way to compartmentalize and reuse code by creating a new class based on a previously created class.
    \begin{itemize}
        \item The previously created class is called a \textbf{superclass} or \textbf{base class}.
        \item The new class derived from a base class is called a \textbf{subclass} or \textbf{derived class}. It represents a smaller, more specialized group of objects than its base class.
        \item A derived class may add new data members, add new methods, and override methods in the base class.
        \item Inheritance is used to represent an \textbf{“is a” relationship} between a derived class and a base class. A derived class object is also an instance of all of its base classes (e.g., a Circle is a Shape).
        \item Be able to code a derived class using \textbf{public inheritance}.
        \item Be able to code a constructor for a derived class, including one that passes arguments to the base class constructor using \textbf{constructor initialization list} syntax.
        \item Know the order in which constructor and destructor bodies will execute when you create or destroy an object of a derived class.
        \item Members of a class with \textbf{protected access} can be directly accessed by methods of the class, friends of the class, and methods of derived classes of the class.
        \item Be able to describe the advantages and disadvantages of making data members protected versus making them private and accessing them using set and get methods.
        \item Know the difference between \textbf{overloading} a method or function and \textbf{overriding} a method:
            \begin{itemize}
                \item \textbf{Overloading} refers to a new method or function with the same name as an existing one in the same scope, but with a different signature (number of arguments, data types of arguments, order of data types, whether or not a method is const).
                \item \textbf{Overriding} a method means writing a method in a derived class with the same name, arguments, and return data type as a method in the base class. The derived class method effectively replaces the base class method.
            \end{itemize}
        \item Know how to call a base class version of a method from within a derived class method that overrides it.
        \item Know how to perform an \textbf{upcast} – a conversion of a derived class pointer or reference type to its base class pointer or reference type. In C++ this does not require an explicit type cast.
        \item A base class pointer or reference can only be used to call methods that are declared in the base class.
        \item Know how to perform a safe \textbf{downcast} – a conversion of a base class pointer or reference to one of its derived class pointer or reference types – using the \texttt{dynamic\_cast} operator. A \texttt{dynamic\_cast} requires that runtime type information be enabled. Know how to test whether or not a \texttt{dynamic\_cast} was successful.
        \item C++ supports \textbf{multiple inheritance} – a derived class may have more than one base class.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Order of constructors and destructors}
    \bigbreak \noindent 
    \subsection{Constructors}
    \begin{itemize}
        \item \textbf{Base Class Constructor First:} When a derived class object is created, the base class constructor is called before the derived class constructor.
        \item \textbf{Derived Class Constructor:} After the base class constructor finishes executing, the derived class constructor is executed.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Destructors}
    \begin{itemize}
        \item \textbf{Derived Class Destructor First:} When a derived class object is destroyed, the derived class destructor is called first.
        \item \textbf{Base Class Destructor:} After the derived class destructor finishes, the base class destructor is called.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{advantages and disadvantages of making data members protected versus making them private and accessing them using set and get methods.}
    \bigbreak \noindent 
    The use of protected data members allows for a slight increase in performance, because we
    avoid incurring the overhead of a call to a ”set” or ”get” member function. Unfortunately,
    protected data members often yield two major problems. First, the derived class object does
    not have to use a ”set” member function to change the value of the base class’s protected
    data. A derived class object can easily assign an illegal value to a protected data member.
    Second, derived class member functions are more likely to depend on base class implementation details. Changes to the base class may require changes to some or all of the derived
    classes of that base class.
    \bigbreak \noindent 
    Declaring data members private, while providing non-private member functions to manipulate and perform validation checking on this data, enforces good software engineering. The
    programmer should be able to change the base class implementation freely, while still providing the same services to the derived class. The performance increases gained by using
    protected data members are often negligible compared to the optimizations that compilers
    can perform. It is appropriate to use the protected access modifier when a base class should
    provide a service (i.e., a member function) only to its derived classes and should not provide
    the service to other clients.

    \bigbreak \noindent 
    \subsection{Overloading vs Overriding}
    \bigbreak \noindent 
    As stated above, \textbf{Overloading} refers to a new method or function with the same name as an existing one
    in the same scope, but with a different signature (number of arguments, data types of
    arguments, order of data types, whether or not a method is const)
    \bigbreak \noindent 
    \textbf{Overriding} a method means writing a method in a derived class with the same name,
    arguments and return data type as a method in the base class. The derived class
    method effectively replaces the base class method.

    \bigbreak \noindent 
    \subsection{Upcasting}
    \bigbreak \noindent 
    Upcasting is the process of converting a derived class pointer or reference to a base class pointer or reference.
    \begin{itemize}
        \item Upcasting is safe because every derived object is also an instance of its base class.
        \item It allows for polymorphism when the base class has virtual functions.
        \item No explicit cast is required, and the conversion is implicit.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Downcasting}
    \bigbreak \noindent 
    Downcasting is the process of converting a base class pointer or reference to a derived class pointer or reference
    \begin{itemize}
        \item Downcasting is potentially unsafe, so it requires an explicit cast.
        \item dynamic\_cast should be used for safe downcasting to check if the cast is valid at runtime.
        \item Downcasting typically requires polymorphic classes with virtual functions to enable dynamic\_cast.
    \end{itemize}

    \bigbreak \noindent 
    In C++, the dynamic\_cast operator, used for safe downcasting, requires that the base class has at least one virtual function. This is because dynamic\_cast relies on runtime type information (RTTI), which is only available for polymorphic classes.
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{RTTI Availability:}
            \begin{itemize}
                \item RTTI is used to store type information at runtime, which dynamic\_cast uses to determine the exact type of the object being cast.
                \item RTTI is only generated by the compiler for polymorphic classes, which are classes that have at least one virtual function.
            \end{itemize}
        \item \textbf{Polymorphic Behavior:} Virtual functions enable polymorphic behavior, allowing derived classes to override base class functions. This is the essence of polymorphism, which dynamic\_cast utilizes to ensure safe downcasting.
        \item \textbf{Checking Actual Type:} The type information stored in RTTI allows dynamic\_cast to check if the object being cast is indeed of the target derived type. If not, it returns nullptr (for pointers) or throws a std::bad\_cast exception (for references).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{What Happens Without Virtual Functions}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{No RTTI:} If the base class has no virtual functions, it is not polymorphic, and the compiler doesn't generate RTTI for it. Without RTTI, dynamic\_cast cannot validate types at runtime.
        \item \textbf{Compile-Time Error:} Attempting to use dynamic\_cast on a class without virtual functions will lead to a compile-time error indicating that the class type is not polymorphic.

    \end{itemize}

    \pagebreak 
    \subsubsection{Downcasting example}
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Base {
            public:
            virtual ~Base() = default; // Make the class polymorphic
        };

        class Derived1 : public Base {
            public:
            void func1() {
                std::cout << "Derived1 Function\n";
            }
        };

        class Derived2 : public Base {
            public:
            void func2() {
                std::cout << "Derived2 Function\n";
            }
        };

        int main() {
            // Case 1: Valid downcast, will not get nullptr
            Base* basePtr1 = new Derived1(); // Base pointer to Derived1
            Derived1* derived1Ptr = dynamic_cast<Derived1*>(basePtr1);
            if (derived1Ptr) {
                derived1Ptr->func1(); // This will execute correctly
            } else {
                std::cout << "Downcast to Derived1 failed\n";
            }

            // Case 2: Invalid downcast, will get nullptr
            Base* basePtr2 = new Derived2(); // Base pointer to Derived2
            Derived1* derived1PtrInvalid = dynamic_cast<Derived1*>(basePtr2);
            if (derived1PtrInvalid) {
                derived1PtrInvalid->func1(); // This will not execute
            } else {
                std::cout << "Downcast to Derived1 failed\n"; // This will be printed
            }

            // Clean up
            delete basePtr1;
            delete basePtr2;

            return 0;
        }
    \end{cppcode}

    \pagebreak 
    \nt{When a Base* points to a Base object and we attempt to downcast it to a derived type using dynamic\_cast, the cast will fail and return nullptr. This is because the actual type of the object being pointed to is Base, not the derived type.}

    \bigbreak \noindent 
    \subsubsection{Base class pointer example}
    \bigbreak \noindent 
    \begin{cppcode}
class base {

public:
    virtual void print() const {
        cout << "Base class" << endl;
    }

};


class derived : public base {
    void print() const override {
        cout << "Child class" << endl;
    }
};


int main(int argc, char* argv[]) {

    base* bptr = new derived();

    bptr->print(); // Child class
    bptr->base::print(); // Base class

    return EXIT_SUCCESS;
}
    \end{cppcode}
    \bigbreak \noindent 
    \nt{Notice we are able to call the private method, this is because the virtual function mechanism directs the call to the most derived method.}

    \bigbreak \noindent 
    \subsection{Object Slicing}
    \bigbreak \noindent 
    Object slicing occurs when a derived class object is assigned or copied to a base class object, causing the derived class's specific members to be "sliced off."
    \bigbreak \noindent 
    \begin{cppcode}
    base b1 = base();
    derived d1 = derived();

    b1 = d1; // Slicing
    d1 = b1; // Does not work
    \end{cppcode}






    \pagebreak 
    \subsection{Multiple Inheritance}
    \bigbreak \noindent 
    Multiple inheritance is a feature in C++ that allows a derived class to inherit from more than one base class.
    \bigbreak \noindent 
    \subsubsection{Why Use Multiple Inheritance?}
    \begin{itemize}
        \item \textbf{Combining Functionality:} When a derived class needs to combine the functionalities of multiple base classes.
        \item \textbf{Mixins:} Allows implementing mixins, which are small base classes that provide specific functionalities to derived classes.
        \item \textbf{Interface Implementation:} Multiple inheritance can also be used to implement interfaces (abstract base classes) in C++.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
#include <iostream>

class Base1 {
public:
    void func1() {
        std::cout << "Base1 Function" << std::endl;
    }
};

class Base2 {
public:
    void func2() {
        std::cout << "Base2 Function" << std::endl;
    }
};

class Derived : public Base1, public Base2 {
    // Derived class inherits from both Base1 and Base2
public:
    void func3() {
        std::cout << "Derived Function" << std::endl;
    }
};

int main() {
    Derived d;
    d.func1(); // Inherited from Base1
    d.func2(); // Inherited from Base2
    d.func3(); // Own function

    return 0;
}
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Issues with Multiple Inheritance}
    \begin{enumerate}
        \item \textbf{Ambiguity:}
        \begin{itemize}
            \item If two base classes have the same method or attribute name, calling it from the derived class can cause ambiguity.
            \item This can be resolved using the scope resolution operator :: to specify which base class method to call.
        \end{itemize}
    \item \textbf{Diamond Problem:}
        \begin{itemize}
            \item If two base classes inherit from the same class and a derived class inherits from both base classes, it leads to ambiguity in the derived class about which base class's implementation to use.
            \item This can be addressed using virtual inheritance to ensure only one copy of the shared base class exists.
        \end{itemize}
    \end{enumerate}
    \pagebreak 
    \subsection{Virtual inheritance}
    \bigbreak \noindent 
    Virtual inheritance in C++ is a mechanism to prevent multiple "copies" of a base class when using multiple inheritance. It ensures that the derived class has only one shared instance of the base class, thus preventing ambiguity and redundant base class objects.
    \bigbreak \noindent 
    \subsubsection{The Diamond Problem}
    \bigbreak \noindent 
    The diamond problem occurs when two classes inherit from the same base class and another class inherits from those two classes. This results in ambiguity and multiple copies of the shared base class.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Base {
            public:
            int data;
            Base() : data(0) {}
        };

        class Derived1 : public Base {};

        class Derived2 : public Base {};

        class FinalDerived : public Derived1, public Derived2 {};

        int main() {
            FinalDerived obj;

            // Error: Ambiguity, which Base::data to access?
            // obj.data = 10;
            // Explicit resolution:
            obj.Derived1::data = 10;
            obj.Derived2::data = 20;

            std::cout << obj.Derived1::data << ", " << obj.Derived2::data << std::endl;

            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    There are two separate instances of the Base class, one inherited through Derived1 and one through Derived2 This leads to ambiguity and multiple instances.
    \pagebreak 
    \subsubsection{Solution with Virtual Inheritance}
    \bigbreak \noindent 
    Virtual inheritance addresses this problem by ensuring that the shared base class is inherited virtually. This makes the derived class have a single, shared instance of the base class.
    \bigbreak \noindent 
    \begin{cppcode}
#include <iostream>
class Base {
public:
    int data;
    Base() : data(0) {}
};

class Derived1 : virtual public Base {};

class Derived2 : virtual public Base {};

class FinalDerived : public Derived1, public Derived2 {};

int main() {
    FinalDerived obj;

    // No ambiguity, only one instance of Base exists
    obj.data = 10;

    std::cout << obj.data << std::endl;

    return 0;
}
    \end{cppcode}

    \pagebreak 
    \unsect{Polymorphism}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Polymorphism:} The ability of objects belonging to different types to respond to method calls of the same name, each one according to an appropriate type-specific behavior. In C++, polymorphism is implemented through the use of virtual methods.
        \item You should know how to code a virtual method. A virtual method called using a pointer or reference will use dynamic binding. Other method or function calls use static binding.
        \begin{itemize}
            \item With dynamic binding, which version of a method to call is determined at runtime based on the data type of the object a pointer or reference points to (the dynamic type), rather than the data type of the pointer or reference (the static type).
            \item With static binding, the data type of the object name, pointer to an object or reference to an object is used to determine which version of a method or function to call at compile time.
        \end{itemize}
        \item A pure virtual method (also called an abstract method) is a virtual method with no implementation, only a prototype (that ends with = 0).
        \item An abstract class in C++ is one that contains one or more pure virtual methods. A class that is not abstract is referred to as a concrete class.
        \begin{itemize}
            \item You cannot create an object of an abstract class.
            \item You can use an abstract class as a base class for inheritance.
            \item You can declare a pointer to an object of an abstract class or a reference to an object of an abstract class. Such a pointer or reference will normally be used to point to an object of one of the abstract class’s derived classes.
        \end{itemize}
        \item A derived class must implement all of the pure virtual methods in an abstract base class or it is also an abstract class.
        \item An interface is an abstract class that contains only pure virtual methods and symbolic constants (static const data members).
    \end{itemize}













    
\end{document}
