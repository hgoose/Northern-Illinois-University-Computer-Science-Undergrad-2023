\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Android Development with Java and XML}
    \bigbreak \noindent 
    \subsection{The Basics}
    \begin{itemize}
        \item \textbf{Layout file for apps "look"}: Note that the XML layout file for our app's "look" is named activity\_main.xml
        \item \textbf{Creating a new project}: Click on the Empty Views Activity template to highlight it and click Next
            \begin{enumerate}
                \item Enter the name of the project
                \item Enter the package name as edu.niu.zid.projectname
                \item Set language to Java
                \item Choose API 22 ("Lollipop"; Android 5.1) for the minimum SDK
                \item Click finish
            \end{enumerate}
        \item \textbf{Directory structure}: please be sure that you have no additional layers than what you see here.
            \bigbreak \noindent 
            \fig{.5}{./figures/mi.png}
            \bigbreak \noindent 
            Notice at the highest level in the hierarchy of our project folders that there are two main "pieces" to the Android project:
            \begin{enumerate}
                \item app
                \item Gradle Scripts
            \end{enumerate}
            \bigbreak \noindent 
            Within the app, there are really three folders we are going to be concerned with for now:
            \begin{enumerate}
                \item manifests
                \item java
                \item res
            \end{enumerate}
        \item \textbf{Manifests}: The directory named manifests holds one xml file - so far. It is the AndroidManifest.xml file.
        \item \textbf{Java (directory):} The directory named java holds one Java source files - so far. It is the MainActivity.java file
        \item \textbf{Res (directory)}: The directory named res holds resource files, such as utility xml files for defining strings, themes, menus, layouts, dimensions, images, sounds, etc
        \item \textbf{MainActivity.java}: This is the logic/controller file. It's the Java class that defines what your app does when it runs. It extends AppCompatActivity (or another activity class), and inside it you set up event handling, lifecycle methods (like onCreate), and the code that reacts to user interactions. For example, if a button is clicked, the code for what happens lives here.
            \bigbreak \noindent 
            The simplest MainActivity.java file is as follows
            \bigbreak \noindent 
            \begin{javacode}
                package YOURPACKAGENAME

                import androidx.appcompat.app.AppCompatActivity;

                import android.os.Bundle;

                public class MainActivity extends AppCompatActivity {

                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        setContentView(R.layout.activity_main);
                    }
                }           
            \end{javacode}
            \bigbreak \noindent 
            In this code, the most important import statement is the import for class android.appcompat.app.AppCompatActivity
            \bigbreak \noindent 
            MainActivity.java class extends, or inherits from, superclass AppCompatActivity class found in Android API package androidx.appcompat.app.AppCompatActivity
            \bigbreak \noindent 
            AppCompatActivity itself is a subclass itself of Activity.
            \bigbreak \noindent 
            An Activity provides the screen with which users can interact, in other words, the User Interface, or UI.
            \bigbreak \noindent 
            The MainActivity class is meant to be used as the Controller for every app we develop
            \bigbreak \noindent 
            Method onCreate() of an Android app is called automatically upon launch just like the main() method is called automatically by the Java Virtual Machine, or JVM, upon launch of a Java applications.
            \bigbreak \noindent 
            Inside method onCreate(), we create the initial View for the app, controlled by this Activity.
            \bigbreak \noindent 
            In method onCreate(), the superclass' onCreate() method is first called.
            \bigbreak \noindent 
            Then the View, or opening screen, for this Activity is set by calling method setContentView().
            \bigbreak \noindent 
            Method setContentView() is inherited from the AppCompatActivity , or Activity class.
            \bigbreak \noindent 
            Its API is 
            \bigbreak \noindent 
            \begin{javacode}
            void setContentView(int layoutResID)
            \end{javacode}
            \bigbreak \noindent 
            layoutResID is a resource found in the subfolder named layout in the folder named res.
            \bigbreak \noindent 
            This ID defaults to: \textit{R.layout.activity\_main.}
            \bigbreak \noindent 
            In MainActivity.java, we refer to and access activity\_main.xml using the syntax
            \bigbreak \noindent 
            \begin{javacode}
            R.layout.activity_main
            \end{javacode}
            \bigbreak \noindent 
            activity\_main is a static constant of the static final class layout defined inside the R.java class or file.
            \bigbreak \noindent 
            The R.java file was automatically created when we began our project
            \bigbreak \noindent 
            R stands for resources and "represents" the res directory.
        \item \textbf{activity\_main.xml}: This is the UI/layout file. It defines the visual structure of your screen using XML: buttons, text fields, images, layouts, etc. You don't put behavior here—only the arrangement and styling of the interface elements.
            \bigbreak \noindent 
            activity\_main is an xml file, a resource located in the layout subdirectory of the res directory
            \bigbreak \noindent 
            It was also automatically created when we began our project using the template we chose.
            \bigbreak \noindent 
            We can think of XML as a markup language similar to HTML, but with user-defined tags
        \item \textbf{Intro to design editor}: With the activity\_main.xml file focused, click on this small button near the upper right
            \bigbreak \noindent 
            \fig{1}{./figures/im2.png}
            \bigbreak \noindent 
            Note that this opens the Design editor in which we can drag and drop widgets into our app. More on this to come!
        \item \textbf{Intro to XML syntax}:
            In XML, an non-empty element uses the general syntax shown here
            \bigbreak \noindent 
            \begin{xmlcode}
            <tagName attribute1="value1">Element Content</tagName> 
            \end{xmlcode}
            \bigbreak \noindent 
            For example:
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name="red">#FFFF0000</color>
            \end{xmlcode}
            which can be interpreted as there is an element color that has the name red and corresponds to the RGB value \#FFFF0000.
            \bigbreak \noindent 
            If an element has no content yet or will never have any content, we can use this syntax
            \bigbreak \noindent 
            \begin{xmlcode}
            <tagName attribute1="value1" attribute2="value2".../>
            \end{xmlcode}
        \item \textbf{XML Naming Rules}: XML elements must follow these naming rules:
            \begin{enumerate}
                \item Names can contain letters, numbers, and other characters.
                \item Names cannot start with a number or punctuation character.
                \item Names cannot start with the letters xml (or XML, or Xml, etc).
                \item Names cannot contain spaces.
            \end{enumerate}
        \item \textbf{XML Comments}: Documentation in XML is done with
            \bigbreak \noindent 
            \begin{xmlcode}
            <!-- comment text -->
            \end{xmlcode}
        \item \textbf{Simple activity\_main.xml Example, TextView and ConstraintLayout}: Let's consider a simple XML example
            \bigbreak \noindent 
            \begin{xmlcode}
                <?xml version="1.0" encoding="utf-8"?>
                <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    xmlns:app="http://schemas.android.com/apk/res-auto"
                    xmlns:tools="http://schemas.android.com/tools"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    tools:context=".MainActivity">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/app_name"
                        app:layout_constraintBottom_toBottomOf="parent"
                        app:layout_constraintEnd_toEndOf="parent"
                        app:layout_constraintStart_toStartOf="parent"
                        app:layout_constraintTop_toTopOf="parent" />

                </androidx.constraintlayout.widget.ConstraintLayout>
            \end{xmlcode}
            \bigbreak \noindent 
            There are two elements in our current activity\_main.xml:
            \begin{enumerate}
                \item ConstraintLayout
                \item TextView
            \end{enumerate}
            \bigbreak \noindent 
            The TextView element is nested inside the ConstraintLayout element
            \bigbreak \noindent 
            A ConstraintLayout allows us to position and size elements in a flexible way.
            \bigbreak \noindent 
            One way is relative positioning, or where an element is placed on the screen, or view, relative to another. 
            \bigbreak \noindent 
            The ConstraintLayout element has several attributes.
            \bigbreak \noindent 
            The android:layout\_width and android:layout\_height attributes define the size of the ConstraintLayout.
            \bigbreak \noindent 
            Their value match\_parent means that it will be as big as its parent element, which is the screen of the Android device in this case.
            \bigbreak \noindent 
            The TextView element is empty, or, in other words, has no content, and has, by default, seven attributes.
            \bigbreak \noindent 
            The first three are layout\_width, layout\_height and text.
            \bigbreak \noindent 
            The android:text attribute specifies the content, or the words, of the TextView to be shown on the screen of the Android device.
            \bigbreak \noindent 
            By default, the four attributes that follow layout\_width, layout\_height and text are for positioning of the TextView within the ConstraintLayout that will be discussed later
            \bigbreak \noindent 
            A TextView element is an instance of the TextView class, which puts a label on the screen.
            \bigbreak \noindent 
            The android:layout\_width and android:layout\_height attributes define the size of the TextView.
            \bigbreak \noindent 
            The value wrap\_content means that it will be as small as possible so that their contents (the text or words) fit inside it.
            \bigbreak \noindent 
            In other words, the element "wraps" around its content.
            \bigbreak \noindent 
            By default, the TextView appears in the middle of the screen
            \bigbreak \noindent 
            The four app:layout attributes specify the relative position of the TextView element's four sides
            \bigbreak \noindent 
            In this example, they are relative to the "parent", or the ConstraintLayout in which the Textview is nested
        \item \textbf{strings.xml}: is the resource file for text values in your app. Stores text like titles, labels, button names, or messages as key–value pairs.
            keep all text centralized for easy updates, consistency, and support for localization
            \bigbreak \noindent 
            You reference them in code (getString(R.string.welcome\_message)) or XML (@string/welcome\_message).
            \bigbreak \noindent 
            One string is defined in the strings.xml file by default
            \bigbreak \noindent 
            \begin{xmlcode}
                <resources>
                    <string name="app_name">Hello, Android!</string>
                <resources>
            \end{xmlcode}
            \bigbreak \noindent 
            The syntax for defining a string is
            \bigbreak \noindent 
            \begin{xmlcode}
                <string name="stringName">valueOfString</string>
            \end{xmlcode}
        \item \textbf{themes.xml}: defines the overall visual style of your Android app.
            \bigbreak \noindent 
            Central place to configure app-wide appearance, like colors, fonts, backgrounds, status bar style, and widget looks.
            \bigbreak \noindent 
            A theme is a collection of style attributes applied globally.
        \item \textbf{themes.xml example}:
            \bigbreak \noindent 
            \begin{xmlcode}
             <resources xmlns:tools="http://schemas.android.com/tools">
                 <!-- Base application theme. -->

                 <style name="Base.Theme.MyApplication" parent="Theme.Material3.DayNight.NoActionBar">
                     <!-- Customize your light theme here. -->
                     <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
                 </style>

                 <style name="Theme.MyApplication" parent="Base.Theme.MyApplication" />
            </resources>
            \end{xmlcode}
            \bigbreak \noindent 
            It is used to define styles that the app uses.
            \bigbreak \noindent 
            We can modify a theme by adding an item element using this syntax
            \bigbreak \noindent 
            \begin{xmlcode}
            <item name="styleAttribute">valueOfItem</item>
            \end{xmlcode}
            \bigbreak \noindent 
            The name of the theme attribute that specifies the text size inside a TextView is android:textSize.
            \bigbreak \noindent 
            Let us change the default text size to 40 by adding the following code to the themes.xml file just above the line </style>
            \bigbreak \noindent 
            \begin{xmlcode}
            <item name="android:textSize">40sp</item>
            \end{xmlcode}
        \item \textbf{Removing and adding action bar (themes.xml)}: Also, this line removes the commonly shown Action Bar:
            \bigbreak \noindent 
            \begin{xmlcode}
            <style name="Base.Theme.HelloAndroid" parent="Theme.Material3.DayNight.NoActionBar">
            \end{xmlcode}
            \bigbreak \noindent 
            \textbf{Note:} The Empty Views Activity template does not provide a default Action Bar
            \bigbreak \noindent 
            If we change the line to
            \bigbreak \noindent 
            \begin{xmlcode}
            <style name="Base.Theme.HelloAndroid" parent="Theme.AppCompat.Light.DarkActionBar">
            \end{xmlcode}
            \bigbreak \noindent 
            And make two other changes, we will see the Action Bar with the name of our app displayed
        \item \textbf{colors.xml}: The colors.xml file in the res > values directory is another automatically generated XML file.
            \bigbreak \noindent 
            It is used to define colors we want to use in our apps
            \bigbreak \noindent 
            The syntax for defining a color is
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name="colorName">valueOfColor</color>
            \end{xmlcode}
            \bigbreak \noindent 
            The color value is defined using hexadecimal, or base 16, notation
            \bigbreak \noindent 
            \#FFrrggbb (uses RGB color system) where:
            \begin{itemize}
                \item rr = amount of red in color
                \item gg = amount of green in color
                \item bb = amount of blue in color
            \end{itemize}
        \item \textbf{colors.xml example}: If we create the color in colors.xml
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name="colorPrimary"> #FF3F51B5 </color>
            \end{xmlcode}
            \bigbreak \noindent 
            Then, in themes.xml, we can add or uncomment the line
            \bigbreak \noindent 
            \begin{xmlcode}
            <item name="colorPrimary">@color/colorPrimary</item>
            \end{xmlcode}
            \bigbreak \noindent 
            inside of the action bar tag
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="Base.Theme.Test3" parent="Theme.AppCompat.Light.DarkActionBar">
                    <item name="colorPrimary">@color/colorPrimary</item>
                </style> 
            \end{xmlcode}
            \bigbreak \noindent 
            Now we have a blue action bar.
        \item \textbf{AndroidManifest.xml}: The AndroidManifest.xml file is located in the manifests directory.
            \bigbreak \noindent 
            It specifies the resources that the app uses, such as activities, the file system, the Internet, and hardware resources.
            \bigbreak \noindent 
            Before a user downloads an app on Google Play, the user is notified about these details
        \item \textbf{Changing the launcher icon}: When your app is installed on a device, its icon and name appear with all other installed apps in the launcher
            \bigbreak \noindent 
            Users can use the icon to launch our app on their device.
            \bigbreak \noindent 
            We should always supply a launcher icon for our app
            \bigbreak \noindent 
            A launcher icon for a mobile device should be 48 x 48 dp.
            \bigbreak \noindent 
            Because various devices can have different screen densities, we can supply several launcher icons, one for each density
            \bigbreak \noindent 
            If we provide these different versions of our icon, we need to follow the 2/3/4/6/8 scaling ratios between the various densities from medium (2) to xxx-high (8)
            \bigbreak \noindent 
            If we supply only one icon - as we will do here - Android Studio will use that icon and expand its density as necessary.
            \bigbreak \noindent 
            If we plan to publish our app, we should provide a 512 x 512 launcher icon for display in Google's app store.
            \bigbreak \noindent 
            Right mouse click on mipmap in the project structure along the right side and choose New and then Image Asset.
            \bigbreak \noindent 
            To set the launch icon for the app to hi.png, we assign the
            String @mipmap/hi to the android:icon attribute and the
            String @mipmap/hi\_round to the android:roundIcon
            attribute of the application element in the
            AndroidManifest.xml file.
            \bigbreak \noindent 
            The @mipmap/hi expression defines the resource in the mipmap
            directory (of the res directory) whose name is hi (note that we do
            not include the extension) and the same for hi\_round
            \bigbreak \noindent 
            \begin{xmlcode}
            android:icon="@mipmap/hi" android:roundIcon="@mipmap/hi_round"
            \end{xmlcode}
        \item \textbf{Orientation}: Sometimes, we want the app to run in only one orientation
            \bigbreak \noindent 
            In other words, we do not want the app to rotate when the user rotates his or her device.
            \bigbreak \noindent 
            Inside the activity element (in the manifest), we can add the
            android:screenOrientation attribute and specify either
            portrait or landscape as its value
            \bigbreak \noindent 
            For example, if we want our app to run in vertical orientation only, we add
            \bigbreak \noindent 
            \begin{xmlcode}
            android:screenOrientation="portrait"
            \end{xmlcode}
            \bigbreak \noindent 
            Note that we can control the behavior of the app on a per activity basis
        \item \textbf{Gradle build system}: Android Application Package, or APK, is the file format for distributing applications that run on the Android operating system. 
            \bigbreak \noindent 
            The file extension is .apk
            \bigbreak \noindent 
            To create an apk file, the project is compiled and its various parts are packaged into the apk file.
            \bigbreak \noindent 
            The apk file can be found in the project directory:
            \begin{center}
                \textit{projectName/app/build/outputs/apk}
            \end{center}
            \bigbreak \noindent 
            These .apk files are built using the gradle build system, which is integrated in the Android Studio environment.
            \bigbreak \noindent 
            When we start creating an app, the gradle build scripts are automatically created
            \bigbreak \noindent 
            They can be modified to build apps that require custom building
        \item \textbf{Debugging}: Just like in a regular Java program, we can send output to the console in addition to displaying data on the screen.
            \bigbreak \noindent 
             For this, we can use one of the static methods of the Log class.
             \bigbreak \noindent 
             The Log class is part of the android.util package
             \bigbreak \noindent 
             Selected methods of the Log class include d, e, i, v, w.
             \bigbreak \noindent 
             They all have the same parameter list and return type; for example, the API of d is
             \bigbreak \noindent 
             \begin{javacode}
             public static void d(String tag, String message)
             \end{javacode}
             \begin{itemize}
                 \item \textbf{Log.d(String tag, String msg):} Debug: Used for debugging messages. These are usually filtered out in release builds.
                 \item \textbf{Log.e(String tag, String msg):} Error: Used to report error conditions. This is the highest-severity logging method.
                 \item \textbf{Log.i(String tag, String msg):} Info: Used for general information messages that highlight the progress of the application.
                 \item \textbf{Log.v(String tag, String msg):} Verbose: Used for the most detailed log messages, often too much for normal use, but helpful during deep debugging.
                 \item \textbf{Log.w(String tag, String msg):} Warning: Used to report potential issues or unexpected states that aren't necessarily errors.
             \end{itemize}
             \bigbreak \noindent 
             \textit{tag} identifies the source of the message and can be associated with a "filter" (described in a few slides).
             \bigbreak \noindent 
             \textit{message} is the String to be output.
             \bigbreak \noindent 
             To run the app in debug mode, we click on the debug icon on the toolbar.
             \bigbreak \noindent 
             The app runs and stops at the first breakpoint.
             \bigbreak \noindent 
             The Debug tab will open in the panel at the bottom of the screen.
             \bigbreak \noindent 
             Here we will see some debugging information and tools.
             \bigbreak \noindent 
             Under Frames, we can see where in the code we are currently executing.
             \bigbreak \noindent 
             To resume the app, we click on the green Resume icon at the top left of the panel.
             \bigbreak \noindent 
             As we resume, stop at breakpoints, and resume the app a few times, the values of the various variables in our app are displayed under Variables.
             \bigbreak \noindent 
             Under Variables, we can check the values of the various variables
             \bigbreak \noindent 
             If the app is running on a device, we can still log output statements in Logcat
             \bigbreak \noindent 
             This is much faster than starting the emulator.
         \item \textbf{Logcat}: Output from logging statements show up in the Logcat
             \bigbreak \noindent 
             To open the Logcat, click on the Logcat tab at the bottom of the IDE.
             \bigbreak \noindent 
             We can filter the output listed in the Logcat by clicking in the dropdown in the upper right of the Logcat
             \bigbreak \noindent 
             Suppose we create a new filter named \textit{f\_mainactivity}, with a tag MainActivity.
             \bigbreak \noindent 
             Now that a filter has been created along with its tag, we can output messages to Logcat.
             \bigbreak \noindent 
             Add the following line to the onCreate method of MainActivity.java but after the call to super.onCreate
             \bigbreak \noindent 
             \begin{javacode}
                 Log.w("MainActivity", "Inside onCreate!");
             \end{javacode}
             \bigbreak \noindent 
             The output we will see in Logcat is: Inside onCreate!
             \bigbreak \noindent 
             Or another way to do it
             \bigbreak \noindent 
             \begin{javacode}
                 ...
                 public static String MA = "MainActivity";
                 ...
                 setContentView(R.layout.activity_main);
                 Log.w(MA, "View resource: " +
                 R.layout.activity_main);
                 ... 
             \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsection{Reference}
    \bigbreak \noindent 
    \subsubsection{Includes}
    \begin{itemize}
        \item androidx.appcompat.app.AppCompatActivity;
        \item android.os.Bundle;
        \item android.util.Log;
        \item android.view.View;
        \item android.view.Gravity;
        \item android.graphics.Color;
        \item android.widget.EditText;
        \item android.widget.TextView;
        \item java.text.NumberFormat;
        \item android.text.TextWatcher: 
        \item android.text.Editable
        \item java.lang.CharSequence
        \item android.graphics.Point;
        \item android.widget.Button;
        \item android.widget.GridLayout;
        \item androidx.constraintlayout.widget.ConstraintLayout;
        \item androidx.constraintlayout.widget.ConstraintSet;
        \item androidx.constraintlayout.widget.Guideline
        \item import androidx.constraintlayout.widget.Barrier;
        \item android.view.ViewGroup;
        \item android.content.Context;
        \item android.content.DialogInterface;
        \item androidx.appcompat.app.AlertDialog;
        \item android.graphics.Typeface;
        \item android.view.Display;
        \item android.widget.RelativeLayout
    \end{itemize}

    \pagebreak 
    \subsubsection{Important information}
    \begin{itemize}
        \item \textbf{AVD (Android virtual device)}: It's basically an emulated device configuration that runs inside the Android Emulator. An AVD defines things like:
            \begin{itemize}
                \item \textbf{Device model}: (screen size, resolution, density, RAM, etc.)
                \item \textbf{System image}: (Android version, API level, Google Play support, etc.)
                \item \textbf{Hardware features}: (camera, GPS, sensors, etc.)
            \end{itemize}
            So when you launch an emulator in Android Studio, you're really starting up an AVD that behaves like a specific Android phone or tablet.
        \item \textbf{Screen Density}: screen density means how many pixels are packed into a physical area of the screen, usually measured as dots per inch (dpi).
            \bigbreak \noindent 
            A screen with high density has many pixels in a small space, making things look sharper but also smaller if not scaled.
            \bigbreak \noindent 
            A screen with low density has fewer pixels in the same area, so things look larger but less sharp.
            \bigbreak \noindent 
            Android groups devices into "density buckets" so developers don't have to manually calculate for every possible screen:
            \bigbreak \noindent 
            \begin{itemize}
                \item \textbf{ldpi (low)}: $\sim$120 dpi
                \item \textbf{mdpi (medium)}: $\sim$160 dpi (baseline)
                \item \textbf{hdpi (high)}: $\sim$240 dpi
                \item \textbf{xhdpi (extra-high)}: $\sim$320 dpi
                \item \textbf{xxhdpi (extra extra high)}: $\sim$480 dpi
                \item \textbf{xxxhdpi (extra extra extra high)}: $\sim$640 dpi
            \end{itemize}
            \bigbreak \noindent 
            Android uses this formula under the hood:
            \begin{align*}
                px = \; dp \times \frac{dpi}{160}
            \end{align*}
            Where
            \begin{itemize}
                \item dp = your value in density-independent pixels (e.g., 20)
                \item dpi = the device's actual screen density in dots-per-inch
                \item 160 = the baseline density (mdpi)
            \end{itemize}
            \bigbreak \noindent 
            Even though the number of pixels changes, the physical size (in inches or mm) stays about the same. That's because on a denser screen, pixels are smaller, so Android uses more of them to maintain the same real-world size.
            \bigbreak \noindent 
            So your 20dp button will look like the same size button whether it's on a cheap low-res phone or a modern super high-res one.
        \item \textbf{Layout Params}: Generally, a layout class like ConstraintLayout or RelativeLayout contains a static inner class that contains XML attributes that allow us to arrange the components within the layout. This static inner class is often named \textbf{LayoutParams}
            \bigbreak \noindent 
            Every child view inside a ViewGroup needs layout parameters (LayoutParams).
            \bigbreak \noindent 
            These tell the parent how big the child should be and how it should be positioned.
            \bigbreak \noindent 
            Different ViewGroups define their own rules:
            \begin{itemize}
                
                \item \textbf{LinearLayout.LayoutParams}: weight, gravity
                \item \textbf{FrameLayout.LayoutParams}: gravity
                \item \textbf{ConstraintLayout.LayoutParams}: constraints like topToBottom, leftToLeft, etc.
            \end{itemize}
        \item \textbf{Positioning components inside ConstraintLayout}: We will use the attributes of ConstraintLayout.LayoutParams to position the XML elements on the screen
        \item \textbf{Ids}: The android:id attribute allows us to give an id to an XML element
            \bigbreak \noindent 
            The syntax for assigning an id to an XML element is
            \bigbreak \noindent 
            \begin{xmlcode}
            android:id = "@+id/idValue"
            \end{xmlcode}
        \item \textbf{Default colors (defined in @android:color)}:
            \begin{itemize}
                \item \textbf{@android:color/black}: \#FF000000
                \item \textbf{@android:color/darker\_gray}: \#FF444444
                \item \textbf{@android:color/dim\_gray}: \#FF696969
                \item \textbf{@android:color/gray}: \#FF888888
                \item \textbf{@android:color/light\_gray}: \#FFCCCCCC
                \item \textbf{@android:color/white}: \#FFFFFFFF
                \item \textbf{@android:color/red}: \#FFFF0000
                \item \textbf{@android:color/green}: \#FF00FF00
                \item \textbf{@android:color/blue}: \#FF0000FF
                \item \textbf{@android:color/yellow}: \#FFFFFF00
                \item \textbf{@android:color/cyan}: \#FF00FFFF
                \item \textbf{@android:color/magenta}: \#FFFF00FF
                \item \textbf{@android:color/transparent}: \#00000000 (fully transparent)
            \end{itemize}
            \bigbreak \noindent 
            We can get access to these default colors in java using
            \bigbreak \noindent 
            \begin{javacode}
                int color = context.getResources().getColor(android.R.color.colorname)
            \end{javacode}
        \item \textbf{ConstraintLayout Enable Autoconnection to Parent}: When you enable it, every new view you drag into the ConstraintLayout will automatically get constraints to its closest edges of the parent (top, bottom, start, end).
        \item \textbf{Styles vs Themes}: A style relates to a UI component or a View. A theme relates to an activity; it can even relate to the whole app.
            \bigbreak \noindent 
            We can also "theme" an app with a style by editing the AndroidManifest.xml file, changing the android:theme attribute of its application element using this syntax:
            \bigbreak \noindent 
            \begin{xmlcode}
                android:theme="@style/nameOfStyle"
            \end{xmlcode}
        \item \textbf{findViewById}: findViewById is a fundamental method in Android development used to obtain a reference to a View object defined in your XML layout files. This method allows you to interact with UI elements programmatically, such as setting text, handling clicks, or changing visibility.
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent
            \begin{javacode}
            EditText billEditText = (EditText)findViewById(R.id.amount_bill);
            \end{javacode}
            \bigbreak \noindent 
            findViewById returns the View that is part of the layout xml file that was inflated in method onCreate() of the Activity class.
            \bigbreak \noindent 
            If we expect to retrieve a TextView and we want to assign the View retrieved to a TextView, we need to cast the View returned by method findViewById() to a TextView:
        \item \textbf{View Event handling with XML (only onClick)}: To set up a click event on a View, we use the android:onClick attribute of the View and assign to it a method using the form:
            \bigbreak \noindent 
            \begin{xmlcode}
            android:onClick="methodName"
            \end{xmlcode}
            \bigbreak \noindent 
            The event will be handled inside that method, which must have the following API
            \bigbreak \noindent 
            \begin{javacode}
            public void methodName(View v) 
            \end{javacode}
            \bigbreak \noindent 
            $v$ is the View where the event happened.
            \bigbreak \noindent 
            When the user clicks on the button, we execute inside calculate, and its View parameter is the Button; if we have the following statement inside calculate
            \bigbreak \noindent 
            \begin{javacode}
            Log.w("MainActivity", "v = " + v);
            \end{javacode}
            \bigbreak \noindent 
            Inside LogCat, we have something like:
            \bigbreak \noindent 
            \begin{javacode}
            v=android.widget.Button@425a2e60
            \end{javacode}
            \bigbreak \noindent 
            The value above identifies the Button
        \item \textbf{IME}: It’s the software keyboard or other input system (like voice typing, handwriting, predictive text) that allows users to enter text into your app.
            \bigbreak \noindent 
            Every EditText communicates with the IME through the Input Method Framework (IMF) in Android.
            \bigbreak \noindent 
            When you tap into an EditText, the IME pops up (usually the on-screen keyboard).
        \item \textbf{Get size of screen}: 
            \bigbreak \noindent 
            \begin{javacode}
                import android.graphics.Point;

                Point size = new Point();
                getWindowManager().getDefaultDisplay().getSize(size);
            \end{javacode}
        \item \textbf{Create grid layout in java (controller)}:
            \bigbreak \noindent 
            \begin{javacode}
                GridLayout gridLayout = new GridLayout(this);
                gridLayout.setRowCount(int m);
                gridLayout.setColumnCount(int n);
            \end{javacode}
        \item \textbf{Adding views to GridLayout}:
            \bigbreak \noindent 
            \begin{javacode}
                gridLayout.addView(view, w, h);

            \end{javacode}
        \item \textbf{setContentView}: the method setContentView(...) is used inside an Activity to specify which layout file (XML) should be used as the UI for that screen.
            \bigbreak \noindent 
            Calling \texttt{setContentView(R.layout.some\_layout)} tells the activity:
            \begin{center}
                "Use the layout resource some\_layout.xml from the \textit{res/layout} folder as the UI for this screen."
            \end{center}
            \bigbreak \noindent 
            If you’re using programmatic UI (creating Views in Java instead of XML), you can pass a View object directly,
        \item \textbf{ViewGroup}:
            In Android, everything you see on screen is either a View or a ViewGroup.
            \bigbreak \noindent 
            A View is a basic UI element — e.g. Button, TextView, EditText, ImageView.
            \bigbreak \noindent 
            A ViewGroup is a container that holds other Views (and even other ViewGroups). 
            \bigbreak \noindent 
            So, a ViewGroup is essentially a layout manager. It defines how child views are positioned, sized, and arranged inside it.
            \begin{itemize}
                \item \textbf{LinearLayout}: places children in a row or column.
                \item \textbf{RelativeLayout (older, mostly replaced by ConstraintLayout)}: places children relative to each other.
                \item \textbf{ConstraintLayout}: a flexible, modern layout system.
                \item \textbf{FrameLayout}: stacks children on top of each other.
                \item \textbf{RecyclerView}: a powerful scrolling container for lists/grids.
            \end{itemize}
            \textbf{Note:} A ViewGroup is a subclass of View.
        \item \textbf{Giving id to view in java}: We can use
            \bigbreak \noindent 
            \begin{javacode}
            View.generateViewId()
            \end{javacode}
            as an argument to \texttt{view.setId()}. The method \texttt{generateViewId()} is a static method in the View class. It creates a unique integer ID at runtime that’s guaranteed not to collide with other view IDs.
        \item \textbf{The finish() method}: finish() is a method of the Activity class. It tells Android:
            \begin{quote}
             "I’m done with this Activity, please close it and remove it from the back stack."
            \end{quote}
            So if you call finish() inside an Activity, that activity will end and control will go back to the previous one (or exit the app if it was the only activity).
        \item \textbf{Converting px to dp in java}: In Android, px (pixels) and dp (density-independent pixels) are not the same thing. You almost always want to work in dp because it scales properly across different screen densities.
            \bigbreak \noindent 
            \begin{javacode}
                float dp = px / context.getResources().getDisplayMetrics().density; // px to dp

                float px = dp * context.getResources().getDisplayMetrics().density; // dp to px
            \end{javacode}
            \bigbreak \noindent 
            when a Java function in Android Studio takes an int representing a dimension (like width, height, margin, radius, stroke width, etc.), it is almost always in raw pixels (px) — not dp.
        \item \textbf{xmlns:android="http://schemas.android.com/apk/res/android"}: One of the most important pieces of XML in Android layouts.
            \bigbreak \noindent 
            It tells the XML parser: "Whenever you see an attribute that starts with android:, it belongs to the Android system’s XML namespace, located at this URI."
            \bigbreak \noindent 
            You must include this in:
            \begin{itemize}
                \item Any layout XML (e.g. activity\_main.xml)
                \item Any drawable XML, menu XML, or style XML that uses android: attributes
            \end{itemize}
            Basically, any file where you use attributes like android:layout\_width, android:padding, android:text, etc.
            \bigbreak \noindent 
            you only need to declare that line once, and it always goes on the root element of your XML layout (like <ConstraintLayout>, <RelativeLayout>, <LinearLayout>, etc.).
        \item \textbf{The dp() function (java)}: In Android, UI dimensions shouldn’t be defined in plain pixels because screens have different pixel densities (dpi). Instead, we must use dp (density-independent pixels), which scale consistently on all screens.
            \bigbreak \noindent 
            XML converts dp to px for us, but in java we must do it ourselves. So, we write the following function
            \bigbreak \noindent 
            \begin{javacode}
                private int dp(int value) {
                    float density = getResources().getDisplayMetrics().density;
                    return (int) (value * density);
                } 
            \end{javacode}
            \bigbreak \noindent 
            We pass in a \textbf{dp} values, and it gets converted to px.
        \item \textbf{Animation directory}: In order to create and use animations in our apps, we need to create a \textbf{Android Resource Directory} in the \textbf{res} directory with resource type \textbf{anim}. Then, we can define animations in XML (one animation per XML file).
        \item \textbf{Action bar}
            \bigbreak \noindent 
            \begin{javacode}
                <resources>
                  <!-- Base application theme. -->
                  <style name="Theme.MusicStore" parent="Theme.AppCompat.Light.DarkActionBar">
                    <!-- Customize your theme here. -->
                    <item name="android:textSize">15sp</item>
                    <item name="colorPrimary">@color/colorPrimary</item>
                  </style>
                  
                </resources> 
            \end{javacode}
        \item \textbf{No action bar}
            \bigbreak \noindent 
            \begin{javacode}
                <resources xmlns:tools="http://schemas.android.com/tools">
                    <!-- Base application theme. -->
                    <style name="Base.Theme.MusicStore" parent="Theme.Material3.DayNight.NoActionBar">
                        <!-- Customize your light theme here. -->
                        <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
                    </style>

                    <style name="Theme.MusicStore" parent="Base.Theme.MusicStore" />
                </resources>
            \end{javacode}
        \item \textbf{Menus}: Menus in Android Studio (and Android apps generally) are UI components that let users interact with common actions — similar to menus in desktop apps, but adapted for mobile.
            \bigbreak \noindent 
            A menu is a set of action items your app displays in:
            \begin{itemize}
                \item The top App Bar (toolbar)
                \item A vertical overflow menu (three-dot icon)
                \item A contextual action bar
                \item Popup menus inside a view
            \end{itemize}
            Menus are defined in \texttt{res/menu}
        \item \textbf{Builtin icons}: These are the most frequently used system drawables (they all live under android.R.drawable):
            \begin{itemize}
                \item \textbf{@android:drawable/ic\_menu\_preferences}:	Settings or preferences 
                \item \textbf{@android:drawable/ic\_menu\_edit}:	Edit / modify item 
                \item \textbf{@android:drawable/ic\_menu\_attach}:	Attach file 
                \item \textbf{@android:drawable/ic\_menu\_send}:	Send / share 
                \item \textbf{@android:drawable/ic\_menu\_delete}:	Delete item 
                \item \textbf{@android:drawable/ic\_menu\_add}:	    Add item 
                \item \textbf{@android:drawable/ic\_menu\_edit}:	Edit item 
                \item \textbf{@android:drawable/ic\_input\_add}:	Add new item 
                \item \textbf{@android:drawable/ic\_delete}:	Remove / clear 
                \item \textbf{@android:drawable/ic\_menu\_search}:	Search action 
                \item \textbf{@android:drawable/ic\_menu\_save}:	Save action 
                \item \textbf{@android:drawable/ic\_menu\_agenda}:	Calendar / agenda 
                \item \textbf{@android:drawable/ic\_menu\_compass}:	Navigation / location 
                \item \textbf{@android:drawable/ic\_menu\_share}:	Share data 
                \item \textbf{@android:drawable/ic\_menu\_info\_details}:	Info dialog 
                \item \textbf{@android:drawable/ic\_menu\_close\_clear\_cancel}:	Cancel / close 
                \item \textbf{@android:drawable/ic\_menu\_myplaces}:	Home / location 
                \item \textbf{@android:drawable/ic\_menu\_camera}:	Camera 
                \item \textbf{@android:drawable/ic\_menu\_gallery}:	Gallery or media 
                \item \textbf{@android:drawable/ic\_menu\_call}:	Call / contact 
                \item \textbf{@android:drawable/ic\_menu\_manage}:	Manage list 
                \item \textbf{@android:drawable/ic\_dialog\_alert}:	Alert or warning dialog 
                \item \textbf{@android:drawable/ic\_dialog\_info}:	Info dialog icon
            \end{itemize}
        \item \textbf{Get height of the action bar}
            \bigbreak \noindent 
            \begin{javacode}
                import android.util.TypedValue;
                ...

                TypedValue typedValue = new TypedValue();
                if (getTheme().resolveAttribute(android.R.attr.actionBarSize, typedValue, true)) {
                    int actionBarHeight = TypedValue.complexToDimensionPixelSize(
                    typedValue.data, getResources().getDisplayMetrics());
                }
            \end{javacode}
        \item \textbf{Move root layout under the actionbar}: For example, if a GridLayout is the root layout
            \bigbreak \noindent 
            \begin{javacode}
            ViewGroup.MarginLayoutParams mlp = new ViewGroup.MarginLayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            );
            mlp.setMargins(0,actionBarHeight*2,0,0);
            \end{javacode}
        \item \textbf{Dynamic resource names}: If your drawable image files are named like:
            \bigbreak \noindent 
            \begin{bashcode}
                res/drawable/u1.png  
                res/drawable/u2.png  
                res/drawable/u3.png  
                ...
                res/drawable/u9.png
            \end{bashcode}
            \bigbreak \noindent 
            Then you can load them like this:
            \bigbreak \noindent 
            \begin{javacode}
                String imageName = "u" + i; // creates u1, u2, ..., u9
                int resID = getResources().getIdentifier(imageName, "drawable", getPackageName());
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsubsection{Units}
    \begin{itemize}
        \item \textbf{dp}: stands for density-independent pixels, or "dips" for short.
            \bigbreak \noindent 
            The most common unit for layout dimensions (width, height, margins, padding). Scales with screen density so UI looks consistent across devices.
        \item \textbf{sp}: stands for scalable pixels. Maybe we can call them "sips"?
            \bigbreak \noindent 
            Primarily for text size. Like dp, but also respects the user's font size settings (accessibility).
        \item \textbf{px (pixels)}: Actual screen pixels. Avoid using directly because it doesn't scale across different densities.
        \item \textbf{pt (points):} 1/72 of an inch. Rarely used, but supported.
        \item \textbf{in (inches)}: Physical size in inches (based on the screen's dpi).
        \item \textbf{mm (millimeter)}: Physical size in millimeters.
    \end{itemize}

    \pagebreak 
    \subsubsection{Files}
    \begin{itemize}
        \item \textbf{AndroidManifest.xml}: The app's blueprint. Declares package name, permissions, minimum SDK, app components (activities, services, etc.), and the launcher activity.
        \item \textbf{MainActivity.java}: The main Java class that runs when the app starts. Controls app logic and connects the UI (XML layouts) with backend code.
        \item \textbf{activity\_main.xml}: The layout file for MainActivity. Defines the UI elements (buttons, text, etc.) using XML.
        \item \textbf{colors.xml}: Central place for defining reusable color values. Used for themes, buttons, backgrounds, etc
        \item \textbf{strings.xml}: Stores all text strings (app name, labels, messages). Helps with reusability and localization (multi-language support).
        \item \textbf{dimens.xml}:  Defines dimensions like margins, padding, font sizes (e.g., 16dp). Ensures consistent spacing and scaling.
        \item \textbf{themes.xml}: Holds styles and themes (colors, fonts, appearances) applied app-wide or to individual components.
    \end{itemize}

    \pagebreak 
    \subsubsection{XML tags}
    \begin{itemize}
        \item \textbf{XML Declaration}: Android's resource compiler can usually parse XML without it. But it is strongly recommended to include it for consistency and to avoid encoding issues 
            \bigbreak \noindent 
            \begin{xmlcode}
                <?xml version="1.0" encoding="utf-8"?>
            \end{xmlcode}
        \item \textbf{Resources}: The root element of an XML resource file in the res/values/ directory (like strings.xml, colors.xml, styles.xml, etc.).
            \bigbreak \noindent 
            \begin{xmlcode}
            <resources>
                ...
            </resources>
            \end{xmlcode}
        \item \textbf{String}: 
            \bigbreak \noindent 
            \begin{xmlcode}
            <string name=""> ... </string>
            \end{xmlcode}
        \item \textbf{Color}:
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name=""> hex </color>
            \end{xmlcode}
        \item \textbf{Dimen}:
            \bigbreak \noindent 
            \begin{xmlcode}
            <dimen name=""> ... </dimen>
            \end{xmlcode}
        \item \textbf{Manifest}
            \bigbreak \noindent 
            \begin{xmlcode}
            <manifest>
                ...
            </manifest>
            \end{xmlcode}
        \item \textbf{Style}: used to define styles and themes for your Android app
            \bigbreak \noindent 
            \begin{xmlcode}
            <style name="" parent="">
                <item name=""> ... </item>
            </style>
            \end{xmlcode}
    \end{itemize}

    \pagebreak 
    \subsubsection{Components}
    \begin{itemize}
        \item \textbf{ConstraintLayout}: In Android Studio, ConstraintLayout is a powerful and flexible layout manager used to design UIs. It's often the default choice in modern Android projects. 
            \bigbreak \noindent 
            It is a \textbf{ViewGroup} (container) that positions and sizes its child views based on constraints you define.
            \begin{itemize}
                \item \textbf{Constraints:} Each view needs at least one horizontal and one vertical constraint (e.g., align left to parent, center in parent, align top to another view).
                \item \textbf{No deep nesting:} Unlike LinearLayout or RelativeLayout, you can achieve complex designs without nesting multiple layouts, which improves performance.
                \item \textbf{Flexible positioning:} You can center, chain, bias (percent-based positioning), or even set aspect ratios.
            \end{itemize}
            \bigbreak \noindent 
            \begin{xmlcode}
            <androidx.constraintlayout.widget.ConstraintLayout 
            xmlns:android="http://schemas.android.com/apk/res/android" 
            xmlns:app="http://schemas.android.com/apk/res-auto"
            xmlns:tools="http://schemas.android.com/tools"
            ...
            tools:context=".MainActivity">
                ...
            </androidx.constraintlayout.widget.ConstraintLayout>
            \end{xmlcode}
            \bigbreak \noindent 
            \textbf{Note:} xmlns stands for \textbf{XML Namespace}. 
            \bigbreak \noindent 
            \texttt{tools:context=".MainActivity"} tells the Layout Editor which Activity will load this layout. It's a design-time hint for Android Studio (not used at runtime).
        \item \textbf{TextView}: is a basic Android UI widget used to display text to the user. It's read-only by default (unlike EditText, which allows input). It can show plain text, styled text, or even links.
            \bigbreak \noindent 
            \begin{xmlcode}
                <TextView ...>
                    ...
                </TextView
            \end{xmlcode}
        \item \textbf{EditText}: Subclass of TextView that allows the user to enter and edit text. It's the standard widget for text input in Android (like forms, search boxes, chat inputs)
            \bigbreak \noindent 
            \begin{xmlcode}
                <EditText ...>
                    ...
                </EditText>
            \end{xmlcode}

    \end{itemize}

    \pagebreak 
    \subsubsection{Attributes}
    \begin{itemize}
        \item \textbf{ConstraintLayout}:
            \begin{itemize}
                \item \textbf{android:layout\_width}: Defines the width of the view inside its parent.
                \item \textbf{android:layout\_height}: Same as above, but for height.
                    \begin{itemize}
                        \item \textbf{wrap\_content}: Size just big enough for its content.
                        \item \textbf{match\_parent}: Fill the entire parent width.
                        \item \textbf{Specific size}: Like 20dp
                    \end{itemize}
                \item \textbf{android:paddingBottom}: space inside the view, between its boundary and its content (like text or an image).
                \item \textbf{android:paddingLeft}: space inside the view, between its boundary and its content (like text or an image).
                \item \textbf{android:paddingRight}: space inside the view, between its boundary and its content (like text or an image).
                \item \textbf{android:paddingTop}: space inside the view, between its boundary and its content (like text or an image).
            \end{itemize}
            The following layout params are placed as attributes in the components nested inside ConstraintLayouts
            \begin{itemize}
                \item \textbf{app:layout\_constraintStart\_toStartOf="targetId"}: Aligns the start edge (left in LTR layouts, right in RTL) of this view to the start edge of the targetId.
                \item \textbf{app:layout\_constraintTop\_toTopOf="targetId"}: Aligns the top edge of this view to the top edge of the targetId.
                \item \textbf{app:layout\_constraintBottom\_toBottomOf="targetId"}: Aligns the bottom edge of this view to the bottom edge of the targetId.
                \item \textbf{app:layout\_constraintLeft\_toRightOf="targetId"}: Places the left edge of this view aligned to the right edge of the targetId.
                \item \textbf{app:layout\_constraintRight\_toRightOf="targetId"}: Aligns the right edge of this view to the right edge of the targetId.
                \item \textbf{app:layout\_constraintLeft\_toLeftOf="targetId"}: Aligns the left edge of this view to the left edge of the targetId.
                \item \textbf{app:layout\_constraintHorizontal\_bias (no units, value 0-1.0)}:
                \item \textbf{app:layout\_constraintVertical\_bias (no units, value 0-1.0)}:
            \end{itemize}
            \textbf{Note:} Instead of \textit{targetId}, we can specify \textit{parent}
            \bigbreak \noindent 
            Bias only works if you constrain both sides (e.g. start and end, or top and bottom). If there's only one constraint, the bias has no effect.
        \item \textbf{RelativeLayout}
            \begin{itemize}
                \item \textbf{android:layout\_alignParentTop="true"}:	Stick to top edge
                \item \textbf{android:layout\_alignParentBottom="true"}:	Stick to bottom edge
                \item \textbf{android:layout\_alignParentStart="true"}:	Stick to left (or start) edge
                \item \textbf{android:layout\_alignParentEnd="true"}:	Stick to right (or end) edge
                \item \textbf{android:layout\_centerInParent="true"}:	Center both vertically and horizontally
                \item \textbf{android:layout\_centerHorizontal="true"}:	Center horizontally only
                \item \textbf{android:layout\_centerVertical="true"}:	Center vertically only
                \item \textbf{android:layout\_above="@id/viewId"}:	Place above another view
                \item \textbf{android:layout\_below="@id/viewId"}:	Place below another view
                \item \textbf{android:layout\_toStartOf="@id/viewId"}:	Place to the left of another view
                \item \textbf{android:layout\_toEndOf="@id/viewId"}:	Place to the right of another view
                \item \textbf{android:layout\_alignStart="@id/viewId"}:	Align left edges
                \item \textbf{android:layout\_alignEnd="@id/viewId"}:	Align right edges
                \item \textbf{android:layout\_alignTop="@id/viewId"}:	Align top edges
                \item \textbf{android:layout\_alignBottom="@id/viewId"}:	Align bottom edges
                \item \textbf{android:layout\_marginStart / android:layout\_marginEnd}:	Logical left/right margins (RTL aware)
                \item \textbf{android:layout\_marginLeft / android:layout\_marginRight}:	Physical left/right margins (legacy)
                \item \textbf{android:layout\_marginTop / android:layout\_marginBottom}:	Vertical margins
                \item \textbf{android:padding*}	Padding inside the view (applies to content, not position)
                \item \textbf{android:layout\_alignBaseline="@id/viewId"}:	Align text baselines of two views
                \item \textbf{android:layout\_alignWithParentIfMissing="true"}:	If referenced ID is missing, align with parent instead (rarely used)
            \end{itemize}
        \item \textbf{LinearLayout}:
            \begin{itemize}
                \item \textbf{android:baselineAligned}:	When set to false, prevents the layout from aligning its children's baselines. 
                \item \textbf{android:baselineAlignedChildIndex}:	When a linear layout is part of another layout that is baseline aligned, it can specify which of its children to baseline align to (that is, which child TextView). 
                \item \textbf{android:divider}:	Drawable to use as a vertical divider between buttons. 
                \item \textbf{android:gravity}:	Specifies how an object should position its content, on both the X and Y axes, within its own bounds. 
                \item \textbf{android:measureWithLargestChild}:	When set to true, all children with a weight will be considered having the minimum size of the largest child. 
                \item \textbf{android:orientation}:	Should the layout be a column or a row? Use "horizontal" for a row, "vertical" for a column. 
                \item \textbf{android:weightSum}: Defines the maximum weight sum.  
            \end{itemize}
        \item \textbf{TableLayout}
            \begin{itemize}
                \item \textbf{android:shrinkColumns}:	The zero-based index of the columns to shrink. 
                \item \textbf{android:stretchColumns}:	The zero-based index of the columns to stretch. 
            \end{itemize}
        \item \textbf{TableRow}: Doesn't have its own XML attributes, inherits from \texttt{LinearLayout}, \texttt{ViewGroup}, and \texttt{View}
        \item \textbf{FrameLayout}
            \begin{itemize}
                \item \textbf{android:foregroundGravity}:	Defines the gravity to apply to the foreground drawable. 
                \item \textbf{android:measureAllChildren}:	Determines whether to measure all children or just those in the VISIBLE or INVISIBLE state when measuring. 
            \end{itemize}
        \item \textbf{TextView}: 
            \begin{itemize}
                \item \textbf{android:text}: the actual text string (not just visual, it's the content).
                \item \textbf{android:hint}: placeholder shown when empty.
                \item \textbf{android:ellipsize}: controls truncation (end, marquee, etc.).
                \item \textbf{android:scrollHorizontally}: enables horizontal scrolling.
                \item \textbf{android:marqueeRepeatLimit}: how many times marquee scroll repeats.
                \item \textbf{android:inputType}: defines the type of expected text (password, email, number, etc.).
                \item \textbf{android:digits}: restricts input to specific characters.
                \item \textbf{android:editable}: (deprecated, use EditText).
                \item \textbf{android:ems}: sets width in units of "M" characters.
                \item \textbf{android:freezesText}: whether text is preserved on screen rotation.
                \item \textbf{android:phoneNumber}: (deprecated, use inputType="phone").
                \item \textbf{android:selectAllOnFocus}: selects all text when focused.
                \item \textbf{android:linksClickable}: whether links are clickable.
                \item \textbf{android:autoLink}: auto-detect links (web, email, phone).
                \item \textbf{android:focusable}: can this view take focus?
                \item \textbf{android:focusableInTouchMode}: can it take focus during touch mode?
                \item \textbf{android:longClickable}: whether it supports long-press actions.
                \item \textbf{android:cursorVisible}: whether the text cursor is shown.
                \item \textbf{android:inputMethod}: IME options (soft keyboard).
                \item \textbf{android:imeOptions}: extra options for keyboard (e.g., actionDone).
                \item \textbf{android:imeActionId}: action ID for IME.
                \item \textbf{android:imeActionLabel}: label for IME action key.
                \item \textbf{android:contentDescription}: for accessibility services (screen readers).
                \item \textbf{android:autoLink}: auto-detect links.
                \item \textbf{android:linksClickable}: enable link clicks.
            \end{itemize}
        \item \textbf{EditText}: 
            \begin{itemize}
                \item \textbf{android:hint}:  A gray placeholder text shown when the field is empty.
                \item \textbf{android:inputType}:  Controls what kind of text can be entered and how the keyboard looks:
                \begin{itemize}
                    \item \textbf{text}: normal text
                    \item \textbf{textPassword}: hidden input (\bullet\bullet\bullet\bullet)
                    \item \textbf{number}: numeric keyboard
                    \item \textbf{numberDecimal}: real numbers
                    \item \textbf{phone}: phone keypad
                    \item \textbf{textEmailAddress}: email-optimized keyboard
                    \item \textbf{android:ems}: Sets the default width in terms of characters.
                \end{itemize}
                \item \textbf{android:maxLines / android:lines}: Control number of visible lines.
                \item \textbf{android:gravity}: Aligns the text inside the box.
                \item \textbf{android:drawableLeft / drawableRight}: Add icons inside the field.
                \item \textbf{android:textColor}: Sets the color of the text
                \item \textbf{android:textColorHint}: Sets the color of the hint text
            \end{itemize}
        \item \textbf{Button}:
            \begin{itemize}
                \item \textbf{android:clickable}: whether the button responds to clicks.
                \item \textbf{android:longClickable}: whether the button responds to long presses.
                \item \textbf{android:focusable}: can the button take focus.
                \item \textbf{android:focusableInTouchMode}: focusable via touch navigation.
                \item \textbf{android:soundEffectsEnabled}: enable/disable click sound.
                \item \textbf{android:hapticFeedbackEnabled}: enable/disable vibration feedback.
                \item \textbf{android:contentDescription}: spoken description for screen readers.
                \item \textbf{android:importantForAccessibility}: whether this button should be exposed to accessibility services.
                \item \textbf{android:labelFor}: associates this button as a label for another view.
                \item \textbf{android:enabled}: whether the button can be interacted with.
                \item \textbf{android:nextFocusUp / nextFocusDown / nextFocusLeft / nextFocusRight}: custom focus navigation.
                \item \textbf{android:checkable (for ToggleButton/MaterialButton)}: whether it can act like a checkbox.
                \item \textbf{android:checked (for toggleable buttons)}: initial checked state.
                \item \textbf{android:duplicateParentState}: inherits enabled/pressed/selected state from parent.
                \item \textbf{android:visibility}: visible, invisible, or gone.
                \item \textbf{android:keepScreenOn}: keep the screen on while this button is visible.
            \end{itemize}
        \item \textbf{ListView}
            \begin{itemize}
                \item \textbf{android:divider}:	Drawable or color to draw between list items. 
                \item \textbf{android:dividerHeight}:	Height of the divider. 
                \item \textbf{android:entries}:	Reference to an array resource that will populate the ListView. 
                \item \textbf{android:footerDividersEnabled}:	When set to false, the ListView will not draw the divider before each footer view. 
                \item \textbf{android:headerDividersEnabled}:	When set to false, the ListView will not draw the divider after each header view. 
            \end{itemize}
        \item \textbf{ImageView}
            \begin{itemize}
                \item \textbf{android:adjustViewBounds}:	Set this to true if you want the ImageView to adjust its bounds to preserve the aspect ratio of its drawable. 
                \item \textbf{android:baseline}:	The offset of the baseline within this view. 
                \item \textbf{android:baselineAlignBottom}:	If true, the image view will be baseline aligned with based on its bottom edge. 
                \item \textbf{android:cropToPadding}:	If true, the image will be cropped to fit within its padding. 
                \item \textbf{android:maxHeight}:	An optional argument to supply a maximum height for this view. 
                \item \textbf{android:maxWidth}:	An optional argument to supply a maximum width for this view. 
                \item \textbf{android:scaleType}:	Controls how the image should be resized or moved to match the size of this ImageView. 
                \item \textbf{android:src}:	Sets a drawable as the content of this ImageView. 
                \item \textbf{android:tint}:	The tinting color for the image. 
                \item \textbf{android:tintMode}:	Blending mode used to apply the image tint. 
            \end{itemize}
        \item \textbf{ImageButton}: Only inherited from View and ImageView
        \item \textbf{CompoundButton}:
            \begin{itemize}
                \item \textbf{android:button}:	Drawable used for the button graphic (for example, checkbox and radio button). 
                \item \textbf{android:buttonTint}:	Tint to apply to the button graphic. 
                \item \textbf{android:buttonTintMode}:	Blending mode used to apply the button graphic tint. 
            \end{itemize}
        \item \textbf{CheckBox}: Only inherited from CompoundButton, TextView, and View
        \item \textbf{RadioGroup}:
            \begin{itemize}
                \item \textbf{android:checkedButton}:	The id of the child radio button that should be checked by default within this radio group. 
            \end{itemize}
        \item \textbf{RadioButton}: Only inherited from CompoundButton, TextView, and View.
        \item \textbf{AbsSpinner}:
            \begin{itemize}
                \item \textbf{android:entries}:	Reference to an array resource that will populate the Spinner. 
            \end{itemize}
        \item \textbf{Spinner}
            \begin{itemize}
                \item \textbf{android:dropDownHorizontalOffset}:	Amount of pixels by which the drop down should be offset horizontally. 
                \item \textbf{android:dropDownSelector}:	List selector to use for spinnerMode="dropdown" display. 
                \item \textbf{android:dropDownVerticalOffset}:	Amount of pixels by which the drop down should be offset vertically. 
                \item \textbf{android:dropDownWidth}:	Width of the dropdown in spinnerMode="dropdown". 
                \item \textbf{android:gravity}:	Gravity setting for positioning the currently selected item. 
                \item \textbf{android:popupBackground}:	Background drawable to use for the dropdown in spinnerMode="dropdown". 
                \item \textbf{android:prompt}:	The prompt to display when the spinner's dialog is shown. 
                \item \textbf{android:spinnerMode}:	Display mode for spinner options. 
            \end{itemize}
        \item \textbf{ProgressBar}
            \begin{itemize}
                \item \textbf{android:animationResolution}:	Timeout between frames of animation in milliseconds. 
                \item \textbf{android:indeterminate}:	Allows to enable the indeterminate mode. 
                \item \textbf{android:indeterminateBehavior}:	Defines how the indeterminate mode should behave when the progress reaches max. 
                \item \textbf{android:indeterminateDrawable}:	Drawable used for the indeterminate mode. 
                \item \textbf{android:indeterminateDuration}:	Duration of the indeterminate animation. 
                \item \textbf{android:indeterminateOnly}:	Restricts to ONLY indeterminate mode (state-keeping progress mode will not work). 
                \item \textbf{android:indeterminateTint}:	Tint to apply to the indeterminate progress indicator. 
                \item \textbf{android:indeterminateTintMode}:	Blending mode used to apply the indeterminate progress indicator tint. 
                \item \textbf{android:interpolator}:	Sets the acceleration curve for the indeterminate animation. 
                \item \textbf{android:max}:	Defines the maximum value. 
                \item \textbf{android:maxHeight}:	An optional argument to supply a maximum height for this view. 
                \item \textbf{android:maxWidth}:	An optional argument to supply a maximum width for this view. 
                \item \textbf{android:min}:	Defines the minimum value. 
                \item \textbf{android:minHeight}:	 
                \item \textbf{android:minWidth}:	 
                \item \textbf{android:mirrorForRtl}:	Defines if the associated drawables need to be mirrored when in RTL mode. 
                \item \textbf{android:progress}:	Defines the default progress value, between 0 and max. 
                \item \textbf{android:progressBackgroundTint}:	Tint to apply to the progress indicator background. 
                \item \textbf{android:progressBackgroundTintMode}:	Blending mode used to apply the progress indicator background tint. 
                \item \textbf{android:progressDrawable}:	Drawable used for the progress mode. 
                \item \textbf{android:progressTint}:	Tint to apply to the progress indicator. 
                \item \textbf{android:progressTintMode}:	Blending mode used to apply the progress indicator tint. 
                \item \textbf{android:secondaryProgress}:	Defines the secondary progress value, between 0 and max. 
                \item \textbf{android:secondaryProgressTint}:	Tint to apply to the secondary progress indicator. 
                \item \textbf{android:secondaryProgressTintMode}:	Blending mode used to apply the secondary progress indicator tint. 
            \end{itemize}
        \item \textbf{AbsSeekBar}
            \begin{itemize}
                \item \textbf{android:thumbTint}:	Tint to apply to the thumb drawable. 
                \item \textbf{android:thumbTintMode}:	Blending mode used to apply the thumb tint. 
                \item \textbf{android:tickMarkTint}:	Tint to apply to the tick mark drawable. 
                \item \textbf{android:tickMarkTintMode}:	Blending mode used to apply the tick mark tint. 
            \end{itemize}
        \item \textbf{SeekBar}
            \begin{itemize}
                \item \textbf{android:thumb}: Draws the thumb on a seekbar. 
            \end{itemize}
        \item \textbf{GradientDrawable}
            \begin{itemize}
                \item \textbf{android:angle}:	Angle of the gradient, used only with linear gradient. 
                \item \textbf{android:bottom}:	Amount of bottom padding inside the gradient shape. 
                \item \textbf{android:centerColor}:	Optional center color. 
                \item \textbf{android:centerX}:	X-position of the center point of the gradient within the shape as a fraction of the width. 
                \item \textbf{android:centerY}:	Y-position of the center point of the gradient within the shape as a fraction of the height. 
                \item \textbf{android:color}:	Solid color for the gradient shape. 
                \item \textbf{android:color}:	Color of the gradient shape's stroke. 
                \item \textbf{android:dashGap}:	Gap between dashes in the stroke. 
                \item \textbf{android:dashWidth}:	Length of a dash in the stroke. 
                \item \textbf{android:endColor}:	End color of the gradient. 
                \item \textbf{android:gradientRadius}:	Radius of the gradient, used only with radial gradient. 
                \item \textbf{android:height}:	Height of the gradient shape. 
                \item \textbf{android:innerRadius}:	Inner radius of the ring. 
                \item \textbf{android:innerRadiusRatio}:	Inner radius of the ring expressed as a ratio of the ring's width. 
                \item \textbf{android:left}:	Amount of left padding inside the gradient shape. 
                \item \textbf{android:right}:	Amount of right padding inside the gradient shape. 
                \item \textbf{android:shape}:	Indicates what shape to fill with a gradient. 
                \item \textbf{android:startColor}:	Start color of the gradient. 
                \item \textbf{android:thickness}:	Thickness of the ring. 
                \item \textbf{android:thicknessRatio}:	Thickness of the ring expressed as a ratio of the ring's width. 
                \item \textbf{android:top}:	Amount of top padding inside the gradient shape. 
                \item \textbf{android:type}:	Type of gradient. 
                \item \textbf{android:useLevel}:	Whether the drawable level value (see Drawable.getLevel()) is used to scale the gradient. 
                \item \textbf{android:useLevel}:	Whether the drawable level value (see Drawable.getLevel()) is used to scale the shape. 
                \item \textbf{android:visible}:	Indicates whether the drawable should intially be visible. 
                \item \textbf{android:width}:	Width of the gradient shape. 
                \item \textbf{android:width}:	Width of the gradient shape's stroke. 
            \end{itemize}
        \item \textbf{Animation}:
            \begin{itemize}
                \item \textbf{android:backdropColor}:	Special option for window animations: whether the window's background should be used as a background to the animation. 
                \item \textbf{android:detachWallpaper}:	Special option for window animations: if this window is on top of a wallpaper, don't animate the wallpaper with it. 
                \item \textbf{android:duration}:	Amount of time (in milliseconds) for the animation to run. 
                \item \textbf{android:fillAfter}:	When set to true, the animation transformation is applied after the animation is over. 
                \item \textbf{android:fillBefore}:	When set to true or when fillEnabled is not set to true, the animation transformation is applied before the animation has started. 
                \item \textbf{android:fillEnabled}:	When set to true, the value of fillBefore is taken into account. 
                \item \textbf{android:interpolator}:	Defines the interpolator used to smooth the animation movement in time. 
                \item \textbf{android:repeatCount}:	Defines how many times the animation should repeat. 
                \item \textbf{android:repeatMode}:	Defines the animation behavior when it reaches the end and the repeat count is greater than 0 or infinite. 
                \item \textbf{android:showBackdrop}:	Special option for window animations: whether to show a background behind the animating windows. 
                \item \textbf{android:startOffset}:	Delay in milliseconds before the animation runs, once start time is reached. 
                \item \textbf{android:zAdjustment}:	Allows for an adjustment of the Z ordering of the content being animated for the duration of the animation. 
            \end{itemize}
        \item \textbf{set (AnimationSet)}: Only inherited from Animation
        \item \textbf{alpha (AlphaAnimation)}: Only inherited from Animation
        \item \textbf{rotate (RotateAnimation)}: Only inherited from Animation
        \item \textbf{scale (ScaleAnimation)}: Only inherited from Animation
        \item \textbf{translate (TranslateAnimation)}: Only inherited from Animation
        \item \textbf{ScrollView}: Only those inherited from View, ViewGroup, and FrameLayout
        \item \textbf{HorizontalScrollView}: Only those inherited from View, ViewGroup, and FrameLayout
    \end{itemize}

    \pagebreak 
    \subsubsection{Menus}
    \begin{itemize}
        \item \textbf{Menu Resource directory}: Menus are defined in \texttt{res/menu}
        \item \textbf{Menu types}
            \begin{itemize}
                \item \textbf{Options menu}: Defined in the action bar / app bar, or in the overflow menu if there's no room.
                \item \textbf{Context menu}: Appears when the user long-presses an item. Appears next to the pressed item OR as a floating context bar
                \item \textbf{Popup menu}: A tiny menu that pops up anchored to a button, Triggered by tapping a specific UI element (not long-press)
            \end{itemize}
        \item \textbf{Options menu}
            \bigbreak \noindent 
            \fig{.6}{./figures/1037.png}
            \bigbreak \noindent 
            We need to override the \texttt{onCreateOptionsMenu} method
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    getMenuInflater().inflate(R.menu.menu_main, menu);
                    return true;
                }
            \end{javacode}
            \bigbreak \noindent 
            The menu parameter is an empty Menu object created by Android. It represents the Action Bar options menu that will be shown to the user.
            \bigbreak \noindent 
            Your job in this method is to add items into this menu, usually done by inflating XML into it
            \bigbreak \noindent 
            Returning true means yes, we successfully created and want to show this menu.
            \bigbreak \noindent 
            To handle clicks, we override
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onOptionsItemSelected(MenuItem item) {
                    if (item.getItemId() == R.id.action_settings) {
                        // action here
                        return true;
                    }
                    return super.onOptionsItemSelected(item);
                }
            \end{javacode}
            \bigbreak \noindent 
            Calling the super version lets the default Android behavior run when your code doesn’t handle the menu click. If it’s not your menu item, let the Android system decide what to do.

        \item \textbf{Context Menu}: We first need to register the view
            \bigbreak \noindent 
            \begin{javacode}
                registerForContextMenu(myView);
            \end{javacode}
            \bigbreak \noindent 
            Then, override
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public void onCreateContextMenu(ContextMenu menu, View v,
                ContextMenu.ContextMenuInfo menuInfo) {
                    getMenuInflater().inflate(R.menu.context_menu, menu);
                }
            \end{javacode}
            \bigbreak \noindent 
            To handle clicks, override
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onContextItemSelected(MenuItem item) {
                    if (item.getItemId() == R.id.action_delete) {
                        // do delete
                        return true;
                    }
                    return super.onContextItemSelected(item);
                }
            \end{javacode}


        \item \textbf{Popup menu}: First, create in code where needed
            \bigbreak \noindent 
            \begin{javacode}
                PopupMenu popup = new PopupMenu(this, myButton);
                popup.getMenuInflater().inflate(R.menu.popup_menu, popup.getMenu());
                popup.show();
            \end{javacode}
            \bigbreak \noindent 
            Handle clicks using a listener
            \bigbreak \noindent 
            \begin{javacode}
                popup.setOnMenuItemClickListener(item -> {
                    if (item.getItemId() == R.id.action_share) {
                        // do share
                        return true;
                    }
                    return false;
                });

            \end{javacode}
    
        \item \textbf{Menu attributes}
            \begin{itemize}
                \item \textbf{android:id="Resource ID"}:. A unique resource ID. To create a new resource ID for this item, use the form: "@+id/name". The plus symbol indicates that this is created as a new ID.
                \item \textbf{android:title="String resource"}:. The menu title as a string resource or raw string.
                \item \textbf{android:titleCondensed="String resource"}:. A condensed title as a string resource or a raw string. This title is used for situations in which the normal title is too long.
                \item \textbf{android:icon="Drawable resource"}:. An image to be used as the menu item icon.
                \item \textbf{android:onClick="Method name"}:. The method to call when this menu item is clicked. The method must be declared in the activity as public. It accepts a MenuItem as its only parameter, which indicates the item clicked. This method takes precedence over the standard callback to onOptionsItemSelected(). See the example at the end of this page.
                \item \textbf{android:showAsAction="Keyword."}: When and how this item appears as an action item in the app bar. A menu item can appear as an action item only when the activity includes an app bar. Valid values:
                    \begin{itemize}
                        \item \textbf{ifRoom}:	Only place this item in the app bar if there is room for it. If there isn't room for all the items marked "ifRoom", the items with the lowest orderInCategory values are displayed as actions, and the remaining items are displayed in the overflow menu.
                        \item \textbf{withText}:	Also include the title text (defined by android:title) with the action item. You can include this value along with one of the others as a flag set by separating them with a pipe |.
                        \item \textbf{never}:	Never place this item in the app bar. Instead, list the item in the app bar's overflow menu.
                        \item \textbf{always}:	Always place this item in the app bar. Avoid using this unless it's critical that the item always appear in the action bar. Setting multiple items to always appear as action items can result in them overlapping with other UI in the app bar.
                        \item \textbf{collapseActionView}:	The action view associated with this action item (as declared by android:actionLayout or android:actionViewClass) is collapsible. Introduced in API level 14.
                    \end{itemize}
                \item \textbf{android:actionLayout="Layout resource"}:. A layout to use as the action view.
                \item \textbf{android:actionViewClass="Class name"}:. A fully-qualified class name for the View to use as the action view. For example, "android.widget.SearchView" to use SearchView as an action view.
                \item \textbf{android:actionProviderClass="Class name"}:. A fully qualified class name for the ActionProvider to use in place of the action item. For example, "android.widget.ShareActionProvider" to use ShareActionProvider.
                \item \textbf{android:alphabeticShortcut="Char."}: A character for the alphabetic shortcut key.
                \item \textbf{android:numericShortcut="Integer."}: A number for the numeric shortcut key.
                \item \textbf{android:alphabeticModifiers="Keyword."}: A modifier for the menu item's alphabetic shortcut. The default value corresponds to the Control key. Valid values:
                    \begin{itemize}
                        \item \textbf{META}:	Corresponds to the Meta meta key.
                        \item \textbf{CTRL}:	Corresponds to the Control meta key.
                        \item \textbf{ALT}:	Corresponds to the Alt meta key.
                        \item \textbf{SHIFT}:	Corresponds to the Shift meta key.
                        \item \textbf{SYM}:	Corresponds to the Sym meta key.
                        \item \textbf{FUNCTION}:	Corresponds to the Function meta key.
                    \end{itemize}
                    You can use the setAlphabeticShortcut() method to set the attribute values programmatically. For more information about the alphabeticModifier attribute
                \item \textbf{android:numericModifiers="Keyword"}:. A modifier for the menu item's numeric shortcut. The default value corresponds to the Control key. Valid values:
                    \begin{itemize}
                        \item \textbf{META}:	Corresponds to the Meta meta key.
                        \item \textbf{CTRL}:	Corresponds to the Control meta key.
                        \item \textbf{ALT}:	Corresponds to the Alt meta key.
                        \item \textbf{SHIFT}:	Corresponds to the Shift meta key.
                        \item \textbf{SYM}:	Corresponds to the Sym meta key.
                        \item \textbf{FUNCTION}:	Corresponds to the Function meta key.
                    \end{itemize}
                    You can use the setNumericShortcut() method to set the attribute values programmatically. For more information about the numericModifier attribute
                \item \textbf{android:checkable="Boolean"}:. True if the item is checkable.
                \item \textbf{android:checked="Boolean"}:. True if the item is checked by default.
                \item \textbf{android:visible="Boolean"}:. True if the item is visible by default.
                \item \textbf{android:enabled="Boolean"}:. True if the item is enabled by default.
                \item \textbf{android:menuCategory="Keyword"}:. Value corresponding to the Menu CATEGORY\_* constants, which define the item's priority. Valid values:
                    \begin{itemize}
                        \item \textbf{container}:	For items that are part of a container.
                        \item \textbf{system}:	For items that are provided by the system.
                        \item \textbf{secondary}:	For items that are user-supplied secondary (infrequently used) options.
                        \item \textbf{alternative}:	For items that are alternative actions on the data that is currently displayed.  
                    \end{itemize}
                \item \textbf{android:orderInCategory="Integer"}:. The order of importance of the item within a group.
            \end{itemize}
        \item \textbf{<group>}: A menu group, to create a collection of items that share traits, such as whether they are visible, enabled, or selectable. Contains one or more <item> elements. Must be a child of a <menu> element.
        \item \textbf{<group> attributes}:
            \begin{itemize}
                \item \textbf{android:id="Resource ID"}: A unique resource ID. To create a new resource ID for this item, use the form: "@+id/name". The plus symbol indicates that this is created as a new ID.
                \item \textbf{android:checkableBehavior="Keyword"}:. The type of selectable behavior for the group. Valid values:
                    \begin{itemize}
                        \item \textbf{none}:	Not selectable.
                        \item \textbf{all}:	All items can be selected (use checkboxes).
                        \item \textbf{single}:	Only one item can be selected (use radio buttons).
                    \end{itemize}
                \item \textbf{android:visible="Boolean"}:. True if the group is visible.
                \item \textbf{android:enabled="Boolean"}:. True if the group is enabled.
                \item \textbf{android:menuCategory="Keyword"}:. Value corresponding to the Menu CATEGORY\_* constants, which define the group's priority. Valid values:
                    \begin{itemize}
                        \item \textbf{container}:	For groups that are part of a container.
                        \item \textbf{system}:	For groups that are provided by the system.
                        \item \textbf{secondary}:	For groups that are user-supplied secondary (infrequently used) options.
                        \item \textbf{alternative}:	For groups that are alternative actions on the data that is currently displayed.
                    \end{itemize}
                \item \textbf{android:orderInCategory}: Integer. The default order of the items within the category.
            \end{itemize}
        
    \end{itemize}

    \pagebreak 
    \subsubsection{SQLite}
    \begin{itemize}
        \item \textbf{Extending SQLiteOpenHelper}: We can create a \texttt{DatebaseManager} class file, in which we extend \texttt{SQLiteOpenHelper}. That’s Android’s built-in helper for:
            \begin{itemize}
                \item \textbf{Creating tables}:	onCreate(SQLiteDatabase db)
                \item \textbf{Upgrading schema versions}:	onUpgrade(SQLiteDatabase db, int oldV, int newV)
                \item \textbf{Opening / closing the DB safely}:	handled by the parent class
            \end{itemize}
            Android automatically calls onCreate() the first time your app accesses the database.
        \item \textbf{Define name and version}: For example,
            \bigbreak \noindent 
            \begin{javacode}
                private static final String DATABASE_NAME = "recordDB";
                private static final int DATABASE_VERSION = 1;
            \end{javacode}
            \bigbreak \noindent 
            Stored in your app’s private folder:
            \bigbreak \noindent 
            \begin{bashcode}
                /data/data/<your-package>/databases/recordDB
            \end{bashcode}
            \bigbreak \noindent 
            Version controls schema changes; bumping it triggers onUpgrade().
        \item \textbf{Table creation}: For example,
            \bigbreak \noindent 
            \begin{javacode}
                public void onCreate(SQLiteDatabase db) {
                    String sqlCreate = "create table record(" +
                        "id integer primary key autoincrement, " +
                        "name text, price real)";
                    db.execSQL(sqlCreate);
                }
            \end{javacode}
            \bigbreak \noindent 
            Called automatically the first time the database is created. Builds one table named record with:
            \begin{itemize}
                \item \textbf{id}: primary key (auto-increment)
                \item \textbf{name}: text column
                \item \textbf{price}: real (floating-point number)
            \end{itemize}
        \item \textbf{Upgrading the schema}: For example, 
            \bigbreak \noindent 
            \begin{javacode}
                public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                    db.execSQL("drop table if exists record");
                    onCreate(db);
                }
            \end{javacode}
            \bigbreak \noindent 
            When you increment DATABASE\_VERSION, Android calls this. It drops the old table and recreates it. (In production you’d use ALTER TABLE instead of dropping data.)
        \item \textbf{Inserting data}: For example, 
            \bigbreak \noindent 
            \begin{javacode}
                public void insert(Record record) {
                    SQLiteDatabase db = this.getWritableDatabase();
                    String sqlInsert = "insert into record values(null, '" +
                                        record.getName() + "', '" + record.getPrice() + "')";
                    db.execSQL(sqlInsert);
                    db.close();
                }
            \end{javacode}
            \bigbreak \noindent 
            Opens a writable connection, Executes a raw SQL INSERT statement, Uses null for the auto-incrementing ID, Closes the database
            \bigbreak \noindent 
            \textbf{Note:} In real apps, you’d use ContentValues to avoid SQL injection.
        \item \textbf{Deleting data}: For example,
            \bigbreak \noindent 
            \begin{javacode}
                public void deleteById(int id) {
                    SQLiteDatabase db = this.getWritableDatabase();
                    db.execSQL("delete from record where id = " + id);
                    db.close();
                }
            \end{javacode}
            \bigbreak \noindent 
            Removes one row where the ID matches.
        \item \textbf{Updating data}
            \bigbreak \noindent 
            \begin{javacode}
                public void updateById(int id, String name, double price) {
                    SQLiteDatabase db = this.getWritableDatabase();
                    db.execSQL("update record set name = '" + name + "', price = '" + price + "' where id = " + id);
                    db.close();
                }
            \end{javacode}
            \bigbreak \noindent 
            Changes both name and price columns for the selected record.
        \item \textbf{Querying one record}
            \bigbreak \noindent 
            \begin{javacode}
                public Record selectById(int id) {
                    String sqlQuery = "select * from record where id = " + id;
                    SQLiteDatabase db = this.getWritableDatabase();
                    Cursor cursor = db.rawQuery(sqlQuery, null);

                    Record record = null;
                    if (cursor.moveToFirst())
                        record = new Record(
                            Integer.parseInt(cursor.getString(0)),
                            cursor.getString(1),
                            cursor.getDouble(2));
                    return record;
                }
            \end{javacode}
            \begin{itemize}
                \item Executes a SELECT query
                \item Returns a Cursor (a pointer over result rows)
                \item Reads columns using indices (0=id, 1=name, 2=price)
                \item Builds and returns a Record object
            \end{itemize}
            A Cursor in Android is a data access object that points to the result set (rows and columns) returned from a database query. It works like an iterator that lets you move across each row of the query result and read each column’s value.
            \begin{itemize}
                \item sqlQuery = a plain SQL command to get 1 row (SELECT * FROM record WHERE id = ?).
                \item db.rawQuery(sqlQuery, null) executes the SQL and returns a Cursor.
                \item The cursor now contains the query result (in memory, inside SQLite).
            \end{itemize}
            \textbf{Important methods}
            \begin{itemize}
                \item \textbf{moveToFirst()}	Moves the cursor to the first row of the result set. Returns false if there are no rows.
                \item \textbf{moveToNext()}	Moves the cursor forward one row. Returns false if there are no more rows.
                \item \textbf{moveToPrevious()}	Moves the cursor back one row.
                \item \textbf{moveToLast()}	Moves the cursor to the last row.
                \item \textbf{move(int offset)}	Moves the cursor relative to its current position.
                \item \textbf{moveToPosition(int position)}	Moves to an exact row index (0-based). Returns false if out of range.
                \item \textbf{isFirst() / isLast()}	Returns true if the cursor is at the first/last row.
                \item \textbf{isBeforeFirst() / isAfterLast()}	Returns true if the cursor hasn’t started or has finished iterating.
                \item \textbf{getPosition()}	Returns the current row index.
                \item \textbf{getInt(int columnIndex)}:	Reads an int value.
                \item \textbf{getLong(int columnIndex)}:	Reads a long.
                \item \textbf{getDouble(int columnIndex)}:	Reads a double.
                \item \textbf{getFloat(int columnIndex)}:	Reads a float.
                \item \textbf{getString(int columnIndex)}:	Reads a String.
                \item \textbf{getBlob(int columnIndex)}:	Reads a byte[] (for images or binary data).
                \item \textbf{isNull(int columnIndex)}:	Returns true if the column’s value is NULL.
                \item \textbf{getColumnCount()}:	Returns number of columns in the result.
                \item \textbf{getColumnName(int index)}:	Returns the name of the column at a given index.
                \item \textbf{getColumnNames()}:	Returns a String[] of all column names.
                \item \textbf{getColumnIndex(String columnName)}:	Returns the column’s index (or -1 if not found).
                \item \textbf{getColumnIndexOrThrow(String columnName)}:	Same as above, but throws IllegalArgumentException if not found.
                \item \textbf{getCount()}:	Returns how many rows are in the result set.
                \item \textbf{isClosed()}:	Returns true if the cursor is already closed.
                \item \textbf{getPosition()}:	Returns current row index (0 = first).
                \item \textbf{close()}: Frees database and native resources. Always call when done!
            \end{itemize}
        \item \textbf{Query all records}
            \bigbreak \noindent 
            \begin{javacode}
                public ArrayList<Record> selectAll() {
                    String sqlQuery = "select * from record";
                    SQLiteDatabase db = this.getWritableDatabase();
                    Cursor cursor = db.rawQuery(sqlQuery, null);

                    ArrayList<Record> records = new ArrayList<>();
                    while (cursor.moveToNext()) {
                        Record current = new Record(
                            Integer.parseInt(cursor.getString(0)),
                            cursor.getString(1),
                            cursor.getDouble(2));
                        records.add(current);
                    }
                    db.close();
                    return records;
                }
            \end{javacode}
        \item \textbf{Impotant SQLiteDatabase methods}
            \begin{itemize}
                \item \textbf{getReadableDatabase()}:	Opens the database in read-only mode.
                \item \textbf{getWritableDatabase()}:	Opens the database in read/write mode (creates it if needed).
                \item \textbf{close()}:	Closes the database connection.
                \item \textbf{isOpen()}:	Returns true if the DB is currently open.
                \item \textbf{getPath()}:	Returns the absolute file path of the database.
                \item \textbf{execSQL(String sql)}:	Executes a single SQL statement (no results returned). For example: db.execSQL("DELETE FROM record WHERE id=5");
                \item \textbf{insert(String table, String nullColumnHack, ContentValues values)}:	Inserts a new row. Returns the new row ID.
                \item \textbf{update(String table, ContentValues values, String whereClause, String[] whereArgs)}:	Updates existing rows matching a condition. Returns number of rows affected.
                \item \textbf{delete(String table, String whereClause, String[] whereArgs)}:	Deletes rows matching the condition. Returns number of rows deleted.
                \item \textbf{beginTransaction()}:	Starts a new transaction.
                \item \textbf{setTransactionSuccessful()}:	Marks the transaction to commit.
                \item \textbf{endTransaction()}:	Ends the transaction (commits if marked successful, rolls back otherwise).
                \item \textbf{inTransaction()}:	Returns true if currently inside a transaction.
                \item \textbf{execSQL(String sql)}:	Run any SQL (CREATE, DROP, etc.).
                \item \textbf{getVersion()}: / setVersion(int version)	Read or change DB version number.
                \item \textbf{getMaximumSize()}: / setMaximumSize(long numBytes)	Check or set max DB file size.
                \item \textbf{needUpgrade(int newVersion)}:	Returns true if the database version is lower than the given version.
                \item \textbf{isDatabaseIntegrityOk()}:	Verifies database file integrity.
                \item \textbf{isReadOnly()}:	Returns true if database is opened read-only.
                \item \textbf{isWriteAheadLoggingEnabled()}:	Returns true if WAL mode is active.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Styles}
    \begin{itemize}
        \item \textbf{How to style}: We can use many attributes to specify how a UI component will look. For example, we can specify the background color of a component.
            \bigbreak \noindent 
            We can specify its text size and color and whether the text is centered or not. We can also specify the component's size and the padding inside it
            \bigbreak \noindent 
            We use styles and themes to organize our project better
            \bigbreak \noindent 
            Themes and styles enable us to separate the look and feel of a View from its content. This is similar to the concept of CSS (Cascading Style Sheets) in web design.
            \bigbreak \noindent 
            We can define more styles in the file named themes.xml in the res > values directory.
        \item \textbf{Define a style} The syntax for defining a style is 
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="nameOfStyle"
                    [parent="styleThisStyleInheritsFrom"]>
                    <item name="attributeName" parent="styleThisStyleInheritsFrom">attributeValue</item>
                    ...
                </style>
            \end{xmlcode}
            \bigbreak \noindent 
            The (optional) parent attribute allows us to create a hierarchy of styles, i.e., styles can inherit from other styles.
        \item \textbf{Example style}: For example, this style specifies width, height, text size, and padding
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="TextStyle"
                    parent="@android:style/TextAppearance">
                    <item name="android:layout_width">wrap_content</item>
                    <item name="android:layout_height">wrap_content</item>
                    <item name="android:textSize">32sp</item>
                    <item name="android:padding">10dp</item>
                </style>
            \end{xmlcode}
        \item \textbf{Apply a style}: We give the style attribute to a component. For example,
            \bigbreak \noindent 
            \begin{xmlcode}
            <button style="@style/styleName" ...> ... </button> 
            \end{xmlcode}
        \item \textbf{TextView Styles}:
            \begin{itemize}
                \item \textbf{android:layout\_width}
                \item \textbf{android:layout\_height}
                \item \textbf{android:layout\_margin}
                \item \textbf{android:layout\_gravity}
                \item \textbf{android:ellipsize}: how text is cut off (none, start, middle, end, marquee)
                \item \textbf{android:singleLine}: (deprecated, use maxLines="1")
                \item \textbf{android:textSize}: font size (e.g. 16sp)
                \item \textbf{android:textColor}: text color (e.g. @color/black)
                \item \textbf{android:textColorHint}: color of the hint text
                \item \textbf{android:textColorHighlight}: color of text selection highlight
                \item \textbf{android:textColorLink}: color of hyperlinks
                \item \textbf{android:textStyle}: normal, bold, italic
                \item \textbf{android:fontFamily}: font family (e.g. sans-serif, serif, or custom font from res/font/)
                \item \textbf{android:typeface}: older way of setting (normal, sans, serif, monospace)
                \item \textbf{android:lineSpacingExtra}: add extra space between lines
                \item \textbf{android:lineSpacingMultiplier}: scale spacing between lines
                \item \textbf{android:letterSpacing}: adjust space between characters
                \item \textbf{android:gravity}: how text is positioned inside its box (top, bottom, left, right, center)
                \item \textbf{android:textAlignment}: alignment relative to parent (gravity, center, viewStart, etc.)
                \item \textbf{android:includeFontPadding}: extra font padding (default true)
                \item \textbf{android:scrollHorizontally}: allow horizontal scroll if needed
                \item \textbf{android:ems}: width in "M" units
                \item \textbf{android:shadowColor}: color of text shadow
                \item \textbf{android:shadowDx, android:shadowDy}: shadow offset
                \item \textbf{android:shadowRadius}: shadow blur radius
            \end{itemize}
        \item \textbf{EditText}: Since EditText is a subclass of TextView, it inherits all of TextView's styling attributes
            \begin{itemize}
                \item \textbf{android:textCursorDrawable}: lets you set a custom drawable for the blinking cursor.
                \item \textbf{android:textSelectHandle}: base selection handle drawable.
                \item \textbf{android:textSelectHandleLeft}: left handle for text selection.
                \item \textbf{android:textSelectHandleRight}: right handle for text selection.
                \item \textbf{android:colorControlActivated}: (theme attr, but affects EditText focus underline in Material/AppCompat).
                \item \textbf{android:colorControlNormal}: normal underline/tint when unfocused.
                \item \textbf{android:colorControlHighlight}: ripple/highlight color when focused.
            \end{itemize}
        \item \textbf{Button}: Button is another subclass of TextView, so it inherits all of TextView’s styling attributes
            \begin{itemize}
                \item \textbf{android:text}: label text.
                \item \textbf{android:textSize}: text size (14sp, 18sp).
                \item \textbf{android:textColor}: text color.
                \item \textbf{android:textStyle}: normal, bold, italic.
                \item \textbf{android:fontFamily}: custom font (@font/roboto\_bold).
                \item \textbf{android:letterSpacing}: adjust spacing between characters.
                \item \textbf{android:lineSpacingExtra / android:lineSpacingMultiplier}: line spacing.
                \item \textbf{android:textAllCaps}: force all caps (default true on Material buttons).
                \item \textbf{android:ellipsize}: how text is cut off if too long.
                \item \textbf{android:background}: drawable for button background (e.g. custom shape).
                \item \textbf{android:foreground}: optional overlay (e.g. ripple).
                \item \textbf{android:insetLeft, android:insetRight, android:insetTop, android:insetBottom}: padding inside button background (mostly for legacy Button).
                \item \textbf{android:padding, android:paddingStart, android:paddingEnd}: space inside button.
                \item \textbf{android:layout\_width, android:layout\_height}: sizing.
                \item \textbf{android:minWidth, android:minHeight}: minimum size (Material buttons have built-in minimums).
                \item \textbf{android:backgroundTint}: tint for the button background.
                \item \textbf{android:backgroundTintMode}: blend mode for tint.
                \item \textbf{android:drawableTint}: tint icons/drawables inside button.
                \item \textbf{android:drawableTintMode}: blending for icon tint.
                \item \textbf{android:drawableStart / android:drawableLeft}: icon at start.
                \item \textbf{android:drawableEnd / android:drawableRight}: icon at end.
                \item \textbf{android:drawableTop, android:drawableBottom}: icons above/below text.
                \item \textbf{android:drawablePadding}: space between icon and text
                \item \textbf{android:elevation}: z-depth shadow (Material design).
                \item \textbf{android:translationZ}: raised elevation when pressed.
                \item \textbf{android:shadowColor, android:shadowDx, android:shadowDy, android:shadowRadius}: text shadow.
                \item \textbf{app:cornerRadius}: rounded corners.
                \item \textbf{app:strokeColor}: outline color.
                \item \textbf{app:strokeWidth}: outline width.
                \item \textbf{app:icon}: set an icon.
                \item \textbf{app:iconPadding}: space between icon and text.
                \item \textbf{app:iconGravity}: where the icon appears (start, end, textStart, textEnd).
                \item \textbf{app:iconTint}: tint icon color.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Events}
    \begin{itemize}
        \item \textbf{View (XML)}
            \begin{itemize}
                \item \textbf{android:onClick}: name of a method in your Activity that gets called when the button is clicked
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Java event listeners}
    \begin{itemize}
        \item \textbf{Views:}
            \begin{itemize}
                \item \textbf{void setOnClickListener(OnClickListener l)}: Registers a listener to be invoked when the view is clicked (short tap).
                \item \textbf{void setOnLongClickListener(OnLongClickListener l)}: Registers a listener to be invoked when the view is long-pressed.
                \item \textbf{void setOnFocusChangeListener(OnFocusChangeListener l)}: Sets a listener that is called whenever the view gains or loses input focus.
                \item \textbf{void setOnTouchListener(OnTouchListener l)}: Sets a listener to receive touch events (e.g., finger down, move, lift) before they are processed by \texttt{onTouchEvent()}.
                \item \textbf{void setOnKeyListener(OnKeyListener l)}: Sets a listener to receive key events (e.g., hardware button presses) before they are passed to \texttt{onKeyDown()} or \texttt{onKeyUp()}.
                \item \textbf{boolean onKeyDown(int keyCode, KeyEvent event)}: Called when a hardware key is pressed down while the view has focus.
                \item \textbf{boolean onKeyUp(int keyCode, KeyEvent event)}: Called when a hardware key is released while the view has focus.
                \item \textbf{boolean onTouchEvent(MotionEvent event)}: Handles touch screen interaction with the view (default implementation supports clicks, scrolls, etc.).
                \item \textbf{boolean onGenericMotionEvent(MotionEvent event)}: Handles non-touch input events such as mouse, joystick, or stylus actions.
                \item \textbf{boolean onKeyPreIme(int keyCode, KeyEvent event)}: Called when a key event occurs before it reaches the input method (useful for intercepting Back button presses while an IME is visible).
                \item \textbf{boolean onTrackballEvent(MotionEvent event)}: Handles trackball events (legacy input for older devices).
            \end{itemize}
        \item \textbf{TextView} 
            \begin{itemize}
                \item \textbf{void addTextChangedListener(TextWatcher watcher)}: Registers a TextWatcher to receive callbacks when the text changes (before, during, or after editing).
                \item \textbf{void removeTextChangedListener(TextWatcher watcher)}: Unregisters a previously added TextWatcher so it no longer receives callbacks.
                \item \textbf{void setOnEditorActionListener(TextView.OnEditorActionListener l)}: Sets a listener to handle editor actions from the soft keyboard (e.g., pressing "Done", "Next", or "Search").
                \item \textbf{void setOnClickListener(View.OnClickListener l)}: Assigns a listener to handle click events when the view is tapped.
                \item \textbf{void setOnLongClickListener(View.OnLongClickListener l)}: Assigns a listener to handle long-click (press-and-hold) events on the view.
                \item \textbf{void setOnFocusChangeListener(View.OnFocusChangeListener l)}: Sets a listener that is triggered when the view gains or loses input focus.
            \end{itemize}
        \item \textbf{EditText}:
            \begin{itemize}
                \item \textbf{void addTextChangedListener(TextWatcher watcher)}: Registers a listener for text changes.
                \item \textbf{void removeTextChangedListener(TextWatcher watcher)}: Unregisters a text change listener.
                \item \textbf{void setOnEditorActionListener(TextView.OnEditorActionListener l)}: Sets a listener for handling IME action events (e.g., pressing Enter, Done, Search).
            \end{itemize}
        \item \textbf{Button:} Subclass of TextView, which is a subclass of View, so all the ones listed above
    \end{itemize}

    \pagebreak 
    \subsubsection{Java event listeners (2)}
    \begin{itemize}
        \item \textbf{TextWatcher}: The \texttt{TextWatcher} interface, from the android.text package, provides three methods to handle key events.
            \bigbreak \noindent 
            You can attach a TextWatcher to any view that implements Editable text content — meaning subclasses of TextView that allow editing.
            \bigbreak \noindent 
            \begin{javacode}
                import android.text.TextWatcher;
                import android.text.Editable;
                import java.lang.CharSequence;

                .
                .
                .


                private class TextChangeHandler implements TextWatcher {
                    public void beforeTextChanged(CharSequence s, int start, int count, int after )

                    public void onTextChanged(CharSequence s, int start, int before, int after)

                    public void afterTextChanged(Editable e)
                }
            \end{javacode}
            Where (\texttt{beforeTextChanged})
            \begin{itemize}
                \item \textbf{CharSequence s}: The text before the change.
                \item \textbf{int start}: The position (index) in the text where the change will begin.
                \item \textbf{int count}: How many characters are about to be replaced (i.e., how many will be removed).
                \item \textbf{int after}: How many characters will replace the old ones (i.e., how many will be added).
            \end{itemize}
            (onTextChanged)
            \begin{itemize}
                \item \textbf{CharSequence s}: The text after the change (current state).
                \item \textbf{int start}: The position in the text where the change happened.
                \item \textbf{int before}: Number of characters that were replaced (removed).
                \item \textbf{int count}: Number of new characters added.
            \end{itemize}
            \bigbreak \noindent 
            (afterTextChanged)
            \begin{itemize}
                \item \textbf{Editable:}  Represents the text content of the EditText after a change has occurred.
            \end{itemize}
            \bigbreak \noindent 
            Instantiate an instance of the class and attach it to a view with \texttt{.addTextChangedListener()}

        \item \textbf{onClick listener}: Create a private inner class that implements View.OnClickListener, and overrides the function onClick with signature
            \bigbreak \noindent 
            \begin{javacode}
            public void onClick(View v)
            \end{javacode}
            \bigbreak \noindent 
            Create an instance of the inner class and use the function \texttt{setOnClickListener()} to add it to a view.
            \bigbreak \noindent 
            Or, use an anonymous inner class
            \bigbreak \noindent 
            \begin{javacode}
                myView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        ...
                    }
                });
            \end{javacode}

    \end{itemize}


\pagebreak 
    \subsubsection{Code examples}
    \begin{itemize}
        \item \textbf{Minimum code for controller}:
            \bigbreak \noindent 
            \begin{javacode}
                package com.example.test3;

                import androidx.appcompat.app.AppCompatActivity;

                import android.os.Bundle;

                public class MainActivity extends AppCompatActivity {

                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        setContentView(R.layout.activity_main);
                    }
                }
            \end{javacode}
        \item \textbf{Base theme:} 
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="Base.Theme.TipCalculator" parent="Theme.Material3.DayNight.NoActionBar">
                    <!-- Customize your light theme here. -->
                    <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
                </style>
            \end{xmlcode}
    \end{itemize}

    \pagebreak 
    \subsection{Java reference}
    \subsubsection{Activity}
    \begin{itemize}
        \item \textbf{Lifecycle methods}
            \begin{itemize}
                \item \textbf{onCreate(Bundle)}:	Initialize activity (UI layout, variables, listeners). Most important one.
                \item \textbf{onStart()}:	Activity is becoming visible.
                \item \textbf{onResume()}:	Activity is now in the foreground and interactive.
                \item \textbf{onPause()}:	Partially visible — pause resources, stop animations. called when Android starts or resumes another
                \item \textbf{onStop()}:	No longer visible — release resources.
                \item \textbf{onRestart()}:	Called before restarting after being stopped.
                \item \textbf{onDestroy()}:	Final cleanup before activity is removed from memory.
            \end{itemize}
        \item \textbf{Transitions}
            \begin{itemize}
                \item \textbf{overridePendingTransition(int enterAnim, int exitAnim)}:	Overrides the default transition right after calling startActivity() or finish()
                \item \textbf{finishAfterTransition()}: 	Finishes the Activity after shared-element transitions complete
                \item \textbf{postponeEnterTransition()}: 	Waits before running transition (useful while loading images)
                \item \textbf{startPostponedEnterTransition()}: 	Resumes the delayed enter transition
                \item \textbf{setEnterSharedElementCallback(SharedElementCallback)}: 	Customize shared element mapping during enter transition
                \item \textbf{setExitSharedElementCallback(SharedElementCallback)}: 	Same as above, but for exit transitions
            \end{itemize}
        \item \textbf{Transition constants}
            \begin{itemize}
                \item \textbf{TRANSITION\_NONE}:	No animation
                \item \textbf{TRANSITION\_OPEN}:	When an Activity is opened
                \item \textbf{TRANSITION\_CLOSE}:	When an Activity is closed
            \end{itemize}
        \item  \textbf{UI and layout management}
            \begin{itemize}
                \item \textbf{setContentView(int layoutResId)}:	Sets the XML layout for the Activity.
                \item \textbf{findViewById(int id)}:	Get references to UI elements.
            \end{itemize}
        \item \textbf{Navigation and intents}
            \begin{itemize}
                \item \textbf{startActivity(Intent)}:	Launch another Activity.
                \item \textbf{startActivityForResult(Intent, int)}:	Launch an Activity and get returned data. (Deprecated in favor of ActivityResult API, but still widely used.)
                \item \textbf{finish()}:	Close the current Activity.
                \item \textbf{getIntent()}:	Retrieve the Intent that started the Activity.
            \end{itemize}
        \item \textbf{State Preservation}: When configuration changes happen (like screen rotation):
            \begin{itemize}
                \item \textbf{onSaveInstanceState(Bundle)}:	Save UI state before destruction.
                \item \textbf{onRestoreInstanceState(Bundle)}:	Restore saved state after recreation.
            \end{itemize}
        \item \textbf{Menu / UI controls}
            \begin{itemize}
                \item \textbf{onCreateOptionsMenu(Menu)}:	Initialize menu options.
                \item \textbf{onOptionsItemSelected(MenuItem)}:	Handle menu selections.
            \end{itemize}
        \item \textbf{Context-provided Methods}
            \begin{itemize}
                \item \textbf{getApplicationContext()}:	Access app-level context.
                \item \textbf{getSystemService(String)}:	Access system services (e.g., LOCATION\_SERVICE).
                \item \textbf{getSharedPreferences(name, mode)}:	App storage for small data.
            \end{itemize}
        \item \textbf{Dialogs, toasts, and interaction}
            \begin{itemize}
                \item \textbf{runOnUiThread(Runnable)}:	Update UI from a background thread.
                \item \textbf{requestPermissions(String[], int)}:	Ask for runtime permissions.
                \item \textbf{onRequestPermissionsResult(...)}:	Handle permission results.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{android.content.Context}
    \begin{itemize}
        \item \textbf{What is it}: Context is an interface to global information about your application environment. It gives you access to:
            \begin{itemize}
                \item App resources (colors, strings, layouts, drawables, etc.)
                \item System services (e.g. LayoutInflater, PowerManager, NotificationManager, etc.)
                \item Permissions
                \item Starting new Activities, Services, etc.
            \end{itemize}
            \bigbreak \noindent 
            When you create a View in code:
            \bigbreak \noindent 
            \begin{javacode}
                Button btn = new Button(this);
                GridLayout grid = new GridLayout(this);
            \end{javacode}
            \bigbreak \noindent 
            That this is a Context. In an Activity, this works because Activity is a subclass of Context.
            \bigbreak \noindent 
            The View needs a Context to:
            \begin{itemize}
                \item Know which theme/style to apply
                \item Access resources (e.g., strings, colors, dimensions)
                \item Hook into the Android system for rendering
            \end{itemize}
            Without a Context, a View has no "connection" to the running Android app environment.
    \end{itemize}


    \pagebreak \bigbreak \noindent 
    \subsubsection{Constraint layout in java (and ConstraintSet)}
    \begin{itemize}
        \item \textbf{Needed includes}:
            \bigbreak \noindent 
            \begin{javacode}
                import androidx.constraintlayout.widget.ConstraintLayout;
                import androidx.constraintlayout.widget.ConstraintSet;
                import android.view.ViewGroup;
            \end{javacode}
        \item \textbf{Create ConstraintLayout}:
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout layout = new ConstraintLayout(this);
            \end{javacode}
            The argument \textit{this} is the \textbf{context}, which in this case is the activity.
        \item \textbf{Constraints}: Constraints are essentially sets of rules that dictate the way in which a widget is aligned and distanced in relation to other widgets. The sides of the containing ConstraintLayout and special elements are called \textbf{guidelines}.
            \bigbreak \noindent 
            Constraints also dictate how the user interface layout of an activity will respond to changes in device orientation, or when displayed on devices of differing screen sizes. In order to be adequately configured, a widget must have sufficient constraint connections such that it’s position can be resolved by the ConstraintLayout layout engine in both the horizontal and vertical planes.
        \item \textbf{Margins}: A margin is a form of constraint that specifies a fixed distance. 
        \item \textbf{Opposing Constraints}: Two constraints operating along the same axis on a single widget are referred to as opposing constraints. In other words, a widget with constraints on both its left and right-hand sides is considered to have horizontally opposing constraints. 
            \bigbreak \noindent 
            The key point to understand here is that once opposing constraints are implemented on a particular axis, the positioning of the widget is now based on percentages of the overall dimensions of the ConstraintLayout rather than coordinate based.
            \bigbreak \noindent 
            \fig{.9}{./figures/1008.png}
            \bigbreak \noindent 
            Instead of being fixed at 20dp from the top of the layout, for example, the widget is now positioned at a point 30\% from the top of the layout, regardless of the physical dimensions of the container, or parent layout.
            \bigbreak \noindent 
            In different orientations and when running on larger or smaller screens, the Button will always be in the same location relative to the dimensions of the parent layout.
        \item \textbf{Constraint Bias}: By default, opposing constraints are equal, resulting in the corresponding widget being centered along the axis of opposition. 
            \bigbreak \noindent 
            To allow for the adjustment of widget position in the case of opposing constraints, the ConstraintLayout implements a feature known as constraint bias. Constraint bias allows the positioning of a widget along the axis of opposition to be biased by a specified percentage in favor of one constraint.
            \bigbreak \noindent 
            \fig{.9}{./figures/1009.png}
            \bigbreak \noindent 
            Figure 2b-4, for example, shows the previous constraint layout with a 75\% horizontal bias and 10\% vertical bias:
        \item \textbf{Chains}: ConstraintLayout chains provide a way for the layout behavior of two or more widgets to be defined as a group.
            \bigbreak \noindent 
            Chains can be declared in either the vertical or horizontal axis and configured to define how the widgets in the chain are spaced and sized. Widgets are chained when connected together by bi-directional constraints.
            \bigbreak \noindent 
            \fig{.7}{./figures/1010.png}
            \bigbreak \noindent 
            Figure 2b-5, for example, illustrates three widgets chained in this way
            \bigbreak \noindent 
            The first element in the chain is the chain head which translates to the top widget in a vertical chain or, in the case of a horizontal chain, the left-most widget.
            \bigbreak \noindent 
            The layout behavior of the entire chain is primarily configured by setting attributes on the chain head widget.
        \item \textbf{Chain Styles}: The layout behavior of a ConstraintLayout chain is dictated by the chain style setting applied to the chain head widget; these are as described next.
            \begin{itemize}
                \item \textbf{Spread Chain}: The widgets contained within the chain are distributed evenly across the available space which is the default behavior for chains.
                    \bigbreak \noindent 
                    \fig{.7}{./figures/1011.png}
                \item \textbf{Spread Inside Chain}: The widgets contained within the chain are spread evenly between the chain head and the last widget in the chain. The head and last widgets are not included in the distribution of spacing
                    \fig{.7}{./figures/1012.png}
                \item \textbf{Weighted Chain}: Allows the space taken up by each widget in the chain to be defined via weighting properties.
                    \fig{.7}{./figures/1013.png}
                \item \textbf{Packed Chain}: The widgets that make up the chain are packed together without any spacing. A bias may be applied to control the horizontal or vertical positioning of the chain in relation to the parent container.
                    \fig{.7}{./figures/1014.png}
            \end{itemize}


        \item \textbf{Creating chains with java code}: You do it by manually setting constraints directly on each view’s ConstraintLayout.LayoutParams, using the leftToRight, rightToLeft, topToBottom, etc. fields.
            \bigbreak \noindent 
            Suppose we have three buttons in a ConstraintLayout, 
            \bigbreak \noindent 
            \begin{javacode}
                // --- Button 1 constraints ---
                ConstraintLayout.LayoutParams lp1 = new ConstraintLayout.LayoutParams(
                        ViewGroup.LayoutParams.WRAP_CONTENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp1.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.rightToLeft = btn2.getId();    // Chain with Button 2
                lp1.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.horizontalChainStyle = ConstraintLayout.LayoutParams.CHAIN_SPREAD;
                btn1.setLayoutParams(lp1);

                // --- Button 2 constraints ---
                ConstraintLayout.LayoutParams lp2 = new ConstraintLayout.LayoutParams(
                        ViewGroup.LayoutParams.WRAP_CONTENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp2.leftToRight = btn1.getId();
                lp2.rightToLeft = btn3.getId();
                lp2.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
                lp2.bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID;
                btn2.setLayoutParams(lp2);

                // --- Button 3 constraints ---
                ConstraintLayout.LayoutParams lp3 = new ConstraintLayout.LayoutParams(
                        ViewGroup.LayoutParams.WRAP_CONTENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp3.leftToRight = btn2.getId();
                lp3.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID;
                lp3.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
                lp3.bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID;
                btn3.setLayoutParams(lp3);
            \end{javacode}
        \item \textbf{Chain styles in java}:
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout.LayoutParams.CHAIN_SPREAD
                ConstraintLayout.LayoutParams.CHAIN_SPREAD_INSIDE
                ConstraintLayout.LayoutParams.CHAIN_PACKED
            \end{javacode}
            \bigbreak \noindent 
            Notice that in the above example, we give \texttt{ConstraintLayout.LayoutParams.CHAIN\_SPREAD} to the head button in the chain.
        \item \textbf{Weighted chain in java}: To make a weighted chain, you must:
            \begin{enumerate}
                \item Use \texttt{MATCH\_CONSTRAINT} (0dp) for the dimension you want to weight (width in a horizontal chain, height in a vertical one).
                \item Assign a weight to each view using layoutParams.horizontalWeight or layoutParams.verticalWeight.
                \item Use either \texttt{CHAIN\_SPREAD} or \texttt{CHAIN\_SPREAD\_INSIDE} style.
            \end{enumerate}
            \bigbreak \noindent 
            For example, consider again those three buttons
            \bigbreak \noindent 
            \begin{javacode}
                // ---- Button 1 ----
                ConstraintLayout.LayoutParams lp1 = new ConstraintLayout.LayoutParams(
                        0,  // MATCH_CONSTRAINT for weighted width
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp1.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.rightToLeft = btn2.getId();
                lp1.horizontalWeight = 1f; // weight = 1
                lp1.horizontalChainStyle = ConstraintLayout.LayoutParams.CHAIN_SPREAD;
                btn1.setLayoutParams(lp1);

                // ---- Button 2 ----
                ConstraintLayout.LayoutParams lp2 = new ConstraintLayout.LayoutParams(
                        0,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp2.leftToRight = btn1.getId();
                lp2.rightToLeft = btn3.getId();
                lp2.horizontalWeight = 2f; // weight = 2
                btn2.setLayoutParams(lp2);

                // ---- Button 3 ----
                ConstraintLayout.LayoutParams lp3 = new ConstraintLayout.LayoutParams(
                        0,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp3.leftToRight = btn2.getId();
                lp3.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID;
                lp3.horizontalWeight = 1f; // weight = 1
                btn3.setLayoutParams(lp3);
            \end{javacode}
        \item \textbf{MATCH\_CONSTRAINT}: Let’s break down what MATCH\_CONSTRAINT means, how it differs from WRAP\_CONTENT and MATCH\_PARENT, and when you use it.
            \bigbreak \noindent 
            MATCH\_CONSTRAINT is a special size mode in ConstraintLayout that tells a view:
            \bigbreak \noindent 
            \begin{center}
                "Size yourself dynamically based on your constraints, rather than fixed content or parent size."
            \end{center}
            \bigbreak \noindent 
            In Java, it’s specified by setting the dimension (width or height) to 0 in the layout params:
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout.LayoutParams params = new ConstraintLayout.LayoutParams(0, WRAP_CONTENT);
            \end{javacode}
            \bigbreak \noindent 
            View size is flexible and determined by the constraints and optionally by weights or ratios
        \item \textbf{Baseline Alignment}: So far,  we have only  referred to constraints that dictate alignment relative to the sides of a widget (typically referred to as side constraints).
            \bigbreak \noindent 
            A common requirement, however, is for a widget to be aligned relative to the content that it displays rather than the boundaries of the widget itself. To address this need, ConstraintLayout provides baseline alignment support.
            \bigbreak \noindent 
            Every view that displays text (e.g. TextView, EditText, Button) has a \textbf{text baseline} - the imaginary horizontal line upon which the text "sits."
            \bigbreak \noindent 
            Baseline alignment means you’re aligning two or more views based on that text baseline, instead of their tops or bottoms.
            \bigbreak \noindent 
            Suppose we require a TextView widget to be positioned 40dp to the left of the Button. 
            \bigbreak \noindent 
            In this case, the TextView needs to be baseline aligned with the Button view.
            \bigbreak \noindent 
            This means that the text within the Button needs to be vertically aligned with the text within the TextView.
            \bigbreak \noindent 
            \fig{.8}{./figures/1015.png}
            \bigbreak \noindent 
            The TextView is now aligned vertically along the baseline of the Button and positioned 40dp horizontally from the Button object’s left-hand edge.
            \bigbreak \noindent 
            In Java, you connect one view’s baseline to another view’s baseline using:
            \bigbreak \noindent 
            \begin{javacode}
            params.baselineToBaseline = otherView.getId();
            \end{javacode}
            \bigbreak \noindent 
            You can combine this with other constraints like leftToLeft, topToTop, etc.
        \item \textbf{Working with Guidelines}: Guidelines are special elements available within the ConstraintLayout that provide an additional target to which constraints may be connected.
            \bigbreak \noindent 
            Multiple guidelines may be added to a ConstraintLayout instance which may, in turn, be configured in horizontal or vertical orientations.
            \bigbreak \noindent 
            Once added, constraint connections may be established from widgets in the layout to the guidelines. This is particularly useful when multiple widgets need to be aligned along an axis. 
            \bigbreak \noindent 
            \fig{.8}{./figures/1016.png}
        \item \textbf{Guidelines in java}: First we create a \texttt{Guideline} object, then configure \texttt{ConstraintLayout.LayoutParams} for it.
            \bigbreak \noindent 
            \begin{javacode}
                import androidx.constraintlayout.widget.Guideline 

                // 1) Make the guideline
                Guideline vGuide = new Guideline(this);
                vGuide.setId(View.generateViewId());

                ConstraintLayout.LayoutParams vgLP = new ConstraintLayout.LayoutParams(
                        ConstraintLayout.LayoutParams.WRAP_CONTENT,
                        ConstraintLayout.LayoutParams.WRAP_CONTENT
                );
                vgLP.orientation = ConstraintLayout.LayoutParams.VERTICAL;
                // Choose ONE of these three ways to position it:
                vgLP.guidePercent = 0.30f;   // 30% from the left (0..1)
                // vgLP.guideBegin  = 120;    // 120px from the left
                // vgLP.guideEnd    = 16;     // 16px from the right

                vGuide.setLayoutParams(vgLP);
                layout.addView(vGuide);

                // 2) Constrain a view to the guideline
                TextView tv = new TextView(this);
                tv.setId(View.generateViewId());
                tv.setText("Hello");
                ConstraintLayout.LayoutParams tvLP = new ConstraintLayout.LayoutParams(
                0,  // MATCH_CONSTRAINT width so it can expand between guideline and parent
                ConstraintLayout.LayoutParams.WRAP_CONTENT
                );
                tvLP.leftToRight = vGuide.getId();                       // to the right of guideline
                tvLP.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID;
                tvLP.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;

                tv.setLayoutParams(tvLP);
                layout.addView(tv);

                setContentView(layout);
            \end{javacode}
            \bigbreak \noindent 
            \textbf{Note:} \texttt{ConstraintLayout.LayoutParams.orientation} is a property that only applies to Guidelines, not to regular Views.
            \bigbreak \noindent 
            \texttt{ConstraintLayout.LayoutParams.orientation} tells the ConstraintLayout whether a Guideline is:
            \begin{itemize}
                \item \textbf{Vertical}: divides the layout left $\leftrightarrow $ right
                \item \textbf{Horizontal}: divides the layout top $\leftrightarrow$ bottom
            \end{itemize}
        \item \textbf{Working with Barriers}: Rather like guidelines, barriers are virtual views that can be used to constrain views within a layout
            \bigbreak \noindent 
            As with guidelines, a barrier can be vertical or horizontal and one or more views may be constrained to it (to avoid confusion, these will be referred to as constrained views).
            \bigbreak \noindent 
            Unlike guidelines where the guideline remains at a fixed position within the layout, however, the position of a barrier is defined by a set of so called reference views.
            \bigbreak \noindent 
            Barriers were introduced to address an issue that occurs with some frequency involving overlapping views.
            \bigbreak \noindent 
            Consider the following example
            \bigbreak \noindent 
            \fig{.8}{./figures/1017.png}
            \bigbreak \noindent 
            The key points to note about the above layout is that the width of View 3 is set to match constraint mode, and the left-hand edge of the view is connected to the right hand edge of View 1.
            \bigbreak \noindent 
            As currently implemented, an increase in width of View 1 will have the desired effect of reducing the width of View 3:
            \bigbreak \noindent 
            \fig{.8}{./figures/1018.png}
            \bigbreak \noindent 
            A problem arises, however, if View 2 increases in width instead of View 1:
            \bigbreak \noindent 
            \fig{.8}{./figures/1019.png}
            \bigbreak \noindent 
            Clearly because View 3 is only constrained by View 1, it does not resize to accommodate the increase in width of View 2 causing the views to overlap.
            \bigbreak \noindent 
            A solution to this problem is to add a vertical barrier and assign Views 1 and 2 as the barrier’s reference views so that they control the barrier position.
            \bigbreak \noindent 
            The left-hand edge of View 3 will then be constrained in relation to the barrier, making it a constrained view.
            \bigbreak \noindent 
            Now when either View 1 or View 2 increase in width, the barrier will move to accommodate the widest of the two views, causing the width of View 3 change in relation to the new barrier position:
            \bigbreak \noindent 
            \fig{.6}{./figures/1020.png}
            \bigbreak \noindent 
            When working with barriers there is no limit to the number of reference views and constrained views that can be associated with a single barrier.
        \item \textbf{Barriers in java}: A Barrier is a virtual helper object in ConstraintLayout that positions itself dynamically based on the position of other views. It’s like a movable guideline that automatically adjusts to the furthest edge of a group of views.
            \bigbreak \noindent 
            Assume we have two TextViews
            \bigbreak \noindent 
            \begin{javacode}
                import androidx.constraintlayout.widget.Barrier;

                // --- Create a barrier ---
                Barrier barrier = new Barrier(this);
                barrier.setId(View.generateViewId());
                barrier.setType(Barrier.END); // or LEFT, RIGHT, START, TOP, BOTTOM
                barrier.setReferencedIds(new int[]{label1.getId(), label2.getId()});
                layout.addView(barrier);

                // Create a button that stays to the right of both text views
                Button btn = new Button(this);
                btn.setId(View.generateViewId());
                btn.setText("Aligned with longest");
                ConstraintLayout.LayoutParams lp3 = new ConstraintLayout.LayoutParams(
                        ConstraintLayout.LayoutParams.WRAP_CONTENT,
                        ConstraintLayout.LayoutParams.WRAP_CONTENT
                );
                lp3.startToEnd = barrier.getId(); // use barrier directly
                lp3.topToTop = t1.getId();       // align top with first label
                lp3.leftMargin = 16;
                btn.setLayoutParams(lp3);

                layout.addView(btn);

                ...
            \end{javacode}

        \item \textbf{Barrier types}: Barrier types you can use:
            \begin{itemize}
                \item Barrier.START
                \item Barrier.END
                \item Barrier.LEFT
                \item Barrier.RIGHT
                \item Barrier.TOP
                \item Barrier.BOTTOM
            \end{itemize}
            Which are explained in the following table
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{4cm}|p{3cm}|p{2cm}|p{3cm}}
                    Constant	&Tracks the...	&Moves toward...	&Typical Use \\
                    \hline \\
                    Barrier.START	&Start edges (left in LTR, right in RTL)	&Start side	&Keep something to the left of the leftmost view \\ && \\
                    Barrier.END	End &edges (right in LTR, left in RTL)	&End side	&Keep something to the right of the rightmost view \\&& \\ 
                    Barrier.LEFT	&Left edges (absolute)	&Left side	&Same as START but ignores layout direction \\ && \\
                    Barrier.RIGHT	&Right edges (absolute)	&Right side	&Same as END but ignores layout direction \\ && \\
                    Barrier.TOP	&Top edges	&Upward	&Keep something below the topmost/tallest view \\ && \\
                    Barrier.BOTTOM	&Bottom edges	&Downward	&Keep something below the lowest/bottommost view 
                \end{tabular}
            \end{center}






        \item \textbf{ConstraintLayout.LayoutParams}: Has constructor
            \bigbreak \noindent 
            \begin{javacode}
            ConstraintLayout.LayoutParams(int width, int height)
            \end{javacode}
            Lets you define width and height (MATCH\_PARENT, WRAP\_CONTENT, or px).
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout.LayoutParams lp =
                    new ConstraintLayout.LayoutParams(
                    ViewGroup.LayoutParams.WRAP_CONTENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT
                );
            \end{javacode}
            Then, we can add constraints, Each field takes an ID of another view (or PARENT\_ID):
            \begin{itemize}
                \item \textbf{leftToLeft}: Align the left edge of this view to the left edge of another view (or parent).
                \item \textbf{leftToRight}: Align the left edge of this view to the right edge of another view.
                \item \textbf{rightToLeft}: Align the right edge of this view to the left edge of another view.
                \item \textbf{rightToRight}: Align the right edge of this view to the right edge of another view.
                \item \textbf{topToTop}: Align the top edge of this view to the top edge of another view.
                \item \textbf{topToBottom}: Align the top edge of this view to the bottom edge of another view.
                \item \textbf{bottomToTop}: Align the bottom edge of this view to the top edge of another view.
                \item \textbf{bottomToBottom}: Align the bottom edge of this view to the bottom edge of another view.
                \item \textbf{startToStart}: Align the start edge of this view to the start edge of another view.
                \item \textbf{startToEnd}: Align the start edge of this view to the end edge of another view.
                \item \textbf{endToStart}: Align the end edge of this view to the start edge of another view.
                \item \textbf{endToEnd}: Align the end edge of this view to the end edge of another view.
                \item \textbf{horizontalBias(float b)}: $b \times 100$ percent from left
                \item \textbf{verticalBias(float b)}: $b \times 100$ percent from top
            \end{itemize}
            \bigbreak \noindent 
            \textbf{Note:}
            \begin{itemize}
                \item left/right = physical edges (always left/right of the screen).
                \item start/end = logical edges (switch meaning in RTL layouts).
            \end{itemize}
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent 
            \begin{javacode}
            lp.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
            \end{javacode}
            \bigbreak \noindent 
            We also have chains, for arranging multiple views in a line with flexible spacing:
        \item \textbf{Retrieve and update LayoutParams}:
            \bigbreak \noindent 
            \begin{javacode}
            ConstraintLayout.LayoutParams lp = (ConstraintLayout.LayoutParams) view.getLayoutParams();
            ...
            view.setLayoutParams(lp);
            \end{javacode}





    \end{itemize}

    \pagebreak 
    \subsubsection{Grid layout in java}
    \bigbreak \noindent 
    GridLayout is a type of ViewGroup that arranges its children in a grid of rows and columns.
    \bigbreak \noindent 
    Each child view is placed into a "cell" defined by its row and column. You can make a child span multiple rows or columns. It’s similar to a table layout but more flexible (alignments, spans, etc.).
    \begin{itemize}
        \item \textbf{Needed Includes}:
            \bigbreak \noindent 
            \begin{javacode}
                import android.content.Context;
                import android.view.ViewGroup;
                import android.widget.GridLayout;
            \end{javacode}
        \item \textbf{Create GridLayout}: You can make a GridLayout in code just like any other layout:
            \bigbreak \noindent 
            \begin{javacode}
                GridLayout grid = new GridLayout(this);   // "this" = Context, usually Activity
                grid.setRowCount(3);                      // number of rows
                grid.setColumnCount(3);                   // number of columns
            \end{javacode}
        \item \textbf{Setting LayoutParams for GridLayout}: We use ViewGroup.LayoutParams to set the layout params for the entire grid container.
            \bigbreak \noindent 
            \begin{javacode}
                grid.setLayoutParams(
                    new ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                );
            \end{javacode}
            
        \item \textbf{GridLayout.LayoutParams}: You need GridLayout.LayoutParams for child views placed inside a GridLayout. GridLayout.LayoutParams is the special layout parameter class that children of a GridLayout must use.
            \bigbreak \noindent 
         It tells the GridLayout parent:
            \begin{itemize}
                \item Which row and column this child belongs to
                \item How many cells to span
                \item How to align inside those cells
                \item How much margin space it should have
            \end{itemize}
            For example,
            \bigbreak \noindent 
            \begin{javacode}
                Button btn = new Button(this);
                btn.setText("Hi");

                GridLayout.LayoutParams btnLp = new GridLayout.LayoutParams(
                        GridLayout.spec(0),  // row 0
                        GridLayout.spec(1)   // column 1
                );
                btnLp.width = GridLayout.LayoutParams.WRAP_CONTENT;
                btnLp.height = GridLayout.LayoutParams.WRAP_CONTENT;

                btn.setLayoutParams(btnLp);
                grid.addView(btn);
            \end{javacode}
            \bigbreak \noindent 
            \texttt{GridLayout.spec(int index)} creates a Spec object. A Spec describes a position in either rows or columns. Here, GridLayout.spec(0) means row 0 (the first row), and GridLayout.spec(1) means the first column.
        \item \textbf{GridLayout.spec overloads}:
            \bigbreak \noindent 
            \begin{javacode}
                GridLayout.spec(int index) // Single index, default span=1, default alignment = UNDEFINED
                GridLayout.spec(int index, int size) // Index + span
                GridLayout.spec(int index, Alignment align) // Index + alignment
                GridLayout.spec(int index, int size, Alignment align) // Index + span + alignment
            \end{javacode}
            You can pass these alignment constants:
            \begin{itemize}
                \item \textbf{GridLayout.START}: align to start (left or top).
                \item \textbf{GridLayout.END}: align to end (right or bottom).
                \item \textbf{GridLayout.CENTER}: center inside the cell.
                \item \textbf{GridLayout.FILL}: expand to fill the cell.
            \end{itemize}
            (BASELINE exists for aligning text baselines in rows.)

        \item \textbf{Rule of thumb}: 
            Use ViewGroup.LayoutParams when sizing a container relative to its parent.
            \bigbreak \noindent 
            Use the container’s own LayoutParams subclass (GridLayout.LayoutParams, LinearLayout.LayoutParams, etc.) when adding children inside that container.
        \item \textbf{Using MarginLayoutParams on GridLayout.setLayoutParams}: This affects the GridLayout as a whole, not its children.
            \bigbreak \noindent 
            For example, 
            \bigbreak \noindent 
            \begin{javacode}
                ViewGroup.MarginLayoutParams lp =
                new ViewGroup.MarginLayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT
                );

                lp.setMargins(20, 40, 20, 40); // left, top, right, bottom in px

                grid.setLayoutParams(lp);
            \end{javacode}

    \end{itemize}

    \pagebreak 
    \subsubsection{Buttons in java}
    \begin{itemize}
        \item \textbf{Subclass}: Buttons are a subclass of TextView, which is a subclass of View 
        \item \textbf{Creating buttons}: There are basically 3 parts:
            \begin{enumerate}
                \item Construct the Button (needs a Context)
                \item Customize it (text, size, colors, etc.)
                \item Add it to a parent layout (like GridLayout, LinearLayout, etc.) with proper LayoutParams.
            \end{enumerate}
            To create the button,
            \bigbreak \noindent 
            \begin{javacode}
            Button myButton = new Button(context);
            \end{javacode}
        \item \textbf{Button methods}:
            \begin{itemize}
                \item setTextSize(int size)
                \item setOnClickListener(listener)
                \item setEnabled(boolean status)
                \item setText(string text)
                \item setLayoutParams(lp)
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{TextView and EditText}
    \begin{itemize}
        \item \textbf{Creating TextView}: TextView is a subclass of View
            \bigbreak \noindent 
            \begin{javacode}
            TextView textView = new TextView(context);
            \end{javacode}
        \item \textbf{TextView methods}:
            \begin{itemize}
                \item setWidth(int w)
                \item setHeight(int h)
                \item setGravity(Gravity g)
                \item setBackgroundColor(Color c)
                \item setTextSize(int size)
                \item setText(string text)
                \item setBackgroundColor(Color c)
                \item setLayoutParams(lp)
                \item setTypeFace(Typeface font, int style)
            \end{itemize}
        \item \textbf{Creating EditText}: EditText is a subclass of TextView, which is a subclass of View
            \bigbreak \noindent 
            \begin{javacode}
            EditText editText = new EditText(context);
            \end{javacode}
        \item \textbf{EditText methods}:
            \begin{itemize}
                \item setWidth(int w)
                \item setHeight(int h)
                \item setHint(String)
                \item setGravity(Gravity g)
                \item setBackgroundColor(Color c)
                \item setTextSize(int size)
                \item setText(string text)
                \item setBackgroundColor(Color c)
                \item setLayoutParams(lp)
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{android.graphics.Color}
    \begin{itemize}
        \item \textbf{Color constants}: This class defines color constants and helper methods for working with colors.
            \bigbreak \noindent 
            \begin{javacode}
            Color.RED
            Color.BLUE
            Color.BLACK
            Color.WHITE
            \end{javacode}
            \bigbreak \noindent 
            These are just integer values representing ARGB colors.
        \item \textbf{Create colors}:
            \begin{itemize}
                \item ARGB values (alpha, red, green, blue):
                \bigbreak \noindent 
                \begin{javacode}
                int myColor = Color.argb(255, 100, 200, 150);
                \end{javacode}
                \bigbreak \noindent 
                Here, 255 = fully opaque.
            \item RGB values (no alpha, alpha = 255):
                \bigbreak \noindent 
                \begin{javacode}
                int myColor = Color.rgb(100, 200, 150);
                \end{javacode}
            \item Parse from string:
                \bigbreak \noindent 
                \begin{javacode}
                int myColor = Color.parseColor("#FF5722");  // hex code
                \end{javacode}
            \end{itemize}

    \end{itemize}



    \pagebreak 
    \subsubsection{android.view.Gravity}
    \begin{itemize}
        \item \textbf{Intro}: This class defines constants used to position or align content inside a View.
            \bigbreak \noindent 
            It doesn’t move the view itself — it controls how the content inside a view (like text in a TextView) or a child inside a parent layout is aligned.
            \begin{itemize}
                \item Gravity.LEFT / Gravity.RIGHT
                \item Gravity.TOP / Gravity.BOTTOM
                \item Gravity.CENTER (both horizontally + vertically)
                \item Gravity.CENTER\_HORIZONTAL
                \item Gravity.CENTER\_VERTICAL
                \item Gravity.FILL (stretch to fill)
            \end{itemize}
            Use bitwise OR (|) to combine:
            \bigbreak \noindent 
            \begin{javacode}
            textView.setGravity(Gravity.CENTER | Gravity.BOTTOM);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsubsection{DiaglogInterface and AlertDialog}
    \begin{itemize}
        \item \textbf{AlertDialog}: A subclass of Dialog. Used to show a modal pop-up window on top of the activity — typically for alerts, confirmations, or choices
            It can have:
            \begin{itemize}
                \item A title
                \item A message
                \item Optional icon
                \item Up to 3 buttons (Positive, Negative, Neutral)
                \item Custom layouts (if you want more than just text)
            \end{itemize}
        \item \textbf{Create an alert}:
            \bigbreak \noindent 
            \begin{javacode}
            AlertDialog.Builder alert = new AlertDialog.Builder(this);
            ...
            AlertDialog dialog = alert.create();
            dialog.show();
            \end{javacode}
        \item \textbf{AlertDialog.builder methods}
            \begin{itemize}
                \item alert.setTitle(string title);
                \item alert.setMessage(string message);
                \item alert.setPositiveButton(string buttonText, DialogInterface.onClickListener);
                \item alert.setNegativeButton(string buttonText, DialogInterface.onClickListener);
                \item alert.show();
            \end{itemize}
        \item \textbf{DialogInterface}: This is just an interface. Many dialog-related classes (including AlertDialog) implement it.
            \bigbreak \noindent 
            \begin{javacode}
                public interface DialogInterface {
                    void cancel();
                    void dismiss();

                    interface OnCancelListener {
                        void onCancel(DialogInterface dialog);
                    }

                    interface OnDismissListener {
                        void onDismiss(DialogInterface dialog);
                    }

                    interface OnClickListener {
                        void onClick(DialogInterface dialog, int which);
                    }

                    // ... and others like OnKeyListener, OnMultiChoiceClickListener
                }
            \end{javacode}
            \bigbreak \noindent 
            It gives you common methods to control the dialog:
            \begin{itemize}
                \item \textbf{dismiss()}: close the dialog
                \item \textbf{cancel()}: cancel the dialog (triggers onCancel() callback)
            \end{itemize}
            It’s also used in listeners for button clicks.
        \item \textbf{DialogInterface.OnClickListener}: We can use this interface to show the alert when something is clicked.
            \bigbreak \noindent 
            \begin{javacode}
                private class MyDialog implements DialogInterface.OnClickListener
                {

                    public void onClick(DialogInterface dialog, int which)
                    {
                        
                    }
                }
            \end{javacode}
            \bigbreak \noindent 
            The which parameter in listeners
            \begin{itemize}
                \item DialogInterface.BUTTON\_POSITIVE (-1)
                \item DialogInterface.BUTTON\_NEGATIVE (-2)
                \item DialogInterface.BUTTON\_NEUTRAL (-3)
            \end{itemize}
            So you know which button was pressed.
            \bigbreak \noindent 
            The dialog parameter is a reference to the dialog that triggered the click. Its type is the interface DialogInterface, but in practice it will usually be an instance of a concrete class like AlertDialog.
            You can use this reference to control the dialog inside the callback:
            \begin{itemize}
                \item \textbf{dialog.dismiss()}: close the dialog immediately.
                \item \textbf{dialog.cancel()}: cancel the dialog (triggers OnCancelListener if one is set).
            \end{itemize}
            \bigbreak \noindent 
            \begin{javacode}
                builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int id) {
                        // dialog is the AlertDialog, typed as DialogInterface
                        dialog.dismiss();   // closes it
                    }
                });
            \end{javacode}

    \end{itemize}

    \pagebreak 
    \subsubsection{GradientDrawable}
    \begin{itemize}
        \item \textbf{Includes}:
            \bigbreak \noindent 
            \begin{javacode}
                import android.graphics.drawable.GradientDrawable;
            \end{javacode}
        \item \textbf{GradientDrawable}: A GradientDrawable is a drawable object (something you can use as a background or graphic) that can display:
            \begin{itemize}
                \item Solid colors, or Gradients (color transitions),
            \end{itemize}
            and can have:
            \begin{itemize}
                \item Rounded corners,
                \item Borders (strokes),
                \item Different shapes (rectangle, oval, line, ring).
            \end{itemize}
            Essentially, it’s Android’s built-in shape painter
        \item \textbf{Creation}:
            \bigbreak \noindent 
            \begin{javacode}
            GradientDrawable shape = new GradientDrawable();
            \end{javacode}
        \item \textbf{Methods}:
            \begin{center}
                \begin{tabular}{p{4cm}|p{4cm}|p{4cm}}
                    \hline
                    \textbf{Method} & \textbf{Description} & \textbf{Example Usage} \\
                    \hline
                    \texttt{setShape(int shape)} & Sets the type: \texttt{RECTANGLE}, \texttt{OVAL}, \texttt{LINE}, \texttt{RING} & \texttt{setShape(GradientDrawable.OVAL)} \\
                    \hline
                    \texttt{setCornerRadius(float radius)} & Rounds the corners (only works for rectangles) & \texttt{setCornerRadius(30f)} \\
                    \hline
                    \texttt{setCornerRadii(float[] radii)} & Gives each corner a different roundness & \texttt{setCornerRadii(new float[]{20,20,0,0,20,20,0,0})} \\
                    \hline
                    \texttt{setColor(int color)} & Fills with a solid color & \texttt{setColor(Color.BLUE)} \\
                    \hline
                    \texttt{setStroke(int width, int color)} & Adds a border & \texttt{setStroke(3, Color.WHITE)} \\
                    \hline
                    \texttt{setGradientType(int type)} & Chooses gradient: \texttt{LINEAR}, \texttt{RADIAL}, \texttt{SWEEP} & \texttt{setGradientType(GradientDrawable.LINEAR\_GRADIENT)} \\
                    \hline
                    \texttt{setColors(int[] colors)} & Defines colors for gradient transitions & \texttt{setColors(new int[]{Color.RED, Color.YELLOW})} \\
                    \hline
                \end{tabular}
            \end{center}
        \item \textbf{Using GradientDrawable}: We can then call .setBackground() on a view, passing in our GradientDrawable.
        \item \textbf{Giving a button rounded edges}:
            \bigbreak \noindent 
            \begin{javacode}
                Button b = new Button();

                GradientDrawable button_shape = new GradientDrawable();
                button_shape.setShape(GradientDrawable.RECTANGLE);
                button_shape.setCornerRadius(35f);
                button_shape.setColor(PURPLE);

                b.setBackground(button_shape);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsubsection{android.graphics.Typeface}
    \begin{itemize}
        \item \textbf{Typeface class}: the Typeface class in Android is the foundation for all text styling related to fonts and weight (bold, italic, etc.). It represents the font face used to render text on screen — in a TextView, Canvas, or anywhere text is drawn.
            \bigbreak \noindent 
            A \texttt{Typeface} is an object that describes the style and family of a font. It defines how text looks — e.g. whether it’s serif or sans-serif, bold or italic, or even a custom font you loaded.
        \item \textbf{Font family constants}:
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{4cm}|p{4cm}|p{4cm}}
                    Constant	&Font family	&Appearance \\
                    \hline \\[0.01cm]
                    Typeface.DEFAULT	&Default system font (usually Roboto on newer Androids)	&Plain \\[2ex]
                    Typeface.SANS\_SERIF	&Sans-serif	&Clean, modern \\[2ex]
                    Typeface.SERIF	&Serif	&Classic (like Times New Roman) \\[2ex]
                    Typeface.MONOSPACE	&Monospace	&Fixed-width (like Courier New)
                \end{tabular}
            \end{center}
        \item \textbf{Weight constants}:
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{4cm}|p{1cm}}
                    Constant	&Style \\ 
                    \hline \\[0.01cm]
                    Typeface.NORMAL	&0 \\[2ex]
                    Typeface.BOLD	&1 \\[2ex]
                    Typeface.ITALIC	&2 \\[2ex]
                    Typeface.BOLD\_ITALIC	&3
                \end{tabular}
            \end{center}
        \item \textbf{Using with setTypeFace}
            \bigbreak \noindent 
            \begin{javacode}
            label.setTypeface(Typeface.SERIF, Typeface.BOLD);
            \end{javacode}
        \item \textbf{Null as a parameter}: We can set the font family but not weight
            \bigbreak \noindent 
            \begin{javacode}
            label.setTypeface(null, Typeface.BOLD);
            \end{javacode}
            \bigbreak \noindent 
            We can set the family but not weight by using the overload that only accepts a family
            \bigbreak \noindent 
            \begin{javacode}
            label.setTypeface(Typeface.SERIF);
            \end{javacode}
        \item \textbf{Loading custom font from res/font}: If you have \texttt{res/font/roboto\_bold.ttf}, you can load it like:
            \bigbreak \noindent 
            \begin{javacode}
                Typeface roboto = ResourcesCompat.getFont(this, R.font.roboto_bold);
                textView.setTypeface(roboto);
            \end{javacode}
            \bigbreak \noindent 
            or programmatically from assets:
            \bigbreak \noindent 
            \begin{javacode}
                Typeface tf = Typeface.createFromAsset(getAssets(), "fonts/CustomFont.ttf");
                textView.setTypeface(tf);
            \end{javacode}
        \item \textbf{Methods}:
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{6cm}|p{6cm}}
                    Method	&Description \\
                    \hline \\[0.01cm]
                    \texttt{create(Typeface family, int style)}	&Returns a new Typeface based on an existing family and style. \\[2ex]
                    \texttt{createFromAsset(AssetManager mgr, String path)}:	&Loads a Typeface from an asset file (assets/fonts/...). \\[2ex]
                    \texttt{createFromFile(File path)}:	&Loads from a file on disk. \\[2ex]
                    \texttt{defaultFromStyle(int style)}:	&Returns the default Typeface for a style (e.g. Typeface.defaultFromStyle(Typeface.BOLD)). \\[2ex]
                    \texttt{equals(Object obj)}:	&Compares two typefaces. \\[2ex]
                    \texttt{hashCode()}:	&Hash for comparison.
                \end{tabular}
            \end{center}

    \end{itemize}

    \pagebreak 
    \subsubsection{Relative layout}
    \begin{itemize}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.RelativeLayout
            \end{javacode}
        \item \textbf{Relative layout}: RelativeLayout is a ViewGroup that lets you position child views relative to each other or to the parent container.
            \bigbreak \noindent 
            Each child view can be placed relative to the parent (top, bottom, left, right, center, etc.) or relative to another view (above, below, to the left/right of another widget).
        \item \textbf{Create a RelativeLayout}:
            \bigbreak \noindent 
            \begin{javacode}
                RelativeLayout layout = new RelativeLayout(this);
                layout.setLayoutParams(new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT
                ));
            \end{javacode}
        \item \textbf{Create RelativeLayout.LayoutParams}
            \bigbreak \noindent 
            \begin{javacode}
            RelativeLayout.LayoutParams rlp = new RelativeLayout.LayoutParams(new ViewGroup.LayoutParams(
                RelativeLayout.LayoutParams.WRAP_CONTENT,
                RelativeLayout.LayoutParams.WRAP_CONTENT
            ));
            \end{javacode}
        \item \textbf{.addRule()}: Adds a layout rule to be interpreted by the RelativeLayout. There are two versions
            \bigbreak \noindent 
            \begin{javacode}
                void addRule(int verb, int subject)
                void addRule(int verb)
            \end{javacode}
            \bigbreak \noindent 
            The first version applies a standalone rule - one that does not reference another view.
            \bigbreak \noindent 
            \begin{javacode}
                params.addRule(RelativeLayout.CENTER_IN_PARENT);
            \end{javacode}
            The rule means: "center this view both horizontally and vertically inside the parent"
            \bigbreak \noindent 
            The second version defines a relationship between this view and another view (by ID).


    \end{itemize}

    \pagebreak 
    \subsubsection{Linear layout}
    \begin{itemize}
        \item \textbf{Creating linear layout with layout params}:
            \bigbreak \noindent 
            \begin{javacode}
                LinearLayout root = new LinearLayout(this);
                root.setOrientation(LinearLayout.VERTICAL);
                root.setPadding(dp(16), dp(16), dp(16), dp(16));
                root.setLayoutParams(new LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.MATCH_PARENT
                ));
                root.setGravity(Gravity.START);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsubsection{Table layout and Table row}
    \begin{itemize}
        \item \textbf{TableLayout}: TableLayout arranges children into rows and columns. But unlike HTML tables, it only positions elements, it does not:
            \begin{itemize}
                \item Draw borders
                \item Automatically size columns evenly
                \item Support row/column spanning without special params
            \end{itemize}
            Each row must be a TableRow, and each TableRow contains children like TextView, EditText, Button, etc.
        \item \textbf{Creating TableLayout}
            \bigbreak \noindent 
            \begin{javacode}
                TableLayout table = new TableLayout(this);
                table.setLayoutParams(new TableLayout.LayoutParams(
                        TableLayout.LayoutParams.MATCH_PARENT,
                        TableLayout.LayoutParams.MATCH_PARENT
                ));
                table.setStretchAllColumns(true); // Makes columns expand evenly
            \end{javacode}
        \item \textbf{Creating rows}:
            \bigbreak \noindent 
            \begin{javacode}
            // Create TableRows and Views (cells)
            for (int i = 0; i < 3; i++) {
                TableRow row = new TableRow(this);
                row.setLayoutParams(new TableLayout.LayoutParams(
                        TableLayout.LayoutParams.MATCH_PARENT,
                        TableLayout.LayoutParams.WRAP_CONTENT
                ));

                for (int j = 0; j < 3; j++) {
                    TextView cell = new TextView(this);
                    cell.setText("R" + i + " C" + j);
                    cell.setPadding(dp(8), dp(8), dp(8), dp(8));
                    cell.setGravity(Gravity.CENTER);

                    row.addView(cell);
                }

                // Add row to table
                table.addView(row);
            }
            \end{javacode}
    \end{itemize}


    \pagebreak 
    \subsubsection{Frame layout}

    \pagebreak 
    \subsubsection{List view}

    \pagebreak 
    \subsubsection{Image view}

    \pagebreak 
    \subsubsection{Compound Button}

    \pagebreak 
    \subsubsection{Check box}

    \pagebreak 
    \subsubsection{RadioGroup and Radio Buttons}

    \pagebreak 
    \subsubsection{Adapter view}

    \pagebreak 
    \subsubsection{Abs spinner}

    \pagebreak 
    \subsubsection{Spinner}

    \pagebreak 
    \subsubsection{Progress bar}

    \pagebreak 
    \subsubsection{Abs seek bar}

    \pagebreak 
    \subsubsection{Seek bar}

    \pagebreak 
    \subsubsection{AttributeSet}

    \pagebreak 
    \subsubsection{Constraint set}

    \pagebreak 
    \subsubsection{defStyleAttr}

    \pagebreak 
    \subsubsection{defStyleRes}

    \pagebreak 
    \subsubsection{android.content.Intent}
    \begin{itemize}
        \item \textbf{Intent}: An Intent is an Android messaging object used to: 
            \begin{itemize}
                \item Start a new Activity
                \item Start a Service
                \item Deliver a broadcast to other apps or system components
                \item Request an action from another app (e.g., open browser, camera)
            \end{itemize}
            An Intent is how Android apps request actions, move between screens, and share data.
        \item \textbf{Explicit intent}: You specify the exact component (Activity) you want to start.
            \bigbreak \noindent 
            \begin{javacode}
                Intent intent = new Intent(MainActivity.this, SecondActivity.class);
                startActivity(intent);
            \end{javacode}
            \bigbreak \noindent 
            Start SecondActivity from MainActivity:
        \item \textbf{Implicit intent}: You ask the system to find an app that can handle the requested action, used to interact with other apps.
            \bigbreak \noindent 
            \begin{javacode}
                Uri url = Uri.parse("https://www.google.com");
                Intent intent = new Intent(Intent.ACTION_VIEW, url);
                startActivity(intent);
            \end{javacode}
            \bigbreak \noindent 
            Here, Android opens whatever browser the user chooses.
        \item \textbf{Passing data with an intent}: To send data to another Activity:
            \bigbreak \noindent 
            \begin{javacode}
                Intent intent = new Intent(MainActivity.this, SecondActivity.class);
                intent.putExtra("username", "Nathan");
                intent.putExtra("age", 21);
                startActivity(intent);
            \end{javacode}
            \bigbreak \noindent 
            Retrieve it in SecondActivity:
            \bigbreak \noindent 
            \begin{javacode}
                String name = getIntent().getStringExtra("username");
                int age = getIntent().getIntExtra("age", 0);
            \end{javacode}
        \item \textbf{Updating AndroidManifest}: When we add an activity to an app, we need to add a corresponding activity element to the AndroidManifest.xml file
            \bigbreak \noindent 
            \begin{javacode}
                <activity
                    android:name=".classname"
                    android:screenOrientation="portrait">
                </activity>
            \end{javacode}
    \end{itemize}


    \pagebreak 
    \subsubsection{android.view.Display}
    \begin{itemize}
        \item \textbf{Display class}: The android.view.Display class represents a physical screen or display device that your app’s UI can be shown on. It provides detailed information about the screen your app is running on — such as its size, refresh rate, orientation, and pixel density.
            \bigbreak \noindent 
            It is useful when adapting layouts, scaling graphics, or handling multi-screen setups
        \item \textbf{Getting a display object}: You usually don’t create Display yourself. Instead, you retrieve it from a system service like \texttt{WindowManager}
            \bigbreak \noindent 
            \begin{javacode}
                WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
                Display display = wm.getDefaultDisplay();
            \end{javacode}
            \bigbreak \noindent 
            Or, with
            \bigbreak \noindent 
            \begin{javacode}
            Display display = getWindowManager().getDefaultDisplay();
            \end{javacode}
            \bigbreak \noindent 
            or, in newer Android versions (API 30+):
            \bigbreak \noindent 
            \begin{javacode}
            Display display = getDisplay();  // available from any Activity or View
            \end{javacode}
            \bigbreak \noindent 
            If you’re in a non-Activity class (like a helper or controller class), you can get it through a Context:
            \bigbreak \noindent 
            \begin{javacode}
                WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
                Display display = wm.getDefaultDisplay();
            \end{javacode}

        \item \textbf{Getting display size}: To get the size of the usable screen in pixels:
            \bigbreak \noindent 
            \begin{javacode}
                Display display = getWindowManager().getDefaultDisplay();

                Point size = new Point();
                display.getSize(size);

                int width = size.x;
                int height = size.y;
            \end{javacode}
        \item \textbf{Getting Real Screen Size}: To include everything (status bar, navigation bar):
            \bigbreak \noindent 
            \begin{javacode}
                Point realSize = new Point();
                display.getRealSize(realSize);
            \end{javacode}
        \item \textbf{Getting Refresh Rate}: Returns how many times per second the screen updates:
            \bigbreak \noindent 
            \begin{javacode}
                float refreshRate = display.getRefreshRate();
            \end{javacode}
        \item \textbf{Getting Display Rotation}: Tells you how the screen is currently rotated relative to its "natural" orientation:
            \bigbreak \noindent 
            \begin{javacode}
            int rotation = display.getRotation();
            \end{javacode}
            \bigbreak \noindent 
            where the possible values are
            \begin{itemize}
                \item \textbf{Surface.ROTATION\_0}:  natural orientation
                \item \textbf{Surface.ROTATION\_90}:  rotated right
                \item \textbf{Surface.ROTATION\_180}:  upside down
                \item \textbf{Surface.ROTATION\_270}:  rotated left
            \end{itemize}
        \item \textbf{Getting Display Metrics}: To obtain screen density and scaling info:
            \bigbreak \noindent 
            \begin{javacode}
                DisplayMetrics metrics = new DisplayMetrics();
                display.getMetrics(metrics);

                int densityDpi = metrics.densityDpi;
                float density = metrics.density;  // Scale factor for dp → px
                float scaledDensity = metrics.scaledDensity;  // Scale for sp → px
            \end{javacode}
        \item \textbf{In Multi-Display or External Display Scenarios}: Starting from Android 4.2+, a device can have multiple displays (like casting to a TV or projector). You can access all of them with:
            \bigbreak \noindent 
            \begin{javacode}
                DisplayManager dm = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
                Display[] displays = dm.getDisplays();
            \end{javacode}
        \item \textbf{Methods}:
            \begin{itemize}
                \item \textbf{getSize(Point)}:	Gets the app-usable screen size (in pixels).
                \item \textbf{getRealSize(Point)}:	Gets the full physical display size.
                \item \textbf{getRotation()}:	Returns the screen rotation (0, 90, 180, 270).
                \item \textbf{getRefreshRate()}:	Returns display refresh rate in Hz.
                \item \textbf{getMetrics(DisplayMetrics)}:	Returns logical density and scaling info.
                \item \textbf{getName()}:	Returns display name (useful in multi-display setups).
            \end{itemize}
    \end{itemize}

    % \pagebreak 
    % \subsubsection{android.hardware.display.DisplayManager}
    % \begin{itemize}
    %     
    % \end{itemize}

    % \pagebreak 
    % \subsubsection{android.view.WindowManager}
    % \begin{itemize}
    %     
    % \end{itemize}

    % \pagebreak 
    % \subsubsection{android.util.DisplayMetrics}
    % \begin{itemize}
    %     
    % \end{itemize}

    \pagebreak 
    \subsubsection{android.view.KeyEvent}
    \begin{itemize}
        \item \textbf{KeyEvent}: \texttt{android.view.KeyEvent} represents a hardware key press or release event — like when the user presses or releases a key on the device’s keyboard, a game controller, or a button such as Volume Up, Back, or Enter.
            \bigbreak \noindent 
            KeyEvent objects are delivered to your app whenever a key action happens.
            \bigbreak \noindent 
            They describe:
            \begin{itemize}
                \item Which key was pressed (keyCode)
                \item Whether it was a press or release
                \item The time, source, modifiers (Shift, Ctrl, etc.)
                \item The Unicode character it represents (if any)
            \end{itemize}
        \item \textbf{Lifecycle}
            \begin{center}
                \begin{tabular}{p{4cm}|p{4cm}|p{4cm}}
                    Stage	&Event Type	&Constant \\
                    \hline \\[0.01cm]
                    Key pressed down	&ACTION\_DOWN	&KeyEvent.ACTION\_DOWN \\[2ex]
                    Key released	&ACTION\_UP	&KeyEvent.ACTION\_UP \\[2ex]
                    Key held (repeats)	&multiple ACTION\_DOWN events	&with getRepeatCount() > 0
                \end{tabular}
            \end{center}
        \item \textbf{Getting a KeyEvent object}: In Android, you don’t manually create KeyEvent objects in most cases. Instead, the Android framework automatically provides them to your app when a user presses or releases a hardware or software key.
            \bigbreak \noindent 
            When a key is pressed, the system calls your Activity, View, or Dialog methods and passes a KeyEvent object as a parameter.
            \begin{itemize}
                \item In an Activity:
                    \bigbreak \noindent 
                    \begin{javacode}
                        @Override
                        public boolean onKeyDown(int keyCode, KeyEvent event) {
                            Log.d("KeyEvent", "Pressed key: " + event.getKeyCode());
                            return super.onKeyDown(keyCode, event);
                        }

                        @Override
                        public boolean onKeyUp(int keyCode, KeyEvent event) {
                            Log.d("KeyEvent", "Released: " + event.getKeyCode());
                            return true;
                        }
                    \end{javacode}
                    \bigbreak \noindent 
                    Here, the system creates and passes the KeyEvent object automatically.
                \item In a View:
                    \bigbreak \noindent 
                    \begin{javacode}
                        @Override
                        public boolean onKeyDown(int keyCode, KeyEvent event) {
                            // Handle key press inside your custom view
                            return true;
                        }
                    \end{javacode}
                    \bigbreak \noindent 
                    Or use a listener:
                    \bigbreak \noindent 
                    \begin{javacode}
                        view.setOnKeyListener(new View.OnKeyListener() {
                            @Override
                            public boolean onKey(View v, int keyCode, KeyEvent event) {
                                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                                    Log.d("KeyEvent", "Key pressed: " + event.getKeyCode());
                                    return true;
                                }
                                return false;
                            }
                        });
                    \end{javacode}

            \end{itemize}
            \bigbreak \noindent 
            \textbf{Note:}  onKeyDown() and onKeyUp() return a boolean because the return value tells the Android framework whether your code has consumed (handled) the key event or no
            \bigbreak \noindent 
            When you return true, it means "I've handled this key event — don’t send it anywhere else."
            \bigbreak \noindent 
            Returning false means: "I didn't handle this — let the system or another component handle it." Then Android passes the event along:
            \begin{itemize}
                \item From the current View up to its parent
                \item From the Activity to the Window
                \item Or eventually to the system (for default behavior)
            \end{itemize}
            super.onKeyDown() calls the default handler in the base Activity class, which performs standard Android behaviors (like handling BACK or MENU keys).
        \item \textbf{Getting the action}
            \bigbreak \noindent 
            \begin{javacode}
            MotionEvent event.getAction()
            \end{javacode}
        \item \textbf{Action constants}:
            \begin{itemize}
                \item \textbf{ACTION\_DOWN}: Key was pressed down
                \item \textbf{ACTION\_UP}: Key was released
                \item \textbf{ACTION\_MULTIPLE}: Multiple repeated key events (e.g., long press)
            \end{itemize}
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent 
            \begin{javacode}
            if (event.getAction() == KeyEvent.ACTION_DOWN) { ... }
            \end{javacode}
        \item \textbf{Getting the key code}:
            \bigbreak \noindent 
            \begin{javacode}
            int event.getKeyCode();
            \end{javacode}
        \item \textbf{Key Code Constants}: These tell you which key was pressed.
            \bigbreak \noindent 
            There are hundreds of these - a few common groups:
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_A, KEYCODE_B, ..., KEYCODE_Z
                KEYCODE_0, KEYCODE_1, ..., KEYCODE_9
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_ENTER
                KEYCODE_DEL           // Backspace
                KEYCODE_TAB
                KEYCODE_ESCAPE
                KEYCODE_SPACE
                KEYCODE_BACK
                KEYCODE_MENU
                KEYCODE_HOME
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_VOLUME_UP
                KEYCODE_VOLUME_DOWN
                KEYCODE_MUTE
                KEYCODE_MEDIA_PLAY_PAUSE
                KEYCODE_MEDIA_NEXT
                KEYCODE_MEDIA_PREVIOUS
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_DPAD_UP
                KEYCODE_DPAD_DOWN
                KEYCODE_DPAD_LEFT
                KEYCODE_DPAD_RIGHT
                KEYCODE_BUTTON_A
                KEYCODE_BUTTON_B
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_POWER
                KEYCODE_SLEEP
                KEYCODE_WAKEUP
            \end{javacode}
        \item \textbf{Checking if shift was pressed}:
            \bigbreak \noindent 
            \begin{javacode}
            boolean event.isShiftPressed()
            \end{javacode}
        \item \textbf{Getting meta state}
            \bigbreak \noindent 
            \begin{javacode}
            event.getMetaState()
            \end{javacode}
        \item \textbf{Meta / modifier key flags}: Used for Shift, Alt, Ctrl, etc. These can be combined using bitwise OR (|).
            \begin{itemize}
                \item \textbf{META\_SHIFT\_ON}:	Shift key active
                \item \textbf{META\_ALT\_ON}:	Alt key active
                \item \textbf{META\_CTRL\_ON}:	Control key active
                \item \textbf{META\_META\_ON}:	Meta/Command key active
                \item \textbf{META\_SYM\_ON}:	Symbol modifier active
                \item \textbf{META\_CAPS\_LOCK\_ON}:	Caps lock active
                \item \textbf{META\_NUM\_LOCK\_ON}:	Num lock active
                \item \textbf{META\_SCROLL\_LOCK\_ON}:	Scroll lock active
            \end{itemize}
        \item \textbf{KeyEvent Methods}
            \begin{itemize}
                \item \textbf{getAction()}:	int	Down, Up, or Multiple
                \item \textbf{getKeyCode()}:	int	Which key was pressed
                \item \textbf{getMetaState()}:	int	Modifier flags
                \item \textbf{getRepeatCount()}:	int	How many times repeated
                \item \textbf{getEventTime()}:	long	Time when event occurred
                \item \textbf{getDownTime()}:	long	Time when key was first pressed
                \item \textbf{getDeviceId()}:	int	ID of the input device (keyboard/gamepad)
                \item \textbf{getScanCode()}:	int	Raw hardware scan code
                \item \textbf{getUnicodeChar()}:	int	Unicode value (e.g., 'A' → 65)
                \item \textbf{getFlags()}:	int	Internal system flags
                \item \textbf{getSource()}:	int	Input source (keyboard, gamepad, etc.)
                \item \textbf{isShiftPressed()}:	boolean	True if Shift active
                \item \textbf{isCtrlPressed()}:	boolean	True if Ctrl active
                \item \textbf{isAltPressed()}:	boolean	True if Alt active 
            \end{itemize}
        \item \textbf{Other useful constants}
            \begin{itemize}
                \item \textbf{Action Constants}:	ACTION\_DOWN, ACTION\_UP
                \item \textbf{Key Codes}:	KEYCODE\_A, KEYCODE\_ENTER, KEYCODE\_BACK
                \item \textbf{Meta Flags}:	META\_SHIFT\_ON, META\_CTRL\_ON
                \item \textbf{Event Data Members}:	getAction(), getKeyCode(), getDownTime(), getRepeatCount(), etc.
                \item \textbf{Flags}:	FLAG\_LONG\_PRESS, FLAG\_SOFT\_KEYBOARD, etc.
            \end{itemize}

    \end{itemize}
    
    \pagebreak 
    \subsubsection{Animations}
    \begin{itemize}
        \item \textbf{Create AnimationSet}:
            \bigbreak \noindent 
            \begin{javacode}
            AnimationSet animation = new AnimationSet(boolean shareInterpolator)
            \end{javacode}
            \bigbreak \noindent 
            An Interpolator controls the animation speed pattern over time:
            \begin{itemize}
                \item \textbf{true}: (default)	All animations inside AnimationSet use the same interpolator (the one set on the AnimationSet itself)
                \item \textbf{false}:	Each animation can define its own interpolator
            \end{itemize}
            \bigbreak \noindent 
            \begin{javacode}
                AnimationSet set = new AnimationSet(true); // true = share interpolator

                // Fade-in animation
                AlphaAnimation alpha = new AlphaAnimation(0f, 1f);
                alpha.setDuration(1000);

                // Move-up animation
                TranslateAnimation move = new TranslateAnimation(
                0, 0,
                50f, 0f
                );
                move.setDuration(1000);

                // Add animations to set
                set.addAnimation(alpha);
                set.addAnimation(move);

                // Start the animation
                view.startAnimation(set);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsubsection{SharedPreferences, SharedPreferences.Editor, and PreferencesManager}
    \begin{itemize}
        \item \textbf{Get a SharedPreferences object}
            \bigbreak \noindent 
            \begin{javacode}
                SharedPreferences prefs = getSharedPreferences("MyPrefs", MODE_PRIVATE);
            \end{javacode}
            \begin{itemize}
                \item \textbf{"MyPrefs"}: the filename to store in
                \item \textbf{MODE\_PRIVATE}: → only your app can access it
            \end{itemize}
        \item \textbf{Write / save data}:
            \bigbreak \noindent 
            \begin{javacode}
                SharedPreferences.Editor editor = prefs.edit();
                editor.putString("username", "Nate");
                editor.putBoolean("isDarkMode", true);
                editor.apply(); // async (recommended)
            \end{javacode}
            \begin{itemize}
                \item \textbf{.apply()}: saves in the background
                \item \textbf{.commit()}: saves immediately but blocks the thread — only use if you must know the result instantly
            \end{itemize}
        \item \textbf{Read data}
            \bigbreak \noindent 
            \begin{javacode}
                String username = prefs.getString("username", "Guest");
                boolean darkMode = prefs.getBoolean("isDarkMode", false);
            \end{javacode}
            \bigbreak \noindent 
            The second argument is the default value if the key does not exist
        \item \textbf{Remove data}
            \bigbreak \noindent 
            \begin{javacode}
                prefs.edit().remove("username").apply();
            \end{javacode}
        \item \textbf{Wipe everything}
            \bigbreak \noindent 
            \begin{javacode}
                prefs.edit().clear().apply();
            \end{javacode}
        \item \textbf{Where is the data stored}: SharedPreferences saves to:
            \bigbreak \noindent 
            \begin{bashcode}
                /data/data/<your package name>/shared_prefs/MyPrefs.xml
            \end{bashcode}

    \end{itemize}

    \pagebreak 
    \subsubsection{Menu and MenuItem}
    \begin{itemize}
        \item \textbf{Which menu type?}: We use the Menu and MenuItem class to create an \textbf{Options Menu}.
        \item \textbf{Creating an options menu}: We override \texttt{onCreateOptionsMenu()}. Android automatically calls this when the Activity starts. Here, you’ll use the Menu object (passed as a parameter) to add items manually.
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    // groupId, itemId, order, title
                    menu.add(0, 101, 0, "Settings");
                    menu.add(0, 102, 1, "Help");
                    menu.add(0, 103, 2, "Exit");

                    // You can also configure each item after adding it
                    MenuItem settingsItem = menu.findItem(101);
                    settingsItem.setIcon(android.R.drawable.ic_menu_preferences);
                    settingsItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);

                    return true;  // tells Android to display this menu
                }
            \end{javacode}
            \bigbreak \noindent 
            menu is the Menu interface object, menu.add(...) returns a MenuItem object. You can customize each MenuItem afterward.
        \item \textbf{Handle clicks}: When the user taps a menu item, Android passes a MenuItem object representing what was clicked.
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onOptionsItemSelected(MenuItem item) {
                    switch (item.getItemId()) {
                        case 101:
                        Toast.makeText(this, "Settings clicked", Toast.LENGTH_SHORT).show();
                        return true;
                        case 102:
                        Toast.makeText(this, "Help clicked", Toast.LENGTH_SHORT).show();
                        return true;
                        case 103:
                        finish(); // close app
                        return true;
                        default:
                        return super.onOptionsItemSelected(item);
                    }
                }
            \end{javacode}



    \end{itemize}

    \pagebreak 
    \subsubsection{SubMenu}
    \begin{itemize}
        \item \textbf{What is a SubMenu}: A SubMenu is basically a menu nested inside another menu item. SubMenu is an interface that extends Menu, you don’t instantiate it directly — instead, you get it from a Menu object using addSubMenu()
            \bigbreak \noindent 
        \item \textbf{Example, creating SubMenu}:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    // Create a regular menu item
                    menu.add(0, 1, 0, "Settings");

                    // Create a submenu under "File"
                    SubMenu fileSubMenu = menu.addSubMenu("File");

                    // Add items to that submenu
                    fileSubMenu.add(0, 2, 0, "New");
                    fileSubMenu.add(0, 3, 1, "Open");
                    fileSubMenu.add(0, 4, 2, "Save");

                    // Another normal menu item
                    menu.add(0, 5, 3, "Help");

                    return true;
                }
            \end{javacode}
        \item \textbf{Handle clicks}: You handle clicks the same way as normal menu items:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onOptionsItemSelected(MenuItem item) {
                    switch (item.getItemId()) {
                        case 1:
                            Toast.makeText(this, "Settings clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 2:
                            Toast.makeText(this, "New clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 3:
                            Toast.makeText(this, "Open clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 4:
                            Toast.makeText(this, "Save clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 5:
                            Toast.makeText(this, "Help clicked", Toast.LENGTH_SHORT).show();
                            return true;
                    }
                    return super.onOptionsItemSelected(item);
                }
            \end{javacode}
        \item \textbf{SubMenus in XML}: Example,
            \bigbreak \noindent 
            \begin{xmlcode}
                <menu xmlns:android="http://schemas.android.com/apk/res/android">
                    <item android:title="File">
                        <menu>
                            <item android:id="@+id/action_new" android:title="New" />
                            <item android:id="@+id/action_open" android:title="Open" />
                            <item android:id="@+id/action_save" android:title="Save" />
                        </menu>
                    </item>
                    <item android:id="@+id/action_help" android:title="Help" />
                </menu>
            \end{xmlcode}
            \bigbreak \noindent 
            Same structure; you just nest a <menu> inside an <item>.
    \end{itemize}

    \pagebreak 
    \subsubsection{ContextMenu}
    \begin{itemize}
        \item \textbf{What is it}: Context menus appear when you long-press a View — like text, a button, or a list item. They’re used for actions specific to that item, not the whole Activity.
        \item \textbf{Register a view for a Context Menu}: We use \texttt{registerForContextMenu(view v)}
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onCreate(Bundle savedInstanceState) {
                    super.onCreate(savedInstanceState);
                    setContentView(R.layout.activity_main);

                    TextView myTextView = findViewById(R.id.myTextView);

                    // Tell Android this view should show a context menu on long-press
                    registerForContextMenu(myTextView);
                }
            \end{javacode}
        \item \textbf{Override onCreateContextMenu}: This method is called automatically when the user long-presses the registered view. Here you use the Menu interface to build the menu in code.
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public void onCreateContextMenu(ContextMenu menu, View v,
                                                ContextMenu.ContextMenuInfo menuInfo) {
                    super.onCreateContextMenu(menu, v, menuInfo);

                    // You can set a header or title
                    menu.setHeaderTitle("Choose an action");

                    // Add items programmatically
                    menu.add(0, 101, 0, "Edit");
                    menu.add(0, 102, 1, "Share");
                    menu.add(0, 103, 2, "Delete");
                }
            \end{javacode}
            \bigbreak \noindent 
            \begin{itemize}
                \item \textbf{ContextMenu Menu}: This is the menu object that you fill with items.
                \item \textbf{View v}: The view that was long pressed
                \item \textbf{ContextMenu.ContextMenuInfo menuInfo}: Provides extra context information about the view that was pressed. It’s often null unless the view supports structured data — e.g., a ListView or RecyclerView.
                    \bigbreak \noindent 
                    For lists, it contains which row was long-pressed:
            \end{itemize}
            You call super to allow the parent class (AppCompatActivity) to perform its own setup logic before or after you modify the menu.
        \item \textbf{Handle clicks}:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onContextItemSelected(MenuItem item) {
                    switch (item.getItemId()) {
                        case 101:
                            Toast.makeText(this, "Edit clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 102:
                            Toast.makeText(this, "Share clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 103:
                            Toast.makeText(this, "Delete clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        default:
                            return super.onContextItemSelected(item);
                    }
                }
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsubsection{PopupMenu}
    \begin{itemize}
        \item \textbf{What is it}: A PopupMenu is a small floating menu that appears anchored to a specific View — for example, when you tap a button with “$\vdots$” or “More options.”
            It’s a temporary dropdown menu used for quick actions — not tied to the Action Bar or long-press events.
            \bigbreak \noindent 
        \item \textbf{Example}:
            \bigbreak \noindent 
            \begin{javacode}
                Button button = findViewById(R.id.myButton);

                button.setOnClickListener(v -> {
                    // Create the popup menu, anchored to the button
                    PopupMenu popup = new PopupMenu(MainActivity.this, v);

                    // Get the Menu object inside the popup
                    Menu menu = popup.getMenu();

                    // Add items manually
                    menu.add(0, 101, 0, "Edit");
                    menu.add(0, 102, 1, "Share");
                    menu.add(0, 103, 2, "Delete");

                    // Handle clicks on the popup items
                    popup.setOnMenuItemClickListener(item -> {
                        switch (item.getItemId()) {
                            case 101:
                                Toast.makeText(MainActivity.this, "Edit clicked", Toast.LENGTH_SHORT).show();
                                return true;
                            case 102:
                                Toast.makeText(MainActivity.this, "Share clicked", Toast.LENGTH_SHORT).show();
                                return true;
                            case 103:
                                Toast.makeText(MainActivity.this, "Delete clicked", Toast.LENGTH_SHORT).show();
                                return true;
                            default:
                                return false;
                        }
                    });

                    // Finally, show the popup
                    popup.show();
                });
            \end{javacode}
            
    \end{itemize}

    \pagebreak 
    \subsubsection{Toast}
    \begin{itemize}
        \item \textbf{What is it}: A Toast is a small popup message that briefly appears at the bottom (or top/center) of the screen. It automatically disappears after a short time. 
        \item \textbf{Basic syntax}:
            \bigbreak \noindent 
            \begin{javacode}
                Toast.makeText(context, "Hello, world!", Toast.LENGTH_SHORT).show();
            \end{javacode}
            \begin{itemize}
                \item \textbf{context}:	Usually this, or getApplicationContext() — tells Android which app is showing the Toast
                \item \textbf{Toast.LENGTH\_SHORT}:	How long it shows (LENGTH\_SHORT $\approx$ 2s, LENGTH\_LONG $\approx$3.5s)
                \item \textbf{.show()}:	Displays the Toast
            \end{itemize}
        \item \textbf{Duration options}
            \begin{itemize}
                \item \textbf{Toast.LENGTH\_SHORT}:	$\sim$2 seconds
                \item \textbf{Toast.LENGTH\_LONG}:	$\sim$3.5 seconds
            \end{itemize}
        \item \textbf{Changing position}: You can move them using setGravity():
            \bigbreak \noindent 
            \begin{javacode}
            Toast toast = Toast.makeText(this, "Top toast!", Toast.LENGTH_SHORT);
            toast.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL, 0, 200);
            toast.show();
            \end{javacode}
            \bigbreak \noindent 
            The last two numbers (xOffset, yOffset) adjust the offset in pixels
        \item \textbf{Custom Layout Toast}: You can even use a custom XML layout instead of plain text:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutInflater inflater = getLayoutInflater();
                View layout = inflater.inflate(R.layout.custom_toast, findViewById(R.id.toastRoot));

                Toast toast = new Toast(getApplicationContext());
                toast.setDuration(Toast.LENGTH_LONG);
                toast.setView(layout);
                toast.show();
            \end{javacode}
            \bigbreak \noindent 
            And res/layout/custom\_toast.xml might look like:
            \bigbreak \noindent 
            \begin{xmlcode}
                <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    android:id="@+id/toastRoot"
                    android:background="#AA000000"
                    android:padding="10dp"
                    android:orientation="horizontal">
                    <ImageView android:src="@android:drawable/ic_dialog_info" />
                    <TextView
                        android:text="Custom Toast"
                        android:textColor="#fff"
                        android:paddingStart="10dp"/>
                </LinearLayout>
            \end{xmlcode}
    \end{itemize}

    \pagebreak 
    \subsubsection{LayoutInflator}
    \begin{itemize}
        \item \textbf{What is it}: LayoutInflater is a class that converts XML layout files (.xml) into actual View objects in memory — that your app can display or interact with.
            \bigbreak \noindent 
            Your XML layout is like a blueprint for a house. LayoutInflater is the builder that reads that blueprint and constructs the actual house (View hierarchy) in Java.
            \bigbreak \noindent 
            Suppose you have a layout file: \texttt{res/layout/my\_custom\_view.xml}
            \bigbreak \noindent 
            \begin{xmlcode}
                <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    android:orientation="horizontal"
                    android:padding="10dp">
                    <ImageView android:src="@android:drawable/ic_menu_info_details"/>
                    <TextView android:text="Hello LayoutInflater!" android:paddingStart="8dp"/>
                </LinearLayout>
            \end{xmlcode}
            \bigbreak \noindent 
            You can load it into memory like this:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutInflater inflater = getLayoutInflater();   // or LayoutInflater.from(context)
                View view = inflater.inflate(R.layout.my_custom_view, null);
            \end{javacode}
            \bigbreak \noindent 
            Now view is a fully constructed View object tree — a LinearLayout containing an ImageView and TextView.
            \bigbreak \noindent 
            You can then:
            \begin{itemize}
                \item Add it dynamically to another layout
                \item Use it in a custom Toast
                \item Return it from an adapter (for example, in a ListView)
            \end{itemize}
        \item \textbf{inflate()}
            \bigbreak \noindent 
            \begin{javacode}
                View inflate(int resource, ViewGroup root, boolean attachToRoot)
            \end{javacode}
            \bigbreak \noindent 
            Where 
            \begin{itemize}
                \item \textbf{resource}:	The XML layout resource to inflate (e.g., R.layout.my\_view)
                \item \textbf{root}:	Optional parent layout to attach to
                \item \textbf{attachToRoot}:	Whether to attach the inflated layout to root immediately
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ScrollView}
    \begin{itemize}
       \item \textbf{What is it}: A ScrollView is a layout container that provides vertical scrolling for its single child view. 
           \bigbreak \noindent 
           If your content doesn’t fit on the screen (too tall), wrapping it inside a ScrollView lets the user scroll up and down to see the rest.
        \item \textbf{Key Rules}:
            \begin{itemize}
                \item \textbf{Only one direct child}:	A ScrollView can host only one child view. If you need multiple items, put them inside a container like LinearLayout or ConstraintLayout inside the ScrollView.
                \item \textbf{Vertical only}:	ScrollView scrolls vertically. For horizontal scrolling, use HorizontalScrollView.
                \item \textbf{The child must be taller than the screen}: Otherwise, it won’t scroll because everything fits on screen already.
            \end{itemize}
        \item \textbf{Example}:
            \bigbreak \noindent 
            \begin{javacode}
                ScrollView scrollView = new ScrollView(this);
                LinearLayout layout = new LinearLayout(this);
                layout.setOrientation(LinearLayout.VERTICAL);

                // Add some child views
                for (int i = 1; i <= 20; i++) {
                    TextView tv = new TextView(this);
                    tv.setText("Item " + i);
                    layout.addView(tv);
                }

                // Add layout inside scrollview
                scrollView.addView(layout);

                // Set as activity content
                setContentView(scrollView);

            \end{javacode}
        \item \textbf{Scrolling programmatically}
            \bigbreak \noindent 
            \begin{javacode}
                scrollView.fullScroll(View.FOCUS_DOWN); // scroll to bottom
                scrollView.fullScroll(View.FOCUS_UP);   // scroll to top
                scrollView.scrollTo(0, 500);            // scroll to specific Y position
                scrollView.smoothScrollBy(0, 100);      // scroll smoothly
            \end{javacode}
        \item \textbf{Common XML attributes}
            \begin{itemize}
                \item \textbf{android:fillViewport="true"}:	Forces the child view to expand to fill the screen height (even if content is short).
                \item \textbf{android:scrollbars="none"}:	Hide scrollbars.
                \item \textbf{android:fadeScrollbars="false"}:	Keep scrollbars always visible.
                \item \textbf{android:overScrollMode="never"}:	Disable the “stretch” overscroll glow effect.
            \end{itemize}

    \end{itemize}



    \pagebreak 
    \subsection{Java Documentation}
    \subsubsection{View}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.View
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                View(Context context)
                View(Context context, AttributeSet attrs)
                View(Context context, AttributeSet attrs, int defStyleAttr)
                View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}

        \item \textbf{Public methods (Only most important)}
            \begin{itemize}
                % --- Core View Functionality ---
                \item \textbf{void setId(int id)}: Sets the unique identifier for the view.
                \item \textbf{void setVisibility(int visibility)}: Sets whether the view is visible, invisible, or gone.
                \item \textbf{int getVisibility()}: Returns the current visibility state.
                \item \textbf{void setEnabled(boolean enabled)}: Enables or disables user interaction.
                \item \textbf{boolean isEnabled()}: Returns whether the view is currently enabled.
                \item \textbf{void setFocusable(boolean focusable)}: Controls whether the view can gain focus.
                \item \textbf{void requestFocus()}: Requests focus for this view.
                \item \textbf{boolean hasFocus()}: Returns true if this view currently has focus.
                \item \textbf{void invalidate()}: Redraws the view on screen.
                \item \textbf{void requestLayout()}: Requests a new layout pass for this view.
                \item \textbf{void layout(int l, int t, int r, int b)}: Assigns size and position to the view.

                    % --- Event Handling ---
                \item \textbf{void setOnClickListener(View.OnClickListener l)}: Sets a callback to handle click events.
                \item \textbf{void setOnLongClickListener(View.OnLongClickListener l)}: Sets a listener for long press events.
                \item \textbf{boolean performClick()}: Programmatically triggers the click listener.
                \item \textbf{boolean onTouchEvent(MotionEvent event)}: Handles touch interactions.
                \item \textbf{boolean onKeyDown(int keyCode, KeyEvent event)}: Called when a hardware key is pressed.
                \item \textbf{void onDraw(Canvas canvas)}: Called to render the view’s visual content.

                    % --- Layout & Measurement ---
                \item \textbf{void measure(int widthMeasureSpec, int heightMeasureSpec)}: Determines the measured size of the view.
                \item \textbf{int getWidth() / int getHeight()}: Return the current dimensions of the view.
                \item \textbf{int getLeft() / getTop() / getRight() / getBottom()}: Return the view’s position relative to its parent.
                \item \textbf{ViewGroup.LayoutParams getLayoutParams()}: Returns layout parameters assigned to this view.
                \item \textbf{void setLayoutParams(ViewGroup.LayoutParams params)}: Updates the layout parameters.

                    % --- Animation & Position ---
                \item \textbf{ViewPropertyAnimator animate()}: Starts an animation for view properties (translation, alpha, rotation, etc.).
                \item \textbf{void setAlpha(float alpha)}: Sets the transparency (0.0 = fully transparent, 1.0 = opaque).
                \item \textbf{void setTranslationX(float translationX)}: Moves the view horizontally relative to its position.
                \item \textbf{void setTranslationY(float translationY)}: Moves the view vertically relative to its position.
                \item \textbf{void setRotation(float rotation)}: Rotates the view around its pivot point.
                \item \textbf{void setScaleX(float scaleX) / setScaleY(float scaleY)}: Scales the view’s size in X or Y direction.

                    % --- Focus and Interaction ---
                \item \textbf{void setClickable(boolean clickable)}: Enables or disables clickability.
                \item \textbf{void setLongClickable(boolean longClickable)}: Enables long-click behavior.
                \item \textbf{boolean isClickable()}: Returns whether the view handles clicks.
                \item \textbf{boolean isLongClickable()}: Returns whether the view handles long clicks.
                \item \textbf{void setPressed(boolean pressed)}: Sets the pressed state for visual feedback.
                \item \textbf{boolean isPressed()}: Returns whether the view is currently pressed.

                    % --- Accessibility & Description ---
                \item \textbf{void setContentDescription(CharSequence contentDescription)}: Sets a description for accessibility tools.
                \item \textbf{CharSequence getContentDescription()}: Returns the view’s accessibility description.
                \item \textbf{void announceForAccessibility(CharSequence text)}: Announces a message for accessibility services.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                % --- Scrollbars and Drawing ---
                \item \textbf{boolean awakenScrollBars(int startDelay, boolean invalidate)}:  
                    Trigger the scrollbars to draw.

                \item \textbf{boolean awakenScrollBars(int startDelay)}:  
                    Trigger the scrollbars to draw.

                \item \textbf{boolean awakenScrollBars()}:  
                    Trigger the scrollbars to draw.

                \item \textbf{int computeHorizontalScrollExtent()}:  
                    Compute the horizontal extent of the scrollbar thumb within its range.

                \item \textbf{int computeHorizontalScrollOffset()}:  
                    Compute the horizontal offset of the scrollbar thumb within its range.

                \item \textbf{int computeHorizontalScrollRange()}:  
                    Compute the horizontal scrollable range.

                \item \textbf{int computeVerticalScrollExtent()}:  
                    Compute the vertical extent of the scrollbar thumb within its range.

                \item \textbf{int computeVerticalScrollOffset()}:  
                    Compute the vertical offset of the scrollbar thumb within its range.

                \item \textbf{int computeVerticalScrollRange()}:  
                    Compute the vertical scrollable range.

                \item \textbf{void dispatchDraw(Canvas canvas)}:  
                    Called by \texttt{draw()} to draw child views.

                    % --- Event Dispatch ---
                \item \textbf{boolean dispatchGenericFocusedEvent(MotionEvent event)}:  
                    Dispatch a generic motion event to the currently focused view.

                \item \textbf{boolean dispatchGenericPointerEvent(MotionEvent event)}:  
                    Dispatch a generic motion event to the view under the first pointer.

                \item \textbf{boolean dispatchHoverEvent(MotionEvent event)}:  
                    Dispatch a hover event.

                \item \textbf{void dispatchRestoreInstanceState(SparseArray<Parcelable> container)}:  
                    Restores the state for this view and its children.

                \item \textbf{void dispatchSaveInstanceState(SparseArray<Parcelable> container)}:  
                    Saves the state for this view and its children.

                \item \textbf{void dispatchSetActivated(boolean activated)}:  
                    Dispatches activation to all of this view’s children.

                \item \textbf{void dispatchSetPressed(boolean pressed)}:  
                    Dispatches pressed state to all of this view’s children.

                \item \textbf{void dispatchSetSelected(boolean selected)}:  
                    Dispatches selected state to all of this view’s children.

                \item \textbf{void dispatchVisibilityChanged(View changedView, int visibility)}:  
                    Propagates a visibility change down the hierarchy.

                    % --- Drawable and State ---
                \item \textbf{void drawableStateChanged()}:  
                    Called whenever the view’s state changes in a way that affects its drawables.

                \item \textbf{boolean fitSystemWindows(Rect insets)}:  
                    (Deprecated) Apply window insets to adjust for system decorations.

                    % --- Fading Edges and Padding Offsets ---
                \item \textbf{float getBottomFadingEdgeStrength()}:  
                    Returns the intensity of the bottom faded edge.

                \item \textbf{int getBottomPaddingOffset()}:  
                    Amount by which to extend the bottom fading region.

                \item \textbf{float getLeftFadingEdgeStrength()}:  
                    Returns the intensity of the left faded edge.

                \item \textbf{int getLeftPaddingOffset()}:  
                    Amount by which to extend the left fading region.

                \item \textbf{float getRightFadingEdgeStrength()}:  
                    Returns the intensity of the right faded edge.

                \item \textbf{int getRightPaddingOffset()}:  
                    Amount by which to extend the right fading region.

                \item \textbf{float getTopFadingEdgeStrength()}:  
                    Returns the intensity of the top faded edge.

                \item \textbf{int getTopPaddingOffset()}:  
                    Amount by which to extend the top fading region.

                \item \textbf{boolean isPaddingOffsetRequired()}:  
                    Returns true if this view draws inside its padding and requires offset support.

                    % --- Scroll, Layout, and Sizing ---
                \item \textbf{int getSuggestedMinimumHeight()}:  
                    Returns the suggested minimum height for this view.

                \item \textbf{int getSuggestedMinimumWidth()}:  
                    Returns the suggested minimum width for this view.

                \item \textbf{boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent)}:  
                    Scrolls the view with standard over-scroll behavior.

                \item \textbf{void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)}:  
                    Responds to an over-scroll operation.

                \item \textbf{void onScrollChanged(int l, int t, int oldl, int oldt)}:  
                    Called when the view scrolls its own content.

                    % --- Window and Configuration ---
                \item \textbf{void onAttachedToWindow()}:  
                    Called when the view is attached to a window.

                \item \textbf{void onDetachedFromWindow()}:  Called when the view is detached from a window.
                \item \textbf{void onConfigurationChanged(Configuration newConfig)}:  Called when the app configuration changes (e.g., orientation).
                \item \textbf{void onDisplayHint(int hint)}:  Receives a hint about whether the view is displayed or not.
                \item \textbf{int getWindowAttachCount()}:  Returns how many times this view has been attached to a window.
                    % --- Layout and Measurement ---
                \item \textbf{void onLayout(boolean changed, int left, int top, int right, int bottom)}:  
                    Called when assigning size and position to child views.

                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}:  
                    Measures the view’s width and height.

                \item \textbf{final void setMeasuredDimension(int measuredWidth, int measuredHeight)}:  
                    Must be called in \texttt{onMeasure()} to store measured dimensions.

                \item \textbf{void onSizeChanged(int w, int h, int oldw, int oldh)}:  
                    Called when the size of this view changes during layout.

                    % --- Drawing and Animation ---
                \item \textbf{void onDraw(Canvas canvas)}:  
                    Implement this to perform custom drawing.

                \item \textbf{final void onDrawScrollBars(Canvas canvas)}:  
                    Draws horizontal and vertical scrollbars.

                \item \textbf{void onAnimationStart()}:  
                    Called when an animation starts.

                \item \textbf{void onAnimationEnd()}:  
                    Called when an animation ends.

                \item \textbf{boolean onSetAlpha(int alpha)}:  
                    Called when a transform involving alpha occurs.

                    % --- Context and Menu ---
                \item \textbf{void onCreateContextMenu(ContextMenu menu)}:  
                    Implement if the view contributes items to a context menu.

                \item \textbf{ContextMenu.ContextMenuInfo getContextMenuInfo()}:  
                    Returns extra info associated with the context menu.

                    % --- Drawable States and Verification ---
                \item \textbf{int[] onCreateDrawableState(int extraSpace)}:  
                    Generates the new drawable state array for this view.

                \item \textbf{boolean verifyDrawable(Drawable who)}:  
                    Override if the view displays custom drawables; return true for those drawables.

                \item \textbf{static int[] mergeDrawableStates(int[] baseState, int[] additionalState)}:  
                    Merges additional drawable states into the base state.

                    % --- Focus and Visibility ---
                \item \textbf{void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)}:  
                    Called when the focus state of this view changes.

                \item \textbf{void onVisibilityChanged(View changedView, int visibility)}:  
                    Called when the visibility of this view or its ancestor changes.

                \item \textbf{void onWindowVisibilityChanged(int visibility)}:  
                    Called when the containing window’s visibility changes (GONE, INVISIBLE, or VISIBLE).

                    % --- State Saving and Restoration ---
                \item \textbf{Parcelable onSaveInstanceState()}:  
                    Generates a representation of this view’s internal state for later restoration.

                \item \textbf{void onRestoreInstanceState(Parcelable state)}:  
                    Restores the view’s internal state from a saved instance.

                \item \textbf{void dispatchRestoreInstanceState(SparseArray<Parcelable> container)}:  
                    Restores hierarchy state for this view and its children.

                \item \textbf{void dispatchSaveInstanceState(SparseArray<Parcelable> container)}:  
                    Saves hierarchy state for this view and its children.
            \end{itemize}

        \item \textbf{Fields}
            \begin{itemize}
                % --- Property Wrappers ---
                \item \textbf{public static final Property<View, Float> ALPHA}:  
                    A Property wrapper around the alpha functionality handled by the \texttt{View.setAlpha(float)} and \texttt{View.getAlpha()} methods.

                \item \textbf{public static final Property<View, Float> ROTATION}:  
                    A Property wrapper around the rotation functionality handled by \texttt{View.setRotation(float)} and \texttt{View.getRotation()}.

                \item \textbf{public static final Property<View, Float> ROTATION\_X}:  
                    A Property wrapper around the rotationX functionality handled by \texttt{View.setRotationX(float)} and \texttt{View.getRotationX()}.

                \item \textbf{public static final Property<View, Float> ROTATION\_Y}:  
                    A Property wrapper around the rotationY functionality handled by \texttt{View.setRotationY(float)} and \texttt{View.getRotationY()}.

                \item \textbf{public static final Property<View, Float> SCALE\_X}:  
                    A Property wrapper around the scaleX functionality handled by \texttt{View.setScaleX(float)} and \texttt{View.getScaleX()}.

                \item \textbf{public static final Property<View, Float> SCALE\_Y}:  
                    A Property wrapper around the scaleY functionality handled by \texttt{View.setScaleY(float)} and \texttt{View.getScaleY()}.

                \item \textbf{public static final Property<View, Float> TRANSLATION\_X}:  
                    A Property wrapper around the translationX functionality handled by \texttt{View.setTranslationX(float)} and \texttt{View.getTranslationX()}.

                \item \textbf{public static final Property<View, Float> TRANSLATION\_Y}:  
                    A Property wrapper around the translationY functionality handled by \texttt{View.setTranslationY(float)} and \texttt{View.getTranslationY()}.

                \item \textbf{public static final Property<View, Float> TRANSLATION\_Z}:  
                    A Property wrapper around the translationZ functionality handled by \texttt{View.setTranslationZ(float)} and \texttt{View.getTranslationZ()}.

                \item \textbf{public static final Property<View, Float> X}:  
                    A Property wrapper around the x-position handled by \texttt{View.setX(float)} and \texttt{View.getX()}.

                \item \textbf{public static final Property<View, Float> Y}:  
                    A Property wrapper around the y-position handled by \texttt{View.setY(float)} and \texttt{View.getY()}.

                \item \textbf{public static final Property<View, Float> Z}:  
                    A Property wrapper around the z-position handled by \texttt{View.setZ(float)} and \texttt{View.getZ()}.

                    % --- View State Sets ---
                \item \textbf{protected static final int[] EMPTY\_STATE\_SET}:  
                    Indicates the view has no states set.

                \item \textbf{protected static final int[] ENABLED\_STATE\_SET}:  
                    Indicates the view is enabled.

                \item \textbf{protected static final int[] ENABLED\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is enabled and has focus.

                \item \textbf{protected static final int[] ENABLED\_SELECTED\_STATE\_SET}:  
                    Indicates the view is enabled and selected.

                \item \textbf{protected static final int[] ENABLED\_FOCUSED\_SELECTED\_STATE\_SET}:  
                    Indicates the view is enabled, focused, and selected.

                \item \textbf{protected static final int[] ENABLED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is enabled and its window has focus.

                \item \textbf{protected static final int[] ENABLED\_FOCUSED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is enabled, focused, and its window has focus.

                \item \textbf{protected static final int[] ENABLED\_SELECTED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is enabled, selected, and its window has focus.

                \item \textbf{protected static final int[] ENABLED\_FOCUSED\_SELECTED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is enabled, focused, selected, and its window has focus.

                \item \textbf{protected static final int[] FOCUSED\_STATE\_SET}:  
                    Indicates the view is focused.

                \item \textbf{protected static final int[] SELECTED\_STATE\_SET}:  
                    Indicates the view is selected.

                \item \textbf{protected static final int[] WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view's window has focus.

                \item \textbf{protected static final int[] PRESSED\_STATE\_SET}:  
                    Indicates the view is pressed.

                    % --- Complex State Combinations ---
                \item \textbf{protected static final int[] PRESSED\_ENABLED\_STATE\_SET}:  
                    Indicates the view is pressed and enabled.

                \item \textbf{protected static final int[] PRESSED\_ENABLED\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is pressed, enabled, and focused.

                \item \textbf{protected static final int[] PRESSED\_ENABLED\_SELECTED\_STATE\_SET}:  
                    Indicates the view is pressed, enabled, and selected.

                \item \textbf{protected static final int[] PRESSED\_ENABLED\_FOCUSED\_SELECTED\_STATE\_SET}:  
                    Indicates the view is pressed, enabled, focused, and selected.

                \item \textbf{protected static final int[] PRESSED\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is pressed and focused.

                \item \textbf{protected static final int[] PRESSED\_SELECTED\_STATE\_SET}:  
                    Indicates the view is pressed and selected.

                \item \textbf{protected static final int[] FOCUSED\_SELECTED\_STATE\_SET}:  
                    Indicates the view is focused and selected.

                \item \textbf{protected static final int[] PRESSED\_ENABLED\_FOCUSED\_SELECTED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is pressed, enabled, focused, selected, and its window has the focus.

                \item \textbf{protected static final int[] PRESSED\_ENABLED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is pressed, enabled, and its window has focus.

                \item \textbf{protected static final int[] PRESSED\_FOCUSED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is pressed, focused, and its window has focus.

                \item \textbf{protected static final int[] PRESSED\_SELECTED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is pressed, selected, and its window has focus.

                \item \textbf{protected static final int[] SELECTED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is selected and its window has focus.

                \item \textbf{protected static final int[] FOCUSED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is focused and its window has focus.

                \item \textbf{protected static final int[] PRESSED\_FOCUSED\_SELECTED\_STATE\_SET}:  
                    Indicates the view is pressed, focused, and selected.

                \item \textbf{protected static final int[] PRESSED\_FOCUSED\_SELECTED\_WINDOW\_FOCUSED\_STATE\_SET}:  
                    Indicates the view is pressed, focused, selected, and its window has focus.
            \end{itemize}

        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int ACCESSIBILITY\_DATA\_SENSITIVE\_AUTO}: Automatically determine whether only accessibility tools may interact with this view.
                \item \textbf{int ACCESSIBILITY\_DATA\_SENSITIVE\_NO}: Allow interactions from all AccessibilityServices.
                \item \textbf{int ACCESSIBILITY\_DATA\_SENSITIVE\_YES}: Only allow interactions from AccessibilityServices marked as tools.
                \item \textbf{int ACCESSIBILITY\_LIVE\_REGION\_ASSERTIVE}: Announce changes immediately.
                \item \textbf{int ACCESSIBILITY\_LIVE\_REGION\_NONE}: Do not automatically announce changes.
                \item \textbf{int ACCESSIBILITY\_LIVE\_REGION\_POLITE}: Announce changes politely.
                \item \textbf{int AUTOFILL\_FLAG\_INCLUDE\_NOT\_IMPORTANT\_VIEWS}: Include not-important-for-autofill views in \texttt{ViewStructure}.
                \item \textbf{String AUTOFILL\_HINT\_CREDIT\_CARD\_EXPIRATION\_DATE}: Hint for credit card expiration date.
                \item \textbf{String AUTOFILL\_HINT\_CREDIT\_CARD\_EXPIRATION\_DAY}: Hint for credit card expiration day.
                \item \textbf{String AUTOFILL\_HINT\_CREDIT\_CARD\_EXPIRATION\_MONTH}: Hint for credit card expiration month.
                \item \textbf{String AUTOFILL\_HINT\_CREDIT\_CARD\_EXPIRATION\_YEAR}: Hint for credit card expiration year.
                \item \textbf{String AUTOFILL\_HINT\_CREDIT\_CARD\_NUMBER}: Hint for credit card number.
                \item \textbf{String AUTOFILL\_HINT\_CREDIT\_CARD\_SECURITY\_CODE}: Hint for credit card CVC/CVV.
                \item \textbf{String AUTOFILL\_HINT\_EMAIL\_ADDRESS}: Hint for email address.
                \item \textbf{String AUTOFILL\_HINT\_NAME}: Hint for real name.
                \item \textbf{String AUTOFILL\_HINT\_PASSWORD}: Hint for password.
                \item \textbf{String AUTOFILL\_HINT\_PHONE}: Hint for phone number.
                \item \textbf{String AUTOFILL\_HINT\_POSTAL\_ADDRESS}: Hint for postal address.
                \item \textbf{String AUTOFILL\_HINT\_POSTAL\_CODE}: Hint for postal/ZIP code.
                \item \textbf{String AUTOFILL\_HINT\_USERNAME}: Hint for username.
                \item \textbf{int AUTOFILL\_TYPE\_DATE}: Field is a date (millis since epoch).
                \item \textbf{int AUTOFILL\_TYPE\_LIST}: Field is a selection list (int index).
                \item \textbf{int AUTOFILL\_TYPE\_NONE}: Not autofillable.
                \item \textbf{int AUTOFILL\_TYPE\_TEXT}: Field is text.
                \item \textbf{int AUTOFILL\_TYPE\_TOGGLE}: Field is boolean/toggle.
                \item \textbf{int CONTENT\_SENSITIVITY\_AUTO}: Framework determines content sensitivity.
                \item \textbf{int CONTENT\_SENSITIVITY\_NOT\_SENSITIVE}: Content not sensitive.
                \item \textbf{int CONTENT\_SENSITIVITY\_SENSITIVE}: Content is sensitive.
                \item \textbf{int DRAG\_FLAG\_ACCESSIBILITY\_ACTION}: Drag initiated via accessibility action.
                \item \textbf{int DRAG\_FLAG\_GLOBAL}: Drag can cross window boundaries.
                \item \textbf{int DRAG\_FLAG\_GLOBAL\_PERSISTABLE\_URI\_PERMISSION}: Persist granted URI permissions across reboots.
                \item \textbf{int DRAG\_FLAG\_GLOBAL\_PREFIX\_URI\_PERMISSION}: URI permission applies to prefix matches.
                \item \textbf{int DRAG\_FLAG\_GLOBAL\_SAME\_APPLICATION}: Drag can cross windows within same app.
                \item \textbf{int DRAG\_FLAG\_GLOBAL\_URI\_READ}: Recipient may request read access to URIs.
                \item \textbf{int DRAG\_FLAG\_GLOBAL\_URI\_WRITE}: Recipient may request write access to URIs.
                \item \textbf{int DRAG\_FLAG\_HIDE\_CALLING\_TASK\_ON\_DRAG\_START}: Hide caller task during drag.
                \item \textbf{int DRAG\_FLAG\_OPAQUE}: Drag shadow is opaque.
                \item \textbf{int DRAG\_FLAG\_START\_INTENT\_SENDER\_ON\_UNHANDLED\_DRAG}: Delegate unhandled drag to system to start.
                \item \textbf{int DRAWING\_CACHE\_QUALITY\_AUTO}: \textit{Deprecated}. Auto drawing cache quality.
                \item \textbf{int DRAWING\_CACHE\_QUALITY\_HIGH}: \textit{Deprecated}. High drawing cache quality.
                \item \textbf{int DRAWING\_CACHE\_QUALITY\_LOW}: \textit{Deprecated}. Low drawing cache quality.
                \item \textbf{int FIND\_VIEWS\_WITH\_CONTENT\_DESCRIPTION}: Find by content description.
                \item \textbf{int FIND\_VIEWS\_WITH\_TEXT}: Find by text.
                \item \textbf{int FOCUSABLE}: View wants keystrokes.
                \item \textbf{int FOCUSABLES\_ALL}: Add all focusables, regardless of touch mode.
                \item \textbf{int FOCUSABLES\_TOUCH\_MODE}: Add only focusables in touch mode.
                \item \textbf{int FOCUSABLE\_AUTO}: Determine focusability automatically.
                \item \textbf{int FOCUS\_BACKWARD}: Focus search backward.
                \item \textbf{int FOCUS\_DOWN}: Focus search down.
                \item \textbf{int FOCUS\_FORWARD}: Focus search forward.
                \item \textbf{int FOCUS\_LEFT}: Focus search left.
                \item \textbf{int FOCUS\_RIGHT}: Focus search right.
                \item \textbf{int FOCUS\_UP}: Focus search up.
                \item \textbf{int GONE}: View is hidden and takes no space.
                \item \textbf{int HAPTIC\_FEEDBACK\_ENABLED}: Enable haptic feedback.
                \item \textbf{int IMPORTANT\_FOR\_ACCESSIBILITY\_AUTO}: Determine importance for accessibility automatically.
                \item \textbf{int IMPORTANT\_FOR\_ACCESSIBILITY\_NO}: Not important for accessibility.
                \item \textbf{int IMPORTANT\_FOR\_ACCESSIBILITY\_NO\_HIDE\_DESCENDANTS}: Neither view nor descendants are important.
                \item \textbf{int IMPORTANT\_FOR\_ACCESSIBILITY\_YES}: Important for accessibility.
                \item \textbf{int IMPORTANT\_FOR\_AUTOFILL\_AUTO}: Determine importance for autofill automatically.
                \item \textbf{int IMPORTANT\_FOR\_AUTOFILL\_NO}: Not important for autofill; traverse children.
                \item \textbf{int IMPORTANT\_FOR\_AUTOFILL\_NO\_EXCLUDE\_DESCENDANTS}: Not important; do not traverse children.
                \item \textbf{int IMPORTANT\_FOR\_AUTOFILL\_YES}: Important; traverse children.
                \item \textbf{int IMPORTANT\_FOR\_AUTOFILL\_YES\_EXCLUDE\_DESCENDANTS}: Important; do not traverse children.
                \item \textbf{int IMPORTANT\_FOR\_CONTENT\_CAPTURE\_AUTO}: Determine importance for content capture automatically.
                \item \textbf{int IMPORTANT\_FOR\_CONTENT\_CAPTURE\_NO}: Not important; traverse children.
                \item \textbf{int IMPORTANT\_FOR\_CONTENT\_CAPTURE\_NO\_EXCLUDE\_DESCENDANTS}: Not important; exclude children.
                \item \textbf{int IMPORTANT\_FOR\_CONTENT\_CAPTURE\_YES}: Important; traverse children.
                \item \textbf{int IMPORTANT\_FOR\_CONTENT\_CAPTURE\_YES\_EXCLUDE\_DESCENDANTS}: Important; exclude children.
                \item \textbf{int INVISIBLE}: View is invisible but takes space.
                \item \textbf{int KEEP\_SCREEN\_ON}: Keep screen on while visible.
                \item \textbf{int LAYER\_TYPE\_HARDWARE}: Hardware layer.
                \item \textbf{int LAYER\_TYPE\_NONE}: No layer.
                \item \textbf{int LAYER\_TYPE\_SOFTWARE}: Software layer.
                \item \textbf{int LAYOUT\_DIRECTION\_INHERIT}: Inherit layout direction from parent.
                \item \textbf{int LAYOUT\_DIRECTION\_LOCALE}: Layout direction from locale script.
                \item \textbf{int LAYOUT\_DIRECTION\_LTR}: Left-to-right layout.
                \item \textbf{int LAYOUT\_DIRECTION\_RTL}: Right-to-left layout.
                \item \textbf{int MEASURED\_HEIGHT\_STATE\_SHIFT}: Bit shift to height state.
                \item \textbf{int MEASURED\_SIZE\_MASK}: Mask for measured size bits.
                \item \textbf{int MEASURED\_STATE\_MASK}: Mask for measured state bits.
                \item \textbf{int MEASURED\_STATE\_TOO\_SMALL}: Measured size is smaller than desired.
                \item \textbf{int NOT\_FOCUSABLE}: View does not want keystrokes.
                \item \textbf{int NO\_ID}: Marks a view with no ID.
                \item \textbf{int OVER\_SCROLL\_ALWAYS}: Always allow overscroll.
                \item \textbf{int OVER\_SCROLL\_IF\_CONTENT\_SCROLLS}: Allow overscroll only if content can scroll.
                \item \textbf{int OVER\_SCROLL\_NEVER}: Never allow overscroll.
                \item \textbf{int RECTANGLE\_ON\_SCREEN\_REQUEST\_SOURCE\_INPUT\_FOCUS}: Request due to input focus.
                \item \textbf{int RECTANGLE\_ON\_SCREEN\_REQUEST\_SOURCE\_SCROLL\_ONLY}: Request only to scroll, not tied to cursor/focus.
                \item \textbf{int RECTANGLE\_ON\_SCREEN\_REQUEST\_SOURCE\_TEXT\_CURSOR}: Request due to text cursor.
                \item \textbf{int RECTANGLE\_ON\_SCREEN\_REQUEST\_SOURCE\_UNDEFINED}: Request via legacy APIs (undefined source).
                \item \textbf{float REQUESTED\_FRAME\_RATE\_CATEGORY\_DEFAULT}: Preferred frame rate: default.
                \item \textbf{float REQUESTED\_FRAME\_RATE\_CATEGORY\_HIGH}: Preferred frame rate: high.
                \item \textbf{float REQUESTED\_FRAME\_RATE\_CATEGORY\_LOW}: Preferred frame rate: low.
                \item \textbf{float REQUESTED\_FRAME\_RATE\_CATEGORY\_NORMAL}: Preferred frame rate: normal.
                \item \textbf{float REQUESTED\_FRAME\_RATE\_CATEGORY\_NO\_PREFERENCE}: No frame rate preference.
                \item \textbf{int SCREEN\_STATE\_OFF}: Screen is off.
                \item \textbf{int SCREEN\_STATE\_ON}: Screen is on.
                \item \textbf{int SCROLLBARS\_INSIDE\_INSET}: Scrollbars inside padded area; increases padding.
                \item \textbf{int SCROLLBARS\_INSIDE\_OVERLAY}: Scrollbars inside content; no padding increase.
                \item \textbf{int SCROLLBARS\_OUTSIDE\_INSET}: Scrollbars at edge; increases padding.
                \item \textbf{int SCROLLBARS\_OUTSIDE\_OVERLAY}: Scrollbars at edge; no padding increase.
                \item \textbf{int SCROLLBAR\_POSITION\_DEFAULT}: Scrollbar at system default position.
                \item \textbf{int SCROLLBAR\_POSITION\_LEFT}: Scrollbar on left edge.
                \item \textbf{int SCROLLBAR\_POSITION\_RIGHT}: Scrollbar on right edge.
                \item \textbf{int SCROLL\_AXIS\_HORIZONTAL}: Horizontal scroll axis.
                \item \textbf{int SCROLL\_AXIS\_NONE}: No scroll axis.
                \item \textbf{int SCROLL\_AXIS\_VERTICAL}: Vertical scroll axis.
                \item \textbf{int SCROLL\_CAPTURE\_HINT\_AUTO}: Consider for scroll capture if scrollable.
                \item \textbf{int SCROLL\_CAPTURE\_HINT\_EXCLUDE}: Exclude this view from scroll capture.
                \item \textbf{int SCROLL\_CAPTURE\_HINT\_EXCLUDE\_DESCENDANTS}: Exclude descendants from scroll capture.
                \item \textbf{int SCROLL\_CAPTURE\_HINT\_INCLUDE}: Include this view for scroll capture.
                \item \textbf{int SCROLL\_INDICATOR\_BOTTOM}: Scroll indicator on bottom edge.
                \item \textbf{int SCROLL\_INDICATOR\_END}: Scroll indicator on end edge.
                \item \textbf{int SCROLL\_INDICATOR\_LEFT}: Scroll indicator on left edge.
                \item \textbf{int SCROLL\_INDICATOR\_RIGHT}: Scroll indicator on right edge.
                \item \textbf{int SCROLL\_INDICATOR\_START}: Scroll indicator on start edge.
                \item \textbf{int SCROLL\_INDICATOR\_TOP}: Scroll indicator on top edge.
                \item \textbf{int SOUND\_EFFECTS\_ENABLED}: Enable click/touch sound effects.
                \item \textbf{int STATUS\_BAR\_HIDDEN}: \textit{Deprecated}. Use low profile instead.
                \item \textbf{int STATUS\_BAR\_VISIBLE}: \textit{Deprecated}. Use \texttt{SYSTEM\_UI\_FLAG\_VISIBLE}.
                \item \textbf{int SYSTEM\_UI\_FLAG\_FULLSCREEN}: \textit{Deprecated}. Use \texttt{WindowInsetsController.hide(Type.statusBars())}.
                \item \textbf{int SYSTEM\_UI\_FLAG\_HIDE\_NAVIGATION}: \textit{Deprecated}. Use \texttt{WindowInsetsController.hide(Type.navigationBars())}.
                \item \textbf{int SYSTEM\_UI\_FLAG\_IMMERSIVE}: \textit{Deprecated}. Use default behavior.
                \item \textbf{int SYSTEM\_UI\_FLAG\_IMMERSIVE\_STICKY}: \textit{Deprecated}. Use show-transient-bars-by-swipe behavior.
                \item \textbf{int SYSTEM\_UI\_FLAG\_LAYOUT\_FULLSCREEN}: \textit{Deprecated}. See modern insets APIs.
                \item \textbf{int SYSTEM\_UI\_FLAG\_LAYOUT\_HIDE\_NAVIGATION}: \textit{Deprecated}. See modern insets APIs.
                \item \textbf{int SYSTEM\_UI\_FLAG\_LAYOUT\_STABLE}: \textit{Deprecated}. Use \texttt{WindowInsets.getInsetsIgnoringVisibility}.
                \item \textbf{int SYSTEM\_UI\_FLAG\_LIGHT\_NAVIGATION\_BAR}: \textit{Deprecated}. Use appearance flags.
                \item \textbf{int SYSTEM\_UI\_FLAG\_LIGHT\_STATUS\_BAR}: \textit{Deprecated}. Use appearance flags.
                \item \textbf{int SYSTEM\_UI\_FLAG\_LOW\_PROFILE}: \textit{Deprecated}. Hide system bars instead.
                \item \textbf{int SYSTEM\_UI\_FLAG\_VISIBLE}: \textit{Deprecated}. Use \texttt{WindowInsetsController}.
                \item \textbf{int SYSTEM\_UI\_LAYOUT\_FLAGS}: \textit{Deprecated}. System UI layout flags deprecated.
                \item \textbf{int TEXT\_ALIGNMENT\_CENTER}: Center paragraph alignment.
                \item \textbf{int TEXT\_ALIGNMENT\_GRAVITY}: Default for root view (gravity).
                \item \textbf{int TEXT\_ALIGNMENT\_INHERIT}: Inherit text alignment.
                \item \textbf{int TEXT\_ALIGNMENT\_TEXT\_END}: Align to paragraph end.
                \item \textbf{int TEXT\_ALIGNMENT\_TEXT\_START}: Align to paragraph start.
                \item \textbf{int TEXT\_ALIGNMENT\_VIEW\_END}: Align to view end (RTL-aware).
                \item \textbf{int TEXT\_ALIGNMENT\_VIEW\_START}: Align to view start (RTL-aware).
                \item \textbf{int TEXT\_DIRECTION\_ANY\_RTL}: Any-RTL algorithm.
                \item \textbf{int TEXT\_DIRECTION\_FIRST\_STRONG}: First-strong algorithm.
                \item \textbf{int TEXT\_DIRECTION\_FIRST\_STRONG\_LTR}: First-strong, force LTR.
                \item \textbf{int TEXT\_DIRECTION\_FIRST\_STRONG\_RTL}: First-strong, force RTL.
                \item \textbf{int TEXT\_DIRECTION\_INHERIT}: Inherit text direction.
                \item \textbf{int TEXT\_DIRECTION\_LOCALE}: From system locale.
                \item \textbf{int TEXT\_DIRECTION\_LTR}: Force LTR.
                \item \textbf{int TEXT\_DIRECTION\_RTL}: Force RTL.
                \item \textbf{String VIEW\_LOG\_TAG}: Logging tag for this class.
                \item \textbf{int VISIBLE}: View is visible.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ViewGroup}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup 
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.ViewGroup 
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                ViewGroup(Context context)
                ViewGroup(Context context, AttributeSet attrs)
                ViewGroup(Context context, AttributeSet attrs, int defStyleAttr)
                ViewGroup(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void addView(View child)}: Adds a child view to this ViewGroup.
                \item \textbf{void addView(View child, int index)}: Inserts a child view at a specific position.
                \item \textbf{void addView(View child, ViewGroup.LayoutParams params)}: Adds a child with explicit layout params.
                \item \textbf{void addView(View child, int index, ViewGroup.LayoutParams params)}: Inserts a child at a position with params.
                \item \textbf{void addView(View child, int width, int height)}: Adds a child using default params plus width/height.

                \item \textbf{void removeView(View view)}: Removes the specified child view.
                \item \textbf{void removeViewAt(int index)}: Removes the child at the given index.
                \item \textbf{void removeViews(int start, int count)}: Removes a range of children.
                \item \textbf{void removeAllViews()} : Removes all child views.

                \item \textbf{int getChildCount()}: Returns the number of children in this ViewGroup.
                \item \textbf{View getChildAt(int index)}: Returns the child at the specified index.
                \item \textbf{int indexOfChild(View child)}: Returns this child's index within the group.
                \item \textbf{void bringChildToFront(View child)}: Moves a child to the top of the Z-order.

                \item \textbf{boolean dispatchTouchEvent(MotionEvent ev)}: Dispatches touch events down the hierarchy.
                \item \textbf{boolean onInterceptTouchEvent(MotionEvent ev)}: Intercepts touch events before children (gesture handling).
                \item \textbf{void requestDisallowInterceptTouchEvent(boolean disallow)}: Child requests parent not to intercept touch.

                \item \textbf{final void layout(int l, int t, int r, int b)}: Assigns size/position to this view and descendants.
                \item \textbf{static int getChildMeasureSpec(int spec, int padding, int childDimension)}: Computes a child’s MeasureSpec.
                \item \textbf{ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs)}: Creates layout params from XML.

                \item \textbf{void setClipToPadding(boolean clipToPadding)}: Controls clipping of children within padding area.
                \item \textbf{void setClipChildren(boolean clipChildren)}: Controls whether children are clipped to this ViewGroup’s bounds.
                \item \textbf{int getDescendantFocusability()} : Gets how focus is handled among descendants.
                \item \textbf{void setDescendantFocusability(int focusability)}: Sets focus behavior for descendants.
                \item \textbf{View getFocusedChild()} : Returns the currently focused child, if any.
                \item \textbf{View focusSearch(View focused, int direction)}: Finds the next focusable view in a direction.
                \item \textbf{void requestChildFocus(View child, View focused)}: Notifies parent that a child wants focus.

                \item \textbf{void setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener l)}: Listens for child add/remove events.
                \item \textbf{void setLayoutTransition(LayoutTransition transition)}: Animates child appearance/disappearance/changes.
                \item \textbf{void suppressLayout(boolean suppress)}: Temporarily defers layout passes for batched changes.
                \item \textbf{void updateViewLayout(View view, ViewGroup.LayoutParams params)}: Updates layout params for an existing child.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean addViewInLayout(View child, int index, ViewGroup.LayoutParams params, boolean preventRequestLayout)}: Adds a view during layout, optionally preventing a layout request.
                \item \textbf{boolean addViewInLayout(View child, int index, ViewGroup.LayoutParams params)}: Adds a view during layout.
                \item \textbf{void attachLayoutAnimationParameters(View child, ViewGroup.LayoutParams params, int index, int count)}: For subclasses to set layout animation parameters on the child.
                \item \textbf{void attachViewToParent(View child, int index, ViewGroup.LayoutParams params)}: Attaches a view to this ViewGroup.
                \item \textbf{boolean canAnimate()}: Returns whether this ViewGroup can animate its children after first layout.
                \item \textbf{boolean checkLayoutParams(ViewGroup.LayoutParams p)}: Checks if the given LayoutParams are valid for this ViewGroup.
                \item \textbf{void cleanupLayoutState(View child)}: Prevents the specified child from being laid out during the next layout pass.
                \item \textbf{void debug(int depth)}: Outputs debug information about this view hierarchy.
                \item \textbf{void detachAllViewsFromParent()}: Detaches all views from the parent.
                \item \textbf{void detachViewFromParent(int index)}: Detaches the child at the given index from its parent.
                \item \textbf{void detachViewFromParent(View child)}: Detaches the specified child from its parent.
                \item \textbf{void detachViewsFromParent(int start, int count)}: Detaches a range of children from their parent.
                \item \textbf{void dispatchDraw(Canvas canvas)}: Called by \texttt{draw} to draw the child views.
                \item \textbf{void dispatchFreezeSelfOnly(SparseArray<Parcelable> container)}: Saves state only for this view (not its children).
                \item \textbf{boolean dispatchGenericFocusedEvent(MotionEvent event)}: Dispatches a generic motion event to the currently focused view.
                \item \textbf{boolean dispatchGenericPointerEvent(MotionEvent event)}: Dispatches a generic motion event to the view under the first pointer.
                \item \textbf{boolean dispatchHoverEvent(MotionEvent event)}: Dispatches a hover event.
                \item \textbf{void dispatchRestoreInstanceState(SparseArray<Parcelable> container)}: Restores state for this view and its children.
                \item \textbf{void dispatchSaveInstanceState(SparseArray<Parcelable> container)}: Saves state for this view and its children.
                \item \textbf{void dispatchSetPressed(boolean pressed)}: Propagates the pressed state to all children.
                \item \textbf{void dispatchThawSelfOnly(SparseArray<Parcelable> container)}: Restores state only for this view (not its children).
                \item \textbf{void dispatchVisibilityChanged(View changedView, int visibility)}: Dispatches visibility changes down the hierarchy.
                \item \textbf{boolean drawChild(Canvas canvas, View child, long drawingTime)}: Draws a single child of this ViewGroup.
                \item \textbf{void drawableStateChanged()}: Called when the view's state changes in a way that affects shown drawables.
                \item \textbf{ViewGroup.LayoutParams generateDefaultLayoutParams()}: Returns a set of default layout parameters.
                \item \textbf{ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p)}: Returns a safe set of layout params based on the supplied params.
                \item \textbf{int getChildDrawingOrder(int childCount, int drawingPosition)}: Maps drawing-order position to container position.
                \item \textbf{boolean getChildStaticTransformation(View child, Transformation t)}: Sets \texttt{t} to the child's static transform if present; returns true if set.
                \item \textbf{boolean isChildrenDrawingOrderEnabled()}: Returns whether children are drawn in the order from \texttt{getChildDrawingOrder}.
                \item \textbf{boolean isChildrenDrawnWithCacheEnabled()}:\footnotesize~Deprecated (API 23). Child caching forced by parents is ignored; use \texttt{View.setLayerType}. \normalsize
                \item \textbf{void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)}: Measures a child with this ViewGroup's specs and padding.
                \item \textbf{void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)}: Measures a child accounting for margins and used space.
                \item \textbf{void measureChildren(int widthMeasureSpec, int heightMeasureSpec)}: Measures all children with the given specs and padding.
                \item \textbf{void onAttachedToWindow()} : Called when the view is attached to a window.
                \item \textbf{int[] onCreateDrawableState(int extraSpace)}: Generates the Drawable state for this view.
                \item \textbf{void onDetachedFromWindow()} : Called when the view is detached from a window.
                \item \textbf{abstract void onLayout(boolean changed, int l, int t, int r, int b)}: Assigns size and position to each child (subclasses must implement).
                \item \textbf{boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect)}: Requests focus on a suitable descendant.
                \item \textbf{void removeDetachedView(View child, boolean animate)}: Finishes removing a detached view, optionally with animation.
                \item \textbf{void setChildrenDrawingCacheEnabled(boolean enabled)}:\footnotesize~Deprecated (API 28). View drawing cache largely obsolete with hardware acceleration; prefer \texttt{View.setLayerType} or \texttt{PixelCopy} for screenshots. \normalsize
                \item \textbf{void setChildrenDrawingOrderEnabled(boolean enabled)}: Controls whether children are drawn using custom drawing order.
                \item \textbf{void setChildrenDrawnWithCacheEnabled(boolean enabled)}:\footnotesize~Deprecated (API 23). Forcing child render caching is ignored; use \texttt{View.setLayerType}. \normalsize
                \item \textbf{void setStaticTransformationsEnabled(boolean enabled)}: Enables static child transformations (invokes \texttt{getChildStaticTransformation} during draw).
            \end{itemize}

        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int CLIP\_TO\_PADDING\_MASK}: Clips to padding when both \texttt{FLAG\_CLIP\_TO\_PADDING} and \texttt{FLAG\_PADDING\_NOT\_NULL} are set.
                \item \textbf{int FOCUS\_AFTER\_DESCENDANTS}: The view receives focus only if none of its descendants request it.
                \item \textbf{int FOCUS\_BEFORE\_DESCENDANTS}: The view receives focus before any of its descendants.
                \item \textbf{int FOCUS\_BLOCK\_DESCENDANTS}: Prevents any descendants from receiving focus, even if they are focusable.
                \item \textbf{int LAYOUT\_MODE\_CLIP\_BOUNDS}: Layout mode constant that aligns layout to the view’s clip bounds.
                \item \textbf{int LAYOUT\_MODE\_OPTICAL\_BOUNDS}: Layout mode constant that aligns layout to the view’s optical bounds.
                \item \textbf{int PERSISTENT\_ALL\_CACHES}: \textit{Deprecated in API 28.} Formerly kept all drawing caches (animation, scrolling, etc.). Superseded by hardware acceleration and \texttt{View.setLayerType(int, Paint)}.
                \item \textbf{int PERSISTENT\_ANIMATION\_CACHE}: \textit{Deprecated in API 28.} Formerly kept only animation caches. Hardware acceleration now handles such effects efficiently.
                \item \textbf{int PERSISTENT\_NO\_CACHE}: \textit{Deprecated in API 28.} Disabled view drawing caches. Replaced by hardware rendering mechanisms.
                \item \textbf{int PERSISTENT\_SCROLLING\_CACHE}: \textit{Deprecated in API 28.} Formerly maintained caches for scrolling operations; hardware acceleration now replaces this feature.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{ViewGroup.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to $	android.view.ViewGroup.LayoutParams
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.ViewGroup.LayoutParams
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams(Context c, AttributeSet attrs)
                LayoutParams(ViewGroup.LayoutParams source)
                LayoutParams(int width, int height)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	resolveLayoutDirection(int layoutDirection)}: Resolve layout parameters depending on the layout direction.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	setBaseAttributes(TypedArray a, int widthAttr, int heightAttr)}: Extracts the layout parameters from the supplied attributes.
            \end{itemize}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public int	height}: Information about how tall the view wants to be.
                \item \textbf{public LayoutAnimationController.AnimationParameters	layoutAnimationParameters}: Used to animate layouts.
                \item \textbf{public int	width}: Information about how wide the view wants to be.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	FILL\_PARENT}: Special value for the height or width requested by a View.
                \item \textbf{int	MATCH\_PARENT}: Special value for the height or width requested by a View.
                \item \textbf{int	WRAP\_CONTENT}: Special value for the height or width requested by a View.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{ViewGroup.MarginLayoutParams}
    \begin{itemize}
         \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to $	android.view.ViewGroup.LayoutParams $\to$ android.view.ViewGroup.MarginLayoutParams
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.ViewGroup.MarginLayoutParams
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                MarginLayoutParams(Context c, AttributeSet attrs)
                MarginLayoutParams(ViewGroup.LayoutParams source)
                MarginLayoutParams(ViewGroup.MarginLayoutParams source)
                MarginLayoutParams(int width, int height)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{int	getLayoutDirection()}: Retuns the layout direction.
                \item \textbf{int	getMarginEnd()}: Returns the end margin in pixels.
                \item \textbf{int	getMarginStart()}: Returns the start margin in pixels.
                \item \textbf{boolean	isMarginRelative()}: Check if margins are relative.
                \item \textbf{void	resolveLayoutDirection(int layoutDirection)}: This will be called by View.requestLayout().
                \item \textbf{void	setLayoutDirection(int layoutDirection)}: Set the layout direction
                \item \textbf{void	setMarginEnd(int end)}: Sets the relative end margin.
                \item \textbf{void	setMarginStart(int start)}: Sets the relative start margin.
                \item \textbf{void	setMargins(int left, int top, int right, int bottom)}: Sets the margins, in pixels.
            \end{itemize}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public int	bottomMargin}: The bottom margin in pixels of the child.
                \item \textbf{public int	leftMargin}: The left margin in pixels of the child.
                \item \textbf{public int	rightMargin}: The right margin in pixels of the child.
                \item \textbf{public int	topMargin}: The top margin in pixels of the child.
            \end{itemize}

       
    \end{itemize}

    \pagebreak 
    \subsubsection{Context}
    \begin{itemize}
         \item \textbf{Hierarchy} 
             \begin{center}
                 java.lang.Object $\to$	android.content.Context
             \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.content.Context
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Context()
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{Context getApplicationContext()}: Returns the global application context.
                \item \textbf{Resources getResources()}: Provides access to the app's resources (layouts, strings, drawables, etc.).
                \item \textbf{PackageManager getPackageManager()}: Returns a PackageManager for querying installed apps and permissions.
                \item \textbf{ContentResolver getContentResolver()}: Gives access to content providers (e.g., Contacts, MediaStore).
                \item \textbf{SharedPreferences getSharedPreferences(String name, int mode)}: Access or create a preferences file for storing key–value pairs.
                \item \textbf{File getFilesDir()}: Returns the app’s private file storage directory.
                \item \textbf{File getCacheDir()}: Returns the app’s private cache directory.
                \item \textbf{Drawable getDrawable(int id)}: Retrieves a drawable resource styled for the current theme.
                \item \textbf{int getColor(int id)}: Returns a color resource styled for the current theme.
                \item \textbf{String getString(int resId)}: Returns a localized string from resources.
                \item \textbf{String getString(int resId, Object... formatArgs)}: Returns a formatted localized string.
                \item \textbf{void startActivity(Intent intent)}: Launches a new activity.
                \item \textbf{ComponentName startService(Intent service)}: Starts a service.
                \item \textbf{boolean stopService(Intent service)}: Stops a running service.
                \item \textbf{boolean bindService(Intent service, ServiceConnection conn, int flags)}: Connects to a service for interaction.
                \item \textbf{void unbindService(ServiceConnection conn)}: Disconnects from a bound service.
                \item \textbf{void sendBroadcast(Intent intent)}: Sends a broadcast to all interested receivers.
                \item \textbf{Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter)}: Registers a broadcast receiver.
                \item \textbf{void unregisterReceiver(BroadcastReceiver receiver)}: Unregisters a previously registered receiver.
                \item \textbf{Object getSystemService(String name)}: Returns a handle to a system-level service (e.g., \texttt{LAYOUT\_INFLATER\_SERVICE}).
                \item \textbf{<T> T getSystemService(Class<T> serviceClass)}: Type-safe version of \texttt{getSystemService}.
                \item \textbf{Resources.Theme getTheme()}: Returns the current theme for styling and inflation.
                \item \textbf{TypedArray obtainStyledAttributes(int[] attrs)}: Retrieves styled attributes in the current theme.
                \item \textbf{FileInputStream openFileInput(String name)}: Opens a private file for reading.
                \item \textbf{FileOutputStream openFileOutput(String name, int mode)}: Opens a private file for writing.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                % --- Core system & UI services ---
                \item \textbf{String ACTIVITY\_SERVICE}: For \texttt{ActivityManager} (process/app state) via \texttt{getSystemService}.
                \item \textbf{String WINDOW\_SERVICE}: For \texttt{WindowManager} (windows, display metrics).
                \item \textbf{String DISPLAY\_SERVICE}: For \texttt{DisplayManager} (displays, modes).
                \item \textbf{String LAYOUT\_INFLATER\_SERVICE}: For \texttt{LayoutInflater} (inflate XML layouts).
                \item \textbf{String POWER\_SERVICE}: For \texttt{PowerManager} (wake locks, power state).
                \item \textbf{String UI\_MODE\_SERVICE}: For \texttt{UiModeManager} (night mode, car/TV mode).

                    % --- Connectivity / networking ---
                \item \textbf{String CONNECTIVITY\_SERVICE}: For \texttt{ConnectivityManager} (network state, requests).
                \item \textbf{String WIFI\_SERVICE}: For \texttt{WifiManager} (Wi-Fi control).
                \item \textbf{String WIFI\_P2P\_SERVICE}: For \texttt{WifiP2pManager} (Wi-Fi Direct).
                \item \textbf{String TETHERING\_SERVICE}: For \texttt{TetheringManager} (tethering APIs).
                \item \textbf{String USB\_SERVICE}: For \texttt{UsbManager} (USB host/device).
                \item \textbf{String NFC\_SERVICE}: For \texttt{NfcManager} (NFC features).
                \item \textbf{String VPN\_MANAGEMENT\_SERVICE}: For \texttt{VpnManager} (built-in VPN profiles).

                    % --- Location / sensors / hardware ---
                \item \textbf{String LOCATION\_SERVICE}: For \texttt{LocationManager} (location providers).
                \item \textbf{String SENSOR\_SERVICE}: For \texttt{SensorManager} (accelerometer, gyro, etc.).
                \item \textbf{String BLUETOOTH\_SERVICE}: For \texttt{BluetoothManager} (Bluetooth stack).
                \item \textbf{String CAMERA\_SERVICE}: For \texttt{CameraManager} (camera devices).
                \item \textbf{String AUDIO\_SERVICE}: For \texttt{AudioManager} (volume, routing).

                    % --- Media / notifications ---
                \item \textbf{String NOTIFICATION\_SERVICE}: For \texttt{NotificationManager} (post/cancel notifications).
                \item \textbf{String MEDIA\_SESSION\_SERVICE}: For \texttt{MediaSessionManager} (media controls).
                \item \textbf{String MEDIA\_PROJECTION\_SERVICE}: For \texttt{MediaProjectionManager} (screen capture).
                \item \textbf{String DOWNLOAD\_SERVICE}: For \texttt{DownloadManager} (HTTP downloads).

                    % --- Input / clipboard / keyguard / biometrics ---
                \item \textbf{String INPUT\_METHOD\_SERVICE}: For \texttt{InputMethodManager} (soft keyboard).
                \item \textbf{String CLIPBOARD\_SERVICE}: For \texttt{ClipboardManager} (global clipboard).
                \item \textbf{String KEYGUARD\_SERVICE}: For \texttt{KeyguardManager} (lock screen).
                \item \textbf{String BIOMETRIC\_SERVICE}: For \texttt{BiometricManager} (biometric auth).

                    % --- App data / users / scheduling ---
                \item \textbf{String STORAGE\_SERVICE}: For \texttt{StorageManager} (volumes, storage ops).
                \item \textbf{String USER\_SERVICE}: For \texttt{UserManager} (multi-user info).
                \item \textbf{String JOB\_SCHEDULER\_SERVICE}: For \texttt{JobScheduler} (deferrable background work).
                \item \textbf{String APP\_OPS\_SERVICE}: For \texttt{AppOpsManager} (app operation checks).

                    % --- Haptics ---
                \item \textbf{String VIBRATOR\_MANAGER\_SERVICE}: For \texttt{VibratorManager} (multi-vibrator control).

                    % ======================
                    % Common flags / modes
                    % ======================
                \item \textbf{int MODE\_PRIVATE}: Default file mode for \texttt{openFileOutput}; file private to the app.
                \item \textbf{int MODE\_APPEND}: Append mode for \texttt{openFileOutput}.
                \item \textbf{int MODE\_ENABLE\_WRITE\_AHEAD\_LOGGING}: DB flag to enable WAL by default.
                \item \textbf{int MODE\_NO\_LOCALIZED\_COLLATORS}: DB flag to omit localized collators.
                \item \textbf{int RECEIVER\_EXPORTED}: \texttt{registerReceiver} flag — receiver accepts broadcasts from other apps.
                \item \textbf{int RECEIVER\_NOT\_EXPORTED}: \texttt{registerReceiver} flag — receiver is app-internal only.
                \item \textbf{int RECEIVER\_VISIBLE\_TO\_INSTANT\_APPS}: \texttt{registerReceiver} flag — visible to Instant Apps.

                    % --- Service binding flags most seen in practice ---
                \item \textbf{int BIND\_AUTO\_CREATE}: Auto-create service while bound.
                \item \textbf{int BIND\_NOT\_FOREGROUND}: Do not raise target service to foreground priority.
                \item \textbf{int BIND\_IMPORTANT}: Treat service as important to the client.
                \item \textbf{int BIND\_DEBUG\_UNBIND}: Include debugging help for unbind mismatches.
                \item \textbf{int BIND\_WAIVE\_PRIORITY}: Do not affect service process priority.
        \end{itemize}


    \end{itemize}

    \pagebreak 
    \subsubsection{ConstraintLayout}
    \begin{itemize}
        \item \textbf{Hierarchy}: 
            \begin{center}
                java.lang.Object $\to $	android.view.View $\to $	android.view.ViewGroup $\to $	androidx.constraintlayout.widget.ConstraintLayout
            \end{center}
        \item \textbf{Include}:
            \bigbreak \noindent 
            \begin{javacode}
            androidx.constraintlayout.widget.ConstraintLayout
            \end{javacode}
        \item \textbf{Constructors}:
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout(@NonNull Context context)
                ConstraintLayout(@NonNull Context context, @Nullable AttributeSet attrs)
                ConstraintLayout( @NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr)

                @TargetApi(value = Build.VERSION_CODES.LOLLIPOP)
                ConstraintLayout( @NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}:
            \begin{itemize}
                \item \textbf{void addValueModifier(ConstraintLayout.ValueModifier modifier)}: Adds a \texttt{ValueModifier} to the \texttt{ConstraintLayout}.
                \item \textbf{void fillMetrics(Metrics metrics)}: Populates the provided \texttt{Metrics} object with performance and measurement data.
                \item \textbf{void forceLayout()}: Forces a layout pass, marking the layout as needing to be re-measured and re-laid out.
                \item \textbf{ConstraintLayout.LayoutParams generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attributes set.
                \item \textbf{Object getDesignInformation(int type, Object value)}: Retrieves design-time information associated with the layout.
                \item \textbf{int getMaxHeight()}: Returns the maximum height of this view.
                \item \textbf{int getMaxWidth()}: Returns the maximum width of this view.
                \item \textbf{int getMinHeight()}: Returns the minimum height of this view.
                \item \textbf{int getMinWidth()}: Returns the minimum width of this view.
                \item \textbf{int getOptimizationLevel()}: Returns the current optimization level for the layout resolution.
                \item \textbf{String getSceneString()}: Returns a JSON5 string useful for debugging the constraints currently applied.
                \item \textbf{static SharedValues getSharedValues()}: Returns the \texttt{SharedValues} instance, creating it if it does not already exist.
                \item \textbf{View getViewById(int id)}: Returns the \texttt{View} corresponding to the given ID.
                \item \textbf{final ConstraintWidget getViewWidget(View view)}: Returns the internal \texttt{ConstraintWidget} associated with a given view.
                \item \textbf{void loadLayoutDescription(int layoutDescription)}: Loads a layout description file from the application's resources.
                \item \textbf{void onViewAdded(View view)}: Called when a child view is added to the layout.
                \item \textbf{void onViewRemoved(View view)}: Called when a child view is removed from the layout.
                \item \textbf{void requestLayout()}: Requests a re-layout of this view hierarchy.
                \item \textbf{void setConstraintSet(ConstraintSet set)}: Sets a \texttt{ConstraintSet} object to manage constraints.
                \item \textbf{void setDesignInformation(int type, Object value1, Object value2)}: Stores design-time information associated with the layout.
                \item \textbf{void setId(int id)}: Sets the ID for this view.
                \item \textbf{void setMaxHeight(int value)}: Sets the maximum height for this view.
                \item \textbf{void setMaxWidth(int value)}: Sets the maximum width for this view.
                \item \textbf{void setMinHeight(int value)}: Sets the minimum height for this view.
                \item \textbf{void setMinWidth(int value)}: Sets the minimum width for this view.
                \item \textbf{void setOnConstraintsChanged(ConstraintsChangedListener constraintsChangedListener)}: Registers a listener to be notified when constraints change.
                \item \textbf{void setOptimizationLevel(int level)}: Sets the optimization level for layout resolution.
                \item \textbf{void setState(int id, int screenWidth, int screenHeight)}: Sets the state of the \texttt{ConstraintLayout}, causing it to load a specific \texttt{ConstraintSet}.
                \item \textbf{boolean shouldDelayChildPressedState()}: Returns true if the pressed state should be delayed for children or descendants of this \texttt{ViewGroup}.
            \end{itemize}
        \item \textbf{Protected methods}:
            \begin{itemize}
                \item \textbf{void applyConstraintsFromLayoutParams(boolean isInEditMode, View child, ConstraintWidget widget, ConstraintLayout.LayoutParams layoutParams, SparseArray<ConstraintWidget> idToWidget)}: Applies constraints from the given layout parameters to the specified \texttt{ConstraintWidget}.
                \item \textbf{boolean checkLayoutParams(ViewGroup.LayoutParams p)}: Determines whether the supplied layout parameters are valid for this layout.
                \item \textbf{void dispatchDraw(Canvas canvas)}: Called to draw the layout’s children onto the provided \texttt{Canvas}.
                \item \textbf{boolean dynamicUpdateConstraints(int widthMeasureSpec, int heightMeasureSpec)}: Can be overridden to change how \texttt{ValueModifier}s are used during dynamic updates of constraints.
                \item \textbf{ConstraintLayout.LayoutParams generateDefaultLayoutParams()}: Returns a set of default layout parameters for this \texttt{ConstraintLayout}.
                \item \textbf{ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p)}: Returns a safe set of layout parameters based on the supplied parameters.
                \item \textbf{boolean isRtl()}: Returns \texttt{true} if the layout direction is right-to-left (RTL).
                \item \textbf{void onLayout(boolean changed, int left, int top, int right, int bottom)}: Called during layout to assign a size and position to each child.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the layout and its children to determine width and height.
                \item \textbf{void parseLayoutDescription(int id)}: Called to handle layout descriptions; subclasses may override this method.
                \item \textbf{void resolveMeasuredDimension(int widthMeasureSpec, int heightMeasureSpec, int measuredWidth, int measuredHeight, boolean isWidthMeasuredTooSmall, boolean isHeightMeasuredTooSmall)}: Handles setting the measured dimensions for the layout.
                \item \textbf{void resolveSystem(ConstraintWidgetContainer layout, int optimizationLevel, int widthMeasureSpec, int heightMeasureSpec)}: Handles the measuring and constraint resolution of the layout.
                \item \textbf{void setSelfDimensionBehaviour(ConstraintWidgetContainer layout, int widthMode, int widthSize, int heightMode, int heightSize)}: Configures the layout’s own dimension behavior during constraint resolution.
            \end{itemize}
        \item \textbf{Constants}:
            \begin{itemize}
                \item \textbf{static final int	DESIGN\_INFO\_ID = 0}:
                \item \textbf{static final String VERSION = "ConstraintLayout-2.2.0-alpha04"}:
            \end{itemize}
        \item \textbf{Protected fields}:
            \begin{itemize}
                \item \textbf{ConstraintLayoutStates	mConstraintLayoutSpec}:
                \item \textbf{boolean	mDirtyHierarchy}:
                \item \textbf{ConstraintWidgetContainer	mLayoutWidget}:
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ConstraintLayout.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy}: 
            \begin{center}
                java.lang.Object $\to $	android.view.View $\to $	android.view.ViewGroup $\to $	androidx.constraintlayout.widget.ConstraintLayout
            \end{center}
        \item \textbf{Include}:
            \bigbreak \noindent 
            \begin{javacode}
            androidx.constraintlayout.widget.ConstraintLayout
            \end{javacode}
        \item \textbf{Constructors}:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams(ViewGroup.LayoutParams params)
                LayoutParams(Context c, AttributeSet attrs)
                LayoutParams(int width, int height)
            \end{javacode}
        \item \textbf{Public methods}:
            \begin{itemize}
                \item \textbf{String getConstraintTag()}: Returns a tag that can be used to identify a view as being part of a constraint group.
                \item \textbf{ConstraintWidget getConstraintWidget()}: Returns the underlying \texttt{ConstraintWidget} object associated with this layout parameter or view.
                \item \textbf{void reset()}: Resets the associated \texttt{ConstraintWidget} to its default state.
                \item \textbf{void resolveLayoutDirection(int layoutDirection)}: Resolves layout direction–dependent constraints such as start/end alignment.
                \item \textbf{void setWidgetDebugName(String text)}: Sets a debug name for the \texttt{ConstraintWidget}, useful for diagnostics or logging.
                \item \textbf{void validate()}: Validates the layout and ensures that all parameters and constraints are consistent.
            \end{itemize}
        \item \textbf{Public fields}:
            \begin{itemize}
                \item \textbf{int baselineMargin}: The baseline margin.
                \item \textbf{int baselineToBaseline}: Constrains the baseline of a child to the baseline of a target child (contains the target child ID).
                \item \textbf{int baselineToBottom}: Constrains the baseline of a child to the bottom of a target child (contains the target child ID).
                \item \textbf{int baselineToTop}: Constrains the baseline of a child to the top of a target child (contains the target child ID).
                \item \textbf{int bottomToBottom}: Constrains the bottom side of a child to the bottom side of a target child (contains the target child ID).
                \item \textbf{int bottomToTop}: Constrains the bottom side of a child to the top side of a target child (contains the target child ID).
                \item \textbf{float circleAngle}: The angle used for a circular constraint.
                \item \textbf{int circleConstraint}: Constrains the center of a child to the center of a target child (contains the target child ID).
                \item \textbf{int circleRadius}: The radius used for a circular constraint.
                \item \textbf{boolean constrainedHeight}: Specifies if the vertical dimension is constrained when both top and bottom constraints are set and the dimension is not fixed.
                \item \textbf{boolean constrainedWidth}: Specifies if the horizontal dimension is constrained when both left and right constraints are set and the dimension is not fixed.
                \item \textbf{String constraintTag}: Defines a category of view to be used by helpers and \texttt{MotionLayout}.
                \item \textbf{String dimensionRatio}: The ratio information defining the aspect ratio of the view.
                \item \textbf{int editorAbsoluteX}: The design-time X coordinate (left position) of the child.
                \item \textbf{int editorAbsoluteY}: The design-time Y coordinate (top position) of the child.
                \item \textbf{int endToEnd}: Constrains the end side of a child to the end side of a target child (contains the target child ID).
                \item \textbf{int endToStart}: Constrains the end side of a child to the start side of a target child (contains the target child ID).
                \item \textbf{int goneBaselineMargin}: The baseline margin to use when the target is gone.
                \item \textbf{int goneBottomMargin}: The bottom margin to use when the target is gone.
                \item \textbf{int goneEndMargin}: The end margin to use when the target is gone.
                \item \textbf{int goneLeftMargin}: The left margin to use when the target is gone.
                \item \textbf{int goneRightMargin}: The right margin to use when the target is gone.
                \item \textbf{int goneStartMargin}: The start margin to use when the target is gone.
                \item \textbf{int goneTopMargin}: The top margin to use when the target is gone.
                \item \textbf{int guideBegin}: The distance of a guideline from the top or left edge of its parent.
                \item \textbf{int guideEnd}: The distance of a guideline from the bottom or right edge of its parent.
                \item \textbf{float guidePercent}: The ratio of the distance to the parent's sides.
                \item \textbf{boolean guidelineUseRtl}: Determines whether guideline position respects RTL layout direction.
                \item \textbf{boolean helped}: Indicates whether the view was modified by a helper.
                \item \textbf{float horizontalBias}: The ratio between two connections when left and right (or start and end) sides are constrained.
                \item \textbf{int horizontalChainStyle}: Defines how elements of a horizontal chain are positioned.
                \item \textbf{float horizontalWeight}: The child’s weight used to distribute available horizontal space in a chain when using \texttt{MATCH\_CONSTRAINT}.
                \item \textbf{int leftToLeft}: Constrains the left side of a child to the left side of a target child (contains the target child ID).
                \item \textbf{int leftToRight}: Constrains the left side of a child to the right side of a target child (contains the target child ID).
                \item \textbf{int matchConstraintDefaultHeight}: Defines how the widget’s vertical dimension is handled when set to \texttt{MATCH\_CONSTRAINT}.
                \item \textbf{int matchConstraintDefaultWidth}: Defines how the widget’s horizontal dimension is handled when set to \texttt{MATCH\_CONSTRAINT}.
                \item \textbf{int matchConstraintMaxHeight}: Specifies a maximum height for the widget.
                \item \textbf{int matchConstraintMaxWidth}: Specifies a maximum width for the widget.
                \item \textbf{int matchConstraintMinHeight}: Specifies a minimum height for the widget.
                \item \textbf{int matchConstraintMinWidth}: Specifies a minimum width for the widget.
                \item \textbf{float matchConstraintPercentHeight}: Specifies a percentage value when using the match-constraint percent mode for height.
                \item \textbf{float matchConstraintPercentWidth}: Specifies a percentage value when using the match-constraint percent mode for width.
                \item \textbf{int orientation}: The orientation of the layout (horizontal or vertical).
                \item \textbf{int rightToLeft}: Constrains the right side of a child to the left side of a target child (contains the target child ID).
                \item \textbf{int rightToRight}: Constrains the right side of a child to the right side of a target child (contains the target child ID).
                \item \textbf{int startToEnd}: Constrains the start side of a child to the end side of a target child (contains the target child ID).
                \item \textbf{int startToStart}: Constrains the start side of a child to the start side of a target child (contains the target child ID).
                \item \textbf{int topToBottom}: Constrains the top side of a child to the bottom side of a target child (contains the target child ID).
                \item \textbf{int topToTop}: Constrains the top side of a child to the top side of a target child (contains the target child ID).
                \item \textbf{float verticalBias}: The ratio between two connections when the top and bottom sides are constrained.
                \item \textbf{int verticalChainStyle}: Defines how elements of a vertical chain are positioned.
                \item \textbf{float verticalWeight}: The child’s weight used to distribute available vertical space in a chain when using \texttt{MATCH\_CONSTRAINT}.
                \item \textbf{int wrapBehaviorInParent}: Specifies how this view is considered during the parent's wrap computation:
                    \begin{itemize}
                        \item \texttt{WRAP\_BEHAVIOR\_INCLUDED}: Included in both directions (default).
                        \item \texttt{WRAP\_BEHAVIOR\_HORIZONTAL\_ONLY}: Included only horizontally.
                        \item \texttt{WRAP\_BEHAVIOR\_VERTICAL\_ONLY}: Included only vertically.
                        \item \texttt{WRAP\_BEHAVIOR\_SKIPPED}: Excluded from wrap computation.
                    \end{itemize}
            \end{itemize}

        \item \textbf{Constants}:
            \begin{itemize}
                \item \textbf{static final int BASELINE = 5}: The baseline of the text in a view.
                \item \textbf{static final int BOTTOM = 4}: The bottom side of a view.
                \item \textbf{static final int CHAIN\_PACKED = 2}: Chain packed style.
                \item \textbf{static final int CHAIN\_SPREAD = 0}: Chain spread style.
                \item \textbf{static final int CHAIN\_SPREAD\_INSIDE = 1}: Chain spread inside style.
                \item \textbf{static final int CIRCLE = 8}: Circle reference from a view.
                \item \textbf{static final int END = 7}: The right side of a view in left-to-right languages.
                \item \textbf{static final int GONE\_UNSET = -2147483648}: Defines an ID that is not set (default unset state).
                \item \textbf{static final int HORIZONTAL = 0}: The horizontal orientation.
                \item \textbf{static final int LEFT = 1}: The left side of a view.
                \item \textbf{static final int MATCH\_CONSTRAINT = 0}: Dimension will be controlled by constraints.
                \item \textbf{static final int MATCH\_CONSTRAINT\_PERCENT = 2}: Sets \texttt{matchConstraintDefault*} percent mode to be based on a percent of another dimension (usually the parent). Used for \texttt{matchConstraintDefaultWidth} and \texttt{matchConstraintDefaultHeight}.
                \item \textbf{static final int MATCH\_CONSTRAINT\_SPREAD = 0}: Sets \texttt{matchConstraintDefault*} to spread as much as possible within its constraints.
                \item \textbf{static final int MATCH\_CONSTRAINT\_WRAP = 1}: Sets \texttt{matchConstraintDefault*} to wrap content size.
                \item \textbf{static final int PARENT\_ID = 0}: References the ID of the parent layout.
                \item \textbf{static final int RIGHT = 2}: The right side of a view.
                \item \textbf{static final int START = 6}: The left side of a view in left-to-right languages.
                \item \textbf{static final int TOP = 3}: The top side of a view.
                \item \textbf{static final int UNSET = -1}: Defines an ID that is not set.
                \item \textbf{static final int VERTICAL = 1}: The vertical orientation.
                \item \textbf{static final int WRAP\_BEHAVIOR\_HORIZONTAL\_ONLY = 1}: Specifies that wrapping occurs only horizontally.
                \item \textbf{static final int WRAP\_BEHAVIOR\_INCLUDED = 0}: Specifies that wrapping includes both horizontal and vertical directions (default).
                \item \textbf{static final int WRAP\_BEHAVIOR\_SKIPPED = 3}: Specifies that the widget is excluded from wrap computation.
                \item \textbf{static final int WRAP\_BEHAVIOR\_VERTICAL\_ONLY = 2}: Specifies that wrapping occurs only vertically.
            \end{itemize}


    \end{itemize}



    \pagebreak 
    \subsubsection{RelativeLayout}
    \begin{itemize}
        \item \textbf{Hierarchy}:
            \begin{center}
                java.lang.Object $\to$ android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.RelativeLayout
            \end{center}
        \item \textbf{Include}:
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.RelativeLayout    
            \end{javacode}
        \item \textbf{Constructors}: 
            \bigbreak \noindent 
            \begin{javacode}
                RelativeLayout(Context context)
                RelativeLayout(Context context, AttributeSet attrs)
                RelativeLayout(Context context, AttributeSet attrs, int defStyleAttr)
                RelativeLayout(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}:
            \begin{itemize}
                \item \textbf{RelativeLayout.LayoutParams generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attributes set.
                \item \textbf{CharSequence getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{int getBaseline()}: Return the offset of the widget's text baseline from the widget's top boundary.
                \item \textbf{int getGravity()}: Describes how the child views are positioned.
                \item \textbf{int getIgnoreGravity()}: Get the ID of the \texttt{View} to be ignored by gravity.
                \item \textbf{void requestLayout()}: Call this when something has changed that invalidates the layout of this view.
                \item \textbf{void setGravity(int gravity)}: Describes how the child views are positioned.
                \item \textbf{void setHorizontalGravity(int horizontalGravity)}: Sets the horizontal gravity of the layout.
                \item \textbf{void setIgnoreGravity(int viewId)}: Defines which \texttt{View} is ignored when gravity is applied.
                \item \textbf{void setVerticalGravity(int verticalGravity)}: Sets the vertical gravity of the layout.
                \item \textbf{boolean shouldDelayChildPressedState()}: Returns true if the pressed state should be delayed for children or descendants of this \texttt{ViewGroup}.
            \end{itemize}
        \item \textbf{Protected methods}:
            \begin{itemize}
                \item \textbf{boolean checkLayoutParams(ViewGroup.LayoutParams p)}: Determines whether the supplied layout parameters are valid for this layout.
                \item \textbf{ViewGroup.LayoutParams generateDefaultLayoutParams()}: Returns a set of layout parameters with a width of \texttt{ViewGroup.LayoutParams.WRAP\_CONTENT}, a height of \texttt{ViewGroup.LayoutParams.WRAP\_CONTENT}, and no spanning.
                \item \textbf{ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp)}: Returns a safe set of layout parameters based on the supplied layout parameters.
                \item \textbf{void onLayout(boolean changed, int l, int t, int r, int b)}: Called from layout when this view should assign a size and position to each of its children.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine the measured width and height.
            \end{itemize}
        \item \textbf{Constants}:
            \begin{itemize}
                \item \textbf{int ABOVE}: Rule that aligns a child's bottom edge with another child's top edge.
                \item \textbf{int ALIGN\_BASELINE}: Rule that aligns a child's baseline with another child's baseline.
                \item \textbf{int ALIGN\_BOTTOM}: Rule that aligns a child's bottom edge with another child's bottom edge.
                \item \textbf{int ALIGN\_END}: Rule that aligns a child's end edge with another child's end edge.
                \item \textbf{int ALIGN\_LEFT}: Rule that aligns a child's left edge with another child's left edge.
                \item \textbf{int ALIGN\_PARENT\_BOTTOM}: Rule that aligns the child's bottom edge with its \texttt{RelativeLayout} parent's bottom edge.
                \item \textbf{int ALIGN\_PARENT\_END}: Rule that aligns the child's end edge with its \texttt{RelativeLayout} parent's end edge.
                \item \textbf{int ALIGN\_PARENT\_LEFT}: Rule that aligns the child's left edge with its \texttt{RelativeLayout} parent's left edge.
                \item \textbf{int ALIGN\_PARENT\_RIGHT}: Rule that aligns the child's right edge with its \texttt{RelativeLayout} parent's right edge.
                \item \textbf{int ALIGN\_PARENT\_START}: Rule that aligns the child's start edge with its \texttt{RelativeLayout} parent's start edge.
                \item \textbf{int ALIGN\_PARENT\_TOP}: Rule that aligns the child's top edge with its \texttt{RelativeLayout} parent's top edge.
                \item \textbf{int ALIGN\_RIGHT}: Rule that aligns a child's right edge with another child's right edge.
                \item \textbf{int ALIGN\_START}: Rule that aligns a child's start edge with another child's start edge.
                \item \textbf{int ALIGN\_TOP}: Rule that aligns a child's top edge with another child's top edge.
                \item \textbf{int BELOW}: Rule that aligns a child's top edge with another child's bottom edge.
                \item \textbf{int CENTER\_HORIZONTAL}: Rule that centers the child horizontally with respect to the bounds of its \texttt{RelativeLayout} parent.
                \item \textbf{int CENTER\_IN\_PARENT}: Rule that centers the child with respect to the bounds of its \texttt{RelativeLayout} parent.
                \item \textbf{int CENTER\_VERTICAL}: Rule that centers the child vertically with respect to the bounds of its \texttt{RelativeLayout} parent.
                \item \textbf{int END\_OF}: Rule that aligns a child's start edge with another child's end edge.
                \item \textbf{int LEFT\_OF}: Rule that aligns a child's right edge with another child's left edge.
                \item \textbf{int RIGHT\_OF}: Rule that aligns a child's left edge with another child's right edge.
                \item \textbf{int START\_OF}: Rule that aligns a child's end edge with another child's start edge.
                \item \textbf{int TRUE}: Constant used for layout rules that take a boolean value.
            \end{itemize}

    \end{itemize}




    \pagebreak 
    \subsubsection{RelativeLayout.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy}:
            \begin{center}
                java.lang.Object $\to $	android.view.ViewGroup.LayoutParams $\to $	android.view.ViewGroup.MarginLayoutParams $\to $	android.widget.RelativeLayout.LayoutParams
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.RelativeLayout.LayoutParams
            \end{javacode}

        \item \textbf{Constructors}:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams(Context c, AttributeSet attrs)
                LayoutParams(ViewGroup.LayoutParams source)
                LayoutParams(ViewGroup.MarginLayoutParams source)
                LayoutParams(RelativeLayout.LayoutParams source)
                LayoutParams(int w, int h)
            \end{javacode}
        \item \textbf{Public methods}:
            \begin{itemize}
                \item \textbf{void addRule(int verb, int subject)}: Adds a layout rule to be interpreted by the \texttt{RelativeLayout}, relative to another view.
                \item \textbf{void addRule(int verb)}: Adds a layout rule to be interpreted by the \texttt{RelativeLayout}.
                \item \textbf{String debug(String output)}: Returns a string representation of this set of layout parameters, typically used for debugging.
                \item \textbf{int getRule(int verb)}: Returns the layout rule associated with a specific verb.
                \item \textbf{int[] getRules()}: Retrieves a complete list of all supported rules, where each index represents a rule verb and each value represents the associated parameter (or \texttt{false} if not set).
                \item \textbf{void removeRule(int verb)}: Removes a layout rule from interpretation by the \texttt{RelativeLayout}.
                \item \textbf{void resolveLayoutDirection(int layoutDirection)}: Called by \texttt{View.requestLayout()} to resolve layout parameters that depend on layout direction (e.g., start/end alignment).
            \end{itemize}
        \item \textbf{Fields}:
            \begin{itemize}
                \item \textbf{public boolean	alignWithParent}: When true, uses the parent as the anchor if the anchor doesn't exist or if the anchor's visibility is GONE.
            \end{itemize}

    \end{itemize}
    

    \pagebreak 
    \subsubsection{LinearLayout}
    \begin{itemize}
        \item \textbf{Hierarchy}:
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to $	android.view.ViewGroup $\to $	android.widget.LinearLayout
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.widget.LinearLayout
            \end{javacode}
        \item \textbf{Constructors}:
            \bigbreak \noindent 
            \begin{javacode}
                LinearLayout(Context context)
                LinearLayout(Context context, AttributeSet attrs)
                LinearLayout(Context context, AttributeSet attrs, int defStyleAttr)
                LinearLayout(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) 
            \end{javacode}
        \item \textbf{Public Methods}:
            \begin{itemize}
                \item \textbf{LinearLayout.LayoutParams generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attributes set.
                \item \textbf{CharSequence getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{int getBaseline()}: Return the offset of the widget's text baseline from the widget's top boundary.
                \item \textbf{int getBaselineAlignedChildIndex()}: Returns the index used for baseline alignment.
                \item \textbf{Drawable getDividerDrawable()}: Returns the drawable used as a divider between child views.
                \item \textbf{int getDividerPadding()}: Get the padding size used to inset dividers in pixels.
                \item \textbf{int getGravity()}: Returns the current gravity.
                \item \textbf{int getOrientation()}: Returns the current orientation.
                \item \textbf{int getShowDividers()}: Returns how dividers are displayed between items.
                \item \textbf{float getWeightSum()}: Returns the desired weights sum.
                \item \textbf{boolean isBaselineAligned()}: Indicates whether widgets contained within this layout are aligned on their baseline or not.
                \item \textbf{boolean isMeasureWithLargestChildEnabled()}: When true, all children with a weight will be considered having the minimum size of the largest child.
                \item \textbf{void onRtlPropertiesChanged(int layoutDirection)}: Called when any RTL property (layout direction or text direction or text alignment) has been changed.
                \item \textbf{void setBaselineAligned(boolean baselineAligned)}: Defines whether widgets contained in this layout are baseline-aligned or not.
                \item \textbf{void setBaselineAlignedChildIndex(int i)}: Sets which child is used for baseline alignment.
                \item \textbf{void setDividerDrawable(Drawable divider)}: Set a drawable to be used as a divider between items.
                \item \textbf{void setDividerPadding(int padding)}: Set padding displayed on both ends of dividers.
                \item \textbf{void setGravity(int gravity)}: Describes how the child views are positioned.
                \item \textbf{void setHorizontalGravity(int horizontalGravity)}: Sets the horizontal gravity of the layout.
                \item \textbf{void setMeasureWithLargestChildEnabled(boolean enabled)}: When set to true, all children with a weight will be considered having the minimum size of the largest child.
                \item \textbf{void setOrientation(int orientation)}: Should the layout be a column or a row.
                \item \textbf{void setShowDividers(int showDividers)}: Set how dividers should be shown between items in this layout.
                \item \textbf{void setVerticalGravity(int verticalGravity)}: Sets the vertical gravity of the layout.
                \item \textbf{void setWeightSum(float weightSum)}: Defines the desired weights sum.
                \item \textbf{boolean shouldDelayChildPressedState()}: Return true if the pressed state should be delayed for children or descendants of this ViewGroup.
            \end{itemize}
        \item \textbf{Protected Methods}:
            \begin{itemize}
                \item \textbf{boolean checkLayoutParams(ViewGroup.LayoutParams p)}: Determines whether the supplied layout parameters are valid for this layout.
                \item \textbf{LinearLayout.LayoutParams generateDefaultLayoutParams()}: Returns a set of layout parameters with a width of \texttt{ViewGroup.LayoutParams.MATCH\_PARENT} and a height of \texttt{ViewGroup.LayoutParams.WRAP\_CONTENT} when the layout's orientation is vertical.
                \item \textbf{LinearLayout.LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp)}: Returns a safe set of layout parameters based on the supplied layout parameters.
                \item \textbf{void onDraw(Canvas canvas)}: Implement this method to perform custom drawing operations on the layout.
                \item \textbf{void onLayout(boolean changed, int l, int t, int r, int b)}: Called from layout when this view should assign a size and position to each of its children.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine the measured width and height.
            \end{itemize}

        \item \textbf{Constants}:
            \begin{itemize}
                \item \textbf{int HORIZONTAL}: Constant indicating a horizontal orientation for the layout.
                \item \textbf{int SHOW\_DIVIDER\_BEGINNING}: Show a divider at the beginning of the group.
                \item \textbf{int SHOW\_DIVIDER\_END}: Show a divider at the end of the group.
                \item \textbf{int SHOW\_DIVIDER\_MIDDLE}: Show dividers between each item in the group.
                \item \textbf{int SHOW\_DIVIDER\_NONE}: Do not show any dividers.
                \item \textbf{int VERTICAL}: Constant indicating a vertical orientation for the layout.
            \end{itemize}


    \end{itemize}

    \pagebreak 
    \subsubsection{LinearLayout.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy}:
            \begin{center}
                java.lang.Object $\to $	android.view.ViewGroup.LayoutParams $\to $	android.view.ViewGroup.MarginLayoutParams $\to $	android.widget.LinearLayout.LayoutParams
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.LinearLayout.LayoutParams
            \end{javacode}
        \item \textbf{Constructors}:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams(Context c, AttributeSet attrs)
                LayoutParams(ViewGroup.LayoutParams p)
                LayoutParams(ViewGroup.MarginLayoutParams source)
                LayoutParams(LinearLayout.LayoutParams source)
                LayoutParams(int width, int height)
                LayoutParams(int width, int height, float weight)
            \end{javacode}
        \item \textbf{Public methods}:
            \begin{itemize}
                \item \textbf{String	debug(String output)}:
            \end{itemize}
        \item \textbf{Fields}:
            \begin{itemize}
                \item \textbf{public int	gravity}: Gravity for the view associated with these LayoutParams.
                \item \textbf{public float	weight}: Indicates how much of the extra space in the LinearLayout will be allocated to the view associated with these LayoutParams.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{GridLayout}
    \begin{itemize}
        \item \textbf{Hierarchy}: 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.GridLayout
            \end{center}
        \item \textbf{Include}:
            \bigbreak \noindent 
            \begin{javacode}
            android.widget.GridLayout
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                GridLayout(Context context)
                GridLayout(Context context, AttributeSet attrs)
                GridLayout(Context context, AttributeSet attrs, int defStyleAttr)
                GridLayout(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{GridLayout.LayoutParams generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attribute set.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object to be used for accessibility purposes.
                \item \textbf{int getAlignmentMode()}: Returns the current alignment mode used for positioning children within their grid cells.
                \item \textbf{int getColumnCount()}: Returns the current number of columns.
                \item \textbf{int getOrientation()}: Returns the current orientation (horizontal or vertical).
                \item \textbf{int getRowCount()}: Returns the current number of rows.
                \item \textbf{boolean getUseDefaultMargins()}: Returns whether this \texttt{GridLayout} will allocate default margins when none are defined in layout parameters.
                \item \textbf{boolean isColumnOrderPreserved()}: Returns whether column boundaries are ordered by their grid indices.
                \item \textbf{boolean isRowOrderPreserved()}: Returns whether row boundaries are ordered by their grid indices.
                \item \textbf{void onViewAdded(View child)}: Called when a new child view is added to this \texttt{ViewGroup}.
                \item \textbf{void onViewRemoved(View child)}: Called when a child view is removed from this \texttt{ViewGroup}.
                \item \textbf{void requestLayout()}: Call this when something has changed that invalidates the layout of this view.
                \item \textbf{void setAlignmentMode(int alignmentMode)}: Sets the alignment mode used for alignments between children of this container.
                \item \textbf{void setColumnCount(int columnCount)}: Sets the total number of columns. Used to generate default column indices when none are specified.
                \item \textbf{void setColumnOrderPreserved(boolean columnOrderPreserved)}: When true, forces \texttt{GridLayout} to place column boundaries so their grid indices appear in ascending order.
                \item \textbf{void setOrientation(int orientation)}: Sets the layout’s orientation. This controls:
                    \begin{itemize}
                        \item The direction in which default row/column indices are generated when not specified.
                        \item Whether the grid is treated as row-major or column-major.
                    \end{itemize}
                \item \textbf{void setRowCount(int rowCount)}: Sets the total number of rows. Used to generate default row indices when none are specified.
                \item \textbf{void setRowOrderPreserved(boolean rowOrderPreserved)}: When true, forces \texttt{GridLayout} to place row boundaries in ascending order of their grid indices.
                \item \textbf{void setUseDefaultMargins(boolean useDefaultMargins)}: When true, \texttt{GridLayout} allocates default margins based on child visual characteristics.
                \item \textbf{static GridLayout.Spec spec(int start, float weight)}: Equivalent to \texttt{spec(start, 1, weight)}.
                \item \textbf{static GridLayout.Spec spec(int start)}: Returns a \texttt{Spec} where:
                    \begin{itemize}
                        \item \texttt{span = [start, start + 1]}
                        \item To leave the start index undefined, use \texttt{UNDEFINED}.
                    \end{itemize}
                \item \textbf{static GridLayout.Spec spec(int start, int size, GridLayout.Alignment alignment, float weight)}: Returns a \texttt{Spec} where:
                    \begin{itemize}
                        \item \texttt{span = [start, start + size]}
                        \item \texttt{alignment = alignment}
                        \item \texttt{weight = weight}
                        \item To leave the start index undefined, use \texttt{UNDEFINED}.
                    \end{itemize}
                \item \textbf{static GridLayout.Spec spec(int start, GridLayout.Alignment alignment, float weight)}: Equivalent to \texttt{spec(start, 1, alignment, weight)}.
                \item \textbf{static GridLayout.Spec spec(int start, int size, GridLayout.Alignment alignment)}: Equivalent to \texttt{spec(start, size, alignment, 0f)}.
                \item \textbf{static GridLayout.Spec spec(int start, GridLayout.Alignment alignment)}: Returns a \texttt{Spec} where:
                    \begin{itemize}
                        \item \texttt{span = [start, start + 1]}
                        \item \texttt{alignment = alignment}
                        \item To leave the start index undefined, use \texttt{UNDEFINED}.
                    \end{itemize}
                \item \textbf{static GridLayout.Spec spec(int start, int size, float weight)}: Equivalent to \texttt{spec(start, size, default\_alignment, weight)}, where \texttt{default\_alignment} is defined in \texttt{GridLayout.LayoutParams}.
                \item \textbf{static GridLayout.Spec spec(int start, int size)}: Returns a \texttt{Spec} where:
                    \begin{itemize}
                        \item \texttt{span = [start, start + size]}
                        \item To leave the start index undefined, use \texttt{UNDEFINED}.
                    \end{itemize}
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean checkLayoutParams(ViewGroup.LayoutParams p)}: Determines whether the supplied layout parameters are valid for this layout.
                \item \textbf{GridLayout.LayoutParams generateDefaultLayoutParams()}: Returns a set of default layout parameters used by this \texttt{GridLayout}.
                \item \textbf{GridLayout.LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp)}: Returns a safe set of layout parameters based on the supplied layout parameters.
                \item \textbf{void onLayout(boolean changed, int left, int top, int right, int bottom)}: Called during layout when this view should assign a size and position to each of its children.
                \item \textbf{void onMeasure(int widthSpec, int heightSpec)}: Measures the view and its content to determine the measured width and height.
            \end{itemize}

        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public static final GridLayout.Alignment BASELINE}: Indicates that a view should be aligned with the baselines of the other views in its cell group.
                \item \textbf{public static final GridLayout.Alignment BOTTOM}: Indicates that a view should be aligned with the bottom edges of the other views in its cell group.
                \item \textbf{public static final GridLayout.Alignment CENTER}: Indicates that a view should be centered with the other views in its cell group.
                \item \textbf{public static final GridLayout.Alignment END}: Indicates that a view should be aligned with the end edges of the other views in its cell group.
                \item \textbf{public static final GridLayout.Alignment FILL}: Indicates that a view should expand to fill the boundaries of its cell group.
                \item \textbf{public static final GridLayout.Alignment LEFT}: Indicates that a view should be aligned with the left edges of the other views in its cell group.
                \item \textbf{public static final GridLayout.Alignment RIGHT}: Indicates that a view should be aligned with the right edges of the other views in its cell group.
                \item \textbf{public static final GridLayout.Alignment START}: Indicates that a view should be aligned with the start edges of the other views in its cell group.
                \item \textbf{public static final GridLayout.Alignment TOP}: Indicates that a view should be aligned with the top edges of the other views in its cell group.
            \end{itemize}

        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int ALIGN\_BOUNDS}: Constant representing an \texttt{alignmentMode}. Child bounds are aligned within their grid cells.
                \item \textbf{int ALIGN\_MARGINS}: Constant representing an \texttt{alignmentMode}. Child margins are aligned within their grid cells.
                \item \textbf{int HORIZONTAL}: Constant representing a horizontal orientation for the layout.
                \item \textbf{int UNDEFINED}: Constant used to indicate that a value is undefined.
                \item \textbf{int VERTICAL}: Constant representing a vertical orientation for the layout.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{GridLayout.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy}: 
            \begin{center}
                java.lang.Object $\to $	android.view.ViewGroup.LayoutParams $\to $	android.view.ViewGroup.MarginLayoutParams $\to$	android.widget.GridLayout.LayoutParams
            \end{center}
        \item \textbf{Include}:
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.GridLayout.LayoutParams
            \end{javacode}
        \item \textbf{Constructors}:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams()
                LayoutParams(Context context, AttributeSet attrs)
                LayoutParams(ViewGroup.LayoutParams params)
                LayoutParams(ViewGroup.MarginLayoutParams params)
                LayoutParams(GridLayout.LayoutParams source)
                LayoutParams(GridLayout.Spec rowSpec, GridLayout.Spec columnSpec)
            \end{javacode}
            \bigbreak \noindent 
            \textbf{Note:} Values not defined in the attribute set take the default values defined in LayoutParams.
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{boolean equals(Object o)}: Indicates whether some other object is "equal to" this one.
                \item \textbf{int hashCode()}: Returns a hash code value for the object.
                \item \textbf{void setGravity(int gravity)}: Describes how the child views are positioned.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void setBaseAttributes(TypedArray attributes, int widthAttr, int heightAttr)}: Extracts the layout parameters from the supplied attributes.
            \end{itemize}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public GridLayout.Spec columnSpec}: The spec that defines the horizontal characteristics of the cell group described by these layout parameters.
                \item \textbf{public GridLayout.Spec rowSpec}: The spec that defines the vertical characteristics of the cell group described by these layout parameters.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{TableLayout}
    \begin{itemize}
        \item \textbf{Hierarchy}:
            \begin{center}
                java.lang.Object $\to $	android.view.View $\to $	android.view.ViewGroup $\to $	android.widget.LinearLayout $\to $	android.widget.TableLayout
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.TableLayout
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                TableLayout(Context context)
                TableLayout(Context context, AttributeSet attrs)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void addView(View child, int index)}: Adds a child view at the specified index.
                \item \textbf{void addView(View child, ViewGroup.LayoutParams params)}: Adds a child view with the specified layout parameters.
                \item \textbf{void addView(View child)}: Adds a child view to the layout.
                \item \textbf{void addView(View child, int index, ViewGroup.LayoutParams params)}: Adds a child view at the specified index with the given layout parameters.
                \item \textbf{TableLayout.LayoutParams generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attribute set.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object to be used for accessibility purposes.
                \item \textbf{boolean isColumnCollapsed(int columnIndex)}: Returns the collapsed state of the specified column.
                \item \textbf{boolean isColumnShrinkable(int columnIndex)}: Returns whether the specified column is shrinkable.
                \item \textbf{boolean isColumnStretchable(int columnIndex)}: Returns whether the specified column is stretchable.
                \item \textbf{boolean isShrinkAllColumns()}: Indicates whether all columns in the table are shrinkable.
                \item \textbf{boolean isStretchAllColumns()}: Indicates whether all columns in the table are stretchable.
                \item \textbf{void requestLayout()}: Call this when something has changed that invalidates the layout of this view.
                \item \textbf{void setColumnCollapsed(int columnIndex, boolean isCollapsed)}: Collapses or restores the specified column.
                \item \textbf{void setColumnShrinkable(int columnIndex, boolean isShrinkable)}: Sets whether the specified column can shrink if necessary.
                \item \textbf{void setColumnStretchable(int columnIndex, boolean isStretchable)}: Sets whether the specified column can stretch to fill available space.
                \item \textbf{void setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener listener)}: Registers a listener to be notified when a child view is added to or removed from this layout.
                \item \textbf{void setShrinkAllColumns(boolean shrinkAllColumns)}: Convenience method to mark all columns as shrinkable.
                \item \textbf{void setStretchAllColumns(boolean stretchAllColumns)}: Convenience method to mark all columns as stretchable.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean checkLayoutParams(ViewGroup.LayoutParams p)}: Determines whether the supplied layout parameters are valid for this layout.
                \item \textbf{LinearLayout.LayoutParams generateDefaultLayoutParams()}: Returns a set of default layout parameters with a width of \texttt{ViewGroup.LayoutParams.MATCH\_PARENT} and a height of \texttt{ViewGroup.LayoutParams.WRAP\_CONTENT}.
                \item \textbf{LinearLayout.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p)}: Returns a safe set of layout parameters based on the supplied layout parameters.
                \item \textbf{void onLayout(boolean changed, int l, int t, int r, int b)}: Called during layout when this view should assign a size and position to each of its children.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine the measured width and height.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{TableLayout.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to $	android.view.ViewGroup.LayoutParams $\to $	android.view.ViewGroup.MarginLayoutParams $\to $	android.widget.LinearLayout.LayoutParams $\to $	android.widget.TableLayout.LayoutParams
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.widget.TableLayout.LayoutParams
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams()
                LayoutParams(Context c, AttributeSet attrs)
                LayoutParams(ViewGroup.LayoutParams p)
                LayoutParams(ViewGroup.MarginLayoutParams source)
                LayoutParams(int w, int h)
                LayoutParams(int w, int h, float initWeight)
            \end{javacode}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void setBaseAttributes(TypedArray a, int widthAttr, int heightAttr)}: Fixes the row's width to ViewGroup.LayoutParams.MATCH\_PARENT; the row's height is fixed to ViewGroup.LayoutParams.WRAP\_CONTENT if no layout height is specified.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{TableRow}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.LinearLayout $\to$	android.widget.TableRow
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.widget.TableRow
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                TableRow(Context context)
                TableRow(Context context, AttributeSet attrs)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{TableRow.LayoutParams	generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attributes set.
                \item \textbf{CharSequence	getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{View	getVirtualChildAt(int i)}:
                \item \textbf{int	getVirtualChildCount()}:
                \item \textbf{void	setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener listener)}: Register a callback to be invoked when a child is added to or removed from this view.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean	checkLayoutParams(ViewGroup.LayoutParams p)}:
                \item \textbf{LinearLayout.LayoutParams	generateDefaultLayoutParams()}: Returns a set of layout parameters with a width of ViewGroup.LayoutParams.MATCH\_PARENT, a height of ViewGroup.LayoutParams.WRAP\_CONTENT and no spanning.
                \item \textbf{LinearLayout.LayoutParams	generateLayoutParams(ViewGroup.LayoutParams p)}: Returns a safe set of layout parameters based on the supplied layout params.
                \item \textbf{void	onLayout(boolean changed, int l, int t, int r, int b)}: Called from layout when this view should assign a size and position to each of its children.
                \item \textbf{void	onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measure the view and its content to determine the measured width and the measured height.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{FrameLayout}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to $	android.widget.FrameLayout
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.FrameLayout
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                FrameLayout(Context context)
                FrameLayout(Context context, AttributeSet attrs)
                FrameLayout(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
                FrameLayout(Context context, AttributeSet attrs, int defStyleAttr)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{FrameLayout.LayoutParams generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attribute set.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object to be used for accessibility purposes.
                \item \textbf{boolean getConsiderGoneChildrenWhenMeasuring()}: \textit{(Deprecated in API level 15)} — Previously determined whether to include \texttt{GONE} children in measurement. Replaced by \texttt{getMeasureAllChildren()} for naming consistency.
                \item \textbf{boolean getMeasureAllChildren()}: Determines whether all children, or only those in the \texttt{VISIBLE} or \texttt{INVISIBLE} state, are considered during measurement.
                \item \textbf{void setForegroundGravity(int foregroundGravity)}: Describes how the foreground drawable is positioned within the layout.
                \item \textbf{void setMeasureAllChildren(boolean measureAll)}: Sets whether all children, or only visible ones, should be considered when measuring the layout.
                \item \textbf{boolean shouldDelayChildPressedState()}: Returns true if the pressed state should be delayed for children or descendants of this \texttt{ViewGroup}.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean checkLayoutParams(ViewGroup.LayoutParams p)}: Determines whether the supplied layout parameters are valid for this layout.
                \item \textbf{FrameLayout.LayoutParams generateDefaultLayoutParams()}: Returns a set of default layout parameters with both width and height set to \texttt{ViewGroup.LayoutParams.MATCH\_PARENT}.
                \item \textbf{ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp)}: Returns a safe set of layout parameters based on the supplied layout parameters.
                \item \textbf{void onLayout(boolean changed, int left, int top, int right, int bottom)}: Called during layout when this view should assign a size and position to each of its children.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine the measured width and height.
            \end{itemize}

        
    \end{itemize}

    \pagebreak 
    \subsubsection{FrameLayout.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy}        
            \begin{center}
                java.lang.Object $\to$	android.view.ViewGroup.LayoutParams $\to$	android.view.ViewGroup.MarginLayoutParams $\to$	android.widget.FrameLayout.LayoutParams
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.FrameLayout.LayoutParams
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams(Context c, AttributeSet attrs)
                LayoutParams(ViewGroup.LayoutParams source)
                LayoutParams(ViewGroup.MarginLayoutParams source)
                LayoutParams(FrameLayout.LayoutParams source)
                LayoutParams(int width, int height)
                LayoutParams(int width, int height, int gravity)
            \end{javacode}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public int gravity}: The gravity to apply with the View to which these layout parameters are associated.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int UNSPECIFIED\_GRAVITY}: Value for gravity indicating that a gravity has not been explicitly specified.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ListView}
    \begin{itemize}
        \item \textbf{Hierarchy}:       
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.AdapterView<android.widget.ListAdapter> $\to$	android.widget.AbsListView $\to$	android.widget.ListView
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.ListView
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                ListView(Context context)
                ListView(Context context, AttributeSet attrs)
                ListView(Context context, AttributeSet attrs, int defStyleAttr)
                ListView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void addFooterView(View v)}: Adds a fixed view to appear at the bottom of the list.
                \item \textbf{void addFooterView(View v, Object data, boolean isSelectable)}: Adds a fixed view to appear at the bottom of the list with optional data and selectable state.
                \item \textbf{void addHeaderView(View v, Object data, boolean isSelectable)}: Adds a fixed view to appear at the top of the list with optional data and selectable state.
                \item \textbf{void addHeaderView(View v)}: Adds a fixed view to appear at the top of the list.
                \item \textbf{boolean areFooterDividersEnabled()}: Returns whether footer dividers are currently enabled.
                \item \textbf{boolean areHeaderDividersEnabled()}: Returns whether header dividers are currently enabled.
                \item \textbf{boolean dispatchKeyEvent(KeyEvent event)}: Dispatches a key event to the next view on the focus path.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the accessibility class name. A \texttt{TYPE\_VIEW\_SCROLLED} event should be sent whenever a scroll happens, even if position and child count remain unchanged.
                \item \textbf{ListAdapter getAdapter()}: Returns the adapter currently in use by this \texttt{ListView}.
                \item \textbf{long[] getCheckItemIds()}: \textit{(Deprecated in API 15)} — Use \texttt{AbsListView.getCheckedItemIds()} instead. Returns the IDs of the currently checked items.
                \item \textbf{Drawable getDivider()}: Returns the drawable that is drawn between each list item.
                \item \textbf{int getDividerHeight()}: Returns the height of the divider between list items.
                \item \textbf{int getFooterViewsCount()}: Returns the number of fixed footer views currently added.
                \item \textbf{int getHeaderViewsCount()}: Returns the number of fixed header views currently added.
                \item \textbf{boolean getItemsCanFocus()}: Returns whether list items can contain focusable elements.
                \item \textbf{int getMaxScrollAmount()}: Returns the maximum amount the list can scroll in response to arrow events.
                \item \textbf{Drawable getOverscrollFooter()}: Returns the drawable drawn below all list content when overscrolling.
                \item \textbf{Drawable getOverscrollHeader()}: Returns the drawable drawn above all list content when overscrolling.
                \item \textbf{boolean isOpaque()}: Indicates whether this view is opaque.
                \item \textbf{void onInitializeAccessibilityNodeInfoForItem(View view, int position, AccessibilityNodeInfo info)}: Initializes accessibility node info for a specific list item.
                \item \textbf{boolean onKeyDown(int keyCode, KeyEvent event)}: Default implementation handles key presses such as \texttt{KEYCODE\_DPAD\_CENTER} or \texttt{KEYCODE\_ENTER} to trigger selection.
                \item \textbf{boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)}: Default implementation always returns false (does not handle multiple key events).
                \item \textbf{boolean onKeyUp(int keyCode, KeyEvent event)}: Default implementation handles key releases such as \texttt{KEYCODE\_DPAD\_CENTER}, \texttt{KEYCODE\_ENTER}, or \texttt{KEYCODE\_SPACE} to perform clicks.
                \item \textbf{boolean removeFooterView(View v)}: Removes a previously added footer view.
                \item \textbf{boolean removeHeaderView(View v)}: Removes a previously added header view.
                \item \textbf{boolean requestChildRectangleOnScreen(View child, Rect rect, boolean immediate)}: Called when a child requests that a specific rectangle within it be visible on the screen.
                \item \textbf{void setAdapter(ListAdapter adapter)}: Sets the adapter that provides the data and views for this \texttt{ListView}.
                \item \textbf{void setCacheColorHint(int color)}: When set to a nonzero value, indicates that the list is drawn on top of a solid, opaque background of that color.
                \item \textbf{void setDivider(Drawable divider)}: Sets the drawable that will be drawn between list items.
                \item \textbf{void setDividerHeight(int height)}: Sets the height of the divider drawn between list items.
                \item \textbf{void setFooterDividersEnabled(boolean footerDividersEnabled)}: Enables or disables drawing of dividers for footer views.
                \item \textbf{void setHeaderDividersEnabled(boolean headerDividersEnabled)}: Enables or disables drawing of dividers for header views.
                \item \textbf{void setItemsCanFocus(boolean itemsCanFocus)}: Indicates whether views created by the adapter can contain focusable items.
                \item \textbf{void setOverscrollFooter(Drawable footer)}: Sets the drawable to be drawn below all list content during overscroll.
                \item \textbf{void setOverscrollHeader(Drawable header)}: Sets the drawable to be drawn above all list content during overscroll.
                \item \textbf{void setRemoteViewsAdapter(Intent intent)}: Sets up this \texttt{ListView} to use a remote views adapter connected via a \texttt{RemoteViewsService}.
                \item \textbf{void setSelection(int position)}: Sets the currently selected item in the list.
                \item \textbf{void setSelectionAfterHeaderView()}: Sets the selection to the first list item following the header views.
                \item \textbf{void smoothScrollByOffset(int offset)}: Smoothly scrolls the list by the specified adapter position offset.
                \item \textbf{void smoothScrollToPosition(int position)}: Smoothly scrolls to the specified adapter position.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean canAnimate()}: Indicates whether the view group can animate its children after the first layout pass.
                \item \textbf{void dispatchDraw(Canvas canvas)}: Called by the system’s \texttt{draw()} method to render all child views within this layout.
                \item \textbf{boolean drawChild(Canvas canvas, View child, long drawingTime)}: Draws a single child view of this \texttt{ViewGroup} onto the provided \texttt{Canvas}.
                \item \textbf{void layoutChildren()}: Abstract method that subclasses must override to define how their child views are positioned and sized.
                \item \textbf{void onDetachedFromWindow()}: Called when the view is detached from its window, typically used to clean up resources or listeners.
                \item \textbf{void onFinishInflate()}: Called after a view and all its children have been inflated from XML to perform any final initialization.
                \item \textbf{void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)}: Invoked when the view’s focus state changes, providing the direction and previously focused rectangle.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its children to determine the overall measured width and height.
                \item \textbf{void onSizeChanged(int w, int h, int oldw, int oldh)}: Called during layout when the view’s size changes, allowing for recalculation of layout-dependent properties.
            \end{itemize}


    \end{itemize}

    \pagebreak 
    \subsubsection{TextView}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.TextView
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.TextView
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                TextView(Context context)
                TextView(Context context, AttributeSet attrs)
                TextView(Context context, AttributeSet attrs, int defStyleAttr)
                TextView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) 
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)}: Adds extra data to an \texttt{AccessibilityNodeInfo} based on an explicit request for the additional data.
                \item \textbf{void addTextChangedListener(TextWatcher watcher)}: Adds a \texttt{TextWatcher} whose methods are called whenever this \texttt{TextView}'s text changes.
                \item \textbf{final void append(CharSequence text)}: Appends text to the display buffer, upgrading to \texttt{BufferType.EDITABLE} if needed.
                \item \textbf{void append(CharSequence text, int start, int end)}: Appends a slice of text to the display buffer, upgrading to \texttt{BufferType.EDITABLE} if needed.
                \item \textbf{void autofill(AutofillValue value)}: Automatically fills this view’s content with the provided value.
                \item \textbf{void beginBatchEdit()}: Begins a batch edit session.
                \item \textbf{boolean bringPointIntoView(int offset)}: Moves the character offset into view if needed.
                \item \textbf{boolean bringPointIntoView(int offset, boolean requestRectWithoutFocus)}: Moves the insertion position at the given offset into the visible area.
                \item \textbf{void cancelLongPress()}: Cancels a pending long press.
                \item \textbf{void clearComposingText()}:\ Uses \texttt{BaseInputConnection.removeComposingSpans()} to clear IME composing state.
                \item \textbf{void computeScroll()}: Requests the child to update \texttt{mScrollX} and \texttt{mScrollY} if necessary.
                \item \textbf{void debug(int depth)}: Outputs debug information with the given depth.
                \item \textbf{boolean didTouchFocusSelect()}:\ During a touch gesture, returns true iff initial touch moved focus to this view and changed selection.
                \item \textbf{void drawableHotspotChanged(float x, float y)}: Propagates view hotspot changes to drawables/children.
                \item \textbf{void endBatchEdit()}: Ends a batch edit session.
                \item \textbf{boolean extractText(ExtractedTextRequest request, ExtractedText outText)}: Extracts a portion of editable content into \texttt{outText}.
                \item \textbf{void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags)}: Finds views containing the given text.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the accessibility class name.
                \item \textbf{final int getAutoLinkMask()}: Gets the autolink mask.
                \item \textbf{int getAutoSizeMaxTextSize()}: Returns max auto-size text size.
                \item \textbf{int getAutoSizeMinTextSize()}: Returns min auto-size text size.
                \item \textbf{int getAutoSizeStepGranularity()}: Returns auto-size step granularity.
                \item \textbf{int[] getAutoSizeTextAvailableSizes()}: Returns available auto-size text sizes.
                \item \textbf{int getAutoSizeTextType()}: Returns the auto-size text type.
                \item \textbf{String[] getAutofillHints()}: Gets autofill hints for \texttt{AutofillService}.
                \item \textbf{int getAutofillType()}: Describes the autofill type for this view.
                \item \textbf{AutofillValue getAutofillValue()}: Returns current text as an \texttt{AutofillValue}.
                \item \textbf{int getBaseline()}: Returns the text baseline offset from the top.
                \item \textbf{int getBreakStrategy()}: Gets the paragraph line-break strategy.
                \item \textbf{int getCompoundDrawablePadding()}: Returns padding between compound drawables and text.
                \item \textbf{BlendMode getCompoundDrawableTintBlendMode()}: Returns the tint blend mode for compound drawables.
                \item \textbf{ColorStateList getCompoundDrawableTintList()}: Returns the tint list for compound drawables.
                \item \textbf{PorterDuff.Mode getCompoundDrawableTintMode()}: Returns the Porter-Duff tint mode for compound drawables.
                \item \textbf{Drawable[] getCompoundDrawables()}: Returns left, top, right, bottom drawables.
                \item \textbf{Drawable[] getCompoundDrawablesRelative()}: Returns start, top, end, bottom drawables.
                \item \textbf{int getCompoundPaddingBottom()}: Returns bottom padding plus drawable space.
                \item \textbf{int getCompoundPaddingEnd()}: Returns end padding plus drawable space.
                \item \textbf{int getCompoundPaddingLeft()}: Returns left padding plus drawable space.
                \item \textbf{int getCompoundPaddingRight()}: Returns right padding plus drawable space.
                \item \textbf{int getCompoundPaddingStart()}: Returns start padding plus drawable space.
                \item \textbf{int getCompoundPaddingTop()}: Returns top padding plus drawable space.
                \item \textbf{final int getCurrentHintTextColor()}: Returns current hint text color.
                \item \textbf{final int getCurrentTextColor()}: Returns current text color.
                \item \textbf{ActionMode.Callback getCustomInsertionActionModeCallback()}: Gets the custom insertion \texttt{ActionMode} callback.
                \item \textbf{ActionMode.Callback getCustomSelectionActionModeCallback()}: Gets the custom selection \texttt{ActionMode} callback.
                \item \textbf{Editable getEditableText()}: Returns the text as an \texttt{Editable}.
                \item \textbf{TextUtils.TruncateAt getEllipsize()}: Returns where long text is ellipsized.
                \item \textbf{CharSequence getError()}: Returns the current error message or \texttt{null}.
                \item \textbf{int getExtendedPaddingBottom()}: Returns extended bottom padding.
                \item \textbf{int getExtendedPaddingTop()}: Returns extended top padding.
                \item \textbf{InputFilter[] getFilters()}: Returns the list of input filters.
                \item \textbf{int getFirstBaselineToTopHeight()}: Distance from first baseline to top.
                \item \textbf{void getFocusedRect(Rect r)}: Fills \texttt{r} with the focus search rectangle.
                \item \textbf{int getFocusedSearchResultHighlightColor()}: Gets focused search result highlight color.
                \item \textbf{int getFocusedSearchResultIndex()}: Gets focused search result index.
                \item \textbf{String getFontFeatureSettings()}: Returns font feature settings.
                \item \textbf{String getFontVariationSettings()}: Returns font variation settings.
                \item \textbf{boolean getFreezesText()}: Whether full text is saved in icicles.
                \item \textbf{int getGravity()}: Returns horizontal/vertical text gravity.
                \item \textbf{int getHighlightColor()}: Returns selection highlight color.
                \item \textbf{Highlights getHighlights()}: Returns highlights.
                \item \textbf{CharSequence getHint()}: Returns the hint text.
                \item \textbf{final ColorStateList getHintTextColors()}: Returns hint text colors.
                \item \textbf{int getHyphenationFrequency()}: Gets automatic hyphenation frequency.
                \item \textbf{int getImeActionId()}: Gets IME action ID set via \texttt{setImeActionLabel}.
                \item \textbf{CharSequence getImeActionLabel()}: Gets IME action label.
                \item \textbf{LocaleList getImeHintLocales()}: Gets IME hint locales.
                \item \textbf{int getImeOptions()}: Gets IME options.
                \item \textbf{boolean getIncludeFontPadding()}: Whether extra ascent/descent padding is included.
                \item \textbf{Bundle getInputExtras(boolean create)}: Retrieves/creates input extras bundle.
                \item \textbf{int getInputType()}: Gets the editable content type.
                \item \textbf{int getJustificationMode()}: Gets text justification mode.
                \item \textbf{final KeyListener getKeyListener()}: Gets the current \texttt{KeyListener}.
                \item \textbf{int getLastBaselineToBottomHeight()}: Distance from last baseline to bottom.
                \item \textbf{final Layout getLayout()}: Gets the current text \texttt{Layout}.
                \item \textbf{float getLetterSpacing()}: Gets letter spacing (em).
                \item \textbf{int getLineBounds(int line, Rect bounds)}: Returns baseline for a line; optionally fills \texttt{bounds}.
                \item \textbf{int getLineBreakStyle()}: Gets line-break style.
                \item \textbf{int getLineBreakWordStyle()}: Gets line-break word style.
                \item \textbf{int getLineCount()}: Returns line count or 0 if layout not built.
                \item \textbf{int getLineHeight()}: Returns line height in pixels.
                \item \textbf{float getLineSpacingExtra()}: Returns extra line spacing.
                \item \textbf{float getLineSpacingMultiplier()}: Returns line spacing multiplier.
                \item \textbf{final ColorStateList getLinkTextColors()}: Returns link text colors.
                \item \textbf{final boolean getLinksClickable()}: Whether \texttt{LinkMovementMethod} is auto-set for links.
                \item \textbf{int getMarqueeRepeatLimit()}: Returns marquee repeat count.
                \item \textbf{int getMaxEms()}: Returns max width in ems, or -1.
                \item \textbf{int getMaxHeight()}: Returns max height in px, or -1.
                \item \textbf{int getMaxLines()}: Returns max lines, or -1.
                \item \textbf{int getMaxWidth()}: Returns max width in px, or -1.
                \item \textbf{int getMinEms()}: Returns min width in ems, or -1.
                \item \textbf{int getMinHeight()}: Returns min height in px, or -1.
                \item \textbf{int getMinLines()}: Returns min lines, or -1.
                \item \textbf{int getMinWidth()}: Returns min width in px, or -1.
                \item \textbf{Paint.FontMetrics getMinimumFontMetrics()}: Returns minimum font metrics used for line spacing.
                \item \textbf{final MovementMethod getMovementMethod()}: Gets the \texttt{MovementMethod}.
                \item \textbf{int getOffsetForPosition(float x, float y)}: Returns closest character offset to the given position.
                \item \textbf{TextPaint getPaint()}: Gets the \texttt{TextPaint}.
                \item \textbf{int getPaintFlags()}: Gets the current paint flags.
                \item \textbf{String getPrivateImeOptions()}: Gets private IME options.
                \item \textbf{int getSearchResultHighlightColor()}: Gets search result highlight color.
                \item \textbf{int[] getSearchResultHighlights()}: Gets current search result ranges.
                \item \textbf{int getSelectionEnd()}: Convenience for \texttt{Selection.getSelectionEnd}.
                \item \textbf{int getSelectionStart()}: Convenience for \texttt{Selection.getSelectionStart}.
                \item \textbf{int getShadowColor()}: Gets shadow color.
                \item \textbf{float getShadowDx()}: Gets shadow X offset.
                \item \textbf{float getShadowDy()}: Gets shadow Y offset.
                \item \textbf{float getShadowRadius()}: Gets shadow blur radius.
                \item \textbf{boolean getShiftDrawingOffsetForStartOverhang()}: True if shifting x-offset for start overhang.
                \item \textbf{final boolean getShowSoftInputOnFocus()}: Whether soft input shows on focus.
                \item \textbf{CharSequence getText()}: Returns the displayed text.
                \item \textbf{TextClassifier getTextClassifier()}: Returns the \texttt{TextClassifier}.
                \item \textbf{final ColorStateList getTextColors()}: Returns text colors by state.
                \item \textbf{Drawable getTextCursorDrawable()}: Returns the cursor drawable.
                \item \textbf{TextDirectionHeuristic getTextDirectionHeuristic()}: Returns resolved text direction heuristic.
                \item \textbf{Locale getTextLocale()}: Returns primary text \texttt{Locale}.
                \item \textbf{LocaleList getTextLocales()}: Returns text \texttt{LocaleList}.
                \item \textbf{PrecomputedText.Params getTextMetricsParams()}: Returns precomputed-text layout params.
                \item \textbf{float getTextScaleX()}: Returns horizontal text scale factor.
                \item \textbf{Drawable getTextSelectHandle()}: Returns selection handle drawable.
                \item \textbf{Drawable getTextSelectHandleLeft()}: Returns left selection handle drawable.
                \item \textbf{Drawable getTextSelectHandleRight()}: Returns right selection handle drawable.
                \item \textbf{float getTextSize()}: Returns text size (sp units).
                \item \textbf{int getTextSizeUnit()}: Returns the defined text size unit.
                \item \textbf{int getTotalPaddingBottom()}: Returns total bottom padding.
                \item \textbf{int getTotalPaddingEnd()}: Returns total end padding.
                \item \textbf{int getTotalPaddingLeft()}: Returns total left padding.
                \item \textbf{int getTotalPaddingRight()}: Returns total right padding.
                \item \textbf{int getTotalPaddingStart()}: Returns total start padding.
                \item \textbf{int getTotalPaddingTop()}: Returns total top padding.
                \item \textbf{final TransformationMethod getTransformationMethod()}: Returns the current text transformation method.
                \item \textbf{Typeface getTypeface()}: Returns the current \texttt{Typeface}.
                \item \textbf{URLSpan[] getUrls()}: Returns \texttt{URLSpan}s attached to the text.
                \item \textbf{boolean getUseBoundsForWidth()}: True if bounding box width is used for line breaking/drawing.
                \item \textbf{boolean hasOverlappingRendering()}: Whether the view has overlapping rendering.
                \item \textbf{boolean hasSelection()}: True iff there is a nonzero-length selection.
                \item \textbf{void invalidateDrawable(Drawable drawable)}: Invalidates the given drawable.
                \item \textbf{boolean isAllCaps()}: Whether ALL CAPS transformation is applied.
                \item \textbf{boolean isAutoHandwritingEnabled()}: Whether automatic handwriting initiation is allowed.
                \item \textbf{boolean isCursorVisible()}: Whether the cursor is visible.
                \item \textbf{boolean isElegantTextHeight()}: Gets elegant height metrics flag.
                \item \textbf{boolean isFallbackLineSpacing()}: Whether fallback font ascent/descent is respected.
                \item \textbf{final boolean isHorizontallyScrollable()}: Whether text may be wider than the view.
                \item \textbf{boolean isInputMethodTarget()}: Whether this view is the current input method target.
                \item \textbf{boolean isLocalePreferredLineHeightForMinimumUsed()}: True if locale-preferred line height is used for minimum line height.
                \item \textbf{boolean isSingleLine()}: Whether text is constrained to a single scrolling line.
                \item \textbf{boolean isSuggestionsEnabled()}: Whether suggestions are enabled.
                \item \textbf{boolean isTextSelectable()}: Returns \texttt{textIsSelectable} state.
                \item \textbf{void jumpDrawablesToCurrentState()}: Calls \texttt{jumpToCurrentState()} on associated drawables.
                \item \textbf{int length()}: Returns the text length in characters.
                \item \textbf{boolean moveCursorToVisibleOffset()}: Moves cursor to a visible offset if needed.
                \item \textbf{void onBeginBatchEdit()}: Called when a batch edit begins.
                \item \textbf{boolean onCheckIsTextEditor()}: Whether this view is a text editor.
                \item \textbf{void onCommitCompletion(CompletionInfo text)}: Called on IME completion.
                \item \textbf{void onCommitCorrection(CorrectionInfo info)}: Called on IME auto-correction.
                \item \textbf{InputConnection onCreateInputConnection(EditorInfo outAttrs)}: Creates an \texttt{InputConnection}.
                \item \textbf{void onCreateViewTranslationRequest(int[] supportedFormats, Consumer<ViewTranslationRequest> requestsCollector)}: Collects view translation requests.
                \item \textbf{boolean onDragEvent(DragEvent event)}: Handles drag events.
                \item \textbf{void onEditorAction(int actionCode)}: Called for \texttt{performEditorAction()}.
                \item \textbf{void onEndBatchEdit()}: Called when a batch edit ends.
                \item \textbf{boolean onGenericMotionEvent(MotionEvent event)}: Handles generic motion events.
                \item \textbf{boolean onKeyDown(int keyCode, KeyEvent event)}: Default handling for key down (e.g., DPAD\_CENTER/ENTER).
                \item \textbf{boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)}: Default returns false for multiple key events.
                \item \textbf{boolean onKeyPreIme(int keyCode, KeyEvent event)}: Handles a key event before IME processes it.
                \item \textbf{boolean onKeyShortcut(int keyCode, KeyEvent event)}: Called when key shortcut isn’t handled.
                \item \textbf{boolean onKeyUp(int keyCode, KeyEvent event)}: Default handling for key up (e.g., DPAD\_CENTER/ENTER/SPACE).
                \item \textbf{boolean onPreDraw()}: Called when the view tree is about to be drawn.
                \item \textbf{boolean onPrivateIMECommand(String action, Bundle data)}: Handles private IME commands.
                \item \textbf{ContentInfo onReceiveContent(ContentInfo payload)}: Default content reception.
                \item \textbf{PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)}: Resolves pointer icon for the event.
                \item \textbf{void onRestoreInstanceState(Parcelable state)}: Restores internal state from \texttt{Parcelable}.
                \item \textbf{void onRtlPropertiesChanged(int layoutDirection)}: Called when RTL-related properties change.
                \item \textbf{Parcelable onSaveInstanceState()}: Saves internal state to a \texttt{Parcelable}.
                \item \textbf{void onScreenStateChanged(int screenState)}: Called when the screen state changes.
                \item \textbf{boolean onTextContextMenuItem(int id)}: Handles a text context menu selection.
                \item \textbf{boolean onTouchEvent(MotionEvent event)}: Handles pointer events.
                \item \textbf{boolean onTrackballEvent(MotionEvent event)}: Handles trackball events.
                \item \textbf{void onVisibilityAggregated(boolean isVisible)}: Called when user-visibility may change.
                \item \textbf{void onWindowFocusChanged(boolean hasWindowFocus)}: Called when the containing window’s focus changes.
                \item \textbf{boolean performLongClick()}: Invokes \texttt{OnLongClickListener}, if defined.
                \item \textbf{void removeTextChangedListener(TextWatcher watcher)}: Removes a \texttt{TextWatcher}.
                \item \textbf{void sendAccessibilityEventUnchecked(AccessibilityEvent event)}: Sends an accessibility event without checking if accessibility is enabled.
                \item \textbf{void setAllCaps(boolean allCaps)}: Transforms input to ALL CAPS display.
                \item \textbf{final void setAutoLinkMask(int mask)}: Sets the autolink mask.
                \item \textbf{void setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit)}: Configures uniform auto-size text.
                \item \textbf{void setAutoSizeTextTypeUniformWithPresetSizes(int[] presetSizes, int unit)}: Sets preset sizes for auto-size text.
                \item \textbf{void setAutoSizeTextTypeWithDefaults(int autoSizeTextType)}: Enables default auto-size configuration.
                \item \textbf{void setBreakStrategy(int breakStrategy)}: Sets paragraph break strategy.
                \item \textbf{void setCompoundDrawablePadding(int pad)}: Sets padding between drawables and text.
                \item \textbf{void setCompoundDrawableTintBlendMode(BlendMode blendMode)}: Sets blend mode for compound drawable tints.
                \item \textbf{void setCompoundDrawableTintList(ColorStateList tint)}: Applies tint to compound drawables.
                \item \textbf{void setCompoundDrawableTintMode(PorterDuff.Mode tintMode)}: Sets Porter-Duff blend mode for drawable tints.
                \item \textbf{void setCompoundDrawables(Drawable left, Drawable top, Drawable right, Drawable bottom)}: Sets left/top/right/bottom drawables.
                \item \textbf{void setCompoundDrawablesRelative(Drawable start, Drawable top, Drawable end, Drawable bottom)}: Sets start/top/end/bottom drawables.
                \item \textbf{void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start, Drawable top, Drawable end, Drawable bottom)}: Sets start/top/end/bottom drawables with intrinsic bounds.
                \item \textbf{void setCompoundDrawablesRelativeWithIntrinsicBounds(int start, int top, int end, int bottom)}: Same as above with resource IDs.
                \item \textbf{void setCompoundDrawablesWithIntrinsicBounds(Drawable left, Drawable top, Drawable right, Drawable bottom)}: Sets left/top/right/bottom drawables with intrinsic bounds.
                \item \textbf{void setCompoundDrawablesWithIntrinsicBounds(int left, int top, int right, int bottom)}: Same as above with resource IDs.
                \item \textbf{void setCursorVisible(boolean visible)}: Shows/hides the cursor.
                \item \textbf{void setCustomInsertionActionModeCallback(ActionMode.Callback actionModeCallback)}: Sets custom insertion \texttt{ActionMode} callback.
                \item \textbf{void setCustomSelectionActionModeCallback(ActionMode.Callback actionModeCallback)}: Sets custom selection \texttt{ActionMode} callback.
                \item \textbf{final void setEditableFactory(Editable.Factory factory)}: Sets the \texttt{Editable.Factory}.
                \item \textbf{void setElegantTextHeight(boolean elegant)}: Sets elegant height metrics flag.
                \item \textbf{void setEllipsize(TextUtils.TruncateAt where)}: Enables ellipsizing of long words.
                \item \textbf{void setEms(int ems)}: Sets exact width in ems.
                \item \textbf{void setEnabled(boolean enabled)}: Enables/disables the view.
                \item \textbf{void setError(CharSequence error)}: Shows an error icon and message popup.
                \item \textbf{void setError(CharSequence error, Drawable icon)}: Shows a custom error icon and message popup.
                \item \textbf{void setExtractedText(ExtractedText text)}: Applies extracted text to the view.
                \item \textbf{void setFallbackLineSpacing(boolean enabled)}: Respects fallback font ascent/descent when enabled.
                \item \textbf{void setFilters(InputFilter[] filters)}: Sets input filters for editable content.
                \item \textbf{void setFirstBaselineToTopHeight(int firstBaselineToTopHeight)}: Adjusts top padding so first baseline is at the given distance from top.
                \item \textbf{void setFocusedSearchResultHighlightColor(int color)}: Sets focused search result highlight color.
                \item \textbf{void setFocusedSearchResultIndex(int index)}: Sets focused search result index.
                \item \textbf{void setFontFeatureSettings(String fontFeatureSettings)}: Sets font feature settings.
                \item \textbf{boolean setFontVariationSettings(String fontVariationSettings)}: Sets TrueType/OpenType variation settings.
                \item \textbf{void setFreezesText(boolean freezesText)}: Controls saving full text on instance state.
                \item \textbf{void setGravity(int gravity)}: Sets horizontal text alignment and vertical gravity.
                \item \textbf{void setHeight(int pixels)}: Sets exact height in pixels.
                \item \textbf{void setHighlightColor(int color)}: Sets selection highlight color.
                \item \textbf{void setHighlights(Highlights highlights)}: Sets highlights.
                \item \textbf{final void setHint(CharSequence hint)}: Sets hint text.
                \item \textbf{final void setHint(int resid)}: Sets hint text from a resource.
                \item \textbf{final void setHintTextColor(ColorStateList colors)}: Sets hint text colors.
                \item \textbf{final void setHintTextColor(int color)}: Sets hint text color for all states.
                \item \textbf{void setHorizontallyScrolling(boolean whether)}: Allows text to exceed view width.
                \item \textbf{void setHyphenationFrequency(int hyphenationFrequency)}: Sets hyphenation frequency.
                \item \textbf{void setImeActionLabel(CharSequence label, int actionId)}: Sets custom IME action label and ID.
                \item \textbf{void setImeHintLocales(LocaleList hintLocales)}: Sets IME hint locales.
                \item \textbf{void setImeOptions(int imeOptions)}: Sets editor type/IME options.
                \item \textbf{void setIncludeFontPadding(boolean includepad)}: Toggles extra ascent/descent font padding.
                \item \textbf{void setInputExtras(int xmlResId)}: Sets extra input data bundle from XML.
                \item \textbf{void setInputType(int type)}: Sets the input content type.
                \item \textbf{void setJustificationMode(int justificationMode)}: Sets text justification mode.
                \item \textbf{void setKeyListener(KeyListener input)}: Sets the \texttt{KeyListener}.
                \item \textbf{void setLastBaselineToBottomHeight(int lastBaselineToBottomHeight)}: Adjusts bottom padding so last baseline is at the given distance from bottom.
                \item \textbf{void setLetterSpacing(float letterSpacing)}: Sets letter spacing (em).
                \item \textbf{void setLineBreakStyle(int lineBreakStyle)}: Sets line-break style.
                \item \textbf{void setLineBreakWordStyle(int lineBreakWordStyle)}: Sets line-break word style.
                \item \textbf{void setLineHeight(int unit, float lineHeight)}: Sets explicit line height with unit.
                \item \textbf{void setLineHeight(int lineHeight)}: Sets explicit line height (px).
                \item \textbf{void setLineSpacing(float add, float mult)}: Sets line spacing extra and multiplier.
                \item \textbf{void setLines(int lines)}: Sets exact line count.
                \item \textbf{final void setLinkTextColor(ColorStateList colors)}: Sets link text colors.
                \item \textbf{final void setLinkTextColor(int color)}: Sets link text color.
                \item \textbf{final void setLinksClickable(boolean whether)}: Controls auto-setting of \texttt{LinkMovementMethod}.
                \item \textbf{void setLocalePreferredLineHeightForMinimumUsed(boolean flag)}: Uses locale-preferred line height for minimum line height.
                \item \textbf{void setMarqueeRepeatLimit(int marqueeLimit)}: Sets marquee repeat count.
                \item \textbf{void setMaxEms(int maxEms)}: Sets maximum width in ems.
                \item \textbf{void setMaxHeight(int maxPixels)}: Sets maximum height in px.
                \item \textbf{void setMaxLines(int maxLines)}: Sets maximum number of lines.
                \item \textbf{void setMaxWidth(int maxPixels)}: Sets maximum width in px.
                \item \textbf{void setMinEms(int minEms)}: Sets minimum width in ems.
                \item \textbf{void setMinHeight(int minPixels)}: Sets minimum height in px.
                \item \textbf{void setMinLines(int minLines)}: Sets minimum number of lines.
                \item \textbf{void setMinWidth(int minPixels)}: Sets minimum width in px.
                \item \textbf{void setMinimumFontMetrics(Paint.FontMetrics minimumFontMetrics)}: Sets minimum font metrics for line spacing.
                \item \textbf{final void setMovementMethod(MovementMethod movement)}: Sets the \texttt{MovementMethod}.
                \item \textbf{void setOnEditorActionListener(TextView.OnEditorActionListener l)}: Sets a listener for editor actions.
                \item \textbf{void setPadding(int left, int top, int right, int bottom)}: Sets absolute padding.
                \item \textbf{void setPaddingRelative(int start, int top, int end, int bottom)}: Sets relative padding.
                \item \textbf{void setPaintFlags(int flags)}: Sets paint flags and reflows text if changed.
                \item \textbf{void setPrivateImeOptions(String type)}: Sets private IME options string.
                \item \textbf{void setRawInputType(int type)}: Directly sets the content type integer.
                \item \textbf{void setScroller(Scroller s)}: Sets the \texttt{Scroller} for scrolling animation.
                \item \textbf{void setSearchResultHighlightColor(int color)}: Sets search result highlight color.
                \item \textbf{void setSearchResultHighlights(int... ranges)}: Sets search result ranges (flattened).
                \item \textbf{void setSelectAllOnFocus(boolean selectAllOnFocus)}: Selects all text when gaining focus.
                \item \textbf{void setSelected(boolean selected)}: Changes selection state of this view.
                \item \textbf{void setShadowLayer(float radius, float dx, float dy, int color)}: Applies a text shadow.
                \item \textbf{void setShiftDrawingOffsetForStartOverhang(boolean shiftDrawingOffsetForStartOverhang)}: Enables shifting x offset to show start overhang.
                \item \textbf{final void setShowSoftInputOnFocus(boolean show)}: Controls soft input visibility on focus.
                \item \textbf{void setSingleLine(boolean singleLine)}: Toggles single-line properties.
                \item \textbf{void setSingleLine()}: Sets single-line properties.
                \item \textbf{final void setSpannableFactory(Spannable.Factory factory)}: Sets the \texttt{Spannable.Factory}.
                \item \textbf{final void setText(int resid)}: Sets text from a string resource.
                \item \textbf{final void setText(CharSequence text)}: Sets the displayed text.
                \item \textbf{void setText(CharSequence text, TextView.BufferType type)}: Sets text and buffer type.
                \item \textbf{final void setText(int resid, TextView.BufferType type)}: Sets text from a resource with buffer type.
                \item \textbf{final void setText(char[] text, int start, int len)}: Displays a slice of a char array.
                \item \textbf{void setTextAppearance(Context context, int resId)}: \textit{Deprecated API 23} — use \texttt{setTextAppearance(int)}.
                \item \textbf{void setTextAppearance(int resId)}: Sets the text appearance from a style resource.
                \item \textbf{void setTextClassifier(TextClassifier textClassifier)}: Sets the \texttt{TextClassifier}.
                \item \textbf{void setTextColor(int color)}: Sets text color for all states.
                \item \textbf{void setTextColor(ColorStateList colors)}: Sets text colors.
                \item \textbf{void setTextCursorDrawable(Drawable textCursorDrawable)}: Sets cursor drawable.
                \item \textbf{void setTextCursorDrawable(int textCursorDrawable)}: Sets cursor drawable by resource.
                \item \textbf{void setTextIsSelectable(boolean selectable)}: Toggles text selectability.
                \item \textbf{final void setTextKeepState(CharSequence text)}: Sets text while retaining cursor position.
                \item \textbf{final void setTextKeepState(CharSequence text, TextView.BufferType type)}: Sets text and buffer type while retaining cursor position.
                \item \textbf{void setTextLocale(Locale locale)}: Sets text \texttt{Locale} to a single-locale list.
                \item \textbf{void setTextLocales(LocaleList locales)}: Sets text \texttt{LocaleList}.
                \item \textbf{void setTextMetricsParams(PrecomputedText.Params params)}: Applies text layout parameters.
                \item \textbf{void setTextScaleX(float size)}: Sets horizontal text scale.
                \item \textbf{void setTextSelectHandle(int textSelectHandle)}: Sets selection handle drawable (resource).
                \item \textbf{void setTextSelectHandle(Drawable textSelectHandle)}: Sets selection handle drawable.
                \item \textbf{void setTextSelectHandleLeft(int textSelectHandleLeft)}: Sets left selection handle (resource).
                \item \textbf{void setTextSelectHandleLeft(Drawable textSelectHandleLeft)}: Sets left selection handle.
                \item \textbf{void setTextSelectHandleRight(Drawable textSelectHandleRight)}: Sets right selection handle.
                \item \textbf{void setTextSelectHandleRight(int textSelectHandleRight)}: Sets right selection handle (resource).
                \item \textbf{void setTextSize(int unit, float size)}: Sets text size with unit.
                \item \textbf{void setTextSize(float size)}: Sets text size in scaled pixels.
                \item \textbf{final void setTransformationMethod(TransformationMethod method)}: Sets text transformation method.
                \item \textbf{void setTypeface(Typeface tf)}: Sets the typeface.
                \item \textbf{void setTypeface(Typeface tf, int style)}: Sets typeface and style (enables fake bold/italic if needed).
                \item \textbf{void setUseBoundsForWidth(boolean useBoundsForWidth)}: Uses bounding-box width for line breaking/drawing.
                \item \textbf{void setWidth(int pixels)}: Sets exact width in pixels.
                \item \textbf{boolean showContextMenu()}: Shows the context menu.
                \item \textbf{boolean showContextMenu(float x, float y)}: Shows the context menu anchored at the given coordinates.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{int computeHorizontalScrollRange()}: Computes the horizontal range represented by the horizontal scrollbar.
                \item \textbf{int computeVerticalScrollExtent()}: Computes the vertical extent of the scrollbar thumb within the total vertical range.
                \item \textbf{int computeVerticalScrollRange()}: Computes the vertical range represented by the vertical scrollbar.
                \item \textbf{void drawableStateChanged()}: Called when the view state changes in a way that affects any displayed drawables.
                \item \textbf{int getBottomPaddingOffset()}: Returns the amount by which to extend the bottom fading region.
                \item \textbf{boolean getDefaultEditable()}: Indicates whether the view has a default \texttt{KeyListener} even if not requested via XML.
                \item \textbf{MovementMethod getDefaultMovementMethod()}: Returns the default \texttt{MovementMethod} for this view.
                \item \textbf{float getLeftFadingEdgeStrength()}: Returns the intensity of the left faded edge.
                \item \textbf{int getLeftPaddingOffset()}: Returns the amount to extend the left fading region.
                \item \textbf{float getRightFadingEdgeStrength()}: Returns the intensity of the right faded edge.
                \item \textbf{int getRightPaddingOffset()}: Returns the amount to extend the right fading region.
                \item \textbf{int getTopPaddingOffset()}: Returns the amount to extend the top fading region.
                \item \textbf{boolean isPaddingOffsetRequired()}: True if the view draws inside padding and supports fading edge padding offsets.
                \item \textbf{void onAttachedToWindow()}: Called when the view is attached to a window.
                \item \textbf{void onConfigurationChanged(Configuration newConfig)}: Called when the device/app configuration changes.
                \item \textbf{void onCreateContextMenu(ContextMenu menu)}: Allows the view to add items to its context menu.
                \item \textbf{int[] onCreateDrawableState(int extraSpace)}: Generates a new drawable state array for this view.
                \item \textbf{void onDraw(Canvas canvas)}: Performs custom drawing for this view.
                \item \textbf{void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect)}: Called when the view’s focus state changes.
                \item \textbf{void onLayout(boolean changed, int left, int top, int right, int bottom)}: Assigns size and position to child views.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine width and height.
                \item \textbf{void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert)}: Called when the view scrolls its own contents.
                \item \textbf{void onSelectionChanged(int selStart, int selEnd)}: Called when the text selection changes.
                \item \textbf{void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter)}: Called when the text content changes.
                \item \textbf{void onVisibilityChanged(View changedView, int visibility)}: Called when visibility of this view or an ancestor changes.
                \item \textbf{boolean setFrame(int l, int t, int r, int b)}: Sets the view’s frame; returns true if it changed.
                \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true for any drawable that this view is displaying.
            \end{itemize}

        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int AUTO\_SIZE\_TEXT\_TYPE\_NONE}: The TextView does not auto-size text (default).
                \item \textbf{int AUTO\_SIZE\_TEXT\_TYPE\_UNIFORM}: The TextView scales text size both horizontally and vertically to fit within the container.
                \item \textbf{int FOCUSED\_SEARCH\_RESULT\_INDEX\_NONE}: A special index used for setFocusedSearchResultIndex(int) and getFocusedSearchResultIndex() inidicating there is no focused search result.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{EditText}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.TextView $\to$	android.widget.EditText
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.EditText
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                EditText(Context context)
                EditText(Context context, AttributeSet attrs)
                EditText(Context context, AttributeSet attrs, int defStyleAttr)
                EditText(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void extendSelection(int index)}: Convenience method for \texttt{Selection.extendSelection}.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object to be used for accessibility purposes.
                \item \textbf{boolean getFreezesText()}: Returns whether this \texttt{TextView} includes its entire text contents in frozen icicles.
                \item \textbf{Editable getText()}: Returns the text that the \texttt{TextView} is displaying.
                \item \textbf{boolean isStyleShortcutEnabled()}: Returns true if style shortcuts are enabled, otherwise false.
                \item \textbf{boolean onKeyShortcut(int keyCode, KeyEvent event)}: Called on the focused view when a key shortcut event is not handled.
                \item \textbf{boolean onTextContextMenuItem(int id)}: Called when a context menu option for the text view is selected.
                \item \textbf{void selectAll()}: Convenience method for \texttt{Selection.selectAll}.
                \item \textbf{void setEllipsize(TextUtils.TruncateAt ellipsis)}: Specifies how overflowing text should be ellipsized instead of wrapped.
                \item \textbf{void setSelection(int index)}: Convenience method for \texttt{Selection.setSelection(Spannable, int)}.
                \item \textbf{void setSelection(int start, int stop)}: Convenience method for \texttt{Selection.setSelection(Spannable, int, int)}.
                \item \textbf{void setStyleShortcutsEnabled(boolean enabled)}: Enables style shortcuts such as \texttt{Ctrl+B} for bold.
                \item \textbf{void setText(CharSequence text, TextView.BufferType type)}: Sets the text to be displayed and the \texttt{TextView.BufferType}.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean getDefaultEditable()}: Subclasses override this to specify that they have a KeyListener by default even if not specifically called for in the XML options.
                \item \textbf{MovementMethod getDefaultMovementMethod()}: Subclasses override this to specify a default movement method.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{InputType (Interface)}
    \begin{itemize}
        \item \textbf{Signature}
            \bigbreak \noindent 
            \begin{javacode}
            public interface InputType
            \end{javacode}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.text.InputType
            \end{javacode}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	TYPE\_CLASS\_DATETIME}: Class for dates and times.
                \item \textbf{int	TYPE\_CLASS\_NUMBER}: Class for numeric text.
                \item \textbf{int	TYPE\_CLASS\_PHONE}: Class for a phone number.
                \item \textbf{int	TYPE\_CLASS\_TEXT}: Class for normal text.
                \item \textbf{int	TYPE\_DATETIME\_VARIATION\_DATE}: Default variation of TYPE\_CLASS\_DATETIME: allows entering only a date.
                \item \textbf{int	TYPE\_DATETIME\_VARIATION\_NORMAL}: Default variation of TYPE\_CLASS\_DATETIME: allows entering both a date and time.
                \item \textbf{int	TYPE\_DATETIME\_VARIATION\_TIME}: Default variation of TYPE\_CLASS\_DATETIME: allows entering only a time.
                \item \textbf{int	TYPE\_MASK\_CLASS}: Mask of bits that determine the overall class of text being given.
                \item \textbf{int	TYPE\_MASK\_FLAGS}: Mask of bits that provide addition bit flags of options.
                \item \textbf{int	TYPE\_MASK\_VARIATION}: Mask of bits that determine the variation of the base content class.
                \item \textbf{int	TYPE\_NULL}: Special content type for when no explicit type has been specified.
                \item \textbf{int	TYPE\_NUMBER\_FLAG\_DECIMAL}: Flag of TYPE\_CLASS\_NUMBER: the number is decimal, allowing a decimal point to provide fractional values.
                \item \textbf{int	TYPE\_NUMBER\_FLAG\_SIGNED}: Flag of TYPE\_CLASS\_NUMBER: the number is signed, allowing a positive or negative sign at the start.
                \item \textbf{int	TYPE\_NUMBER\_VARIATION\_NORMAL}: Default variation of TYPE\_CLASS\_NUMBER: plain normal numeric text.
                \item \textbf{int	TYPE\_NUMBER\_VARIATION\_PASSWORD}: Variation of TYPE\_CLASS\_NUMBER: entering a numeric password.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_AUTO\_COMPLETE}: Flag for TYPE\_CLASS\_TEXT: the text editor (which means the application) is performing auto-completion of the text being entered based on its own semantics, which it will present to the user as they type.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_AUTO\_CORRECT}: Flag for TYPE\_CLASS\_TEXT: the user is entering free-form text that should have auto-correction applied to it.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_CAP\_CHARACTERS}: Flag for TYPE\_CLASS\_TEXT: capitalize all characters.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_CAP\_SENTENCES}: Flag for TYPE\_CLASS\_TEXT: capitalize the first character of each sentence.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_CAP\_WORDS}: Flag for TYPE\_CLASS\_TEXT: capitalize the first character of every word.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_ENABLE\_TEXT\_CONVERSION\_SUGGESTIONS}: Flag for TYPE\_CLASS\_TEXT: Let the IME know the text conversion suggestions are required by the application.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_IME\_MULTI\_LINE}: Flag for TYPE\_CLASS\_TEXT: the regular text view associated with this should not be multi-line, but when a fullscreen input method is providing text it should use multiple lines if it can.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_MULTI\_LINE}: Flag for TYPE\_CLASS\_TEXT: multiple lines of text can be entered into the field.
                \item \textbf{int	TYPE\_TEXT\_FLAG\_NO\_SUGGESTIONS}: Flag for TYPE\_CLASS\_TEXT: the input method does not need to display any dictionary-based candidates.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_EMAIL\_ADDRESS}: Variation of TYPE\_CLASS\_TEXT: entering an e-mail address.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_EMAIL\_SUBJECT}: Variation of TYPE\_CLASS\_TEXT: entering the subject line of an e-mail.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_FILTER}: Variation of TYPE\_CLASS\_TEXT: entering text to filter contents of a list etc.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_LONG\_MESSAGE}: Variation of TYPE\_CLASS\_TEXT: entering the content of a long, possibly formal message such as the body of an e-mail.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_NORMAL}: Default variation of TYPE\_CLASS\_TEXT: plain old normal text.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_PASSWORD}: Variation of TYPE\_CLASS\_TEXT: entering a password.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_PERSON\_NAME}: Variation of TYPE\_CLASS\_TEXT: entering the name of a person.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_PHONETIC}: Variation of TYPE\_CLASS\_TEXT: entering text for phonetic pronunciation, such as a phonetic name field in contacts.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_POSTAL\_ADDRESS}: Variation of TYPE\_CLASS\_TEXT: entering a postal mailing address.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_SHORT\_MESSAGE}: Variation of TYPE\_CLASS\_TEXT: entering a short, possibly informal message such as an instant message or a text message.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_URI}: Variation of TYPE\_CLASS\_TEXT: entering a URI.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_VISIBLE\_PASSWORD}: Variation of TYPE\_CLASS\_TEXT: entering a password, which should be visible to the user.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_WEB\_EDIT\_TEXT}: Variation of TYPE\_CLASS\_TEXT: entering text inside of a web form.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_WEB\_EMAIL\_ADDRESS}: Variation of TYPE\_CLASS\_TEXT: entering e-mail address inside of a web form.
                \item \textbf{int	TYPE\_TEXT\_VARIATION\_WEB\_PASSWORD}: Variation of TYPE\_CLASS\_TEXT: entering password inside of a web form.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Button}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.TextView $\to$	android.widget.Button
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.Button
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Button(Context context)
                Button(Context context, AttributeSet attrs)
                Button(Context context, AttributeSet attrs, int defStyleAttr)
                Button(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{CharSequence getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)}: Resolve the pointer icon that should be used for specified pointer in the motion event.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{ImageView}
    \begin{itemize}
         \item \textbf{Hierarchy} 
             \begin{center}
                 java.lang.Object $\to$	android.view.View $\to$	android.widget.ImageView
             \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.ImageView
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                ImageView(Context context)
                ImageView(Context context, AttributeSet attrs)
                ImageView(Context context, AttributeSet attrs, int defStyleAttr)
                ImageView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void animateTransform(Matrix matrix)}: Applies a temporary transformation matrix to the view's drawable when it is drawn.
                \item \textbf{final void clearColorFilter()}: Removes the image's \texttt{ColorFilter}.
                \item \textbf{void drawableHotspotChanged(float x, float y)}: Called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object to be used for accessibility purposes.
                \item \textbf{boolean getAdjustViewBounds()}: Returns true if the ImageView is adjusting its bounds to preserve the aspect ratio of its drawable.
                \item \textbf{int getBaseline()}: Returns the offset of the widget's text baseline from the widget's top boundary.
                \item \textbf{boolean getBaselineAlignBottom()}: Checks whether this view's baseline is considered the bottom of the view.
                \item \textbf{ColorFilter getColorFilter()}: Returns the active color filter for this ImageView.
                \item \textbf{boolean getCropToPadding()}: Returns whether this ImageView crops to its padding.
                \item \textbf{Drawable getDrawable()}: Gets the current drawable, or null if none has been assigned.
                \item \textbf{int getImageAlpha()}: Returns the alpha value applied to the drawable of this ImageView.
                \item \textbf{Matrix getImageMatrix()}: Returns the view's transformation matrix, if any.
                \item \textbf{BlendMode getImageTintBlendMode()}: Gets the blending mode used to apply the tint to the image drawable.
                \item \textbf{ColorStateList getImageTintList()}: Returns the current color tint list used for the image drawable.
                \item \textbf{PorterDuff.Mode getImageTintMode()}: Gets the blending mode used to apply the tint to the image drawable.
                \item \textbf{int getMaxHeight()}: Returns the maximum height of this view.
                \item \textbf{int getMaxWidth()}: Returns the maximum width of this view.
                \item \textbf{ImageView.ScaleType getScaleType()}: Returns the current scale type used to resize or move the image.
                \item \textbf{boolean hasOverlappingRendering()}: Returns whether this view has overlapping content.
                \item \textbf{void invalidateDrawable(Drawable dr)}: Invalidates the specified drawable.
                \item \textbf{boolean isOpaque()}: Indicates whether this view is opaque.
                \item \textbf{void jumpDrawablesToCurrentState()}: Calls \texttt{Drawable.jumpToCurrentState()} on all associated drawables.
                \item \textbf{int[] onCreateDrawableState(int extraSpace)}: Generates the new drawable state for this view.
                \item \textbf{void onRtlPropertiesChanged(int layoutDirection)}: Called when any RTL property (layout direction or text alignment) changes.
                \item \textbf{void onVisibilityAggregated(boolean isVisible)}: Called when the visibility of this view or one of its ancestors changes.
                \item \textbf{void setAdjustViewBounds(boolean adjustViewBounds)}: When true, adjusts the bounds to preserve the drawable's aspect ratio.
                \item \textbf{void setAlpha(int alpha)}: \textit{Deprecated in API 16.} Use \texttt{setImageAlpha(int)} instead.
                \item \textbf{void setBaseline(int baseline)}: Sets the offset of the widget's text baseline from the widget's top boundary.
                \item \textbf{void setBaselineAlignBottom(boolean aligned)}: Sets whether the baseline is considered the bottom of the view.
                \item \textbf{final void setColorFilter(int color, PorterDuff.Mode mode)}: Sets a tint color and mode for the image.
                \item \textbf{void setColorFilter(ColorFilter cf)}: Applies a custom color filter to the image.
                \item \textbf{final void setColorFilter(int color)}: Sets a tint color for the image.
                \item \textbf{void setCropToPadding(boolean cropToPadding)}: Sets whether this ImageView will crop its content to padding.
                \item \textbf{void setImageAlpha(int alpha)}: Sets the alpha transparency applied to the image.
                \item \textbf{void setImageBitmap(Bitmap bm)}: Sets a bitmap as the content of the ImageView.
                \item \textbf{void setImageDrawable(Drawable drawable)}: Sets a drawable as the content of the ImageView.
                \item \textbf{void setImageIcon(Icon icon)}: Sets an icon as the content of the ImageView.
                \item \textbf{void setImageLevel(int level)}: Sets the level for a \texttt{LevelListDrawable}.
                \item \textbf{void setImageMatrix(Matrix matrix)}: Applies a transformation matrix to the drawable.
                \item \textbf{void setImageResource(int resId)}: Sets a drawable resource as the content of the ImageView.
                \item \textbf{void setImageState(int[] state, boolean merge)}: Sets the drawable state for a \texttt{StateListDrawable}.
                \item \textbf{void setImageTintBlendMode(BlendMode blendMode)}: Sets the blending mode for applying the tint.
                \item \textbf{void setImageTintList(ColorStateList tint)}: Applies a tint list to the image drawable.
                \item \textbf{void setImageTintMode(PorterDuff.Mode tintMode)}: Sets the blending mode for applying the tint.
                \item \textbf{void setImageURI(Uri uri)}: Sets the content of this ImageView to the image located at the specified URI.
                \item \textbf{void setMaxHeight(int maxHeight)}: Sets a maximum height for the view.
                \item \textbf{void setMaxWidth(int maxWidth)}: Sets a maximum width for the view.
                \item \textbf{void setScaleType(ImageView.ScaleType scaleType)}: Defines how the image should be resized or moved to fit the view bounds.
                \item \textbf{void setSelected(boolean selected)}: Changes the selection state of this view.
                \item \textbf{void setVisibility(int visibility)}: Sets the visibility state of this view.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects the state of its drawables.
                \item \textbf{void onAttachedToWindow()}: Called when the view is attached to a window.
                \item \textbf{void onDetachedFromWindow()}: Called when the view is detached from a window.
                \item \textbf{void onDraw(Canvas canvas)}: Implement this method to perform custom drawing for the view.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine the measured width and height.
                \item \textbf{boolean setFrame(int l, int t, int r, int b)}: Assigns size and position to the view within its parent layout.
                \item \textbf{boolean verifyDrawable(Drawable dr)}: Returns true if the view is displaying the given drawable; subclasses should override when managing their own drawables.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{ImageButton}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.ImageView $\to$	android.widget.ImageButton
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.ImageButton
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                ImageButton(Context context)
                ImageButton(Context context, AttributeSet attrs)
                ImageButton(Context context, AttributeSet attrs, int defStyleAttr)
                ImageButton(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{CharSequence	getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{PointerIcon	onResolvePointerIcon(MotionEvent event, int pointerIndex)}: Resolve the pointer icon that should be used for specified pointer in the motion event.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean	onSetAlpha(int alpha)}: Invoked if there is a Transform that involves alpha.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{CompoundButton}
    \begin{itemize}
         \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.TextView $\to$	android.widget.Button $\to$	android.widget.CompoundButton
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.CompoundButton
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                CompoundButton(Context context)
                CompoundButton(Context context, AttributeSet attrs)
                CompoundButton(Context context, AttributeSet attrs, int defStyleAttr)
                CompoundButton(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void autofill(AutofillValue value)}: Automatically fills the content of this view with the given autofill value.
                \item \textbf{void drawableHotspotChanged(float x, float y)}: Called when the view hotspot changes and must be propagated to drawables or child views.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object for accessibility purposes.
                \item \textbf{int getAutofillType()}: Describes the autofill type of this view, allowing an \texttt{AutofillService} to create an appropriate \texttt{AutofillValue}.
                \item \textbf{AutofillValue getAutofillValue()}: Returns the current text of this \texttt{TextView} for autofill purposes.
                \item \textbf{Drawable getButtonDrawable()}: Returns the button drawable associated with this compound button.
                \item \textbf{BlendMode getButtonTintBlendMode()}: Returns the blending mode used to apply the tint to the button drawable.
                \item \textbf{ColorStateList getButtonTintList()}: Returns the tint list applied to the button drawable.
                \item \textbf{PorterDuff.Mode getButtonTintMode()}: Returns the blending mode used to apply the tint to the button drawable.
                \item \textbf{int getCompoundPaddingLeft()}: Returns the left padding of the view, including space for the left drawable if present.
                \item \textbf{int getCompoundPaddingRight()}: Returns the right padding of the view, including space for the right drawable if present.
                \item \textbf{boolean isChecked()}: Returns the checked state of this button.
                \item \textbf{void jumpDrawablesToCurrentState()}: Calls \texttt{Drawable.jumpToCurrentState()} on all drawable objects associated with this view.
                \item \textbf{void onRestoreInstanceState(Parcelable state)}: Restores the internal state of the view from a previously saved state.
                \item \textbf{Parcelable onSaveInstanceState()}: Saves the internal state of the view for later restoration.
                \item \textbf{boolean performClick()}: Calls this view’s \texttt{OnClickListener}, if one is defined.
                \item \textbf{void setButtonDrawable(int resId)}: Sets a drawable as the compound button image using its resource identifier.
                \item \textbf{void setButtonDrawable(Drawable drawable)}: Sets a drawable as the compound button image.
                \item \textbf{void setButtonIcon(Icon icon)}: Sets the button of this compound button to the specified icon.
                \item \textbf{void setButtonTintBlendMode(BlendMode tintMode)}: Sets the blending mode used to apply the tint specified by \texttt{setButtonTintList()}.
                \item \textbf{void setButtonTintList(ColorStateList tint)}: Applies a color tint to the button drawable.
                \item \textbf{void setButtonTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used to apply the tint specified by \texttt{setButtonTintList()}.
                \item \textbf{void setChecked(boolean checked)}: Changes the checked state of this button.
                \item \textbf{void setOnCheckedChangeListener(CompoundButton.OnCheckedChangeListener listener)}: Registers a callback to be invoked when the checked state changes.
                \item \textbf{void setStateDescription(CharSequence stateDescription)}: Called when the view or subclass sets the state description for accessibility.
                \item \textbf{void toggle()}: Toggles the checked state of the button to the opposite of its current state.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects the state of its drawables.
                \item \textbf{int[] onCreateDrawableState(int extraSpace)}: Generates and returns the new drawable state array for this view, allocating extra space if needed.
                \item \textbf{void onDraw(Canvas canvas)}: Implement this method to perform custom drawing for the view.
                \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true if the specified drawable is being displayed by this view; subclasses should override when managing their own drawables.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{CheckBox}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.TextView $\to$	android.widget.Button $\to$	android.widget.CompoundButton $\to$	android.widget.CheckBox
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.CheckBox
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                CheckBox(Context context)
                CheckBox(Context context, AttributeSet attrs)
                CheckBox(Context context, AttributeSet attrs, int defStyleAttr)
                CheckBox(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{CharSequence getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{RadioGroup}
    \begin{itemize}
         \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.LinearLayout $\to$	android.widget.RadioGroup
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.RadioGroup
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                RadioGroup(Context context)
                RadioGroup(Context context, AttributeSet attrs)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	addView(View child, int index, ViewGroup.LayoutParams params)}: Adds a child view with the specified layout parameters.
                \item \textbf{void	autofill(AutofillValue value)}: Automatically fills the content of this view with the value.
                \item \textbf{void	check(int id)}: Sets the selection to the radio button whose identifier is passed in parameter.
                \item \textbf{void	clearCheck()}: Clears the selection.
                \item \textbf{RadioGroup.LayoutParams	generateLayoutParams(AttributeSet attrs)}: Returns a new set of layout parameters based on the supplied attributes set.
                \item \textbf{CharSequence	getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{int	getAutofillType()}: Describes the autofill type of this view, so an AutofillService can create the proper AutofillValue when autofilling the view.
                \item \textbf{AutofillValue	getAutofillValue()}: Gets the View's current autofill value.
                \item \textbf{int	getCheckedRadioButtonId()}: Returns the identifier of the selected radio button in this group.
                \item \textbf{void	onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info)}: Initializes an AccessibilityNodeInfo with information about this view.
                \item \textbf{void	setOnCheckedChangeListener(RadioGroup.OnCheckedChangeListener listener)}: Register a callback to be invoked when the checked radio button changes in this group.
                \item \textbf{void	setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener listener)}: Register a callback to be invoked when a child is added to or removed from this view.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{boolean	checkLayoutParams(ViewGroup.LayoutParams p)}:
                \item \textbf{LinearLayout.LayoutParams	generateDefaultLayoutParams()}: Returns a set of layout parameters with a width of ViewGroup.LayoutParams.MATCH\_PARENT and a height of ViewGroup.LayoutParams.WRAP\_CONTENT when the layout's orientation is VERTICAL.
                \item \textbf{void	onFinishInflate()}: Finalize inflating a view from XML.
            \end{itemize}
       
    \end{itemize}

    \pagebreak 
    \subsubsection{RadioGroup.LayoutParams}
    \begin{itemize}
        \item \textbf{Hierarchy}: 
            \begin{center}
                java.lang.Object $\to$	android.view.ViewGroup.LayoutParams $\to$	android.view.ViewGroup.MarginLayoutParams $\to$	android.widget.LinearLayout.LayoutParams $\to$	android.widget.RadioGroup.LayoutParams
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.RadioGroup.LayoutParams
            \end{javacode}
        \item \textbf{constructors}
            \bigbreak \noindent 
            \begin{javacode}
                LayoutParams(Context c, AttributeSet attrs)
                LayoutParams(ViewGroup.LayoutParams p)
                LayoutParams(ViewGroup.MarginLayoutParams source)
                LayoutParams(int w, int h)
                LayoutParams(int w, int h, float initWeight)
            \end{javacode}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	setBaseAttributes(TypedArray a, int widthAttr, int heightAttr)}: Fixes the child's width to ViewGroup.LayoutParams.WRAP\_CONTENT and the child's height to ViewGroup.LayoutParams.WRAP\_CONTENT when not specified in the XML file.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{RadioButton}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.TextView $\to$	android.widget.Button $\to$	android.widget.CompoundButton $\to$	android.widget.RadioButton
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.RadioButton
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Public constructors
                RadioButton(Context context)
                RadioButton(Context context, AttributeSet attrs)
                RadioButton(Context context, AttributeSet attrs, int defStyleAttr)
                RadioButton(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{CharSequence getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info)}: Initializes an AccessibilityNodeInfo with information about this view.
                \item \textbf{void toggle()}: Change the checked state of the view to the inverse of its current state
                    \bigbreak \noindent 
                    If the radio button is already checked, this method will not toggle the radio button.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{AbsSpinner}
    \begin{itemize}
         \item \textbf{Hierarchy} 
            \bigbreak \noindent 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.AdapterView<android.widget.SpinnerAdapter> $\to$	android.widget.AbsSpinner 
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.AbsSpinner 
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                AbsSpinner(Context context)
                AbsSpinner(Context context, AttributeSet attrs)
                AbsSpinner(Context context, AttributeSet attrs, int defStyleAttr)
                AbsSpinner(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	autofill(AutofillValue value)}: Automatically fills the content of this view with the value.
                \item \textbf{CharSequence	getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{SpinnerAdapter	getAdapter()}: Returns the adapter currently associated with this widget.
                \item \textbf{int	getAutofillType()}: Describes the autofill type of this view, so an AutofillService can create the proper AutofillValue when autofilling the view.
                \item \textbf{AutofillValue	getAutofillValue()}: Gets the View's current autofill value.
                \item \textbf{int	getCount()}:
                \item \textbf{View	getSelectedView()}:
                \item \textbf{void	onRestoreInstanceState(Parcelable state)}: Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState().
                \item \textbf{Parcelable	onSaveInstanceState()}: Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.
                \item \textbf{int	pointToPosition(int x, int y)}: Maps a point to a position in the list.
                \item \textbf{void	requestLayout()}: Override to prevent spamming ourselves with layout requests as we place views
                \item \textbf{void	setAdapter(SpinnerAdapter adapter)}: The Adapter is used to provide the data which backs this Spinner.
                \item \textbf{void	setSelection(int position, boolean animate)}: Jump directly to a specific item in the adapter data.
                \item \textbf{void	setSelection(int position)}: Sets the currently selected item.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	dispatchRestoreInstanceState(SparseArray<Parcelable> container)}: Override to prevent thawing of any views created by the adapter.
                \item \textbf{ViewGroup.LayoutParams	generateDefaultLayoutParams()}: Returns a set of default layout parameters.
                \item \textbf{void	onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measure the view and its content to determine the measured width and the measured height.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Spinner}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \bigbreak \noindent 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.AdapterView<android.widget.SpinnerAdapter> $\to$	android.widget.AbsSpinner $\to$	android.widget.Spinner
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.Spinner
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Spinner(Context context)
                Spinner(Context context, AttributeSet attrs)
                Spinner(Context context, AttributeSet attrs, int defStyleAttr)
                Spinner(Context context, AttributeSet attrs, int defStyleAttr, int mode)
                Spinner(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes, int mode)
                Spinner(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes, int mode, Resources.Theme popupTheme)
                Spinner(Context context, int mode)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object to be used for accessibility purposes.
                \item \textbf{int getBaseline()}: Returns the offset of the widget’s text baseline from the widget’s top boundary.
                \item \textbf{int getDropDownHorizontalOffset()}: Returns the configured horizontal offset in pixels for the spinner’s popup window of choices.
                \item \textbf{int getDropDownVerticalOffset()}: Returns the configured vertical offset in pixels for the spinner’s popup window of choices.
                \item \textbf{int getDropDownWidth()}: Returns the configured width of the spinner’s popup window of choices in pixels.
                \item \textbf{int getGravity()}: Describes how the selected item view is positioned within the spinner.
                \item \textbf{Drawable getPopupBackground()}: Returns the background drawable for the spinner’s popup window of choices.
                \item \textbf{Context getPopupContext()}: Returns the context used to inflate the spinner’s popup window.
                \item \textbf{CharSequence getPrompt()}: Returns the prompt text displayed when the spinner dialog is shown.
                \item \textbf{void onClick(DialogInterface dialog, int which)}: Invoked when a button in the dialog is clicked.
                \item \textbf{PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)}: Resolves the pointer icon that should be used for the specified pointer in the motion event.
                \item \textbf{void onRestoreInstanceState(Parcelable state)}: Restores the internal state of the spinner from a previously saved state.
                \item \textbf{Parcelable onSaveInstanceState()}: Saves the spinner’s current state for later restoration.
                \item \textbf{boolean onTouchEvent(MotionEvent event)}: Handles touch input events for the spinner.
                \item \textbf{boolean performClick()}: Calls this spinner’s \texttt{OnClickListener}, if one is defined.
                \item \textbf{void setAdapter(SpinnerAdapter adapter)}: Sets the \texttt{SpinnerAdapter} that provides the data backing this spinner.
                \item \textbf{void setDropDownHorizontalOffset(int pixels)}: Sets a horizontal offset in pixels for the spinner’s popup window of choices.
                \item \textbf{void setDropDownVerticalOffset(int pixels)}: Sets a vertical offset in pixels for the spinner’s popup window of choices.
                \item \textbf{void setDropDownWidth(int pixels)}: Sets the width of the spinner’s popup window of choices in pixels.
                \item \textbf{void setEnabled(boolean enabled)}: Sets the enabled state of this spinner.
                \item \textbf{void setGravity(int gravity)}: Defines how the selected item view is positioned within the spinner.
                \item \textbf{void setOnItemClickListener(AdapterView.OnItemClickListener l)}: No-op; spinners do not support item click events.
                \item \textbf{void setPopupBackgroundDrawable(Drawable background)}: Sets the background drawable for the spinner’s popup window of choices.
                \item \textbf{void setPopupBackgroundResource(int resId)}: Sets the background resource for the spinner’s popup window of choices.
                \item \textbf{void setPrompt(CharSequence prompt)}: Sets the prompt text to display when the dialog is shown.
                \item \textbf{void setPromptId(int promptId)}: Sets the prompt text to display when the dialog is shown using a resource ID.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void onDetachedFromWindow()}: This is called when the view is detached from a window.
                \item \textbf{void onLayout(boolean changed, int l, int t, int r, int b)}: Called from layout when this view should assign a size and position to each of its children.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measure the view and its content to determine the measured width and the measured height.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int MODE\_DIALOG}: Use a dialog window for selecting spinner options.
                \item \textbf{int MODE\_DROPDOWN}: Use a dropdown anchored to the Spinner for selecting spinner options.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{Progessbar}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.ProgressBar
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.ProgressBar
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                ProgressBar(Context context)
                ProgressBar(Context context, AttributeSet attrs)
                ProgressBar(Context context, AttributeSet attrs, int defStyleAttr)
                ProgressBar(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void drawableHotspotChanged(float x, float y)}: Called whenever the view hotspot changes and must be propagated to drawables or child views.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object for accessibility purposes.
                \item \textbf{Drawable getCurrentDrawable()}: Returns the drawable currently used to draw the progress bar.
                \item \textbf{Drawable getIndeterminateDrawable()}: Returns the drawable used to draw the progress bar in indeterminate mode.
                \item \textbf{BlendMode getIndeterminateTintBlendMode()}: Returns the blending mode used to apply the tint to the indeterminate drawable, if specified.
                \item \textbf{ColorStateList getIndeterminateTintList()}: Returns the color tint list used for the indeterminate drawable.
                \item \textbf{PorterDuff.Mode getIndeterminateTintMode()}: Returns the blending mode used to apply the tint to the indeterminate drawable.
                \item \textbf{Interpolator getInterpolator()}: Gets the acceleration curve type for the indeterminate animation.
                \item \textbf{int getMax()}: Returns the upper limit of this progress bar's range.
                \item \textbf{int getMaxHeight()}: Returns the maximum height of the progress bar, in pixels.
                \item \textbf{int getMaxWidth()}: Returns the maximum width of the progress bar, in pixels.
                \item \textbf{int getMin()}: Returns the lower limit of this progress bar's range.
                \item \textbf{int getMinHeight()}: Returns the minimum height of the progress bar, in pixels.
                \item \textbf{int getMinWidth()}: Returns the minimum width of the progress bar, in pixels.
                \item \textbf{int getProgress()}: Returns the current progress level of the progress bar.
                \item \textbf{BlendMode getProgressBackgroundTintBlendMode()}: Returns the blending mode used to apply the tint to the progress background, if specified.
                \item \textbf{ColorStateList getProgressBackgroundTintList()}: Returns the tint list applied to the progress background, if specified.
                \item \textbf{PorterDuff.Mode getProgressBackgroundTintMode()}: Returns the blending mode used to apply the tint to the progress background.
                \item \textbf{Drawable getProgressDrawable()}: Returns the drawable used to draw the progress bar in progress mode.
                \item \textbf{BlendMode getProgressTintBlendMode()}: Returns the blending mode used to apply the tint to the progress drawable, if specified.
                \item \textbf{ColorStateList getProgressTintList()}: Returns the color tint list applied to the progress drawable.
                \item \textbf{PorterDuff.Mode getProgressTintMode()}: Returns the blending mode used to apply the tint to the progress drawable.
                \item \textbf{int getSecondaryProgress()}: Returns the current level of secondary progress.
                \item \textbf{BlendMode getSecondaryProgressTintBlendMode()}: Returns the blending mode used to apply the tint to the secondary progress drawable.
                \item \textbf{ColorStateList getSecondaryProgressTintList()}: Returns the color tint list applied to the secondary progress drawable.
                \item \textbf{PorterDuff.Mode getSecondaryProgressTintMode()}: Returns the blending mode used to apply the tint to the secondary progress drawable.
                \item \textbf{final void incrementProgressBy(int diff)}: Increases the primary progress by the specified amount.
                \item \textbf{final void incrementSecondaryProgressBy(int diff)}: Increases the secondary progress by the specified amount.
                \item \textbf{void invalidateDrawable(Drawable dr)}: Invalidates the specified drawable, forcing a redraw.
                \item \textbf{boolean isAnimating()}: Returns whether the progress bar is currently animating.
                \item \textbf{boolean isIndeterminate()}: Indicates whether this progress bar is in indeterminate mode.
                \item \textbf{void jumpDrawablesToCurrentState()}: Calls \texttt{Drawable.jumpToCurrentState()} on all associated drawables.
                \item \textbf{void onRestoreInstanceState(Parcelable state)}: Restores the internal state of the progress bar from a previously saved state.
                \item \textbf{Parcelable onSaveInstanceState()}: Saves the internal state of the progress bar for later restoration.
                \item \textbf{void onVisibilityAggregated(boolean isVisible)}: Called when the visibility of this view or its ancestors changes.
                \item \textbf{void postInvalidate()}: Schedules a redraw for the next event loop cycle.
                \item \textbf{void setIndeterminate(boolean indeterminate)}: Changes whether the progress bar is in indeterminate mode.
                \item \textbf{void setIndeterminateDrawable(Drawable d)}: Defines the drawable used to draw the progress bar in indeterminate mode.
                \item \textbf{void setIndeterminateDrawableTiled(Drawable d)}: Defines a tileable drawable used to draw the indeterminate progress bar.
                \item \textbf{void setIndeterminateTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for applying the indeterminate tint.
                \item \textbf{void setIndeterminateTintList(ColorStateList tint)}: Applies a color tint to the indeterminate drawable.
                \item \textbf{void setIndeterminateTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for applying the indeterminate tint.
                \item \textbf{void setInterpolator(Interpolator interpolator)}: Sets the acceleration curve for the indeterminate animation.
                \item \textbf{void setInterpolator(Context context, int resID)}: Sets the interpolator resource for the indeterminate animation.
                \item \textbf{void setMax(int max)}: Sets the upper range of the progress bar.
                \item \textbf{void setMaxHeight(int maxHeight)}: Sets the maximum height the progress bar can have.
                \item \textbf{void setMaxWidth(int maxWidth)}: Sets the maximum width the progress bar can have.
                \item \textbf{void setMin(int min)}: Sets the lower range of the progress bar.
                \item \textbf{void setMinHeight(int minHeight)}: Sets the minimum height the progress bar can have.
                \item \textbf{void setMinWidth(int minWidth)}: Sets the minimum width the progress bar can have.
                \item \textbf{void setProgress(int progress)}: Sets the current progress value.
                \item \textbf{void setProgress(int progress, boolean animate)}: Sets the current progress value, optionally animating the transition.
                \item \textbf{void setProgressBackgroundTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the progress background tint.
                \item \textbf{void setProgressBackgroundTintList(ColorStateList tint)}: Applies a tint to the progress background.
                \item \textbf{void setProgressBackgroundTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the progress background tint.
                \item \textbf{void setProgressDrawable(Drawable d)}: Defines the drawable used to draw the progress bar in progress mode.
                \item \textbf{void setProgressDrawableTiled(Drawable d)}: Defines a tileable drawable for the progress bar in progress mode.
                \item \textbf{void setProgressTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the progress indicator tint.
                \item \textbf{void setProgressTintList(ColorStateList tint)}: Applies a tint to the progress indicator.
                \item \textbf{void setProgressTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the progress indicator tint.
                \item \textbf{void setSecondaryProgress(int secondaryProgress)}: Sets the current secondary progress value.
                \item \textbf{void setSecondaryProgressTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the secondary progress tint.
                \item \textbf{void setSecondaryProgressTintList(ColorStateList tint)}: Applies a tint to the secondary progress indicator.
                \item \textbf{void setSecondaryProgressTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the secondary progress tint.
                \item \textbf{void setStateDescription(CharSequence stateDescription)}: Called when an instance or subclass sets the state description.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects the state of its drawables.
                \item \textbf{void onAttachedToWindow()}: Called when the view is attached to a window.
                \item \textbf{void onDetachedFromWindow()}: Called when the view is detached from a window.
                \item \textbf{void onDraw(Canvas canvas)}: Implement this method to perform custom drawing for the view.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine the measured width and height.
                \item \textbf{void onSizeChanged(int w, int h, int oldw, int oldh)}: Called during layout when the size of this view has changed.
                \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true if the specified drawable is being displayed by this view; subclasses should override this when managing their own drawables.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{AbsSeekBar}
    \begin{itemize}
         \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.ProgressBar $\to$	android.widget.AbsSeekBar
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.widget.AbsSeekBar
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                AbsSeekBar(Context context)
                AbsSeekBar(Context context, AttributeSet attrs)
                AbsSeekBar(Context context, AttributeSet attrs, int defStyleAttr)
                AbsSeekBar(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void drawableHotspotChanged(float x, float y)}: Called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view.
                \item \textbf{CharSequence getAccessibilityClassName()}: Returns the class name of this object to be used for accessibility purposes.
                \item \textbf{int getKeyProgressIncrement()}: Returns the amount by which the progress changes when the user presses an arrow key.
                \item \textbf{boolean getSplitTrack()}: Returns whether the track is split by the thumb.
                \item \textbf{Drawable getThumb()}: Returns the drawable representing the scroll thumb — the component the user can drag to indicate progress.
                \item \textbf{int getThumbOffset()}: Returns the amount by which the thumb extends beyond the track.
                \item \textbf{BlendMode getThumbTintBlendMode()}: Returns the blending mode used to apply the tint to the thumb drawable, if specified.
                \item \textbf{ColorStateList getThumbTintList()}: Returns the tint color list applied to the thumb drawable, if specified.
                \item \textbf{PorterDuff.Mode getThumbTintMode()}: Returns the blending mode used to apply the tint to the thumb drawable, if specified.
                \item \textbf{Drawable getTickMark()}: Returns the drawable used as the tick mark for each progress position.
                \item \textbf{BlendMode getTickMarkTintBlendMode()}: Returns the blending mode used to apply the tint to the tick mark drawable, if specified.
                \item \textbf{ColorStateList getTickMarkTintList()}: Returns the tint color list applied to the tick mark drawable, if specified.
                \item \textbf{PorterDuff.Mode getTickMarkTintMode()}: Returns the blending mode used to apply the tint to the tick mark drawable, if specified.
                \item \textbf{void jumpDrawablesToCurrentState()}: Immediately updates all drawables associated with this view to their current state.
                \item \textbf{boolean onKeyDown(int keyCode, KeyEvent event)}: Handles key press events such as DPAD center or enter when the view is enabled and clickable.
                \item \textbf{void onRtlPropertiesChanged(int layoutDirection)}: Called when any RTL (right-to-left) layout property or alignment has changed.
                \item \textbf{boolean onTouchEvent(MotionEvent event)}: Handles touch or pointer events for user interaction.
                \item \textbf{void setKeyProgressIncrement(int increment)}: Sets the amount by which progress changes when the user presses arrow keys.
                \item \textbf{void setMax(int max)}: Sets the maximum value of the progress range.
                \item \textbf{void setMin(int min)}: Sets the minimum value of the progress range.
                \item \textbf{void setSplitTrack(boolean splitTrack)}: Specifies whether the track should be visually split by the thumb.
                \item \textbf{void setSystemGestureExclusionRects(List<Rect> rects)}: Defines regions within the view where system gestures should not be intercepted.
                \item \textbf{void setThumb(Drawable thumb)}: Sets the drawable used as the thumb in the progress meter.
                \item \textbf{void setThumbOffset(int thumbOffset)}: Sets the offset allowing the thumb to extend beyond the track.
                \item \textbf{void setThumbTintBlendMode(BlendMode blendMode)}: Defines the blending mode used when applying tint to the thumb drawable.
                \item \textbf{void setThumbTintList(ColorStateList tint)}: Applies a tint color list to the thumb drawable.
                \item \textbf{void setThumbTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used with the thumb tint.
                \item \textbf{void setTickMark(Drawable tickMark)}: Sets the drawable used as a tick mark at each progress position.
                \item \textbf{void setTickMarkTintBlendMode(BlendMode blendMode)}: Specifies the blending mode used to apply tint to the tick mark drawable.
                \item \textbf{void setTickMarkTintList(ColorStateList tint)}: Applies a tint color list to the tick mark drawable.
                \item \textbf{void setTickMarkTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used with the tick mark tint.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects the state of its drawables.
                \item \textbf{void onDraw(Canvas canvas)}: Implement this method to perform custom drawing operations for the view.
                \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measures the view and its content to determine the measured width and height.
                \item \textbf{void onSizeChanged(int w, int h, int oldw, int oldh)}: Called during layout when the size of the view changes, providing both new and old dimensions.
                \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true if the specified drawable is managed and displayed by this view; subclasses should override when handling custom drawables.
            \end{itemize}


    \end{itemize}

    \pagebreak 
    \subsubsection{SeekBar}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.widget.ProgressBar $\to$	android.widget.AbsSeekBar $\to$	android.widget.SeekBar
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.widget.SeekBar
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                SeekBar(Context context)
                SeekBar(Context context, AttributeSet attrs)
                SeekBar(Context context, AttributeSet attrs, int defStyleAttr)
                SeekBar(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{CharSequence getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{void setOnSeekBarChangeListener(SeekBar.OnSeekBarChangeListener l)}: Sets a listener to receive notifications of changes to the SeekBar's progress level.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{Drawable}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.graphics.drawable.Drawable
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.graphics.drawable.Drawable
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Drawable()
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void applyTheme(Resources.Theme t)}: Applies the specified theme to this \texttt{Drawable} and its children.
                \item \textbf{boolean canApplyTheme()}: Returns true if this \texttt{Drawable} can apply a theme.
                \item \textbf{void clearColorFilter()}: Removes any color filter currently applied to the drawable.
                \item \textbf{final Rect copyBounds()}: Returns a copy of the drawable’s bounds in a new \texttt{Rect} object.
                \item \textbf{final void copyBounds(Rect bounds)}: Copies the drawable’s bounds into the specified \texttt{Rect}.
                \item \textbf{static Drawable createFromPath(String pathName)}: Creates a drawable from the specified file path name.
                \item \textbf{static Drawable createFromResourceStream(Resources res, TypedValue value, InputStream is, String srcName, BitmapFactory.Options opts)}: \textit{Deprecated in API 28.} Creates a drawable from an input stream using the specified options.
                \item \textbf{static Drawable createFromResourceStream(Resources res, TypedValue value, InputStream is, String srcName)}: Creates a drawable from an input stream using the given resources and density information.
                \item \textbf{static Drawable createFromStream(InputStream is, String srcName)}: Creates a drawable from the specified input stream.
                \item \textbf{static Drawable createFromXml(Resources r, XmlPullParser parser)}: Creates a drawable from an XML document.
                \item \textbf{static Drawable createFromXml(Resources r, XmlPullParser parser, Resources.Theme theme)}: Creates a drawable from an XML document using the specified theme.
                \item \textbf{static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)}: Creates a drawable from within an XML document using an optional theme.
                \item \textbf{static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs)}: Creates a drawable from within an XML document.
                \item \textbf{abstract void draw(Canvas canvas)}: Draws the drawable within its bounds, respecting alpha and color filters.
                \item \textbf{int getAlpha()}: Returns the current alpha value for the drawable.
                \item \textbf{final Rect getBounds()}: Returns the drawable’s bounding rectangle.
                \item \textbf{Drawable.Callback getCallback()}: Returns the current callback attached to this drawable.
                \item \textbf{int getChangingConfigurations()}: Returns a mask of configuration parameters that may change and require the drawable to be re-created.
                \item \textbf{ColorFilter getColorFilter()}: Returns the current color filter, or null if none is set.
                \item \textbf{Drawable.ConstantState getConstantState()}: Returns the constant state of this drawable, allowing shared state across instances.
                \item \textbf{Drawable getCurrent()}: Returns the current drawable in use, if the drawable supports multiple states.
                \item \textbf{Rect getDirtyBounds()}: Returns the drawable’s dirty bounds rectangle.
                \item \textbf{void getHotspotBounds(Rect outRect)}: Populates the provided \texttt{Rect} with the hotspot bounds.
                \item \textbf{int getIntrinsicHeight()}: Returns the drawable’s intrinsic (default) height.
                \item \textbf{int getIntrinsicWidth()}: Returns the drawable’s intrinsic (default) width.
                \item \textbf{int getLayoutDirection()}: Returns the resolved layout direction for this drawable.
                \item \textbf{final int getLevel()}: Returns the current drawable level.
                \item \textbf{int getMinimumHeight()}: Returns the minimum height suggested by this drawable.
                \item \textbf{int getMinimumWidth()}: Returns the minimum width suggested by this drawable.
                \item \textbf{abstract int getOpacity()}: \textit{Deprecated in API 29.} Returns the drawable’s opacity mode.
                \item \textbf{Insets getOpticalInsets()}: Returns the optical insets for alignment during layout.
                \item \textbf{void getOutline(Outline outline)}: Populates the given \texttt{Outline} with the drawable’s shape for rendering effects such as shadows.
                \item \textbf{boolean getPadding(Rect padding)}: Fills the given \texttt{Rect} with content insets suggested by the drawable.
                \item \textbf{int[] getState()}: Returns the current state of the drawable as an array of state attributes.
                \item \textbf{Region getTransparentRegion()}: Returns a region representing areas of complete transparency.
                \item \textbf{boolean hasFocusStateSpecified()}: Returns true if the drawable explicitly specifies a focused state.
                \item \textbf{void inflate(Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)}: Inflates this drawable from XML, optionally styled by a theme.
                \item \textbf{void inflate(Resources r, XmlPullParser parser, AttributeSet attrs)}: Inflates this drawable from XML.
                \item \textbf{void invalidateSelf()}: Requests a redraw of the drawable using its current callback.
                \item \textbf{boolean isAutoMirrored()}: Returns whether the drawable automatically mirrors its image in RTL layouts.
                \item \textbf{boolean isFilterBitmap()}: Returns whether this drawable is filtering bitmaps when scaled or rotated.
                \item \textbf{boolean isProjected()}: Returns true if the drawable is projected.
                \item \textbf{boolean isStateful()}: Returns whether this drawable changes appearance based on its state.
                \item \textbf{final boolean isVisible()}: Returns true if the drawable is currently visible.
                \item \textbf{void jumpToCurrentState()}: Skips any active state transition animations and jumps directly to the current state.
                \item \textbf{Drawable mutate()}: Returns a mutable instance of this drawable that can be modified independently.
                \item \textbf{boolean onLayoutDirectionChanged(int layoutDirection)}: Called when the drawable’s layout direction changes.
                \item \textbf{static int resolveOpacity(int op1, int op2)}: Resolves and returns an appropriate opacity value from two input opacities.
                \item \textbf{void scheduleSelf(Runnable what, long when)}: Schedules the drawable to execute the given runnable at a specified time.
                \item \textbf{abstract void setAlpha(int alpha)}: Sets the drawable’s alpha value for transparency.
                \item \textbf{void setAutoMirrored(boolean mirrored)}: Sets whether this drawable automatically mirrors when layout direction is RTL.
                \item \textbf{void setBounds(int left, int top, int right, int bottom)}: Defines the bounding rectangle of the drawable.
                \item \textbf{void setBounds(Rect bounds)}: Sets the drawable’s bounds using the provided rectangle.
                \item \textbf{final void setCallback(Drawable.Callback cb)}: Binds a callback to the drawable for invalidation and scheduling.
                \item \textbf{void setChangingConfigurations(int configs)}: Specifies which configuration changes require the drawable to be recreated.
                \item \textbf{void setColorFilter(int color, PorterDuff.Mode mode)}: \textit{Deprecated in API 29.} Use \texttt{setColorFilter(ColorFilter)} instead.
                \item \textbf{abstract void setColorFilter(ColorFilter colorFilter)}: Sets an optional color filter to modify how the drawable’s pixels are rendered.
                \item \textbf{void setDither(boolean dither)}: \textit{Deprecated in API 23.} This property is ignored.
                \item \textbf{void setFilterBitmap(boolean filter)}: Enables or disables bilinear filtering for scaled or rotated bitmaps.
                \item \textbf{void setHotspot(float x, float y)}: Specifies the hotspot’s location within the drawable.
                \item \textbf{void setHotspotBounds(int left, int top, int right, int bottom)}: Defines the bounds for the hotspot within the drawable.
                \item \textbf{final boolean setLayoutDirection(int layoutDirection)}: Sets the layout direction for the drawable (LTR or RTL).
                \item \textbf{final boolean setLevel(int level)}: Sets the drawable’s current level, used by certain drawable types for animation or progress indication.
                \item \textbf{boolean setState(int[] stateSet)}: Sets the drawable’s current state using the given array of state attributes.
                \item \textbf{void setTint(int tintColor)}: Applies a single color tint to the drawable.
                \item \textbf{void setTintBlendMode(BlendMode blendMode)}: Specifies the blending mode used to apply the tint color.
                \item \textbf{void setTintList(ColorStateList tint)}: Applies a tint color list to the drawable for different states.
                \item \textbf{void setTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used to apply the tint list.
                \item \textbf{boolean setVisible(boolean visible, boolean restart)}: Sets the drawable’s visibility, optionally restarting animations.
                \item \textbf{void unscheduleSelf(Runnable what)}: Cancels any scheduled runnables associated with this drawable.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void onBoundsChange(Rect bounds)}: Override this in your subclass to change appearance if you vary based on the bounds.
                \item \textbf{boolean onLevelChange(int level)}: Override this in your subclass to change appearance if you vary based on level.
                \item \textbf{boolean onStateChange(int[] state)}: Override this in your subclass to change appearance if you recognize the specified state.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{GradientDrawable}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to$	android.graphics.drawable.Drawable $\to$	android.graphics.drawable.GradientDrawable
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.graphics.drawable.GradientDrawable
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
            GradientDrawable()
            GradientDrawable(GradientDrawable.Orientation orientation, int[] colors)
        \end{javacode}
    \item \textbf{Public methods}
        \begin{itemize}
            \item \textbf{void applyTheme(Resources.Theme t)}: Applies the specified theme to this \texttt{Drawable} and its children.
            \item \textbf{boolean canApplyTheme()}: Returns true if this \texttt{Drawable} can apply a theme.
            \item \textbf{void draw(Canvas canvas)}: Draws the shape within its bounds, respecting alpha and color filter effects.
            \item \textbf{int getAlpha()}: Returns the current alpha value of the drawable.
            \item \textbf{int getChangingConfigurations()}: Returns a mask of configuration parameters that can change, requiring the drawable to be recreated.
            \item \textbf{ColorStateList getColor()}: Returns the color state list used to fill the shape, or \texttt{null} if it uses a gradient or no fill color.
            \item \textbf{ColorFilter getColorFilter()}: Returns the currently applied color filter, or \texttt{null} if none.
            \item \textbf{int[] getColors()}: Returns the colors used for the gradient fill, or \texttt{null} if not applicable.
            \item \textbf{Drawable.ConstantState getConstantState()}: Returns the constant state shared by this drawable.
            \item \textbf{float[] getCornerRadii()}: Returns the corner radii for all four corners.
            \item \textbf{float getCornerRadius()}: Returns the uniform corner radius set with \texttt{setCornerRadius(float)}.
            \item \textbf{float getGradientCenterX()}: Returns the X position of the gradient center as a fraction of the width.
            \item \textbf{float getGradientCenterY()}: Returns the Y position of the gradient center as a fraction of the height.
            \item \textbf{float getGradientRadius()}: Returns the gradient’s radius in pixels.
            \item \textbf{int getGradientType()}: Returns the gradient type: \texttt{LINEAR\_GRADIENT}, \texttt{RADIAL\_GRADIENT}, or \texttt{SWEEP\_GRADIENT}.
            \item \textbf{int getInnerRadius()}: Returns the inner radius of the ring shape in pixels.
            \item \textbf{float getInnerRadiusRatio()}: Returns the inner radius of the ring as a ratio of the ring’s width.
            \item \textbf{int getIntrinsicHeight()}: Returns the drawable’s intrinsic height.
            \item \textbf{int getIntrinsicWidth()}: Returns the drawable’s intrinsic width.
            \item \textbf{int getOpacity()}: \textit{Deprecated.} No longer used for optimization.
            \item \textbf{Insets getOpticalInsets()}: Returns the suggested layout insets for alignment operations.
            \item \textbf{GradientDrawable.Orientation getOrientation()}: Returns the orientation of the gradient.
            \item \textbf{void getOutline(Outline outline)}: Populates the given \texttt{Outline} with the drawable’s shape outline.
            \item \textbf{boolean getPadding(Rect padding)}: Returns padding in the given \texttt{Rect}, as suggested by the drawable.
            \item \textbf{int getShape()}: Returns the shape type (\texttt{LINE}, \texttt{OVAL}, \texttt{RECTANGLE}, or \texttt{RING}).
            \item \textbf{int getThickness()}: Returns the ring’s thickness in pixels.
            \item \textbf{float getThicknessRatio()}: Returns the ring’s thickness as a ratio of its width.
            \item \textbf{boolean getUseLevel()}: Returns whether the drawable’s level property is used to scale the gradient.
            \item \textbf{boolean hasFocusStateSpecified()}: Returns true if the drawable explicitly defines a focused state.
            \item \textbf{void inflate(Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)}: Inflates the drawable from XML, optionally using a theme.
            \item \textbf{boolean isStateful()}: Returns true if the drawable changes appearance based on state.
            \item \textbf{Drawable mutate()}: Returns a mutable instance of this drawable that can be modified independently.
            \item \textbf{void setAlpha(int alpha)}: Sets the transparency level of the drawable.
            \item \textbf{void setColor(ColorStateList colorStateList)}: Changes the drawable to use a solid color state list instead of a gradient.
            \item \textbf{void setColor(int argb)}: Changes the drawable to use a single solid color.
            \item \textbf{void setColorFilter(ColorFilter colorFilter)}: Applies a color filter to the drawable.
            \item \textbf{void setColors(int[] colors, float[] offsets)}: Defines multiple colors and their relative positions in the gradient.
            \item \textbf{void setColors(int[] colors)}: Sets multiple colors for the gradient fill.
            \item \textbf{void setCornerRadii(float[] radii)}: Sets custom radii for each corner of the shape.
            \item \textbf{void setCornerRadius(float radius)}: Sets a uniform radius for all corners.
            \item \textbf{void setDither(boolean dither)}: \textit{Deprecated.} Ignored property.
            \item \textbf{void setGradientCenter(float x, float y)}: Sets the center of the gradient as a fraction of width and height.
            \item \textbf{void setGradientRadius(float gradientRadius)}: Sets the gradient’s radius in pixels.
            \item \textbf{void setGradientType(int gradient)}: Defines the gradient type (\texttt{LINEAR}, \texttt{RADIAL}, or \texttt{SWEEP}).
            \item \textbf{void setInnerRadius(int innerRadius)}: Sets the inner radius of a ring shape.
            \item \textbf{void setInnerRadiusRatio(float innerRadiusRatio)}: Defines the ring’s inner radius as a ratio of its width.
            \item \textbf{void setOrientation(GradientDrawable.Orientation orientation)}: Sets the direction of the gradient.
            \item \textbf{void setPadding(int left, int top, int right, int bottom)}: Defines the padding of the shape.
            \item \textbf{void setShape(int shape)}: Sets the shape type (\texttt{LINE}, \texttt{OVAL}, \texttt{RECTANGLE}, \texttt{RING}).
            \item \textbf{void setSize(int width, int height)}: Defines the overall size of the shape.
            \item \textbf{void setStroke(int width, ColorStateList colorStateList)}: Sets stroke width and color using a color state list.
            \item \textbf{void setStroke(int width, ColorStateList colorStateList, float dashWidth, float dashGap)}: Sets stroke width, color, and dash pattern.
            \item \textbf{void setStroke(int width, int color, float dashWidth, float dashGap)}: Sets stroke width, solid color, and dash pattern.
            \item \textbf{void setStroke(int width, int color)}: Sets stroke width and solid color.
            \item \textbf{void setThickness(int thickness)}: Sets the thickness of the ring shape.
            \item \textbf{void setThicknessRatio(float thicknessRatio)}: Sets the ring thickness as a ratio of its width.
            \item \textbf{void setTintBlendMode(BlendMode blendMode)}: Specifies how tint color should be blended with the drawable.
            \item \textbf{void setTintList(ColorStateList tint)}: Applies a tint color list for different drawable states.
            \item \textbf{void setUseLevel(boolean useLevel)}: Configures whether the drawable’s level affects the gradient scaling.
        \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void onBoundsChange(Rect r)}: Override this in your subclass to change appearance if you vary based on the bounds.
                \item \textbf{boolean onLevelChange(int level)}: Override this in your subclass to change appearance if you vary based on level.
                \item \textbf{boolean onStateChange(int[] stateSet)}: Override this in your subclass to change appearance if you recognize the specified state.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int ARC}: Shape is an arc.
                \item \textbf{int LINE}: Shape is a line
                \item \textbf{int LINEAR\_GRADIENT}: Gradient is linear (default.)
                \item \textbf{int OVAL}: Shape is an ellipse
                \item \textbf{int RADIAL\_GRADIENT}: Gradient is circular.
                \item \textbf{int RECTANGLE}: Shape is a rectangle, possibly with rounded corners
                \item \textbf{int RING}: Shape is a ring.
                \item \textbf{int SWEEP\_GRADIENT}: Gradient is a sweep.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Intent}
    \begin{itemize}
        \item \textbf{Hierarchy} 
            \begin{center}
                java.lang.Object $\to $	android.content.Intent
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.content.Intent
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Intent()
                Intent(Context packageContext, Class<?> cls)
                Intent(Intent o)
                Intent(String action)
                Intent(String action, Uri uri)
                Intent(String action, Uri uri, Context packageContext, Class<?> cls)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{setAction(String)}:	Sets the action to perform (like ACTION\_VIEW, ACTION\_SEND).
                \item \textbf{getAction()}:	Returns the currently set action.
                \item \textbf{setData(Uri)}:	Sets a URI for the intent (like content to view/open).
                \item \textbf{getData()}:	Gets the URI associated with the intent.
                \item \textbf{setType(String)}:	Sets the MIME type of data (like "image/*").
                \item \textbf{getType()}:	Gets the MIME type.
                \item \textbf{setDataAndType(Uri, String)}:	Sets both URI and MIME type at once.
                \item \textbf{addCategory(String)}:	Adds a category (e.g. CATEGORY\_LAUNCHER).
                \item \textbf{removeCategory(String)}:	Removes a category.
                \item \textbf{getCategories()}:	Returns all categories added.
                \item \textbf{putExtra(String, T)}: (overloads)	Stores data in the intent (String, int, ArrayList, etc.).
                \item \textbf{get*Extra(...)}: (e.g., getStringExtra)	Retrieves specific extra values.
                \item \textbf{getExtras()}:	Gets entire Bundle of extras.
                \item \textbf{replaceExtras(Bundle)}:	Replaces all extras.
                \item \textbf{removeExtra(String)}:	Removes a specific extra.
                \item \textbf{setClass(Context, Class<?>)}:	Directs the Intent to a specific Activity class (explicit intent).
                \item \textbf{setClassName(String, String)}:	Sets a target component by package/class name.
                \item \textbf{setComponent(ComponentName)}:	Specifies the component directly.
                \item \textbf{getComponent()}:	Returns the component if explicitly set.
                \item \textbf{setPackage(String)}:	Limits resolution to a specific package.
                \item \textbf{addFlags(int)}:	Adds flags like FLAG\_ACTIVITY\_NEW\_TASK, controlling launch behavior.
                \item \textbf{setFlags(int)}:	Replaces all existing flags.
                \item \textbf{getFlags()}:	Returns currently-set flags.
                \item \textbf{resolveActivity(PackageManager)}:	Checks if an intent can be handled by installed apps.
                \item \textbf{toUri(int)}:	Converts the intent to a URI string.
                \item \textbf{filterEquals(Intent)}:	Compares actions/data/categories/type but ignores extras.
                \item \textbf{getScheme()}:	Returns URI scheme (like "content", "http").
                \item \textbf{getClipData()}: / setClipData()	Used for advanced data transfers (drag-drop, multiple selections).
            \end{itemize}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public static final Creator<Intent> CREATOR}:
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{ACTION\_MAIN}:	Entry point Activity (launcher screen)
                \item \textbf{ACTION\_VIEW}:	Display data to the user (webpage, map, file)
                \item \textbf{ACTION\_EDIT}:	Edit existing data
                \item \textbf{ACTION\_PICK}:	Pick an item from data (gallery, contacts)
                \item \textbf{ACTION\_GET\_CONTENT}:	Allow the user to select a type of data (e.g., file picker)
                \item \textbf{ACTION\_CHOOSER}:	Show app-chooser dialog for an Intent
                \item \textbf{ACTION\_SEND}:	Share text, images, files
                \item \textbf{ACTION\_SENDTO}:	Send to a specific communication target (email, SMS)
                \item \textbf{EXTRA\_TEXT}:	Extra: text to send
                \item \textbf{EXTRA\_SUBJECT}:	Extra: email subject
                \item \textbf{EXTRA\_STREAM}:	Extra: send images/files
                \item \textbf{EXTRA\_EMAIL}:	Extra: receiver email addresses
                \item \textbf{ACTION\_DIAL}:	Open dialer with number prefilled
                \item \textbf{ACTION\_CALL}:	Directly place a call (requires permission)
                \item \textbf{ACTION\_SENDSMS / ACTION\_VIEW}: with SMS URI	Send SMS message
                \item \textbf{EXTRA\_PHONE\_NUMBER}:	Extra: phone number
                \item \textbf{ACTION\_IMAGE\_CAPTURE}:	Open camera app to take a picture
                \item \textbf{ACTION\_VIDEO\_CAPTURE}:	Record video
                \item \textbf{EXTRA\_OUTPUT}:	Where to save captured image/video
                \item \textbf{ACTION\_SETTINGS}:	Open device settings screen
                \item \textbf{ACTION\_WIRELESS\_SETTINGS}:	Wireless settings
                \item \textbf{ACTION\_APPLICATION\_DETAILS\_SETTINGS}:	App details settings (like uninstall/permissions page)
                \item \textbf{FLAG\_ACTIVITY\_NEW\_TASK}:	Start Activity in a new task (important for services)
                \item \textbf{FLAG\_ACTIVITY\_CLEAR\_TOP}:	Clear Activities on top of target
                \item \textbf{FLAG\_ACTIVITY\_SINGLE\_TOP}:	Reuse existing instance if already on top
                \item \textbf{ACTION\_AIRPLANE\_MODE\_CHANGED}:	Airplane mode switch
                \item \textbf{ACTION\_BATTERY\_LOW}:	Battery low warning
                \item \textbf{ACTION\_BOOT\_COMPLETED}:	Device boot finished (permission required)
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Animation}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.animation.Animation
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.animation.Animation
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Animation()
                Animation(Context context, AttributeSet attrs)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{cancel()}: Cancel the animation.
                \item \textbf{computeDurationHint()}: Compute a hint at how long the entire animation may last, in milliseconds.
                \item \textbf{getBackdropColor()}: Returns the background color to show behind the animating windows.
                \item \textbf{getBackgroundColor()}: \textit{Deprecated in API level 30.} None of window animations are running with background color.
                \item \textbf{getDetachWallpaper()}: \textit{Deprecated in API level 29.} All window animations are running with detached wallpaper.
                \item \textbf{getDuration()}: How long this animation should last.
                \item \textbf{getFillAfter()}: If fillAfter is true, this animation will apply its transformation after the end time.
                \item \textbf{getFillBefore()}: If fillBefore is true, this animation will apply its transformation before the start time.
                \item \textbf{getInterpolator()}: Gets the acceleration curve type for this animation.
                \item \textbf{getRepeatCount()}: Defines how many times the animation should repeat.
                \item \textbf{getRepeatMode()}: Defines what this animation should do when it reaches the end.
                \item \textbf{getShowBackdrop()}: If true, animation will show the backdrop behind window animations.
                \item \textbf{getStartOffset()}: When this animation should start relative to StartTime.
                \item \textbf{getStartTime()}: When this animation should start.
                \item \textbf{getTransformation(long, Transformation, float)}: Gets the transformation at a specified point in time.
                \item \textbf{getTransformation(long, Transformation)}: Gets the transformation at a specified point in time.
                \item \textbf{getZAdjustment()}: Returns the Z ordering mode while running the animation.
                \item \textbf{hasEnded()}: Indicates whether this animation has ended.
                \item \textbf{hasStarted()}: Indicates whether this animation has started.
                \item \textbf{initialize(int, int, int, int)}: Initialize animation with view and parent dimensions.
                \item \textbf{isFillEnabled()}: If true, animation applies the value of fillBefore.
                \item \textbf{isInitialized()}: Whether the animation has been initialized.
                \item \textbf{reset()}: Reset the initialization state of this animation.
                \item \textbf{restrictDuration(long)}: Ensure the duration is not longer than durationMillis.
                \item \textbf{scaleCurrentDuration(float)}: Scale the duration by the given factor.
                \item \textbf{setAnimationListener(Animation.AnimationListener)}: Bind an animation listener to this animation.
                \item \textbf{setBackdropColor(int)}: Set the backdrop color behind animating windows.
                \item \textbf{setBackgroundColor(int)}: \textit{Deprecated in API level 30.}
                \item \textbf{setDetachWallpaper(boolean)}: \textit{Deprecated in API level 29.}
                \item \textbf{setDuration(long)}: Set how long this animation should last.
                \item \textbf{setFillAfter(boolean)}: If true, the transformation persists after animation finishes.
                \item \textbf{setFillBefore(boolean)}: If true, apply transformation before animation start.
                \item \textbf{setFillEnabled(boolean)}: If true, animation applies the value of fillBefore.
                \item \textbf{setInterpolator(Interpolator)}: Sets the acceleration curve for the animation.
                \item \textbf{setInterpolator(Context, int)}: Sets acceleration curve using resources.
                \item \textbf{setRepeatCount(int)}: Sets how many times animation repeats.
                \item \textbf{setRepeatMode(int)}: Defines behavior when animation reaches the end.
                \item \textbf{setShowBackdrop(boolean)}: Enable backdrop animation behind windows.
                \item \textbf{setStartOffset(long)}: When animation should start relative to start time.
                \item \textbf{setStartTime(long)}: When animation should start.
                \item \textbf{setZAdjustment(int)}: Set Z ordering mode while running the animation.
                \item \textbf{start()}: Start the animation the first time getTransformation is invoked.
                \item \textbf{startNow()}: Start the animation at the current system time.
                \item \textbf{willChangeBounds()}: Indicates if animation affects bounds of animated view.
                \item \textbf{willChangeTransformationMatrix()}: Indicates if animation affects transformation matrix.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{applyTransformation(float interpolatedTime, Transformation t)}: Helper for getTransformation.
                \item \textbf{clone()}: Creates and returns a copy of this object.
                \item \textbf{ensureInterpolator()}: Guarantees that this animation has an interpolator.
                \item \textbf{finalize()}: Called by the garbage collector when there are no more references to the object.
                \item \textbf{getScaleFactor()}: Returns the scale factor set by the call to getTransformation.
                \item \textbf{resolveSize(int type, float value, int size, int parentSize)}: Convert size description to an actual dimension.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{applyTransformation(float interpolatedTime, Transformation t)}: Helper for getTransformation.
                \item \textbf{clone()}: Creates and returns a copy of this object.
                \item \textbf{ensureInterpolator()}: Guarantees that this animation has an interpolator.
                \item \textbf{finalize()}: Called by the garbage collector when there are no more references to the object.
                \item \textbf{getScaleFactor()}: Returns the scale factor set by the call to getTransformation.
                \item \textbf{resolveSize(int type, float value, int size, int parentSize)}: Convert size description to an actual dimension.
            \end{itemize}

    \end{itemize}


    \pagebreak 
    \subsubsection{AnimationSet}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
               java.lang.Object $\to$	android.view.animation.Animation $\to$	android.view.animation.AnimationSet
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.animation.AnimationSet
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                AnimationSet(Context context, AttributeSet attrs)
                AnimationSet(boolean shareInterpolator)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{addAnimation(Animation a)}: Add a child animation to this animation set.
                \item \textbf{computeDurationHint()}: Duration hint is the maximum duration hint of all child animations.
                \item \textbf{getAnimations()}: Returns the list of child animations.
                \item \textbf{getDuration()}: Duration is defined as the duration of the longest child animation.
                \item \textbf{getStartTime()}: When this animation should start.
                \item \textbf{getTransformation(long currentTime, Transformation t)}: Transformation is the concatenation of all component animations.
                \item \textbf{initialize(int width, int height, int parentWidth, int parentHeight)}: Initialize with the dimensions of the object and its parent.
                \item \textbf{reset()}: Reset the initialization state of this animation.
                \item \textbf{restrictDuration(long durationMillis)}: Ensure duration does not exceed durationMillis.
                \item \textbf{scaleCurrentDuration(float scale)}: Scale the duration by the specified factor.
                \item \textbf{setDuration(long durationMillis)}: Sets the duration for every child animation.
                \item \textbf{setFillAfter(boolean fillAfter)}: If true, transformation persists after animation ends.
                \item \textbf{setFillBefore(boolean fillBefore)}: If true, apply transformation before animation starts.
                \item \textbf{setRepeatMode(int repeatMode)}: Defines what happens when animation reaches the end.
                \item \textbf{setStartOffset(long startOffset)}: When this animation should start relative to start time.
                \item \textbf{setStartTime(long startTimeMillis)}: Sets start time for this animation and all child animations.
                \item \textbf{willChangeBounds()}: Indicates whether this animation affects bounds of the animated view.
                \item \textbf{willChangeTransformationMatrix()}: Indicates whether this animation affects the transformation matrix.
            \end{itemize}

        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{AnimationSet	clone()}: Creates and returns a copy of this object.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{AlphaAnimation}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.animation.Animation $\to$	android.view.animation.AlphaAnimation
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.animation.AlphaAnimation
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                AlphaAnimation(Context context, AttributeSet attrs)
                AlphaAnimation(float fromAlpha, float toAlpha)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{boolean	willChangeBounds()}: Indicates whether or not this animation will affect the bounds of the animated view.
                \item \textbf{boolean	willChangeTransformationMatrix()}: Indicates whether or not this animation will affect the transformation matrix.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	applyTransformation(float interpolatedTime, Transformation t)}: Changes the alpha property of the supplied Transformation
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{RotateAnimation}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.animation.Animation $\to$	android.view.animation.RotateAnimation
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.animation.RotateAnimation
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                RotateAnimation(Context context, AttributeSet attrs)
                RotateAnimation(float fromDegrees, float toDegrees)
                RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)
                RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	initialize(int width, int height, int parentWidth, int parentHeight)}: Initialize this animation with the dimensions of the object being animated as well as the objects parents.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	applyTransformation(float interpolatedTime, Transformation t)}: Helper for getTransformation.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{ScaleAnimation}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.animation.Animation $\to$	android.view.animation.ScaleAnimation
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.animation.ScaleAnimation
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                ScaleAnimation(Context context, AttributeSet attrs)
                ScaleAnimation(float fromX, float toX, float fromY, float toY)
                ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)
                ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	initialize(int width, int height, int parentWidth, int parentHeight)}: Initialize this animation with the dimensions of the object being animated as well as the objects parents.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	applyTransformation(float interpolatedTime, Transformation t)}: Helper for getTransformation.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{TranslateAnimation}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.animation.Animation $\to$	android.view.animation.TranslateAnimation
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.animation.TranslateAnimation
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                TranslateAnimation(Context context, AttributeSet attrs)
                TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)
                TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	initialize(int width, int height, int parentWidth, int parentHeight)}: Initialize this animation with the dimensions of the object being animated as well as the objects parents.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	applyTransformation(float interpolatedTime, Transformation t)}: Helper for getTransformation.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{PreferenceManager}
    \begin{itemize}
        \item \textbf{Include}:
            \bigbreak \noindent 
            \begin{javacode}
                android.preference.PreferenceManager
            \end{javacode}
        \item \textbf{Nested interfaces}
            \begin{itemize}
                \item \textbf{interface	PreferenceManager.OnActivityDestroyListener}: This interface was deprecated in API level 29. Use the AndroidX Preference Library for consistent behavior across all devices. For more information on using the AndroidX Preference Library see Settings. 
                \item \textbf{interface	PreferenceManager.OnActivityResultListener}: This interface was deprecated in API level 29. Use the AndroidX Preference Library for consistent behavior across all devices. For more information on using the AndroidX Preference Library see Settings. 
                \item \textbf{interface	PreferenceManager.OnActivityStopListener}: This interface was deprecated in API level 29. Use the AndroidX Preference Library for consistent behavior across all devices. For more information on using the AndroidX Preference Library see Settings. 
            \end{itemize}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{PreferenceScreen	createPreferenceScreen(Context context)}:
                \item \textbf{Preference	findPreference(CharSequence key)}: Finds a Preference based on its key.
                \item \textbf{static SharedPreferences	getDefaultSharedPreferences(Context context)}: Gets a SharedPreferences instance that points to the default file that is used by the preference framework in the given context.
                \item \textbf{static String	getDefaultSharedPreferencesName(Context context)}: Returns the name used for storing default shared preferences.
                \item \textbf{PreferenceDataStore	getPreferenceDataStore()}: Returns the PreferenceDataStore associated with this manager or null if the default SharedPreferences are used instead.
                \item \textbf{SharedPreferences	getSharedPreferences()}: Gets a SharedPreferences instance that preferences managed by this will use.
                \item \textbf{int	getSharedPreferencesMode()}: Returns the current mode of the SharedPreferences file that preferences managed by this will use.
                \item \textbf{String	getSharedPreferencesName()}: Returns the current name of the SharedPreferences file that preferences managed by this will use.
                \item \textbf{boolean	isStorageDefault()}: Indicates if the storage location used internally by this class is the default provided by the hosting Context.
                \item \textbf{boolean	isStorageDeviceProtected()}: Indicates if the storage location used internally by this class is backed by device-protected storage.
                \item \textbf{static void	setDefaultValues(Context context, String sharedPreferencesName, int sharedPreferencesMode, int resId, boolean readAgain)}: Similar to setDefaultValues(android.content.Context, int, boolean) but allows the client to provide the filename and mode of the shared preferences file.
                \item \textbf{static void	setDefaultValues(Context context, int resId, boolean readAgain)}: Sets the default values from an XML preference file by reading the values defined by each Preference item's android:defaultValue attribute.
                \item \textbf{void	setPreferenceDataStore(PreferenceDataStore dataStore)}: Sets a PreferenceDataStore to be used by all Preferences associated with this manager that don't have a custom PreferenceDataStore assigned via Preference.setPreferenceDataStore(PreferenceDataStore).
                \item \textbf{void	setSharedPreferencesMode(int sharedPreferencesMode)}: Sets the mode of the SharedPreferences file that preferences managed by this will use.
                \item \textbf{void	setSharedPreferencesName(String sharedPreferencesName)}: Sets the name of the SharedPreferences file that preferences managed by this will use.
                \item \textbf{void	setStorageDefault()}: Sets the storage location used internally by this class to be the default provided by the hosting Context.
                \item \textbf{void	setStorageDeviceProtected()}: Explicitly set the storage location used internally by this class to be device-protected storage.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{String	KEY\_HAS\_SET\_DEFAULT\_VALUES}:
                \item \textbf{String	METADATA\_KEY\_PREFERENCES}: The Activity meta-data key for its XML preference hierarchy.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{SharedPreferences (interface)}
    \begin{itemize}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.content.SharedPreferences
            \end{javacode}
        \item \textbf{Nested interfaces}
            \begin{itemize}
                \item \textbf{interface	SharedPreferences.Editor}: Interface used for modifying values in a SharedPreferences object. 
                \item \textbf{interface	SharedPreferences.OnSharedPreferenceChangeListener}: Interface definition for a callback to be invoked when a shared preference is changed. 
            \end{itemize}
        \item \textbf{Abstract methods}
            \begin{itemize}
                \item \textbf{abstract boolean	contains(String key)}: Checks whether the preferences contains a preference.
                \item \textbf{abstract SharedPreferences.Editor	edit()}: Create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.
                \item \textbf{abstract Map<String, ?>	getAll()}: Retrieve all values from the preferences.
                \item \textbf{abstract boolean	getBoolean(String key, boolean defValue)}: Retrieve a boolean value from the preferences.
                \item \textbf{abstract float	getFloat(String key, float defValue)}: Retrieve a float value from the preferences.
                \item \textbf{abstract int	getInt(String key, int defValue)}: Retrieve an int value from the preferences.
                \item \textbf{abstract long	getLong(String key, long defValue)}: Retrieve a long value from the preferences.
                \item \textbf{abstract String	getString(String key, String defValue)}: Retrieve a String value from the preferences.
                \item \textbf{abstract Set<String>	getStringSet(String key, Set<String> defValues)}: Retrieve a set of String values from the preferences.
                \item \textbf{abstract void	registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener)}: Registers a callback to be invoked when a change happens to a preference.
                \item \textbf{abstract void	unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener)}: Unregisters a previous callback.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{SharedPreferences.Editor (Interface)}
    \begin{itemize}
        \item \textbf{Description}: Interface used for modifying values in a SharedPreferences object. All changes you make in an editor are batched, and not copied back to the original SharedPreferences until you call commit() or apply()
        \item \textbf{Abstract methods}:
            \begin{itemize}
                \item \textbf{abstract void	apply()}: Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.
                \item \textbf{abstract SharedPreferences.Editor	clear()}: Mark in the editor to remove all values from the preferences.
                \item \textbf{abstract boolean	commit()}: Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.
                \item \textbf{abstract SharedPreferences.Editor	putBoolean(String key, boolean value)}: Set a boolean value in the preferences editor, to be written back once commit() or apply() are called.
                \item \textbf{abstract SharedPreferences.Editor	putFloat(String key, float value)}: Set a float value in the preferences editor, to be written back once commit() or apply() are called.
                \item \textbf{abstract SharedPreferences.Editor	putInt(String key, int value)}: Set an int value in the preferences editor, to be written back once commit() or apply() are called.
                \item \textbf{abstract SharedPreferences.Editor	putLong(String key, long value)}: Set a long value in the preferences editor, to be written back once commit() or apply() are called.
                \item \textbf{abstract SharedPreferences.Editor	putString(String key, String value)}: Set a String value in the preferences editor, to be written back once commit() or apply() are called.
                \item \textbf{abstract SharedPreferences.Editor	putStringSet(String key, Set<String> values)}: Set a set of String values in the preferences editor, to be written back once commit() or apply() is called.
                \item \textbf{abstract SharedPreferences.Editor	remove(String key)}: Mark in the editor that a preference value should be removed, which will be done in the actual preferences once commit() is called.
            \end{itemize}


    \end{itemize}

    \pagebreak 
    \subsubsection{Menu (Interface)}
    \begin{itemize}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.Menu
            \end{javacode}
        \item \textbf{Public abstract methods}
            \begin{itemize}
                \item \textbf{abstract MenuItem	add(int groupId, int itemId, int order, CharSequence title)}: Add a new item to the menu.
                \item \textbf{abstract MenuItem	add(int titleRes)}: Add a new item to the menu.
                \item \textbf{abstract MenuItem	add(CharSequence title)}: Add a new item to the menu.
                \item \textbf{abstract MenuItem	add(int groupId, int itemId, int order, int titleRes)}: Variation on add(int, int, int, java.lang.CharSequence) that takes a string resource identifier instead of the string itself.
                \item \textbf{abstract int	addIntentOptions(int groupId, int itemId, int order, ComponentName caller, Intent[] specifics, Intent intent, int flags, MenuItem[] outSpecificItems)}: Add a group of menu items corresponding to actions that can be performed for a particular Intent.
                \item \textbf{abstract SubMenu	addSubMenu(CharSequence title)}: Add a new sub-menu to the menu.
                \item \textbf{abstract SubMenu	addSubMenu(int groupId, int itemId, int order, int titleRes)}: Variation on addSubMenu(int, int, int, java.lang.CharSequence) that takes a string resource identifier for the title instead of the string itself.
                \item \textbf{abstract SubMenu	addSubMenu(int groupId, int itemId, int order, CharSequence title)}: Add a new sub-menu to the menu.
                \item \textbf{abstract SubMenu	addSubMenu(int titleRes)}: Add a new sub-menu to the menu.
                \item \textbf{abstract void	clear()}: Remove all existing items from the menu, leaving it empty as if it had just been created.
                \item \textbf{abstract void	close()}: Closes the menu, if open.
                \item \textbf{abstract MenuItem	findItem(int id)}: Return the menu item with a particular identifier.
                \item \textbf{abstract MenuItem	getItem(int index)}: Gets the menu item at the given index.
                \item \textbf{abstract boolean	hasVisibleItems()}: Return whether the menu currently has item items that are visible.
                \item \textbf{abstract boolean	isShortcutKey(int keyCode, KeyEvent event)}: Is a keypress one of the defined shortcut keys for this window.
                \item \textbf{abstract boolean	performIdentifierAction(int id, int flags)}: Execute the menu item action associated with the given menu identifier.
                \item \textbf{abstract boolean	performShortcut(int keyCode, KeyEvent event, int flags)}: Execute the menu item action associated with the given shortcut character.
                \item \textbf{abstract void	removeGroup(int groupId)}: Remove all items in the given group.
                \item \textbf{abstract void	removeItem(int id)}: Remove the item with the given identifier.
                \item \textbf{abstract void	setGroupCheckable(int group, boolean checkable, boolean exclusive)}: Control whether a particular group of items can show a check mark.
                \item \textbf{default void	setGroupDividerEnabled(boolean groupDividerEnabled)}: Enable or disable the group dividers.
                \item \textbf{abstract void	setGroupEnabled(int group, boolean enabled)}: Enable or disable all menu items that are in the given group.
                \item \textbf{abstract void	setGroupVisible(int group, boolean visible)}: Show or hide all menu items that are in the given group.
                \item \textbf{abstract void	setQwertyMode(boolean isQwerty)}: Control whether the menu should be running in qwerty mode (alphabetic shortcuts) or 12-key mode (numeric shortcuts).
                \item \textbf{abstract int	size()}: Get the number of items in the menu.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	CATEGORY\_ALTERNATIVE}: Category code for the order integer for items/groups that are alternative actions on the data that is currently displayed -- or/add this with your base value.
                \item \textbf{int	CATEGORY\_CONTAINER}: Category code for the order integer for items/groups that are part of a container -- or/add this with your base value.
                \item \textbf{int	CATEGORY\_SECONDARY}: Category code for the order integer for items/groups that are user-supplied secondary (infrequently used) options -- or/add this with your base value.
                \item \textbf{int	CATEGORY\_SYSTEM}: Category code for the order integer for items/groups that are provided by the system -- or/add this with your base value.
                \item \textbf{int	FIRST}: First value for group and item identifier integers.
                \item \textbf{int	FLAG\_ALWAYS\_PERFORM\_CLOSE}: Flag for performShortcut(int, android.view.KeyEvent, int): if set, always close the menu after executing the shortcut.
                \item \textbf{int	FLAG\_APPEND\_TO\_GROUP}: Flag for addIntentOptions(int, int, int, ComponentName, Intent, Intent, int, MenuItem): if set, do not automatically remove any existing menu items in the same group.
                \item \textbf{int	FLAG\_PERFORM\_NO\_CLOSE}: Flag for performShortcut(int, KeyEvent, int): if set, do not close the menu after executing the shortcut.
                \item \textbf{int	NONE}: Value to use for group and item identifier integers when you don't care about them.
                \item \textbf{int	SUPPORTED\_MODIFIERS\_MASK}: A mask of all supported modifiers for MenuItem's keyboard shortcuts
    \end{itemize}

    \pagebreak 
    \subsubsection{MenuItem (Interface)}
    \begin{itemize}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.MenuItem
            \end{javacode}
        \item \textbf{Public abstract methods}:
            \begin{itemize}
                \item \textbf{abstract boolean	collapseActionView()}: Collapse the action view associated with this menu item.
                \item \textbf{abstract boolean	expandActionView()}: Expand the action view associated with this menu item.
                \item \textbf{abstract ActionProvider	getActionProvider()}: Gets the ActionProvider.
                \item \textbf{abstract View	getActionView()}: Returns the currently set action view for this menu item.
                \item \textbf{default int	getAlphabeticModifiers()}: Return the modifier for this menu item's alphabetic shortcut.
                \item \textbf{abstract char	getAlphabeticShortcut()}: Return the char for this menu item's alphabetic shortcut.
                \item \textbf{default CharSequence	getContentDescription()}: Retrieve the content description associated with this menu item.
                \item \textbf{abstract int	getGroupId()}: Return the group identifier that this menu item is part of.
                \item \textbf{abstract Drawable	getIcon()}: Returns the icon for this item as a Drawable (getting it from resources if it hasn't been loaded before).
                \item \textbf{default BlendMode	getIconTintBlendMode()}: Returns the blending mode used to apply the tint to this item's icon, if specified.
                \item \textbf{default ColorStateList	getIconTintList()}: default PorterDuff.Mode	getIconTintMode()
                \item \textbf{abstract Intent	getIntent()}: Return the Intent associated with this item.
                \item \textbf{abstract int	getItemId()}: Return the identifier for this menu item.
                \item \textbf{abstract ContextMenu.ContextMenuInfo	getMenuInfo()}: Gets the extra information linked to this menu item.
                \item \textbf{default int	getNumericModifiers()}: Return the modifiers for this menu item's numeric (12-key) shortcut.
                \item \textbf{abstract char	getNumericShortcut()}: Return the char for this menu item's numeric (12-key) shortcut.
                \item \textbf{abstract int	getOrder()}: Return the category and order within the category of this item.
                \item \textbf{abstract SubMenu	getSubMenu()}: Get the sub-menu to be invoked when this item is selected, if it has one.
                \item \textbf{abstract CharSequence	getTitle()}: Retrieve the current title of the item.
                \item \textbf{abstract CharSequence	getTitleCondensed()}: Retrieve the current condensed title of the item.
                \item \textbf{default CharSequence	getTooltipText()}: Retrieve the tooltip text associated with this menu item.
                \item \textbf{abstract boolean	hasSubMenu()}: Check whether this item has an associated sub-menu.
                \item \textbf{abstract boolean	isActionViewExpanded()}: Returns true if this menu item's action view has been expanded.
                \item \textbf{abstract boolean	isCheckable()}: Return whether the item can currently display a check mark.
                \item \textbf{abstract boolean	isChecked()}: Return whether the item is currently displaying a check mark.
                \item \textbf{abstract boolean	isEnabled()}: Return the enabled state of the menu item.
                \item \textbf{abstract boolean	isVisible()}: Return the visibility of the menu item.
                \item \textbf{abstract MenuItem	setActionProvider(ActionProvider actionProvider)}: Sets the ActionProvider responsible for creating an action view if the item is placed on the action bar.
                \item \textbf{abstract MenuItem	setActionView(int resId)}: Set an action view for this menu item.
                \item \textbf{abstract MenuItem	setActionView(View view)}: Set an action view for this menu item.
                \item \textbf{abstract MenuItem	setAlphabeticShortcut(char alphaChar)}: Change the alphabetic shortcut associated with this item.
                \item \textbf{default MenuItem	setAlphabeticShortcut(char alphaChar, int alphaModifiers)}: Change the alphabetic shortcut associated with this item.
                \item \textbf{abstract MenuItem	setCheckable(boolean checkable)}: Control whether this item can display a check mark.
                \item \textbf{abstract MenuItem	setChecked(boolean checked)}: Control whether this item is shown with a check mark.
                \item \textbf{default MenuItem	setContentDescription(CharSequence contentDescription)}: Change the content description associated with this menu item.
                \item \textbf{abstract MenuItem	setEnabled(boolean enabled)}: Sets whether the menu item is enabled.
                \item \textbf{abstract MenuItem	setIcon(Drawable icon)}: Change the icon associated with this item.
                \item \textbf{abstract MenuItem	setIcon(int iconRes)}: Change the icon associated with this item.
                \item \textbf{default MenuItem	setIconTintBlendMode(BlendMode blendMode)}: Specifies the blending mode used to apply the tint specified by setIconTintList(android.content.res.ColorStateList) to this item's icon.
                \item \textbf{default MenuItem	setIconTintList(ColorStateList tint)}: Applies a tint to this item's icon.
                \item \textbf{default MenuItem	setIconTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used to apply the tint specified by setIconTintList(android.content.res.ColorStateList) to this item's icon.
                \item \textbf{abstract MenuItem	setIntent(Intent intent)}: Change the Intent associated with this item.
                \item \textbf{default MenuItem	setNumericShortcut(char numericChar, int numericModifiers)}: Change the numeric shortcut and modifiers associated with this item.
                \item \textbf{abstract MenuItem	setNumericShortcut(char numericChar)}: Change the numeric shortcut associated with this item.
                \item \textbf{abstract MenuItem	setOnActionExpandListener(MenuItem.OnActionExpandListener listener)}: Set an OnActionExpandListener on this menu item to be notified when the associated action view is expanded or collapsed.
                \item \textbf{abstract MenuItem	setOnMenuItemClickListener(MenuItem.OnMenuItemClickListener menuItemClickListener)}: Set a custom listener for invocation of this menu item.
                \item \textbf{abstract MenuItem	setShortcut(char numericChar, char alphaChar)}: Change both the numeric and alphabetic shortcut associated with this item.
                \item \textbf{default MenuItem	setShortcut(char numericChar, char alphaChar, int numericModifiers, int alphaModifiers)}: Change both the numeric and alphabetic shortcut associated with this item.
                \item \textbf{abstract void	setShowAsAction(int actionEnum)}: Sets how this item should display in the presence of an Action Bar.
                \item \textbf{abstract MenuItem	setShowAsActionFlags(int actionEnum)}: Sets how this item should display in the presence of an Action Bar.
                \item \textbf{abstract MenuItem	setTitle(CharSequence title)}: Change the title associated with this item.
                \item \textbf{abstract MenuItem	setTitle(int title)}: Change the title associated with this item.
                \item \textbf{abstract MenuItem	setTitleCondensed(CharSequence title)}: Change the condensed title associated with this item.
                \item \textbf{default MenuItem	setTooltipText(CharSequence tooltipText)}: Change the tooltip text associated with this menu item.
                \item \textbf{abstract MenuItem	setVisible(boolean visible)}: Sets the visibility of the menu item.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	SHOW\_AS\_ACTION\_ALWAYS}: Always show this item as a button in an Action Bar.
                \item \textbf{int	SHOW\_AS\_ACTION\_COLLAPSE\_ACTION\_VIEW}: This item's action view collapses to a normal menu item.
                \item \textbf{int	SHOW\_AS\_ACTION\_IF\_ROOM}: Show this item as a button in an Action Bar if the system decides there is room for it.
                \item \textbf{int	SHOW\_AS\_ACTION\_NEVER}: Never show this item as a button in an Action Bar.
                \item \textbf{int	SHOW\_AS\_ACTION\_WITH\_TEXT}: When this item is in the action bar, always show it with a text label even if it also has an icon specified.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ContextMenu (interface)}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                android.view.Menu $\to$ android.view.ContextMenu
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.ContextMenu 
            \end{javacode}
        \item \textbf{Public abstract methods}
            \begin{itemize}
                \item \textbf{abstract void	clearHeader()}: Clears the header of the context menu.
                \item \textbf{abstract ContextMenu	setHeaderIcon(int iconRes)}: Sets the context menu header's icon to the icon given in iconRes resource id.
                \item \textbf{abstract ContextMenu	setHeaderIcon(Drawable icon)}: Sets the context menu header's icon to the icon given in icon Drawable.
                \item \textbf{abstract ContextMenu	setHeaderTitle(int titleRes)}: Sets the context menu header's title to the title given in titleRes resource identifier.
                \item \textbf{abstract ContextMenu	setHeaderTitle(CharSequence title)}: Sets the context menu header's title to the title given in title.
                \item \textbf{abstract ContextMenu	setHeaderView(View view)}: Sets the header of the context menu to the View given in view.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{PopupMenu}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$ android.widget.PopupMenu
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.widget.PopupMenu
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                PopupMenu(Context context, View anchor)
                PopupMenu(Context context, View anchor, int gravity)
                PopupMenu(Context context, View anchor, int gravity, int popupStyleAttr, int popupStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	dismiss()}: Dismiss the menu popup.
                \item \textbf{View.OnTouchListener	getDragToOpenListener()}: Returns an OnTouchListener that can be added to the anchor view to implement drag-to-open behavior.
                \item \textbf{int	getGravity()}:
                \item \textbf{Menu	getMenu()}: Returns the Menu associated with this popup.
                \item \textbf{MenuInflater	getMenuInflater()}:
                \item \textbf{void	inflate(int menuRes)}: Inflate a menu resource into this PopupMenu.
                \item \textbf{void	setForceShowIcon(boolean forceShowIcon)}: Sets whether the popup menu's adapter is forced to show icons in the menu item views.
                \item \textbf{void	setGravity(int gravity)}: Sets the gravity used to align the popup window to its anchor view.
                \item \textbf{void	setOnDismissListener(PopupMenu.OnDismissListener listener)}: Sets a listener that will be notified when this menu is dismissed.
                \item \textbf{void	setOnMenuItemClickListener(PopupMenu.OnMenuItemClickListener listener)}: Sets a listener that will be notified when the user selects an item from the menu.
                \item \textbf{void	show()}: Show the menu popup anchored to the view specified during construction.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsubsection{SubMenu (interface)}
    \begin{itemize}
        \item \textbf{Signature}
            \bigbreak \noindent 
            \begin{javacode}
                public interface SubMenu implements Menu
            \end{javacode}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.view.SubMenu
            \end{javacode}
        \item \textbf{Public abstract methods}
            \begin{itemize}
                \item \textbf{abstract void	clearHeader()}: Clears the header of the submenu.
                \item \textbf{abstract MenuItem	getItem()}: Gets the MenuItem that represents this submenu in the parent menu.
                \item \textbf{abstract SubMenu	setHeaderIcon(int iconRes)}: Sets the submenu header's icon to the icon given in iconRes resource id.
                \item \textbf{abstract SubMenu	setHeaderIcon(Drawable icon)}: Sets the submenu header's icon to the icon given in icon Drawable.
                \item \textbf{abstract SubMenu	setHeaderTitle(int titleRes)}: Sets the submenu header's title to the title given in titleRes resource identifier.
                \item \textbf{abstract SubMenu	setHeaderTitle(CharSequence title)}: Sets the submenu header's title to the title given in title.
                \item \textbf{abstract SubMenu	setHeaderView(View view)}: Sets the header of the submenu to the View given in view.
                \item \textbf{abstract SubMenu	setIcon(Drawable icon)}: Change the icon associated with this submenu's item in its parent menu.
                \item \textbf{abstract SubMenu	setIcon(int iconRes)}: Change the icon associated with this submenu's item in its parent menu.
            \end{itemize}
    \end{itemize}


    \pagebreak 
    \subsubsection{MenuInflator}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.MenuInflater
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.MenuInflater
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                MenuInflater(Context context) 
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	inflate(int menuRes, Menu menu)}: Inflate a menu hierarchy from the specified XML resource.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Toast}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to $	android.widget.Toast
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.Toast
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                Toast(Context context)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	addCallback(Toast.Callback callback)}: Adds a callback to be notified when the toast is shown or hidden.
                \item \textbf{void	cancel()}: Close the view if it's showing, or don't show it if it isn't showing yet.
                \item \textbf{int	getDuration()}: Return the duration.
                \item \textbf{int	getGravity()}: Get the location at which the notification should appear on the screen.
                \item \textbf{float	getHorizontalMargin()}: Return the horizontal margin.
                \item \textbf{float	getVerticalMargin()}: Return the vertical margin.
                \item \textbf{View	getView()}: This method was deprecated in API level 30. Custom toast views are deprecated. Apps can create a standard text toast with the makeText(android.content.Context, java.lang.CharSequence, int) method, or use a Snackbar when in the foreground. Starting from Android Build.VERSION\_CODES.R, apps targeting API level Build.VERSION\_CODES.R or higher that are in the background will not have custom toast views displayed.
                \item \textbf{int	getXOffset()}: Return the X offset in pixels to apply to the gravity's location.
                \item \textbf{int	getYOffset()}: Return the Y offset in pixels to apply to the gravity's location.
                \item \textbf{static Toast	makeText(Context context, int resId, int duration)}: Make a standard toast that just contains text from a resource.
                \item \textbf{static Toast	makeText(Context context, CharSequence text, int duration)}: Make a standard toast that just contains text.
                \item \textbf{void	removeCallback(Toast.Callback callback)}: Removes a callback previously added with addCallback(android.widget.Toast.Callback).
                \item \textbf{void	setDuration(int duration)}: Set how long to show the view for.
                \item \textbf{void	setGravity(int gravity, int xOffset, int yOffset)}: Set the location at which the notification should appear on the screen.
                \item \textbf{void	setMargin(float horizontalMargin, float verticalMargin)}: Set the margins of the view.
                \item \textbf{void	setText(int resId)}: Update the text in a Toast that was previously created using one of the makeText() methods.
                \item \textbf{void	setText(CharSequence s)}: Update the text in a Toast that was previously created using one of the makeText() methods.
                \item \textbf{void	setView(View view)}: This method was deprecated in API level 30. Custom toast views are deprecated. Apps can create a standard text toast with the makeText(android.content.Context, java.lang.CharSequence, int) method, or use a Snackbar when in the foreground. Starting from Android Build.VERSION\_CODES.R, apps targeting API level Build.VERSION\_CODES.R or higher that are in the background will not have custom toast views displayed.
                \item \textbf{void	show()}: Show the view for the specified duration.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	LENGTH\_LONG}: Show the view or text notification for a long period of time.
                \item \textbf{int	LENGTH\_SHORT}: Show the view or text notification for a short period of time.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{LayoutInflator (Abstract class)}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.LayoutInflater
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.view.LayoutInflater
            \end{javacode}
        \item \textbf{Constructors (Protected)}
            \bigbreak \noindent 
            \begin{javacode}
                LayoutInflater(Context context)
                LayoutInflater(LayoutInflater original, Context newContext)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{abstract LayoutInflater	cloneInContext(Context newContext)}: Create a copy of the existing LayoutInflater object, with the copy pointing to a different Context than the original.
                \item \textbf{final View	createView(Context viewContext, String name, String prefix, AttributeSet attrs)}: Low-level function for instantiating a view by name.
                \item \textbf{final View	createView(String name, String prefix, AttributeSet attrs)}: Low-level function for instantiating a view by name.
                \item \textbf{static LayoutInflater	from(Context context)}: Obtains the LayoutInflater from the given context.
                \item \textbf{Context	getContext()}: Return the context we are running in, for access to resources, class loader, etc.
                \item \textbf{final LayoutInflater.Factory	getFactory()}: Return the current Factory (or null).
                \item \textbf{final LayoutInflater.Factory2	getFactory2()}: Return the current Factory2.
                \item \textbf{LayoutInflater.Filter	getFilter()}:
                \item \textbf{View	inflate(int resource, ViewGroup root)}: Inflate a new view hierarchy from the specified xml resource.
                \item \textbf{View	inflate(XmlPullParser parser, ViewGroup root)}: Inflate a new view hierarchy from the specified xml node.
                \item \textbf{View	inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)}: Inflate a new view hierarchy from the specified XML node.
                \item \textbf{View	inflate(int resource, ViewGroup root, boolean attachToRoot)}: Inflate a new view hierarchy from the specified xml resource.
                \item \textbf{View	onCreateView(Context viewContext, View parent, String name, AttributeSet attrs)}: Version of onCreateView(android.view.View, java.lang.String, android.util.AttributeSet) that also takes the inflation context.
                \item \textbf{void	setFactory(LayoutInflater.Factory factory)}: Attach a custom Factory interface for creating views while using this LayoutInflater.
                \item \textbf{void	setFactory2(LayoutInflater.Factory2 factory)}: Like setFactory(Factory), but allows you to set a Factory2 interface.
                \item \textbf{void	setFilter(LayoutInflater.Filter filter)}: Sets the Filter to by this LayoutInflater.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{View	onCreateView(View parent, String name, AttributeSet attrs)}: Version of onCreateView(java.lang.String, android.util.AttributeSet) that also takes the future parent of the view being constructed.
                \item \textbf{View	onCreateView(String name, AttributeSet attrs)}: This routine is responsible for creating the correct subclass of View given the xml element name.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{SQLiteDatabase}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to $	android.database.sqlite.SQLiteClosable $\to $	android.database.sqlite.SQLiteDatabase
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.database.sqlite.SQLiteDatabase
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	beginTransaction()}: Begins a transaction in EXCLUSIVE mode.
                \item \textbf{void	beginTransactionNonExclusive()}: Begins a transaction in IMMEDIATE mode.
                \item \textbf{void	beginTransactionReadOnly()}: Begins a transaction in DEFERRED mode, with the android-specific constraint that the transaction is read-only.
                \item \textbf{void	beginTransactionWithListener(SQLiteTransactionListener transactionListener)}: Begins a transaction in EXCLUSIVE mode.
                \item \textbf{void	beginTransactionWithListenerNonExclusive(SQLiteTransactionListener transactionListener)}: Begins a transaction in IMMEDIATE mode.
                \item \textbf{void	beginTransactionWithListenerReadOnly(SQLiteTransactionListener transactionListener)}: Begins a transaction in read-only mode with a SQLiteTransactionListener listener.
                \item \textbf{SQLiteStatement	compileStatement(String sql)}: Compiles an SQL statement into a reusable pre-compiled statement object.
                \item \textbf{static SQLiteDatabase	create(SQLiteDatabase.CursorFactory factory)}: Create a memory backed SQLite database.
                \item \textbf{static SQLiteDatabase	createInMemory(SQLiteDatabase.OpenParams openParams)}: Create a memory backed SQLite database.
                \item \textbf{SQLiteRawStatement	createRawStatement(String sql)}: Return a SQLiteRawStatement connected to the database.
                \item \textbf{int	delete(String table, String whereClause, String[] whereArgs)}: Convenience method for deleting rows in the database.
                \item \textbf{static boolean	deleteDatabase(File file)}: Deletes a database including its journal file and other auxiliary files that may have been created by the database engine.
                \item \textbf{void	disableWriteAheadLogging()}: This method disables the features enabled by enableWriteAheadLogging().
                \item \textbf{boolean	enableWriteAheadLogging()}: Write-ahead logging enables parallel execution of queries from multiple threads on the same database, and reduces the likelihood of stalling on filesystem syncs.
                \item \textbf{void	endTransaction()}: End a transaction.
                \item \textbf{void	execPerConnectionSQL(String sql, Object[] bindArgs)}: Execute the given SQL statement on all connections to this database.
                \item \textbf{void	execSQL(String sql)}: Execute a single SQL statement that is NOT a SELECT or any other SQL statement that returns data.
                \item \textbf{void	execSQL(String sql, Object[] bindArgs)}: Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE.
                \item \textbf{static String	findEditTable(String tables)}: Finds the name of the first table, which is editable.
                \item \textbf{List<Pair<String, String>>	getAttachedDbs()}: Returns list of full pathnames of all attached databases including the main database by executing 'pragma database\_list' on the database.
                \item \textbf{long	getLastChangedRowCount()}: Return the number of database rows that were inserted, updated, or deleted by the most recent SQL statement within the current transaction.
                \item \textbf{long	getLastInsertRowId()}: Return the "rowid" of the last row to be inserted on the current connection.
                \item \textbf{long	getMaximumSize()}: Returns the maximum size the database may grow to.
                \item \textbf{long	getPageSize()}: Returns the current database page size, in bytes.
                \item \textbf{String	getPath()}: Gets the path to the database file.
                \item \textbf{Map<String, String>	getSyncedTables()}: This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated.
                \item \textbf{long	getTotalChangedRowCount()}: Return the total number of database rows that have been inserted, updated, or deleted on the current connection since it was created.
                \item \textbf{int	getVersion()}: Gets the database version.
                \item \textbf{boolean	inTransaction()}: Returns true if the current thread has a transaction pending.
                \item \textbf{long	insert(String table, String nullColumnHack, ContentValues values)}: Convenience method for inserting a row into the database.
                \item \textbf{long	insertOrThrow(String table, String nullColumnHack, ContentValues values)}: Convenience method for inserting a row into the database.
                \item \textbf{long	insertWithOnConflict(String table, String nullColumnHack, ContentValues initialValues, int conflictAlgorithm)}: General method for inserting a row into the database.
                \item \textbf{boolean	isDatabaseIntegrityOk()}: Runs 'pragma integrity\_check' on the given database (and all the attached databases) and returns true if the given database (and all its attached databases) pass integrity\_check, false otherwise.
                \item \textbf{boolean	isDbLockedByCurrentThread()}: Returns true if the current thread is holding an active connection to the database.
                \item \textbf{boolean	isDbLockedByOtherThreads()}: This method was deprecated in API level 16. Always returns false. Do not use this method.
                \item \textbf{boolean	isOpen()}: Returns true if the database is currently open.
                \item \textbf{boolean	isReadOnly()}: Returns true if the database is opened as read only.
                \item \textbf{boolean	isWriteAheadLoggingEnabled()}: Returns true if write-ahead logging has been enabled for this database.
                \item \textbf{void	markTableSyncable(String table, String deletedTable)}: This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated.
                \item \textbf{void	markTableSyncable(String table, String foreignKey, String updateTable)}: This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated.
                \item \textbf{boolean	needUpgrade(int newVersion)}: Returns true if the new version code is greater than the current database version.
                \item \textbf{static SQLiteDatabase	openDatabase(String path, SQLiteDatabase.CursorFactory factory, int flags)}: Open the database according to the flags OPEN\_READWRITE OPEN\_READONLY CREATE\_IF\_NECESSARY and/or NO\_LOCALIZED\_COLLATORS.
                \item \textbf{static SQLiteDatabase	openDatabase(File path, SQLiteDatabase.OpenParams openParams)}: Open the database according to the specified parameters
                \item \textbf{static SQLiteDatabase	openDatabase(String path, SQLiteDatabase.CursorFactory factory, int flags, DatabaseErrorHandler errorHandler)}: Open the database according to the flags OPEN\_READWRITE OPEN\_READONLY CREATE\_IF\_NECESSARY and/or NO\_LOCALIZED\_COLLATORS.
                \item \textbf{static SQLiteDatabase	openOrCreateDatabase(File file, SQLiteDatabase.CursorFactory factory)}: Equivalent to openDatabase(file.getPath(), factory, CREATE\_IF\_NECESSARY).
                \item \textbf{static SQLiteDatabase	openOrCreateDatabase(String path, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)}: Equivalent to openDatabase(path, factory, CREATE\_IF\_NECESSARY, errorHandler).
                \item \textbf{static SQLiteDatabase	openOrCreateDatabase(String path, SQLiteDatabase.CursorFactory factory)}: Equivalent to openDatabase(path, factory, CREATE\_IF\_NECESSARY).
                \item \textbf{Cursor	query(boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)}: Query the given URL, returning a Cursor over the result set.
                \item \textbf{Cursor	query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)}: Query the given table, returning a Cursor over the result set.
                \item \textbf{Cursor	query(boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit, CancellationSignal cancellationSignal)}: Query the given URL, returning a Cursor over the result set.
                \item \textbf{Cursor	query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy)}: Query the given table, returning a Cursor over the result set.
                \item \textbf{Cursor	queryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit, CancellationSignal cancellationSignal)}: Query the given URL, returning a Cursor over the result set.
                \item \textbf{Cursor	queryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)}: Query the given URL, returning a Cursor over the result set.
                \item \textbf{Cursor	rawQuery(String sql, String[] selectionArgs, CancellationSignal cancellationSignal)}: Runs the provided SQL and returns a Cursor over the result set.
                \item \textbf{Cursor	rawQuery(String sql, String[] selectionArgs)}: Runs the provided SQL and returns a Cursor over the result set.
                \item \textbf{Cursor	rawQueryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, String sql, String[] selectionArgs, String editTable, CancellationSignal cancellationSignal)}: Runs the provided SQL and returns a cursor over the result set.
                \item \textbf{Cursor	rawQueryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, String sql, String[] selectionArgs, String editTable)}: Runs the provided SQL and returns a cursor over the result set.
                \item \textbf{static int	releaseMemory()}: Attempts to release memory that SQLite holds but does not require to operate properly.
                \item \textbf{long	replace(String table, String nullColumnHack, ContentValues initialValues)}: Convenience method for replacing a row in the database.
                \item \textbf{long	replaceOrThrow(String table, String nullColumnHack, ContentValues initialValues)}: Convenience method for replacing a row in the database.
                \item \textbf{void	setCustomAggregateFunction(String functionName, BinaryOperator<String> aggregateFunction)}: Register a custom aggregate function that can be called from SQL expressions.
                \item \textbf{void	setCustomScalarFunction(String functionName, UnaryOperator<String> scalarFunction)}: Register a custom scalar function that can be called from SQL expressions.
                \item \textbf{void	setForeignKeyConstraintsEnabled(boolean enable)}: Sets whether foreign key constraints are enabled for the database.
                \item \textbf{void	setLocale(Locale locale)}: Sets the locale for this database.
                \item \textbf{void	setLockingEnabled(boolean lockingEnabled)}: This method was deprecated in API level 16. This method now does nothing. Do not use.
                \item \textbf{void	setMaxSqlCacheSize(int cacheSize)}: Sets the maximum size of the prepared-statement cache for this database.
                \item \textbf{long	setMaximumSize(long numBytes)}: Sets the maximum size the database will grow to.
                \item \textbf{void	setPageSize(long numBytes)}: Sets the database page size.
                \item \textbf{void	setTransactionSuccessful()}: Marks the current transaction as successful.
                \item \textbf{void	setVersion(int version)}: Sets the database version.
                \item \textbf{String	toString()}: Returns a string representation of the object.
                \item \textbf{int	update(String table, ContentValues values, String whereClause, String[] whereArgs)}: Convenience method for updating rows in the database.
                \item \textbf{int	updateWithOnConflict(String table, ContentValues values, String whereClause, String[] whereArgs, int conflictAlgorithm)}: Convenience method for updating rows in the database.
                \item \textbf{void	validateSql(String sql, CancellationSignal cancellationSignal)}: Verifies that a SQL SELECT statement is valid by compiling it.
                \item \textbf{boolean	yieldIfContended()}: This method was deprecated in API level 15. if the db is locked more than once (because of nested transactions) then the lock will not be yielded. Use yieldIfContendedSafely instead.
                \item \textbf{boolean	yieldIfContendedSafely()}: Temporarily end the transaction to let other threads run.
                \item \textbf{boolean	yieldIfContendedSafely(long sleepAfterYieldDelay)}: Temporarily end the transaction to let other threads run.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{void	finalize()}: Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.
                \item \textbf{void	onAllReferencesReleased()}: Called when the last reference to the object was released by a call to releaseReference() or close().
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	CONFLICT\_ABORT}: When a constraint violation occurs,no ROLLBACK is executed so changes from prior commands within the same transaction are preserved.
                \item \textbf{int	CONFLICT\_FAIL}: When a constraint violation occurs, the command aborts with a return code SQLITE\_CONSTRAINT.
                \item \textbf{int	CONFLICT\_IGNORE}: When a constraint violation occurs, the one row that contains the constraint violation is not inserted or changed.
                \item \textbf{int	CONFLICT\_NONE}: Use the following when no conflict action is specified.
                \item \textbf{int	CONFLICT\_REPLACE}: When a UNIQUE constraint violation occurs, the pre-existing rows that are causing the constraint violation are removed prior to inserting or updating the current row.
                \item \textbf{int	CONFLICT\_ROLLBACK}: When a constraint violation occurs, an immediate ROLLBACK occurs, thus ending the current transaction, and the command aborts with a return code of SQLITE\_CONSTRAINT.
                \item \textbf{int	CREATE\_IF\_NECESSARY}: Open flag: Flag for openDatabase(File, OpenParams) to create the database file if it does not already exist.
                \item \textbf{int	ENABLE\_WRITE\_AHEAD\_LOGGING}: Open flag: Flag for openDatabase(File, OpenParams) to open the database file with write-ahead logging enabled by default.
                \item \textbf{String	JOURNAL\_MODE\_DELETE}: The DELETE journaling mode is the normal behavior.
                \item \textbf{String	JOURNAL\_MODE\_MEMORY}: The MEMORY journaling mode stores the rollback journal in volatile RAM.
                \item \textbf{String	JOURNAL\_MODE\_OFF}: The OFF journaling mode disables the rollback journal completely.
                \item \textbf{String	JOURNAL\_MODE\_PERSIST}: The PERSIST journaling mode prevents the rollback journal from being deleted at the end of each transaction.
                \item \textbf{String	JOURNAL\_MODE\_TRUNCATE}: The TRUNCATE journaling mode commits transactions by truncating the rollback journal to zero-length instead of deleting it.
                \item \textbf{String	JOURNAL\_MODE\_WAL}: The WAL journaling mode uses a write-ahead log instead of a rollback journal to implement transactions.
                \item \textbf{int	MAX\_SQL\_CACHE\_SIZE}: Absolute max value that can be set by setMaxSqlCacheSize(int).
                \item \textbf{int	NO\_LOCALIZED\_COLLATORS}: Open flag: Flag for openDatabase(File, OpenParams) to open the database without support for localized collators.
                \item \textbf{int	OPEN\_READONLY}: Open flag: Flag for openDatabase(File, OpenParams) to open the database for reading only.
                \item \textbf{int	OPEN\_READWRITE}: Open flag: Flag for openDatabase(File, OpenParams) to open the database for reading and writing. If the disk is full, this may fail even before you actually write anything.
                \item \textbf{int	SQLITE\_MAX\_LIKE\_PATTERN\_LENGTH}: Maximum Length Of A LIKE Or GLOB Pattern The pattern matching algorithm used in the default LIKE and GLOB implementation of SQLite can exhibit O($N^{2}$) performance (where $N$ is the number of characters in the pattern) for certain pathological cases.
                \item \textbf{String	SYNC\_MODE\_EXTRA}: The EXTRA sync mode is like FULL sync mode with the addition that the directory containing a rollback journal is synced after that journal is unlinked to commit a transaction in DELETE journal mode.
                \item \textbf{String	SYNC\_MODE\_FULL}: In FULL sync mode the SQLite database engine will use the xSync method of the VFS to ensure that all content is safely written to the disk surface prior to continuing.
                \item \textbf{String	SYNC\_MODE\_NORMAL}: The NORMAL sync mode, the SQLite database engine will still sync at the most critical moments, but less often than in FULL mode.
                \item \textbf{String	SYNC\_MODE\_OFF}: In OFF sync mode SQLite continues without syncing as soon as it has handed data off to the operating system.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{Cursor (Interface)}
    \begin{itemize}
        \item \textbf{Signature} :
            \bigbreak \noindent 
            \begin{javacode}
                public interface Cursor implements Closeable
            \end{javacode}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
            android.database.Cursor
            \end{javacode}
        \item \textbf{Public abstract methods}
            \begin{itemize}
                \item \textbf{abstract void	close()}: Closes the Cursor, releasing all of its resources and making it completely invalid.
                \item \textbf{abstract void	copyStringToBuffer(int columnIndex, CharArrayBuffer buffer)}: Retrieves the requested column text and stores it in the buffer provided.
                \item \textbf{abstract void	deactivate()}: This method was deprecated in API level 16. Since requery() is deprecated, so too is this.
                \item \textbf{abstract byte[]	getBlob(int columnIndex)}: Returns the value of the requested column as a byte array.
                \item \textbf{abstract int	getColumnCount()}: Return total number of columns
                \item \textbf{abstract int	getColumnIndex(String columnName)}: Returns the zero-based index for the given column name, or -1 if the column doesn't exist.
                \item \textbf{abstract int	getColumnIndexOrThrow(String columnName)}: Returns the zero-based index for the given column name, or throws IllegalArgumentException if the column doesn't exist.
                \item \textbf{abstract String	getColumnName(int columnIndex)}: Returns the column name at the given zero-based column index.
                \item \textbf{abstract String[]	getColumnNames()}: Returns a string array holding the names of all of the columns in the result set in the order in which they were listed in the result.
                \item \textbf{abstract int	getCount()}: Returns the numbers of rows in the cursor.
                \item \textbf{abstract double	getDouble(int columnIndex)}: Returns the value of the requested column as a double.
                \item \textbf{abstract Bundle	getExtras()}: Returns a bundle of extra values.
                \item \textbf{abstract float	getFloat(int columnIndex)}: Returns the value of the requested column as a float.
                \item \textbf{abstract int	getInt(int columnIndex)}: Returns the value of the requested column as an int.
                \item \textbf{abstract long	getLong(int columnIndex)}: Returns the value of the requested column as a long.
                \item \textbf{abstract Uri	getNotificationUri()}: Return the URI at which notifications of changes in this Cursor's data will be delivered, as previously set by setNotificationUri(ContentResolver, Uri).
                \item \textbf{default List<Uri>	getNotificationUris()}: Return the URIs at which notifications of changes in this Cursor's data will be delivered, as previously set by setNotificationUris(ContentResolver, List).
                \item \textbf{abstract int	getPosition()}: Returns the current position of the cursor in the row set.
                \item \textbf{abstract short	getShort(int columnIndex)}: Returns the value of the requested column as a short.
                \item \textbf{abstract String	getString(int columnIndex)}: Returns the value of the requested column as a String.
                \item \textbf{abstract int	getType(int columnIndex)}: Returns data type of the given column's value.
                \item \textbf{abstract boolean	getWantsAllOnMoveCalls()}: onMove() will only be called across processes if this method returns true.
                \item \textbf{abstract boolean	isAfterLast()}: Returns whether the cursor is pointing to the position after the last row.
                \item \textbf{abstract boolean	isBeforeFirst()}: Returns whether the cursor is pointing to the position before the first row.
                \item \textbf{abstract boolean	isClosed()}: return true if the cursor is closed
                \item \textbf{abstract boolean	isFirst()}: Returns whether the cursor is pointing to the first row.
                \item \textbf{abstract boolean	isLast()}: Returns whether the cursor is pointing to the last row.
                \item \textbf{abstract boolean	isNull(int columnIndex)}: Returns true if the value in the indicated column is null.
                \item \textbf{abstract boolean	move(int offset)}: Move the cursor by a relative amount, forward or backward, from the current position.
                \item \textbf{abstract boolean	moveToFirst()}: Move the cursor to the first row.
                \item \textbf{abstract boolean	moveToLast()}: Move the cursor to the last row.
                \item \textbf{abstract boolean	moveToNext()}: Move the cursor to the next row.
                \item \textbf{abstract boolean	moveToPosition(int position)}: Move the cursor to an absolute position.
                \item \textbf{abstract boolean	moveToPrevious()}: Move the cursor to the previous row.
                \item \textbf{abstract void	registerContentObserver(ContentObserver observer)}: Register an observer that is called when changes happen to the content backing this cursor.
                \item \textbf{abstract void	registerDataSetObserver(DataSetObserver observer)}: Register an observer that is called when changes happen to the contents of the this cursors data set, for example, when the data set is changed via requery(), deactivate(), or close().
                \item \textbf{abstract boolean	requery()}: This method was deprecated in API level 15. Don't use this. Just request a new cursor, so you can do this asynchronously and update your list view once the new cursor comes back.
                \item \textbf{abstract Bundle	respond(Bundle extras)}: This is an out-of-band way for the user of a cursor to communicate with the cursor.
                \item \textbf{abstract void	setExtras(Bundle extras)}: Sets a Bundle that will be returned by getExtras().
                \item \textbf{abstract void	setNotificationUri(ContentResolver cr, Uri uri)}: Register to watch a content URI for changes.
                \item \textbf{default void	setNotificationUris(ContentResolver cr, List<Uri> uris)}: Similar to setNotificationUri(android.content.ContentResolver, android.net.Uri), except this version allows to watch multiple content URIs for changes.
                \item \textbf{abstract void	unregisterContentObserver(ContentObserver observer)}: Unregister an observer that has previously been registered with this cursor via registerContentObserver(ContentObserver).
                \item \textbf{abstract void	unregisterDataSetObserver(DataSetObserver observer)}: Unregister an observer that has previously been registered with this cursor via registerContentObserver(ContentObserver).
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ScrollView}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.FrameLayout $\to$	android.widget.ScrollView
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.ScrollView
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
                ScrollView(Context context)
                ScrollView(Context context, AttributeSet attrs)
                ScrollView(Context context, AttributeSet attrs, int defStyleAttr)
                ScrollView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
            \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	addView(View child, int index)}: Adds a child view.
                \item \textbf{void	addView(View child, ViewGroup.LayoutParams params)}: Adds a child view with the specified layout parameters.
                \item \textbf{void	addView(View child, int index, ViewGroup.LayoutParams params)}: Adds a child view with the specified layout parameters.
                \item \textbf{void	addView(View child)}: Adds a child view.
                \item \textbf{boolean	arrowScroll(int direction)}: Handle scrolling in response to an up or down arrow click.
                \item \textbf{void	computeScroll()}: Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.
                \item \textbf{boolean	dispatchKeyEvent(KeyEvent event)}: Dispatch a key event to the next view on the focus path.
                \item \textbf{void	draw(Canvas canvas)}: Manually render this view (and all of its children) to the given Canvas.
                \item \textbf{boolean	executeKeyEvent(KeyEvent event)}: You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
                \item \textbf{void	fling(int velocityY)}: Fling the scroll view
                \item \textbf{boolean	fullScroll(int direction)}: Handles scrolling in response to a "home/end" shortcut press.
                \item \textbf{CharSequence	getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{int	getBottomEdgeEffectColor()}: Returns the bottom edge effect color.
                \item \textbf{int	getMaxScrollAmount()}: int	getTopEdgeEffectColor()
                \item \textbf{boolean	isFillViewport()}: Indicates whether this ScrollView's content is stretched to fill the viewport.
                \item \textbf{boolean	isSmoothScrollingEnabled()}:
                \item \textbf{boolean	onGenericMotionEvent(MotionEvent event)}: Implement this method to handle generic motion events.
                \item \textbf{boolean	onInterceptTouchEvent(MotionEvent ev)}: Implement this method to intercept all touch screen motion events.
                \item \textbf{boolean	onNestedFling(View target, float velocityX, float velocityY, boolean consumed)}: Request a fling from a nested scroll.
                \item \textbf{void	onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)}: React to a nested scroll in progress.
                \item \textbf{void	onNestedScrollAccepted(View child, View target, int axes)}: React to the successful claiming of a nested scroll operation.
                \item \textbf{boolean	onStartNestedScroll(View child, View target, int nestedScrollAxes)}: React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate.
                \item \textbf{void	onStopNestedScroll(View target)}: React to a nested scroll operation ending.
                \item \textbf{boolean	onTouchEvent(MotionEvent ev)}: Implement this method to handle pointer events.
                \item \textbf{boolean	pageScroll(int direction)}: Handles scrolling in response to a "page up/down" shortcut press.
                \item \textbf{void	requestChildFocus(View child, View focused)}: Called when a child of this parent wants focus
                \item \textbf{boolean	requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)}: Called when a child of this group wants a particular rectangle to be positioned onto the screen.
                \item \textbf{void	requestDisallowInterceptTouchEvent(boolean disallowIntercept)}: Called when a child does not want this parent and its ancestors to intercept touch events with ViewGroup.onInterceptTouchEvent(MotionEvent).
                \item \textbf{void	requestLayout()}: Call this when something has changed which has invalidated the layout of this view.
                \item \textbf{void	scrollTo(int x, int y)}: Set the scrolled position of your view. This version also clamps the scrolling to the bounds of our child.
                \item \textbf{void	scrollToDescendant(View child)}: Scrolls the view to the given child.
                \item \textbf{void	setBottomEdgeEffectColor(int color)}: Sets the bottom edge effect color.
                \item \textbf{void	setEdgeEffectColor(int color)}: Sets the edge effect color for both top and bottom edge effects.
                \item \textbf{void	setFillViewport(boolean fillViewport)}: Indicates this ScrollView whether it should stretch its content height to fill the viewport or not.
                \item \textbf{void	setSmoothScrollingEnabled(boolean smoothScrollingEnabled)}: Set whether arrow scrolling will animate its transition.
                \item \textbf{void	setTopEdgeEffectColor(int color)}: Sets the top edge effect color.
                \item \textbf{boolean	shouldDelayChildPressedState()}: Return true if the pressed state should be delayed for children or descendants of this ViewGroup.
                \item \textbf{final void	smoothScrollBy(int dx, int dy)}: Like View.scrollBy, but scroll smoothly instead of immediately.
                \item \textbf{final void	smoothScrollTo(int x, int y)}: Like scrollTo(int, int), but scroll smoothly instead of immediately.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{int	computeScrollDeltaToGetChildRectOnScreen(Rect rect)}: Compute the amount to scroll in the Y direction in order to get a rectangle completely on the screen (or, if taller than the screen, at least the first screen size chunk of it).
                \item \textbf{int	computeVerticalScrollOffset()}: Compute the vertical offset of the vertical scrollbar's thumb within the horizontal range.
                \item \textbf{int	computeVerticalScrollRange()}: The scroll range of a scroll view is the overall height of all of its children.
                \item \textbf{float	getBottomFadingEdgeStrength()}: Returns the strength, or intensity, of the bottom faded edge.
                \item \textbf{float	getTopFadingEdgeStrength()}: Returns the strength, or intensity, of the top faded edge.
                \item \textbf{void	measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)}: Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding.
                \item \textbf{void	measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)}: Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding and margins.
                \item \textbf{void	onDetachedFromWindow()}: This is called when the view is detached from a window.
                \item \textbf{void	onLayout(boolean changed, int l, int t, int r, int b)}: Called from layout when this view should assign a size and position to each of its children.
                \item \textbf{void	onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measure the view and its content to determine the measured width and the measured height.
                \item \textbf{void	onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)}: Called by overScrollBy(int, int, int, int, int, int, int, int, boolean) to respond to the results of an over-scroll operation.
                \item \textbf{boolean	onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect)}: When looking for focus in children of a scroll view, need to be a little more careful not to give focus to something that is scrolled off screen.
                \item \textbf{void	onRestoreInstanceState(Parcelable state)}: Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState().
                \item \textbf{Parcelable	onSaveInstanceState()}: Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.
                \item \textbf{void	onSizeChanged(int w, int h, int oldw, int oldh)}: This is called during layout when the size of this view has changed.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{HorizontalScrollView}
    \begin{itemize}
        \item \textbf{Hierarchy}
            \begin{center}
                java.lang.Object $\to$	android.view.View $\to$	android.view.ViewGroup $\to$	android.widget.FrameLayout $\to$	android.widget.HorizontalScrollView
            \end{center}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.HorizontalScrollView
            \end{javacode}
        \item \textbf{Constructors}
            \bigbreak \noindent 
            \begin{javacode}
            HorizontalScrollView(Context context)
            HorizontalScrollView(Context context, AttributeSet attrs)
            HorizontalScrollView(Context context, AttributeSet attrs, int defStyleAttr)
            HorizontalScrollView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)
        \end{javacode}
        \item \textbf{Public methods}
            \begin{itemize}
                \item \textbf{void	addView(View child, int index)}: Adds a child view.
                \item \textbf{void	addView(View child)}: Adds a child view.
                \item \textbf{void	addView(View child, ViewGroup.LayoutParams params)}: Adds a child view with the specified layout parameters.
                \item \textbf{void	addView(View child, int index, ViewGroup.LayoutParams params)}: Adds a child view with the specified layout parameters.
                \item \textbf{boolean	arrowScroll(int direction)}: Handle scrolling in response to a left or right arrow click.
                \item \textbf{void	computeScroll()}: Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.
                \item \textbf{boolean	dispatchKeyEvent(KeyEvent event)}: Dispatch a key event to the next view on the focus path.
                \item \textbf{void	draw(Canvas canvas)}: Manually render this view (and all of its children) to the given Canvas.
                \item \textbf{boolean	executeKeyEvent(KeyEvent event)}: You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
                \item \textbf{void	fling(int velocityX)}: Fling the scroll view
                \item \textbf{boolean	fullScroll(int direction)}: Handles scrolling in response to a "home/end" shortcut press.
                \item \textbf{CharSequence	getAccessibilityClassName()}: Return the class name of this object to be used for accessibility purposes.
                \item \textbf{int	getLeftEdgeEffectColor()}: Returns the left edge effect color.
                \item \textbf{int	getMaxScrollAmount()}:
                \item \textbf{int	getRightEdgeEffectColor()}: Returns the right edge effect color.
                \item \textbf{boolean	isFillViewport()}: Indicates whether this HorizontalScrollView's content is stretched to fill the viewport.
                \item \textbf{boolean	isSmoothScrollingEnabled()}:
                \item \textbf{boolean	onGenericMotionEvent(MotionEvent event)}: Implement this method to handle generic motion events.
                \item \textbf{boolean	onInterceptTouchEvent(MotionEvent ev)}: Implement this method to intercept all touch screen motion events.
                \item \textbf{boolean	onTouchEvent(MotionEvent ev)}: Implement this method to handle pointer events.
                \item \textbf{boolean	pageScroll(int direction)}: Handles scrolling in response to a "page up/down" shortcut press.
                \item \textbf{void	requestChildFocus(View child, View focused)}: Called when a child of this parent wants focus
                \item \textbf{boolean	requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)}: Called when a child of this group wants a particular rectangle to be positioned onto the screen.
                \item \textbf{void	requestDisallowInterceptTouchEvent(boolean disallowIntercept)}: Called when a child does not want this parent and its ancestors to intercept touch events with ViewGroup.onInterceptTouchEvent(MotionEvent).
                \item \textbf{void	requestLayout()}: Call this when something has changed which has invalidated the layout of this view.
                \item \textbf{void	scrollTo(int x, int y)}: Set the scrolled position of your view. This version also clamps the scrolling to the bounds of our child.
                \item \textbf{void	setEdgeEffectColor(int color)}: Sets the edge effect color for both left and right edge effects.
                \item \textbf{void	setFillViewport(boolean fillViewport)}: Indicates this HorizontalScrollView whether it should stretch its content width to fill the viewport or not.
                \item \textbf{void	setLeftEdgeEffectColor(int color)}: Sets the left edge effect color.
                \item \textbf{void	setRightEdgeEffectColor(int color)}: Sets the right edge effect color.
                \item \textbf{void	setSmoothScrollingEnabled(boolean smoothScrollingEnabled)}: Set whether arrow scrolling will animate its transition.
                \item \textbf{boolean	shouldDelayChildPressedState()}: Return true if the pressed state should be delayed for children or descendants of this ViewGroup.
                \item \textbf{final void	smoothScrollBy(int dx, int dy)}: Like View.scrollBy, but scroll smoothly instead of immediately.
                \item \textbf{final void	smoothScrollTo(int x, int y)}: Like scrollTo(int, int), but scroll smoothly instead of immediately.
            \end{itemize}
        \item \textbf{Protected methods}
            \begin{itemize}
                \item \textbf{int	computeHorizontalScrollOffset()}: Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal range.
                \item \textbf{int	computeHorizontalScrollRange()}: The scroll range of a scroll view is the overall width of all of its children.
                \item \textbf{int	computeScrollDeltaToGetChildRectOnScreen(Rect rect)}: Compute the amount to scroll in the X direction in order to get a rectangle completely on the screen (or, if taller than the screen, at least the first screen size chunk of it).
                \item \textbf{float	getLeftFadingEdgeStrength()}: Returns the strength, or intensity, of the left faded edge.
                \item \textbf{float	getRightFadingEdgeStrength()}: Returns the strength, or intensity, of the right faded edge.
                \item \textbf{void	measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)}: Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding.
                \item \textbf{void	measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)}: Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding and margins.
                \item \textbf{void	onLayout(boolean changed, int l, int t, int r, int b)}: Called from layout when this view should assign a size and position to each of its children.
                \item \textbf{void	onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: Measure the view and its content to determine the measured width and the measured height.
                \item \textbf{void	onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)}: Called by overScrollBy(int, int, int, int, int, int, int, int, boolean) to respond to the results of an over-scroll operation.
                \item \textbf{boolean	onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect)}: When looking for focus in children of a scroll view, need to be a little more careful not to give focus to something that is scrolled off screen.
                \item \textbf{void	onRestoreInstanceState(Parcelable state)}: Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState().
                \item \textbf{Parcelable	onSaveInstanceState()}: Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.
                \item \textbf{void	onSizeChanged(int w, int h, int oldw, int oldh)}: This is called during layout when the size of this view has changed.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Styling widgets with java}
    \subsubsection{View}
    \begin{itemize}
        % --- Styling and Appearance ---
        \item \textbf{void setBackgroundColor(int color)}: Fills the view’s background with a solid color.
        \item \textbf{void setBackground(Drawable background)}: Sets a Drawable as the background.
        \item \textbf{Drawable getBackground()}: Returns the current background drawable.
        \item \textbf{void setForeground(Drawable foreground)}: Draws a Drawable on top of the view’s content.
        \item \textbf{void setPadding(int left, int top, int right, int bottom)}: Sets the padding inside the view.
        \item \textbf{int getPaddingLeft() / getPaddingTop() / getPaddingRight() / getPaddingBottom()}: Returns padding values.
        \item \textbf{void setElevation(float elevation)}: Adds shadow depth to the view for visual layering.
        \item \textbf{void setClipToOutline(boolean clipToOutline)}: Clips the view’s drawing to its outline (e.g., rounded corners).
        \item \textbf{void setOutlineProvider(ViewOutlineProvider provider)}: Defines the outline shape for shadows and clipping.
        \item \textbf{void setBackgroundTintList(ColorStateList tint)}: Applies tint coloring to the background.
        \item \textbf{void setBackgroundTintMode(PorterDuff.Mode mode)}: Defines how the background tint blends with the original color.
        \item \textbf{void setForegroundTintList(ColorStateList tint)}: Applies tint coloring to the foreground.
        \item \textbf{void setOutlineSpotShadowColor(int color)}: Sets the color of the view’s spot shadow.
        \item \textbf{void setOutlineAmbientShadowColor(int color)}: Sets the color of the view’s ambient shadow.
        \item \textbf{void setRotationX(float rotationX) / setRotationY(float rotationY)}: Rotates the view around the X or Y axis.
        \item \textbf{void setCameraDistance(float distance)}: Adjusts the 3D perspective depth for rotation effects.
    \end{itemize}

    \pagebreak 
    \subsubsection{TextView}
    \begin{itemize}
        \item \textbf{Color, size, typeface}
            \begin{itemize}
                \item \textbf{void setTextColor(int color)}: Sets the text color.
                \item \textbf{void setTextColor(ColorStateList colors)}: Sets text colors for different states.
                \item \textbf{void setHighlightColor(int color)}: Sets selection highlight color.
                \item \textbf{void setLinkTextColor(int color)}: Sets link color.
                \item \textbf{void setLinkTextColor(ColorStateList colors)}: Sets link colors for states.
                \item \textbf{void setTextSize(float size)}: Sets text size in scaled pixels.
                \item \textbf{void setTextSize(int unit, float size)}: Sets text size with unit.
                \item \textbf{void setTextScaleX(float size)}: Horizontal text scale.
                \item \textbf{void setTypeface(Typeface tf)}: Sets typeface.
                \item \textbf{void setTypeface(Typeface tf, int style)}: Sets typeface and style.
                \item \textbf{void setAllCaps(boolean allCaps)}: Transforms input to ALL CAPS display.
                \item \textbf{void setTextAppearance(int resId)}: Applies a text appearance style.
                \item \textbf{void setTextAppearance(Context context, int resId)}: \textit{Deprecated} in API 23.
            \end{itemize}

        \item \textbf{Auto-size text}
            \begin{itemize}
                \item \textbf{void setAutoSizeTextTypeWithDefaults(int autoSizeTextType)}: Enables default auto-size.
                \item \textbf{void setAutoSizeTextTypeUniformWithConfiguration(int min, int max, int step, int unit)}: Uniform auto-size config.
                \item \textbf{void setAutoSizeTextTypeUniformWithPresetSizes(int[] presetSizes, int unit)}: Uniform auto-size with presets.
            \end{itemize}

        \item \textbf{Typography, wrapping, justification}
            \begin{itemize}
                \item \textbf{void setLetterSpacing(float letterSpacing)}: Sets letter spacing.
                \item \textbf{void setLineSpacing(float add, float mult)}: Extra and multiplier.
                \item \textbf{void setLineHeight(int lineHeight)}: Explicit line height (px).
                \item \textbf{void setLineHeight(int unit, float lineHeight)}: Explicit line height with unit.
                \item \textbf{void setEllipsize(TextUtils.TruncateAt where)}: Ellipsize strategy.
                \item \textbf{void setBreakStrategy(int breakStrategy)}: Paragraph line-break strategy.
                \item \textbf{void setLineBreakStyle(int lineBreakStyle)}: Line-break style.
                \item \textbf{void setLineBreakWordStyle(int lineBreakWordStyle)}: Word-break style.
                \item \textbf{void setHyphenationFrequency(int hyphenationFrequency)}: Hyphenation setting.
                \item \textbf{void setJustificationMode(int justificationMode)}: Text justification.
                \item \textbf{void setFallbackLineSpacing(boolean enabled)}: Respect fallback font metrics.
                \item \textbf{void setIncludeFontPadding(boolean includepad)}: Include extra ascent/descent padding.
                \item \textbf{void setFirstBaselineToTopHeight(int px)}: Align first baseline to top padding.
                \item \textbf{void setLastBaselineToBottomHeight(int px)}: Align last baseline to bottom padding.
                \item \textbf{void setLocalePreferredLineHeightForMinimumUsed(boolean flag)}: Locale-preferred min line height.
            \end{itemize}

        \item \textbf{Compound drawables and tints}
            \begin{itemize}
                \item \textbf{void setCompoundDrawables(Drawable left, Drawable top, Drawable right, Drawable bottom)}: L/T/R/B drawables.
                \item \textbf{void setCompoundDrawablesWithIntrinsicBounds(Drawable left, Drawable top, Drawable right, Drawable bottom)}: With intrinsic bounds.
                \item \textbf{void setCompoundDrawablesWithIntrinsicBounds(int left, int top, int right, int bottom)}: By resource IDs.
                \item \textbf{void setCompoundDrawablesRelative(Drawable start, Drawable top, Drawable end, Drawable bottom)}: Start/End variants.
                \item \textbf{void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start, Drawable top, Drawable end, Drawable bottom)}: With intrinsic bounds.
                \item \textbf{void setCompoundDrawablesRelativeWithIntrinsicBounds(int start, int top, int end, int bottom)}: By resource IDs.
                \item \textbf{void setCompoundDrawablePadding(int pad)}: Space between text and drawables.
                \item \textbf{void setCompoundDrawableTintList(ColorStateList tint)}: Drawable tint list.
                \item \textbf{void setCompoundDrawableTintMode(PorterDuff.Mode mode)}: Porter-Duff tint mode.
                \item \textbf{void setCompoundDrawableTintBlendMode(BlendMode blendMode)}: BlendMode tinting.
            \end{itemize}

        \item \textbf{Hint \& cursor/selection visuals}
            \begin{itemize}
                \item \textbf{void setHint(CharSequence hint)}: Hint text.
                \item \textbf{void setHint(int resid)}: Hint from resource.
                \item \textbf{void setHintTextColor(int color)}: Hint color.
                \item \textbf{void setHintTextColor(ColorStateList colors)}: Hint color states.
                \item \textbf{void setTextCursorDrawable(Drawable d)}: Cursor drawable.
                \item \textbf{void setTextCursorDrawable(int resId)}: Cursor drawable by resource.
                \item \textbf{void setTextSelectHandle(int resId)}: Selection handle (resource).
                \item \textbf{void setTextSelectHandle(Drawable d)}: Selection handle.
                \item \textbf{void setTextSelectHandleLeft(int resId)}: Left handle (resource).
                \item \textbf{void setTextSelectHandleLeft(Drawable d)}: Left handle.
                \item \textbf{void setTextSelectHandleRight(int resId)}: Right handle (resource).
                \item \textbf{void setTextSelectHandleRight(Drawable d)}: Right handle.
            \end{itemize}

        \item \textbf{Shadows, transforms, and paint flags}
            \begin{itemize}
                \item \textbf{void setShadowLayer(float radius, float dx, float dy, int color)}: Text shadow.
                \item \textbf{final void setTransformationMethod(TransformationMethod method)}: Visual text transformation (e.g., password).
                \item \textbf{void setPaintFlags(int flags)}: Underline/strike-through, etc.
                \item \textbf{void setElegantTextHeight(boolean elegant)}: Use elegant height metrics.
                \item \textbf{void setFontFeatureSettings(String settings)}: OpenType features.
                \item \textbf{boolean setFontVariationSettings(String settings)}: Font variations (axes).
            \end{itemize}

        \item \textbf{Alignment / layout-affecting (often part of style guides)}
            \begin{itemize}
                \item \textbf{void setGravity(int gravity)}: Horizontal/vertical alignment within the view.
                \item \textbf{void setEms(int ems)}: Exact width in ems (typographic sizing).
                \item \textbf{void setLines(int lines)}: Exact number of lines (tight control of layout look).
            \end{itemize}

        \item \textbf{Styling-related getters (useful to read current style)}
            \begin{itemize}
                \item \textbf{int getCurrentTextColor()}, \textbf{ColorStateList getTextColors()}, \textbf{int getHighlightColor()}, \textbf{ColorStateList getHintTextColors()}, \textbf{ColorStateList getLinkTextColors()}
                \item \textbf{float getTextSize()}, \textbf{Typeface getTypeface()}, \textbf{float getLetterSpacing()}, \textbf{int getLineHeight()}
                \item \textbf{TextUtils.TruncateAt getEllipsize()}, \textbf{int getBreakStrategy()}, \textbf{int getHyphenationFrequency()}, \textbf{int getJustificationMode()}
                \item \textbf{String getFontFeatureSettings()}, \textbf{String getFontVariationSettings()}
                \item \textbf{Drawable[] getCompoundDrawables()}, \textbf{Drawable[] getCompoundDrawablesRelative()}, \textbf{int getCompoundDrawablePadding()}, \textbf{ColorStateList getCompoundDrawableTintList()}, \textbf{PorterDuff.Mode getCompoundDrawableTintMode()}, \textbf{BlendMode getCompoundDrawableTintBlendMode()}
            \end{itemize}

        \item \textbf{Advanced styling hooks (from the \emph{other} list)}
            \begin{itemize}
                \item \textbf{void drawableStateChanged()}: React to state changes that affect drawables/tints.
                \item \textbf{int[] onCreateDrawableState(int extraSpace)}: Customize drawable state for styling.
                \item \textbf{void onDraw(Canvas canvas)}: Custom rendering of text/effects.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{EditText (Use TextView methods)}
    \begin{itemize}
        \item \textbf{boolean isStyleShortcutEnabled()}: Returns true if style shortcuts (e.g., \texttt{Ctrl+B} for bold) are enabled.
        \item \textbf{void setStyleShortcutsEnabled(boolean enabled)}: Enables or disables style shortcuts such as \texttt{Ctrl+B}, \texttt{Ctrl+I}, etc.
        \item \textbf{void setEllipsize(TextUtils.TruncateAt ellipsis)}: Specifies how overflowing text should be ellipsized (e.g., at the end or middle) instead of wrapped.
        \item \textbf{void setText(CharSequence text, TextView.BufferType type)}: Sets the text and determines how it’s stored (e.g., as plain, styled, or editable text), affecting styling.
    \end{itemize}


    \pagebreak 
    \subsubsection{Button (Use TextView methods)}

    \pagebreak 
    \subsubsection{ListView}
    \begin{itemize}
        \item \textbf{Drawable getDivider()}: Returns the drawable that is drawn between each list item.
        \item \textbf{int getDividerHeight()}: Returns the height of the divider between list items.
        \item \textbf{Drawable getOverscrollFooter()}: Returns the drawable drawn below all list content during overscroll.
        \item \textbf{Drawable getOverscrollHeader()}: Returns the drawable drawn above all list content during overscroll.
        \item \textbf{boolean areFooterDividersEnabled()}: Returns whether footer dividers are currently enabled.
        \item \textbf{boolean areHeaderDividersEnabled()}: Returns whether header dividers are currently enabled.
        \item \textbf{void setCacheColorHint(int color)}: Sets a hint color indicating the solid background behind the list, improving appearance on transparent backgrounds.
        \item \textbf{void setDivider(Drawable divider)}: Sets the drawable that will be drawn between list items.
        \item \textbf{void setDividerHeight(int height)}: Sets the height of the divider drawn between list items.
        \item \textbf{void setFooterDividersEnabled(boolean footerDividersEnabled)}: Enables or disables drawing dividers for footer views.
        \item \textbf{void setHeaderDividersEnabled(boolean headerDividersEnabled)}: Enables or disables drawing dividers for header views.
        \item \textbf{void setOverscrollFooter(Drawable footer)}: Sets the drawable to be drawn below all list content during overscroll.
        \item \textbf{void setOverscrollHeader(Drawable header)}: Sets the drawable to be drawn above all list content during overscroll.
        \item \textbf{void dispatchDraw(Canvas canvas)}: (Protected) Called to draw all child views — can be overridden for custom list-item rendering effects.
        \item \textbf{boolean drawChild(Canvas canvas, View child, long drawingTime)}: (Protected) Draws a single list item onto the canvas; used to customize per-item drawing style.
    \end{itemize}


    \pagebreak 
    \subsubsection{ImageView}
    \begin{itemize}
        \item \textbf{void animateTransform(Matrix matrix)}: Applies a temporary transformation matrix for animation or visual effects.
        \item \textbf{final void clearColorFilter()}: Removes any color filter or tint applied to the image.
        \item \textbf{ColorFilter getColorFilter()}: Returns the active color filter used for tinting or blending.
        \item \textbf{int getImageAlpha()}: Returns the current alpha (transparency) level of the image.
        \item \textbf{Matrix getImageMatrix()}: Returns the current transformation matrix applied to the image.
        \item \textbf{BlendMode getImageTintBlendMode()}: Returns the blending mode used for applying tints.
        \item \textbf{ColorStateList getImageTintList()}: Returns the color tint list applied to the image drawable.
        \item \textbf{PorterDuff.Mode getImageTintMode()}: Returns the blending mode used for applying the tint.
        \item \textbf{ImageView.ScaleType getScaleType()}: Returns the scale type that defines how the image fits within the view bounds.
        \item \textbf{void setAlpha(int alpha)}: \textit{Deprecated in API 16.} Sets the overall opacity of the view (use \texttt{setImageAlpha(int)} instead).
        \item \textbf{final void setColorFilter(int color, PorterDuff.Mode mode)}: Applies a tint color and blending mode to the image.
        \item \textbf{void setColorFilter(ColorFilter cf)}: Applies a custom color filter to modify image appearance.
        \item \textbf{final void setColorFilter(int color)}: Applies a tint color to the image using the default blending mode.
        \item \textbf{void setCropToPadding(boolean cropToPadding)}: Determines whether the image is cropped to the view’s padding.
        \item \textbf{void setImageAlpha(int alpha)}: Sets the transparency level for the image drawable.
        \item \textbf{void setImageBitmap(Bitmap bm)}: Sets a bitmap as the content of the ImageView.
        \item \textbf{void setImageDrawable(Drawable drawable)}: Sets a drawable as the image content.
        \item \textbf{void setImageIcon(Icon icon)}: Sets an icon as the content.
        \item \textbf{void setImageMatrix(Matrix matrix)}: Applies a transformation matrix to the image drawable.
        \item \textbf{void setImageResource(int resId)}: Sets an image resource by its resource ID.
        \item \textbf{void setImageTintBlendMode(BlendMode blendMode)}: Sets how the tint blends with the image.
        \item \textbf{void setImageTintList(ColorStateList tint)}: Applies a color tint list to the image drawable.
        \item \textbf{void setImageTintMode(PorterDuff.Mode tintMode)}: Defines the blending mode for the tint.
        \item \textbf{void setScaleType(ImageView.ScaleType scaleType)}: Defines how the image should be scaled or cropped to fit within the view.
        \item \textbf{void onDraw(Canvas canvas)}: (Protected) Allows custom drawing of the image—useful for advanced visual effects.
    \end{itemize}

    \pagebreak 
    \subsubsection{CompoundButton}
    \begin{itemize}
        \item \textbf{Drawable getButtonDrawable()}: Returns the drawable used as the button image (e.g., checkmark or radio indicator).
        \item \textbf{BlendMode getButtonTintBlendMode()}: Returns the blending mode used to apply the tint to the button drawable.
        \item \textbf{ColorStateList getButtonTintList()}: Returns the color tint list applied to the button drawable.
        \item \textbf{PorterDuff.Mode getButtonTintMode()}: Returns the blending mode used for tinting.
        \item \textbf{void setButtonDrawable(int resId)}: Sets a drawable resource as the button image.
        \item \textbf{void setButtonDrawable(Drawable drawable)}: Sets a drawable object as the button image.
        \item \textbf{void setButtonIcon(Icon icon)}: Sets an icon as the visual button image.
        \item \textbf{void setButtonTintBlendMode(BlendMode tintMode)}: Defines how the tint color blends with the drawable.
        \item \textbf{void setButtonTintList(ColorStateList tint)}: Applies a tint list (different colors for different states) to the button image.
        \item \textbf{void setButtonTintMode(PorterDuff.Mode tintMode)}: Specifies the tint blending mode.
        \item \textbf{void drawableStateChanged()}: (Protected) Called when the state of the view changes in a way that affects drawable appearance (e.g., pressed, focused, checked).
        \item \textbf{int[] onCreateDrawableState(int extraSpace)}: (Protected) Generates the drawable state array — affects how state-based drawables (like selectors) are drawn.
        \item \textbf{void onDraw(Canvas canvas)}: (Protected) Used for custom drawing — allows overriding default appearance.
        \item \textbf{boolean verifyDrawable(Drawable who)}: (Protected) Ensures the drawable being displayed belongs to this view; relevant for custom visual drawables.
    \end{itemize}

    \pagebreak 
    \subsubsection{CheckBox (Use Button and CompoundButton styles)}

    \pagebreak 
    \subsubsection{RadioButton (Use button and CompoundButton styles)}

    \pagebreak 
    \subsubsection{Spinner}
    \begin{itemize}
        \item \textbf{int getDropDownHorizontalOffset()}: Returns the horizontal offset in pixels for positioning the dropdown popup.
        \item \textbf{int getDropDownVerticalOffset()}: Returns the vertical offset in pixels for positioning the dropdown popup.
        \item \textbf{int getDropDownWidth()}: Returns the configured width of the dropdown popup window.
        \item \textbf{int getGravity()}: Returns how the selected item view is positioned within the spinner (e.g., left, center, right).
        \item \textbf{Drawable getPopupBackground()}: Returns the background drawable used for the spinner’s dropdown popup.
        \item \textbf{void setDropDownHorizontalOffset(int pixels)}: Sets the horizontal offset in pixels for the spinner’s dropdown popup.
        \item \textbf{void setDropDownVerticalOffset(int pixels)}: Sets the vertical offset in pixels for the spinner’s dropdown popup.
        \item \textbf{void setDropDownWidth(int pixels)}: Sets the width in pixels for the spinner’s dropdown popup window.
        \item \textbf{void setGravity(int gravity)}: Defines how the selected item is positioned within the spinner (e.g., \texttt{Gravity.CENTER}).
        \item \textbf{void setPopupBackgroundDrawable(Drawable background)}: Sets a drawable as the background for the dropdown popup.
        \item \textbf{void setPopupBackgroundResource(int resId)}: Sets a background resource for the dropdown popup.
        \item \textbf{CharSequence getPrompt()}: Returns the prompt text displayed when the dialog version of the spinner is shown.
        \item \textbf{void setPrompt(CharSequence prompt)}: Sets custom prompt text for the spinner dialog.
        \item \textbf{void setPromptId(int promptId)}: Sets the prompt text by its string resource ID.
        \item \textbf{int getBaseline()}: Returns the text baseline offset (useful when aligning the spinner with other text views visually).
        \item \textbf{void onLayout(boolean changed, int l, int t, int r, int b)}: (Protected) Handles positioning of spinner items — can affect visual alignment.
        \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: (Protected) Determines size and layout — affects how the spinner and dropdown appear.
    \end{itemize}
    \textbf{Styles from AdapterView}
    \begin{itemize}
        \item \textbf{void setSelection(int position)}: Visually highlights the selected item.
        \item \textbf{void setEmptyView(View emptyView)}: Specifies a view to display when the adapter is empty.
    \end{itemize}



    \pagebreak 
    \subsubsection{ProgessBar}
    \begin{itemize}
        \item \textbf{void drawableHotspotChanged(float x, float y)}: Called when the view hotspot changes and must be propagated to drawables or child views.
        \item \textbf{Drawable getCurrentDrawable()}: Returns the drawable currently used to draw the progress bar.
        \item \textbf{Drawable getIndeterminateDrawable()}: Returns the drawable used to draw the progress bar in indeterminate mode.
        \item \textbf{BlendMode getIndeterminateTintBlendMode()}: Returns the blending mode used to apply the tint to the indeterminate drawable.
        \item \textbf{ColorStateList getIndeterminateTintList()}: Returns the color tint list applied to the indeterminate drawable.
        \item \textbf{PorterDuff.Mode getIndeterminateTintMode()}: Returns the blending mode used to apply the tint to the indeterminate drawable.
        \item \textbf{Interpolator getInterpolator()}: Gets the acceleration curve for the indeterminate animation.
        \item \textbf{BlendMode getProgressBackgroundTintBlendMode()}: Returns the blending mode used to apply the tint to the progress background.
        \item \textbf{ColorStateList getProgressBackgroundTintList()}: Returns the tint list applied to the progress background.
        \item \textbf{PorterDuff.Mode getProgressBackgroundTintMode()}: Returns the blending mode used to apply the tint to the progress background.
        \item \textbf{Drawable getProgressDrawable()}: Returns the drawable used to draw the progress bar in progress mode.
        \item \textbf{BlendMode getProgressTintBlendMode()}: Returns the blending mode used to apply the tint to the progress drawable.
        \item \textbf{ColorStateList getProgressTintList()}: Returns the color tint list applied to the progress drawable.
        \item \textbf{PorterDuff.Mode getProgressTintMode()}: Returns the blending mode used to apply the tint to the progress drawable.
        \item \textbf{BlendMode getSecondaryProgressTintBlendMode()}: Returns the blending mode used to apply the tint to the secondary progress drawable.
        \item \textbf{ColorStateList getSecondaryProgressTintList()}: Returns the color tint list applied to the secondary progress drawable.
        \item \textbf{PorterDuff.Mode getSecondaryProgressTintMode()}: Returns the blending mode used to apply the tint to the secondary progress drawable.
        \item \textbf{void invalidateDrawable(Drawable dr)}: Invalidates the specified drawable, forcing a redraw.
        \item \textbf{void jumpDrawablesToCurrentState()}: Jumps all drawables to their current state instantly, skipping animations.
        \item \textbf{void setIndeterminateDrawable(Drawable d)}: Defines the drawable used to draw the progress bar in indeterminate mode.
        \item \textbf{void setIndeterminateDrawableTiled(Drawable d)}: Defines a tileable drawable for the indeterminate mode.
        \item \textbf{void setIndeterminateTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for applying the indeterminate tint.
        \item \textbf{void setIndeterminateTintList(ColorStateList tint)}: Applies a color tint to the indeterminate drawable.
        \item \textbf{void setIndeterminateTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the indeterminate tint.
        \item \textbf{void setInterpolator(Interpolator interpolator)}: Sets the acceleration curve for the indeterminate animation.
        \item \textbf{void setProgressBackgroundTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the progress background tint.
        \item \textbf{void setProgressBackgroundTintList(ColorStateList tint)}: Applies a tint to the progress background.
        \item \textbf{void setProgressBackgroundTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the progress background tint.
        \item \textbf{void setProgressDrawable(Drawable d)}: Defines the drawable used to draw the progress bar in progress mode.
        \item \textbf{void setProgressDrawableTiled(Drawable d)}: Defines a tileable drawable for the progress bar in progress mode.
        \item \textbf{void setProgressTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the progress indicator tint.
        \item \textbf{void setProgressTintList(ColorStateList tint)}: Applies a tint to the progress indicator.
        \item \textbf{void setProgressTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the progress indicator tint.
        \item \textbf{void setSecondaryProgressTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the secondary progress tint.
        \item \textbf{void setSecondaryProgressTintList(ColorStateList tint)}: Applies a tint to the secondary progress indicator.
        \item \textbf{void setSecondaryProgressTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the secondary progress tint.
        \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects drawable appearance.
        \item \textbf{void onDraw(Canvas canvas)}: Used to perform custom drawing for the progress bar.
        \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true if the specified drawable is managed and displayed by this view.
    \end{itemize}

    \pagebreak 
    \subsubsection{AbsSeekBar}
    \begin{itemize}
        \item \textbf{void drawableHotspotChanged(float x, float y)}: Called whenever the view hotspot changes and must be propagated to drawables or child views.
        \item \textbf{boolean getSplitTrack()}: Returns whether the track is visually split by the thumb.
        \item \textbf{Drawable getThumb()}: Returns the drawable representing the thumb — the draggable component indicating progress.
        \item \textbf{int getThumbOffset()}: Returns the amount by which the thumb extends beyond the track.
        \item \textbf{BlendMode getThumbTintBlendMode()}: Returns the blending mode used to apply the tint to the thumb drawable.
        \item \textbf{ColorStateList getThumbTintList()}: Returns the tint color list applied to the thumb drawable.
        \item \textbf{PorterDuff.Mode getThumbTintMode()}: Returns the blending mode used to apply the tint to the thumb drawable.
        \item \textbf{Drawable getTickMark()}: Returns the drawable used as the tick mark for each progress position.
        \item \textbf{BlendMode getTickMarkTintBlendMode()}: Returns the blending mode used to apply tint to the tick mark drawable.
        \item \textbf{ColorStateList getTickMarkTintList()}: Returns the tint color list applied to the tick mark drawable.
        \item \textbf{PorterDuff.Mode getTickMarkTintMode()}: Returns the blending mode used to apply tint to the tick mark drawable.
        \item \textbf{void jumpDrawablesToCurrentState()}: Immediately updates all drawables associated with this view to their current state.
        \item \textbf{void setSplitTrack(boolean splitTrack)}: Specifies whether the track should be visually split by the thumb.
        \item \textbf{void setThumb(Drawable thumb)}: Sets the drawable used as the thumb in the progress meter.
        \item \textbf{void setThumbOffset(int thumbOffset)}: Sets the offset allowing the thumb to extend beyond the track visually.
        \item \textbf{void setThumbTintBlendMode(BlendMode blendMode)}: Defines the blending mode used when applying tint to the thumb drawable.
        \item \textbf{void setThumbTintList(ColorStateList tint)}: Applies a tint color list to the thumb drawable.
        \item \textbf{void setThumbTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used with the thumb tint.
        \item \textbf{void setTickMark(Drawable tickMark)}: Sets the drawable used as tick marks at each progress position.
        \item \textbf{void setTickMarkTintBlendMode(BlendMode blendMode)}: Specifies the blending mode used to apply tint to the tick mark drawable.
        \item \textbf{void setTickMarkTintList(ColorStateList tint)}: Applies a tint color list to the tick mark drawable.
        \item \textbf{void setTickMarkTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used with the tick mark tint.
        \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects drawable appearance.
        \item \textbf{void onDraw(Canvas canvas)}: Implement this method to perform custom drawing operations for the view.
        \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true if the specified drawable is being displayed by this view; subclasses override when managing custom drawables.
    \end{itemize}



    \pagebreak 
    \subsubsection{SeekBar (Use styles from ProgessBar and AbsSeekBar)}


    \pagebreak 
    \subsection{Used Methods, constants, and fields}
    \subsubsection{Activity}
    \begin{itemize}
        \item \textbf{setContentView(int view)} 
    \end{itemize}

    \bigbreak \noindent \pagebreak \noindent
    \subsubsection{View}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{setVisibility(int) / getVisibility()}:	Show, hide (INVISIBLE), or remove (GONE) a view.
                \item \textbf{findViewById(int)}:	Get a view inside another view or layout.
                \item \textbf{getId() / setId(int)}:	Get or assign a unique view ID.
                \item \textbf{setOnClickListener(...)}:	Handle click actions.
                \item \textbf{setEnabled(boolean) / isEnabled()}:	Enable/disable a view.
                \item \textbf{setAlpha(float)}:	Adjust transparency.
                \item \textbf{getX(), getY()}:	View’s position relative to its parent.
                \item \textbf{setX(), setY()}:	Move a view.
                \item \textbf{getWidth(), getHeight()}:	View’s measured width/height.
                \item \textbf{setLayoutParams(ViewGroup.LayoutParams)}:	Change width, height, margins programmatically.
                \item \textbf{getLayoutParams()}:	Access current layout parameters.
                \item \textbf{requestLayout()}:	Ask parent to re-measure and re-layout (after size change).
                \item \textbf{setTranslationX/Y(float)}:	Move view without changing layout.
                \item \textbf{setScaleX/Y(float)}:	Scale the view.
                \item \textbf{setRotation(float)}:	Rotate the view.
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsubsection{ViewGroup}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{addView(View) / addView(View, int) / addView(View, LayoutParams)}: Add children quickly.
                \item \textbf{removeView(View) / removeViewAt(int) / removeAllViews()}: Remove children.
                \item \textbf{removeAllViewsInLayout()}: Called by a ViewGroup subclass to remove child views from itself
                \item \textbf{getChildCount(), getChildAt(int), indexOfChild(View)}: Inspect/manage children.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ViewGroup.LayoutParams}
    \begin{itemize}
        \item \textbf{Fields} 
            \begin{itemize}
                \item \textbf{public int	height}: Information about how tall the view wants to be.
                \item \textbf{public int	width}: Information about how wide the view wants to be.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	FILL\_PARENT}: Special value for the height or width requested by a View.
                \item \textbf{int	MATCH\_PARENT}: Special value for the height or width requested by a View.
                \item \textbf{int	WRAP\_CONTENT}: Special value for the height or width requested by a View.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ViewGroup.MarginLayoutParams}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{int	getLayoutDirection()}: Retuns the layout direction.
                \item \textbf{int	getMarginEnd()}: Returns the end margin in pixels.
                \item \textbf{int	getMarginStart()}: Returns the start margin in pixels.
                \item \textbf{void	setLayoutDirection(int layoutDirection)}: Set the layout direction
                \item \textbf{void	setMarginEnd(int end)}: Sets the relative end margin.
                \item \textbf{void	setMarginStart(int start)}: Sets the relative start margin.
                \item \textbf{void	setMargins(int left, int top, int right, int bottom)}: Sets the margins, in pixels.
            \end{itemize}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public int	bottomMargin}: The bottom margin in pixels of the child.
                \item \textbf{public int	leftMargin}: The left margin in pixels of the child.
                \item \textbf{public int	rightMargin}: The right margin in pixels of the child.
                \item \textbf{public int	topMargin}: The top margin in pixels of the child.
            \end{itemize}
    \end{itemize}

    \pagebreak \noindent
    \subsubsection{Context}



    \pagebreak \noindent
    \subsubsection{ConstraintLayout}


    \pagebreak \noindent
    \subsubsection{ConstraintLayout.LayoutParams}


    \pagebreak \noindent
    \subsubsection{RelativeLayout}


    \pagebreak \noindent
    \subsubsection{RelativeLayout.LayoutParams}


    \pagebreak \noindent
    \subsubsection{LinearLayout}


    \pagebreak \noindent
    \subsubsection{LinearLayout.LayoutParams}


    \pagebreak \noindent
    \subsubsection{GridLayout}
    \begin{itemize}
        \item \textbf{Methods} 
            \begin{itemize}
                \item \textbf{setRowCount(int rows)}
                \item \textbf{setColumnCount(int cols)}
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsubsection{GridLayout.LayoutParams}


    \pagebreak \noindent
    \subsubsection{TableLayout}


    \pagebreak \noindent
    \subsubsection{TableLayout.LayoutParams}


    \pagebreak \noindent
    \subsubsection{TableRow}


    \pagebreak \noindent
    \subsubsection{FrameLayout}


    \pagebreak \noindent
    \subsubsection{FrameLayout.LayoutParams}


    \pagebreak \noindent
    \subsubsection{ListView}


    \pagebreak \noindent
    \subsubsection{TextView}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{void	setInputType(int type)}: Set the type of the content with a constant as defined for EditorInfo.inputType.
                \item \textbf{int	getInputType()}: Get the type of the editable content.
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsubsection{EditText}
    \begin{itemize}
        \item \textbf{Methods}
    \end{itemize}

    \pagebreak 
    \subsubsection{InputType}
    \begin{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{TYPE\_CLASS\_TEXT}:	Plain text input.
                \item \textbf{TYPE\_CLASS\_NUMBER}:	Numeric input (digits 0-9).
                \item \textbf{TYPE\_CLASS\_PHONE}:	Phone number input.
                \item \textbf{TYPE\_CLASS\_DATETIME}:	Date/time input field.
                \item \textbf{TYPE\_TEXT\_VARIATION\_NORMAL}:	Default plain text.
                \item \textbf{TYPE\_TEXT\_VARIATION\_PASSWORD}:	Password (hidden input).
                \item \textbf{TYPE\_TEXT\_VARIATION\_VISIBLE\_PASSWORD}:	Password but visible.
                \item \textbf{TYPE\_TEXT\_VARIATION\_EMAIL\_ADDRESS}:	Email input.
                \item \textbf{TYPE\_TEXT\_VARIATION\_PERSON\_NAME}:	Person’s name.
                \item \textbf{TYPE\_TEXT\_VARIATION\_URI}:	URL/website.
                \item \textbf{TYPE\_TEXT\_VARIATION\_POSTAL\_ADDRESS}:	Mailing address.
                \item \textbf{TYPE\_TEXT\_VARIATION\_SHORT\_MESSAGE}:	SMS/chat message.
                \item \textbf{TYPE\_TEXT\_VARIATION\_LONG\_MESSAGE}:	Long message or email body.
                \item \textbf{TYPE\_TEXT\_VARIATION\_WEB\_EMAIL\_ADDRESS}:	Email in web form.
                \item \textbf{TYPE\_TEXT\_VARIATION\_WEB\_PASSWORD}:	Web password field.
                \item \textbf{TYPE\_TEXT\_FLAG\_CAP\_SENTENCES}:	Capitalize first letter of sentences.
                \item \textbf{TYPE\_TEXT\_FLAG\_CAP\_WORDS}:	Capitalize first letter of words.
                \item \textbf{TYPE\_TEXT\_FLAG\_CAP\_CHARACTERS}:	All caps.
                \item \textbf{TYPE\_TEXT\_FLAG\_MULTI\_LINE}:	Allows multiple lines.
                \item \textbf{TYPE\_TEXT\_FLAG\_NO\_SUGGESTIONS}:	Disable suggestions/autocorrect.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_COMPLETE}:	Enable auto-complete.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_CORRECT}:	Enable auto-correct.
                \item \textbf{TYPE\_NUMBER\_FLAG\_DECIMAL}:	Allows decimal point (e.g., 3.14).
                \item \textbf{TYPE\_NUMBER\_FLAG\_SIGNED}:	Allows + or – at start.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_NORMAL}:	Normal number input.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_PASSWORD}:	Number password (hidden).
                \item \textbf{TYPE\_DATETIME\_VARIATION\_NORMAL}:	Default date & time.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_DATE}:	Only date input.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_TIME}:	Only time input.
                \item \textbf{TYPE\_TEXT\_FLAG\_MULTI\_LINE}:	Allows multiple lines.
                \item \textbf{TYPE\_TEXT\_FLAG\_NO\_SUGGESTIONS}:	Disable suggestions/autocorrect.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_COMPLETE}:	Enable auto-complete.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_CORRECT}:	Enable auto-correct.
                \item \textbf{TYPE\_NUMBER\_FLAG\_DECIMAL}:	Allows decimal point (e.g., 3.14).
                \item \textbf{TYPE\_NUMBER\_FLAG\_SIGNED}:	Allows + or – at start.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_NORMAL}:	Normal number input.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_PASSWORD}:	Number password (hidden).
                \item \textbf{TYPE\_DATETIME\_VARIATION\_NORMAL}:	Default date & time.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_DATE}:	Only date input.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_TIME}:	Only time input.
                \item \textbf{TYPE\_NULL}:	No input type specified.
                \item \textbf{TYPE\_MASK\_CLASS}:	Mask to extract base class (text/number/etc.).
                \item \textbf{TYPE\_MASK\_FLAGS}:	Mask to extract all flags.
                \item \textbf{TYPE\_MASK\_VARIATION}:	Mask to extract variation (like email/password).
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsubsection{Button}


    \pagebreak \noindent
    \subsubsection{ImageView}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{setImageResource(int resource)}
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsubsection{ImageButton}
    \begin{itemize}
        
    \end{itemize}


    \pagebreak \noindent
    \subsubsection{CompoundButton}


    \pagebreak \noindent
    \subsubsection{CheckBox}


    \pagebreak \noindent
    \subsubsection{RadioGroup}


    \pagebreak \noindent
    \subsubsection{RadioGroup.LayoutParams}


    \pagebreak \noindent
    \subsubsection{RadioButton}


    \pagebreak \noindent
    \subsubsection{AbsSpinner}


    \pagebreak \noindent
    \subsubsection{Spinner}


    \pagebreak \noindent
    \subsubsection{Progessbar}


    \pagebreak \noindent
    \subsubsection{AbsSeekBar}


    \pagebreak \noindent
    \subsubsection{SeekBar}


    \pagebreak \noindent
    \subsubsection{Drawable}


    \pagebreak \noindent
    \subsubsection{GradientDrawable}


    \pagebreak \noindent
    \subsubsection{Intent}


    \pagebreak \noindent
    \subsubsection{Animation}


    \pagebreak \noindent
    \subsubsection{AnimationSet}


    \pagebreak \noindent
    \subsubsection{AlphaAnimation}


    \pagebreak \noindent
    \subsubsection{RotateAnimation}


    \pagebreak \noindent
    \subsubsection{ScaleAnimation}


    \pagebreak \noindent
    \subsubsection{TranslateAnimation}


    \pagebreak \noindent
    \subsubsection{PreferenceManager}


    \pagebreak \noindent
    \subsubsection{SharedPreferences (interface)}


    \pagebreak \noindent
    \subsubsection{SharedPreferences.Editor (Interface)}


    \pagebreak \noindent
    \subsubsection{Menu (Interface)}


    \pagebreak \noindent
    \subsubsection{MenuItem (Interface)}


    \pagebreak \noindent
    \subsubsection{ContextMenu (interface)}


    \pagebreak \noindent
    \subsubsection{PopupMenu}


    \pagebreak \noindent
    \subsubsection{SubMenu (interface)}


    \pagebreak \noindent
    \subsubsection{MenuInflator}


    \pagebreak \noindent
    \subsubsection{Toast}


    \pagebreak \noindent
    \subsubsection{LayoutInflator (Abstract class)}


    \pagebreak \noindent
    \subsubsection{SQLiteDatabase}


    \pagebreak \noindent
    \subsubsection{Cursor (Interface)}


    \pagebreak \noindent
    \subsubsection{ScrollView}


    \pagebreak \noindent
    \subsubsection{HorizontalScrollView}

    \pagebreak 
    \subsection{Activity overloads}
    \begin{itemize}
        
    \end{itemize}

    \pagebreak 
    \subsection{Event response}
    \begin{itemize}
        \item \textbf{View.OnClickListener} 
            \bigbreak \noindent 
            \begin{javacode}
                private class ButtonHandler implements View.OnClickListener {
                    public void onClick(View v) {
                        ...
                    }
                }

            \end{javacode}
        \item \textbf{RadioGroup.OnCheckedChangeListener}
            \bigbreak \noindent 
            \begin{javacode}
                private class RadioButtonHandler implements RadioGroup.OnCheckedChangeListener {
                    public void onCheckedChanged(RadioGroup group, int checkedId) {
                        ...
                    }
                }
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsection{Transitions}
    \begin{itemize}
        
    \end{itemize}











    
\end{document}
