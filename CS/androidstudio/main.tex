\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{The Basics}
    \begin{itemize}
        \item \textbf{Layout file for apps "look"}: Note that the XML layout file for our app's "look" is named activity\_main.xml
        \item \textbf{Creating a new project}: Click on the Empty Views Activity template to highlight it and click Next
            \begin{enumerate}
                \item Enter the name of the project
                \item Enter the package name as edu.niu.zid.projectname
                \item Set language to Java
                \item Choose API 22 ("Lollipop"; Android 5.1) for the minimum SDK
                \item Click finish
            \end{enumerate}
        \item \textbf{Directory structure}: please be sure that you have no additional layers than what you see here.
            \bigbreak \noindent 
            \fig{.5}{./figures/mi.png}
            \bigbreak \noindent 
            Notice at the highest level in the hierarchy of our project folders that there are two main "pieces" to the Android project:
            \begin{enumerate}
                \item app
                \item Gradle Scripts
            \end{enumerate}
            \bigbreak \noindent 
            Within the app, there are really three folders we are going to be concerned with for now:
            \begin{enumerate}
                \item manifests
                \item java
                \item res
            \end{enumerate}
        \item \textbf{Manifests}: The directory named manifests holds one xml file - so far. It is the AndroidManifest.xml file.
        \item \textbf{Java (directory):} The directory named java holds one Java source files - so far. It is the MainActivity.java file
        \item \textbf{Res (directory)}: The directory named res holds resource files, such as utility xml files for defining strings, themes, menus, layouts, dimensions, images, sounds, etc
        \item \textbf{MainActivity.java}: This is the logic/controller file. It's the Java class that defines what your app does when it runs. It extends AppCompatActivity (or another activity class), and inside it you set up event handling, lifecycle methods (like onCreate), and the code that reacts to user interactions. For example, if a button is clicked, the code for what happens lives here.
            \bigbreak \noindent 
            The simplest MainActivity.java file is as follows
            \bigbreak \noindent 
            \begin{javacode}
                package YOURPACKAGENAME

                import androidx.appcompat.app.AppCompatActivity;

                import android.os.Bundle;

                public class MainActivity extends AppCompatActivity {

                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        setContentView(R.layout.activity_main);
                    }
                }           
            \end{javacode}
            \bigbreak \noindent 
            In this code, the most important import statement is the import for class android.appcompat.app.AppCompatActivity
            \bigbreak \noindent 
            MainActivity.java class extends, or inherits from, superclass AppCompatActivity class found in Android API package androidx.appcompat.app.AppCompatActivity
            \bigbreak \noindent 
            AppCompatActivity itself is a subclass itself of Activity.
            \bigbreak \noindent 
            An Activity provides the screen with which users can interact, in other words, the User Interface, or UI.
            \bigbreak \noindent 
            The MainActivity class is meant to be used as the Controller for every app we develop
            \bigbreak \noindent 
            Method onCreate() of an Android app is called automatically upon launch just like the main() method is called automatically by the Java Virtual Machine, or JVM, upon launch of a Java applications.
            \bigbreak \noindent 
            Inside method onCreate(), we create the initial View for the app, controlled by this Activity.
            \bigbreak \noindent 
            In method onCreate(), the superclass' onCreate() method is first called.
            \bigbreak \noindent 
            Then the View, or opening screen, for this Activity is set by calling method setContentView().
            \bigbreak \noindent 
            Method setContentView() is inherited from the AppCompatActivity , or Activity class.
            \bigbreak \noindent 
            Its API is 
            \bigbreak \noindent 
            \begin{javacode}
            void setContentView(int layoutResID)
            \end{javacode}
            \bigbreak \noindent 
            layoutResID is a resource found in the subfolder named layout in the folder named res.
            \bigbreak \noindent 
            This ID defaults to: \textit{R.layout.activity\_main.}
            \bigbreak \noindent 
            In MainActivity.java, we refer to and access activity\_main.xml using the syntax
            \bigbreak \noindent 
            \begin{javacode}
            R.layout.activity_main
            \end{javacode}
            \bigbreak \noindent 
            activity\_main is a static constant of the static final class layout defined inside the R.java class or file.
            \bigbreak \noindent 
            The R.java file was automatically created when we began our project
            \bigbreak \noindent 
            R stands for resources and "represents" the res directory.
        \item \textbf{activity\_main.xml}: This is the UI/layout file. It defines the visual structure of your screen using XML: buttons, text fields, images, layouts, etc. You don't put behavior here—only the arrangement and styling of the interface elements.
            \bigbreak \noindent 
            activity\_main is an xml file, a resource located in the layout subdirectory of the res directory
            \bigbreak \noindent 
            It was also automatically created when we began our project using the template we chose.
            \bigbreak \noindent 
            We can think of XML as a markup language similar to HTML, but with user-defined tags
        \item \textbf{Intro to design editor}: With the activity\_main.xml file focused, click on this small button near the upper right
            \bigbreak \noindent 
            \fig{1}{./figures/im2.png}
            \bigbreak \noindent 
            Note that this opens the Design editor in which we can drag and drop widgets into our app. More on this to come!
        \item \textbf{Intro to XML syntax}:
            In XML, an non-empty element uses the general syntax shown here
            \bigbreak \noindent 
            \begin{xmlcode}
            <tagName attribute1="value1">Element Content</tagName> 
            \end{xmlcode}
            \bigbreak \noindent 
            For example:
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name="red">#FFFF0000</color>
            \end{xmlcode}
            which can be interpreted as there is an element color that has the name red and corresponds to the RGB value \#FFFF0000.
            \bigbreak \noindent 
            If an element has no content yet or will never have any content, we can use this syntax
            \bigbreak \noindent 
            \begin{xmlcode}
            <tagName attribute1="value1" attribute2="value2".../>
            \end{xmlcode}
        \item \textbf{XML Naming Rules}: XML elements must follow these naming rules:
            \begin{enumerate}
                \item Names can contain letters, numbers, and other characters.
                \item Names cannot start with a number or punctuation character.
                \item Names cannot start with the letters xml (or XML, or Xml, etc).
                \item Names cannot contain spaces.
            \end{enumerate}
        \item \textbf{XML Comments}: Documentation in XML is done with
            \bigbreak \noindent 
            \begin{xmlcode}
            <!-- comment text -->
            \end{xmlcode}
        \item \textbf{Simple activity\_main.xml Example, TextView and ConstraintLayout}: Let's consider a simple XML example
            \bigbreak \noindent 
            \begin{xmlcode}
                <?xml version="1.0" encoding="utf-8"?>
                <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    xmlns:app="http://schemas.android.com/apk/res-auto"
                    xmlns:tools="http://schemas.android.com/tools"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    tools:context=".MainActivity">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/app_name"
                        app:layout_constraintBottom_toBottomOf="parent"
                        app:layout_constraintEnd_toEndOf="parent"
                        app:layout_constraintStart_toStartOf="parent"
                        app:layout_constraintTop_toTopOf="parent" />

                </androidx.constraintlayout.widget.ConstraintLayout>
            \end{xmlcode}
            \bigbreak \noindent 
            There are two elements in our current activity\_main.xml:
            \begin{enumerate}
                \item ConstraintLayout
                \item TextView
            \end{enumerate}
            \bigbreak \noindent 
            The TextView element is nested inside the ConstraintLayout element
            \bigbreak \noindent 
            A ConstraintLayout allows us to position and size elements in a flexible way.
            \bigbreak \noindent 
            One way is relative positioning, or where an element is placed on the screen, or view, relative to another. 
            \bigbreak \noindent 
            The ConstraintLayout element has several attributes.
            \bigbreak \noindent 
            The android:layout\_width and android:layout\_height attributes define the size of the ConstraintLayout.
            \bigbreak \noindent 
            Their value match\_parent means that it will be as big as its parent element, which is the screen of the Android device in this case.
            \bigbreak \noindent 
            The TextView element is empty, or, in other words, has no content, and has, by default, seven attributes.
            \bigbreak \noindent 
            The first three are layout\_width, layout\_height and text.
            \bigbreak \noindent 
            The android:text attribute specifies the content, or the words, of the TextView to be shown on the screen of the Android device.
            \bigbreak \noindent 
            By default, the four attributes that follow layout\_width, layout\_height and text are for positioning of the TextView within the ConstraintLayout that will be discussed later
            \bigbreak \noindent 
            A TextView element is an instance of the TextView class, which puts a label on the screen.
            \bigbreak \noindent 
            The android:layout\_width and android:layout\_height attributes define the size of the TextView.
            \bigbreak \noindent 
            The value wrap\_content means that it will be as small as possible so that their contents (the text or words) fit inside it.
            \bigbreak \noindent 
            In other words, the element "wraps" around its content.
            \bigbreak \noindent 
            By default, the TextView appears in the middle of the screen
            \bigbreak \noindent 
            The four app:layout attributes specify the relative position of the TextView element's four sides
            \bigbreak \noindent 
            In this example, they are relative to the "parent", or the ConstraintLayout in which the Textview is nested
        \item \textbf{strings.xml}: is the resource file for text values in your app. Stores text like titles, labels, button names, or messages as key–value pairs.
            keep all text centralized for easy updates, consistency, and support for localization
            \bigbreak \noindent 
            You reference them in code (getString(R.string.welcome\_message)) or XML (@string/welcome\_message).
            \bigbreak \noindent 
            One string is defined in the strings.xml file by default
            \bigbreak \noindent 
            \begin{xmlcode}
                <resources>
                    <string name="app_name">Hello, Android!</string>
                <resources>
            \end{xmlcode}
            \bigbreak \noindent 
            The syntax for defining a string is
            \bigbreak \noindent 
            \begin{xmlcode}
                <string name="stringName">valueOfString</string>
            \end{xmlcode}
        \item \textbf{themes.xml}: defines the overall visual style of your Android app.
            \bigbreak \noindent 
            Central place to configure app-wide appearance, like colors, fonts, backgrounds, status bar style, and widget looks.
            \bigbreak \noindent 
            A theme is a collection of style attributes applied globally.
        \item \textbf{themes.xml example}:
            \bigbreak \noindent 
            \begin{xmlcode}
             <resources xmlns:tools="http://schemas.android.com/tools">
                 <!-- Base application theme. -->

                 <style name="Base.Theme.MyApplication" parent="Theme.Material3.DayNight.NoActionBar">
                     <!-- Customize your light theme here. -->
                     <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
                 </style>

                 <style name="Theme.MyApplication" parent="Base.Theme.MyApplication" />
            </resources>
            \end{xmlcode}
            \bigbreak \noindent 
            It is used to define styles that the app uses.
            \bigbreak \noindent 
            We can modify a theme by adding an item element using this syntax
            \bigbreak \noindent 
            \begin{xmlcode}
            <item name="styleAttribute">valueOfItem</item>
            \end{xmlcode}
            \bigbreak \noindent 
            The name of the theme attribute that specifies the text size inside a TextView is android:textSize.
            \bigbreak \noindent 
            Let us change the default text size to 40 by adding the following code to the themes.xml file just above the line </style>
            \bigbreak \noindent 
            \begin{xmlcode}
            <item name="android:textSize">40sp</item>
            \end{xmlcode}
        \item \textbf{Removing and adding action bar (themes.xml)}: Also, this line removes the commonly shown Action Bar:
            \bigbreak \noindent 
            \begin{xmlcode}
            <style name="Base.Theme.HelloAndroid" parent="Theme.Material3.DayNight.NoActionBar">
            \end{xmlcode}
            \bigbreak \noindent 
            \textbf{Note:} The Empty Views Activity template does not provide a default Action Bar
            \bigbreak \noindent 
            If we change the line to
            \bigbreak \noindent 
            \begin{xmlcode}
            <style name="Base.Theme.HelloAndroid" parent="Theme.AppCompat.Light.DarkActionBar">
            \end{xmlcode}
            \bigbreak \noindent 
            And make two other changes, we will see the Action Bar with the name of our app displayed
        \item \textbf{colors.xml}: The colors.xml file in the res > values directory is another automatically generated XML file.
            \bigbreak \noindent 
            It is used to define colors we want to use in our apps
            \bigbreak \noindent 
            The syntax for defining a color is
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name="colorName">valueOfColor</color>
            \end{xmlcode}
            \bigbreak \noindent 
            The color value is defined using hexadecimal, or base 16, notation
            \bigbreak \noindent 
            \#FFrrggbb (uses RGB color system) where:
            \begin{itemize}
                \item rr = amount of red in color
                \item gg = amount of green in color
                \item bb = amount of blue in color
            \end{itemize}
        \item \textbf{colors.xml example}: If we create the color in colors.xml
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name="colorPrimary"> #FF3F51B5 </color>
            \end{xmlcode}
            \bigbreak \noindent 
            Then, in themes.xml, we can add or uncomment the line
            \bigbreak \noindent 
            \begin{xmlcode}
            <item name="colorPrimary">@color/colorPrimary</item>
            \end{xmlcode}
            \bigbreak \noindent 
            inside of the action bar tag
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="Base.Theme.Test3" parent="Theme.AppCompat.Light.DarkActionBar">
                    <item name="colorPrimary">@color/colorPrimary</item>
                </style> 
            \end{xmlcode}
            \bigbreak \noindent 
            Now we have a blue action bar.
        \item \textbf{AndroidManifest.xml}: The AndroidManifest.xml file is located in the manifests directory.
            \bigbreak \noindent 
            It specifies the resources that the app uses, such as activities, the file system, the Internet, and hardware resources.
            \bigbreak \noindent 
            Before a user downloads an app on Google Play, the user is notified about these details
        \item \textbf{Changing the launcher icon}: When your app is installed on a device, its icon and name appear with all other installed apps in the launcher
            \bigbreak \noindent 
            Users can use the icon to launch our app on their device.
            \bigbreak \noindent 
            We should always supply a launcher icon for our app
            \bigbreak \noindent 
            A launcher icon for a mobile device should be 48 x 48 dp.
            \bigbreak \noindent 
            Because various devices can have different screen densities, we can supply several launcher icons, one for each density
            \bigbreak \noindent 
            If we provide these different versions of our icon, we need to follow the 2/3/4/6/8 scaling ratios between the various densities from medium (2) to xxx-high (8)
            \bigbreak \noindent 
            If we supply only one icon - as we will do here - Android Studio will use that icon and expand its density as necessary.
            \bigbreak \noindent 
            If we plan to publish our app, we should provide a 512 x 512 launcher icon for display in Google's app store.
            \bigbreak \noindent 
            Right mouse click on mipmap in the project structure along the right side and choose New and then Image Asset.
            \bigbreak \noindent 
            To set the launch icon for the app to hi.png, we assign the
            String @mipmap/hi to the android:icon attribute and the
            String @mipmap/hi\_round to the android:roundIcon
            attribute of the application element in the
            AndroidManifest.xml file.
            \bigbreak \noindent 
            The @mipmap/hi expression defines the resource in the mipmap
            directory (of the res directory) whose name is hi (note that we do
            not include the extension) and the same for hi\_round
            \bigbreak \noindent 
            \begin{xmlcode}
            android:icon="@mipmap/hi" android:roundIcon="@mipmap/hi_round"
            \end{xmlcode}
        \item \textbf{Orientation}: Sometimes, we want the app to run in only one orientation
            \bigbreak \noindent 
            In other words, we do not want the app to rotate when the user rotates his or her device.
            \bigbreak \noindent 
            Inside the activity element (in the manifest), we can add the
            android:screenOrientation attribute and specify either
            portrait or landscape as its value
            \bigbreak \noindent 
            For example, if we want our app to run in vertical orientation only, we add
            \bigbreak \noindent 
            \begin{xmlcode}
            android:screenOrientation="portrait"
            \end{xmlcode}
            \bigbreak \noindent 
            Note that we can control the behavior of the app on a per activity basis
        \item \textbf{Gradle build system}: Android Application Package, or APK, is the file format for distributing applications that run on the Android operating system. 
            \bigbreak \noindent 
            The file extension is .apk
            \bigbreak \noindent 
            To create an apk file, the project is compiled and its various parts are packaged into the apk file.
            \bigbreak \noindent 
            The apk file can be found in the project directory:
            \begin{center}
                \textit{projectName/app/build/outputs/apk}
            \end{center}
            \bigbreak \noindent 
            These .apk files are built using the gradle build system, which is integrated in the Android Studio environment.
            \bigbreak \noindent 
            When we start creating an app, the gradle build scripts are automatically created
            \bigbreak \noindent 
            They can be modified to build apps that require custom building
        \item \textbf{Debugging}: Just like in a regular Java program, we can send output to the console in addition to displaying data on the screen.
            \bigbreak \noindent 
             For this, we can use one of the static methods of the Log class.
             \bigbreak \noindent 
             The Log class is part of the android.util package
             \bigbreak \noindent 
             Selected methods of the Log class include d, e, i, v, w.
             \bigbreak \noindent 
             They all have the same parameter list and return type; for example, the API of d is
             \bigbreak \noindent 
             \begin{javacode}
             public static void d(String tag, String message)
             \end{javacode}
             \begin{itemize}
                 \item \textbf{Log.d(String tag, String msg):} Debug: Used for debugging messages. These are usually filtered out in release builds.
                 \item \textbf{Log.e(String tag, String msg):} Error: Used to report error conditions. This is the highest-severity logging method.
                 \item \textbf{Log.i(String tag, String msg):} Info: Used for general information messages that highlight the progress of the application.
                 \item \textbf{Log.v(String tag, String msg):} Verbose: Used for the most detailed log messages, often too much for normal use, but helpful during deep debugging.
                 \item \textbf{Log.w(String tag, String msg):} Warning: Used to report potential issues or unexpected states that aren't necessarily errors.
             \end{itemize}
             \bigbreak \noindent 
             \textit{tag} identifies the source of the message and can be associated with a "filter" (described in a few slides).
             \bigbreak \noindent 
             \textit{message} is the String to be output.
             \bigbreak \noindent 
             To run the app in debug mode, we click on the debug icon on the toolbar.
             \bigbreak \noindent 
             The app runs and stops at the first breakpoint.
             \bigbreak \noindent 
             The Debug tab will open in the panel at the bottom of the screen.
             \bigbreak \noindent 
             Here we will see some debugging information and tools.
             \bigbreak \noindent 
             Under Frames, we can see where in the code we are currently executing.
             \bigbreak \noindent 
             To resume the app, we click on the green Resume icon at the top left of the panel.
             \bigbreak \noindent 
             As we resume, stop at breakpoints, and resume the app a few times, the values of the various variables in our app are displayed under Variables.
             \bigbreak \noindent 
             Under Variables, we can check the values of the various variables
             \bigbreak \noindent 
             If the app is running on a device, we can still log output statements in Logcat
             \bigbreak \noindent 
             This is much faster than starting the emulator.
         \item \textbf{Logcat}: Output from logging statements show up in the Logcat
             \bigbreak \noindent 
             To open the Logcat, click on the Logcat tab at the bottom of the IDE.
             \bigbreak \noindent 
             We can filter the output listed in the Logcat by clicking in the dropdown in the upper right of the Logcat
             \bigbreak \noindent 
             Suppose we create a new filter named \textit{f\_mainactivity}, with a tag MainActivity.
             \bigbreak \noindent 
             Now that a filter has been created along with its tag, we can output messages to Logcat.
             \bigbreak \noindent 
             Add the following line to the onCreate method of MainActivity.java but after the call to super.onCreate
             \bigbreak \noindent 
             \begin{javacode}
                 Log.w("MainActivity", "Inside onCreate!");
             \end{javacode}
             \bigbreak \noindent 
             The output we will see in Logcat is: Inside onCreate!
             \bigbreak \noindent 
             Or another way to do it
             \bigbreak \noindent 
             \begin{javacode}
                 ...
                 public static String MA = "MainActivity";
                 ...
                 setContentView(R.layout.activity_main);
                 Log.w(MA, "View resource: " +
                 R.layout.activity_main);
                 ... 
             \end{javacode}
    \end{itemize}

    \pagebreak 
    \unsect{Reference}
    \bigbreak \noindent 
    \subsection{Includes}
    \begin{itemize}
        \item androidx.appcompat.app.AppCompatActivity;
        \item android.os.Bundle;
        \item android.util.Log;
        \item android.view.View;
        \item android.view.Gravity;
        \item android.graphics.Color;
        \item android.widget.EditText;
        \item android.widget.TextView;
        \item java.text.NumberFormat;
        \item android.text.TextWatcher: 
        \item android.text.Editable
        \item java.lang.CharSequence
        \item android.graphics.Point;
        \item android.widget.Button;
        \item android.widget.GridLayout;
        \item androidx.constraintlayout.widget.ConstraintLayout;
        \item androidx.constraintlayout.widget.ConstraintSet;
        \item androidx.constraintlayout.widget.Guideline
        \item import androidx.constraintlayout.widget.Barrier;
        \item android.view.ViewGroup;
        \item android.content.Context;
        \item android.content.DialogInterface;
        \item androidx.appcompat.app.AlertDialog;
        \item android.graphics.Typeface;
        \item android.view.Display;
        \item android.widget.RelativeLayout
    \end{itemize}

    \pagebreak 
    \subsection{Important information}
    \begin{itemize}
        \item \textbf{AVD (Android virtual device)}: It's basically an emulated device configuration that runs inside the Android Emulator. An AVD defines things like:
            \begin{itemize}
                \item \textbf{Device model}: (screen size, resolution, density, RAM, etc.)
                \item \textbf{System image}: (Android version, API level, Google Play support, etc.)
                \item \textbf{Hardware features}: (camera, GPS, sensors, etc.)
            \end{itemize}
            So when you launch an emulator in Android Studio, you're really starting up an AVD that behaves like a specific Android phone or tablet.
        \item \textbf{Screen Density}: screen density means how many pixels are packed into a physical area of the screen, usually measured as dots per inch (dpi).
            \bigbreak \noindent 
            A screen with high density has many pixels in a small space, making things look sharper but also smaller if not scaled.
            \bigbreak \noindent 
            A screen with low density has fewer pixels in the same area, so things look larger but less sharp.
            \bigbreak \noindent 
            Android groups devices into "density buckets" so developers don't have to manually calculate for every possible screen:
            \bigbreak \noindent 
            \begin{itemize}
                \item \textbf{ldpi (low)}: $\sim$120 dpi
                \item \textbf{mdpi (medium)}: $\sim$160 dpi (baseline)
                \item \textbf{hdpi (high)}: $\sim$240 dpi
                \item \textbf{xhdpi (extra-high)}: $\sim$320 dpi
                \item \textbf{xxhdpi (extra extra high)}: $\sim$480 dpi
                \item \textbf{xxxhdpi (extra extra extra high)}: $\sim$640 dpi
            \end{itemize}
            \bigbreak \noindent 
            Android uses this formula under the hood:
            \begin{align*}
                px = \; dp \times \frac{dpi}{160}
            \end{align*}
            Where
            \begin{itemize}
                \item dp = your value in density-independent pixels (e.g., 20)
                \item dpi = the device's actual screen density in dots-per-inch
                \item 160 = the baseline density (mdpi)
            \end{itemize}
            \bigbreak \noindent 
            Even though the number of pixels changes, the physical size (in inches or mm) stays about the same. That's because on a denser screen, pixels are smaller, so Android uses more of them to maintain the same real-world size.
            \bigbreak \noindent 
            So your 20dp button will look like the same size button whether it's on a cheap low-res phone or a modern super high-res one.
        \item \textbf{Layout Params}: Generally, a layout class like ConstraintLayout or RelativeLayout contains a static inner class that contains XML attributes that allow us to arrange the components within the layout. This static inner class is often named \textbf{LayoutParams}
            \bigbreak \noindent 
            Every child view inside a ViewGroup needs layout parameters (LayoutParams).
            \bigbreak \noindent 
            These tell the parent how big the child should be and how it should be positioned.
            \bigbreak \noindent 
            Different ViewGroups define their own rules:
            \begin{itemize}
                
                \item \textbf{LinearLayout.LayoutParams}: weight, gravity
                \item \textbf{FrameLayout.LayoutParams}: gravity
                \item \textbf{ConstraintLayout.LayoutParams}: constraints like topToBottom, leftToLeft, etc.
            \end{itemize}
        \item \textbf{Positioning components inside ConstraintLayout}: We will use the attributes of ConstraintLayout.LayoutParams to position the XML elements on the screen
        \item \textbf{Ids}: The android:id attribute allows us to give an id to an XML element
            \bigbreak \noindent 
            The syntax for assigning an id to an XML element is
            \bigbreak \noindent 
            \begin{xmlcode}
            android:id = "@+id/idValue"
            \end{xmlcode}
        \item \textbf{Default colors (defined in @android:color)}:
            \begin{itemize}
                \item \textbf{@android:color/black}: \#FF000000
                \item \textbf{@android:color/darker\_gray}: \#FF444444
                \item \textbf{@android:color/dim\_gray}: \#FF696969
                \item \textbf{@android:color/gray}: \#FF888888
                \item \textbf{@android:color/light\_gray}: \#FFCCCCCC
                \item \textbf{@android:color/white}: \#FFFFFFFF
                \item \textbf{@android:color/red}: \#FFFF0000
                \item \textbf{@android:color/green}: \#FF00FF00
                \item \textbf{@android:color/blue}: \#FF0000FF
                \item \textbf{@android:color/yellow}: \#FFFFFF00
                \item \textbf{@android:color/cyan}: \#FF00FFFF
                \item \textbf{@android:color/magenta}: \#FFFF00FF
                \item \textbf{@android:color/transparent}: \#00000000 (fully transparent)
            \end{itemize}
            \bigbreak \noindent 
            We can get access to these default colors in java using
            \bigbreak \noindent 
            \begin{javacode}
                int color = context.getResources().getColor(android.R.color.colorname)
            \end{javacode}
        \item \textbf{ConstraintLayout Enable Autoconnection to Parent}: When you enable it, every new view you drag into the ConstraintLayout will automatically get constraints to its closest edges of the parent (top, bottom, start, end).
        \item \textbf{Styles vs Themes}: A style relates to a UI component or a View. A theme relates to an activity; it can even relate to the whole app.
            \bigbreak \noindent 
            We can also "theme" an app with a style by editing the AndroidManifest.xml file, changing the android:theme attribute of its application element using this syntax:
            \bigbreak \noindent 
            \begin{xmlcode}
                android:theme="@style/nameOfStyle"
            \end{xmlcode}
        \item \textbf{findViewById}: findViewById is a fundamental method in Android development used to obtain a reference to a View object defined in your XML layout files. This method allows you to interact with UI elements programmatically, such as setting text, handling clicks, or changing visibility.
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent
            \begin{javacode}
            EditText billEditText = (EditText)findViewById(R.id.amount_bill);
            \end{javacode}
            \bigbreak \noindent 
            findViewById returns the View that is part of the layout xml file that was inflated in method onCreate() of the Activity class.
            \bigbreak \noindent 
            If we expect to retrieve a TextView and we want to assign the View retrieved to a TextView, we need to cast the View returned by method findViewById() to a TextView:
        \item \textbf{View Event handling with XML (only onClick)}: To set up a click event on a View, we use the android:onClick attribute of the View and assign to it a method using the form:
            \bigbreak \noindent 
            \begin{xmlcode}
            android:onClick="methodName"
            \end{xmlcode}
            \bigbreak \noindent 
            The event will be handled inside that method, which must have the following API
            \bigbreak \noindent 
            \begin{javacode}
            public void methodName(View v) 
            \end{javacode}
            \bigbreak \noindent 
            $v$ is the View where the event happened.
            \bigbreak \noindent 
            When the user clicks on the button, we execute inside calculate, and its View parameter is the Button; if we have the following statement inside calculate
            \bigbreak \noindent 
            \begin{javacode}
            Log.w("MainActivity", "v = " + v);
            \end{javacode}
            \bigbreak \noindent 
            Inside LogCat, we have something like:
            \bigbreak \noindent 
            \begin{javacode}
            v=android.widget.Button@425a2e60
            \end{javacode}
            \bigbreak \noindent 
            The value above identifies the Button
        \item \textbf{IME}: It’s the software keyboard or other input system (like voice typing, handwriting, predictive text) that allows users to enter text into your app.
            \bigbreak \noindent 
            Every EditText communicates with the IME through the Input Method Framework (IMF) in Android.
            \bigbreak \noindent 
            When you tap into an EditText, the IME pops up (usually the on-screen keyboard).
        \item \textbf{Get size of screen}: 
            \bigbreak \noindent 
            \begin{javacode}
                import android.graphics.Point;

                Point size = new Point();
                getWindowManager().getDefaultDisplay().getSize(size);
            \end{javacode}
        \item \textbf{Create grid layout in java (controller)}:
            \bigbreak \noindent 
            \begin{javacode}
                GridLayout gridLayout = new GridLayout(this);
                gridLayout.setRowCount(int m);
                gridLayout.setColumnCount(int n);
            \end{javacode}
        \item \textbf{Adding views to GridLayout}:
            \bigbreak \noindent 
            \begin{javacode}
                gridLayout.addView(view, w, h);

            \end{javacode}
        \item \textbf{setContentView}: the method setContentView(...) is used inside an Activity to specify which layout file (XML) should be used as the UI for that screen.
            \bigbreak \noindent 
            Calling \texttt{setContentView(R.layout.some\_layout)} tells the activity:
            \begin{center}
                "Use the layout resource some\_layout.xml from the \textit{res/layout} folder as the UI for this screen."
            \end{center}
            \bigbreak \noindent 
            If you’re using programmatic UI (creating Views in Java instead of XML), you can pass a View object directly,
        \item \textbf{ViewGroup}:
            In Android, everything you see on screen is either a View or a ViewGroup.
            \bigbreak \noindent 
            A View is a basic UI element — e.g. Button, TextView, EditText, ImageView.
            \bigbreak \noindent 
            A ViewGroup is a container that holds other Views (and even other ViewGroups). 
            \bigbreak \noindent 
            So, a ViewGroup is essentially a layout manager. It defines how child views are positioned, sized, and arranged inside it.
            \begin{itemize}
                \item \textbf{LinearLayout}: places children in a row or column.
                \item \textbf{RelativeLayout (older, mostly replaced by ConstraintLayout)}: places children relative to each other.
                \item \textbf{ConstraintLayout}: a flexible, modern layout system.
                \item \textbf{FrameLayout}: stacks children on top of each other.
                \item \textbf{RecyclerView}: a powerful scrolling container for lists/grids.
            \end{itemize}
            \textbf{Note:} A ViewGroup is a subclass of View.
        \item \textbf{Giving id to view in java}: We can use
            \bigbreak \noindent 
            \begin{javacode}
            View.generateViewId()
            \end{javacode}
            as an argument to \texttt{view.setId()}. The method \texttt{generateViewId()} is a static method in the View class. It creates a unique integer ID at runtime that’s guaranteed not to collide with other view IDs.
        \item \textbf{The finish() method}: finish() is a method of the Activity class. It tells Android:
            \begin{quote}
             "I’m done with this Activity, please close it and remove it from the back stack."
            \end{quote}
            So if you call finish() inside an Activity, that activity will end and control will go back to the previous one (or exit the app if it was the only activity).
        \item \textbf{Converting px to dp in java}: In Android, px (pixels) and dp (density-independent pixels) are not the same thing. You almost always want to work in dp because it scales properly across different screen densities.
            \bigbreak \noindent 
            \begin{javacode}
                float dp = px / context.getResources().getDisplayMetrics().density; // px to dp

                float px = dp * context.getResources().getDisplayMetrics().density; // dp to px
            \end{javacode}
            \bigbreak \noindent 
            when a Java function in Android Studio takes an int representing a dimension (like width, height, margin, radius, stroke width, etc.), it is almost always in raw pixels (px) — not dp.
            \bigbreak \noindent 
            \texttt{context.getResources().getDisplayMetrics().density} gets the screens density factor (dpi / 160)
        \item \textbf{xmlns:android="http://schemas.android.com/apk/res/android"}: One of the most important pieces of XML in Android layouts.
            \bigbreak \noindent 
            It tells the XML parser: "Whenever you see an attribute that starts with android:, it belongs to the Android system’s XML namespace, located at this URI."
            \bigbreak \noindent 
            You must include this in:
            \begin{itemize}
                \item Any layout XML (e.g. activity\_main.xml)
                \item Any drawable XML, menu XML, or style XML that uses android: attributes
            \end{itemize}
            Basically, any file where you use attributes like android:layout\_width, android:padding, android:text, etc.
            \bigbreak \noindent 
            you only need to declare that line once, and it always goes on the root element of your XML layout (like <ConstraintLayout>, <RelativeLayout>, <LinearLayout>, etc.).
        \item \textbf{The dp function (java)}: In Android, UI dimensions shouldn’t be defined in plain pixels because screens have different pixel densities (dpi). Instead, we must use dp (density-independent pixels), which scale consistently on all screens.
            \bigbreak \noindent 
            XML converts dp to px for us, but in java we must do it ourselves. So, we write the following function
            \bigbreak \noindent 
            \begin{javacode}
                private int dp(int value) {
                    float density = getResources().getDisplayMetrics().density;
                    return (int) (value * density);
                } 
            \end{javacode}
            \bigbreak \noindent 
            We pass in a \textbf{dp} values, and it gets converted to px.
        \item \textbf{Animation directory}: In order to create and use animations in our apps, we need to create a \textbf{Android Resource Directory} in the \textbf{res} directory with resource type \textbf{anim}. Then, we can define animations in XML (one animation per XML file).
        \item \textbf{Action bar}
            \bigbreak \noindent 
            \begin{javacode}
                <resources>
                  <!-- Base application theme. -->
                  <style name="Theme.MusicStore" parent="Theme.AppCompat.Light.DarkActionBar">
                    <!-- Customize your theme here. -->
                    <item name="android:textSize">15sp</item>
                    <item name="colorPrimary">@color/colorPrimary</item>
                  </style>
                  
                </resources> 
            \end{javacode}
        \item \textbf{No action bar}
            \bigbreak \noindent 
            \begin{javacode}
                <resources xmlns:tools="http://schemas.android.com/tools">
                    <!-- Base application theme. -->
                    <style name="Base.Theme.MusicStore" parent="Theme.Material3.DayNight.NoActionBar">
                        <!-- Customize your light theme here. -->
                        <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
                    </style>

                    <style name="Theme.MusicStore" parent="Base.Theme.MusicStore" />
                </resources>
            \end{javacode}
        \item \textbf{Menus}: Menus in Android Studio (and Android apps generally) are UI components that let users interact with common actions — similar to menus in desktop apps, but adapted for mobile.
            \bigbreak \noindent 
            A menu is a set of action items your app displays in:
            \begin{itemize}
                \item The top App Bar (toolbar)
                \item A vertical overflow menu (three-dot icon)
                \item A contextual action bar
                \item Popup menus inside a view
            \end{itemize}
            Menus are defined in \texttt{res/menu}
        \item \textbf{Builtin icons}: These are the most frequently used system drawables (they all live under android.R.drawable):
            \begin{itemize}
                \item \textbf{@android:drawable/ic\_menu\_preferences}:	Settings or preferences 
                \item \textbf{@android:drawable/ic\_menu\_edit}:	Edit / modify item 
                \item \textbf{@android:drawable/ic\_menu\_attach}:	Attach file 
                \item \textbf{@android:drawable/ic\_menu\_send}:	Send / share 
                \item \textbf{@android:drawable/ic\_menu\_delete}:	Delete item 
                \item \textbf{@android:drawable/ic\_menu\_add}:	    Add item 
                \item \textbf{@android:drawable/ic\_menu\_edit}:	Edit item 
                \item \textbf{@android:drawable/ic\_input\_add}:	Add new item 
                \item \textbf{@android:drawable/ic\_delete}:	Remove / clear 
                \item \textbf{@android:drawable/ic\_menu\_search}:	Search action 
                \item \textbf{@android:drawable/ic\_menu\_save}:	Save action 
                \item \textbf{@android:drawable/ic\_menu\_agenda}:	Calendar / agenda 
                \item \textbf{@android:drawable/ic\_menu\_compass}:	Navigation / location 
                \item \textbf{@android:drawable/ic\_menu\_share}:	Share data 
                \item \textbf{@android:drawable/ic\_menu\_info\_details}:	Info dialog 
                \item \textbf{@android:drawable/ic\_menu\_close\_clear\_cancel}:	Cancel / close 
                \item \textbf{@android:drawable/ic\_menu\_myplaces}:	Home / location 
                \item \textbf{@android:drawable/ic\_menu\_camera}:	Camera 
                \item \textbf{@android:drawable/ic\_menu\_gallery}:	Gallery or media 
                \item \textbf{@android:drawable/ic\_menu\_call}:	Call / contact 
                \item \textbf{@android:drawable/ic\_menu\_manage}:	Manage list 
                \item \textbf{@android:drawable/ic\_dialog\_alert}:	Alert or warning dialog 
                \item \textbf{@android:drawable/ic\_dialog\_info}:	Info dialog icon
            \end{itemize}
        \item \textbf{Dynamic resource names}: If your drawable image files are named like:
            \bigbreak \noindent 
            \begin{bashcode}
                res/drawable/u1.png  
                res/drawable/u2.png  
                res/drawable/u3.png  
                ...
                res/drawable/u9.png
            \end{bashcode}
            \bigbreak \noindent 
            Then you can load them like this:
            \bigbreak \noindent 
            \begin{javacode}
                String imageName = "u" + i; // creates u1, u2, ..., u9
                int resID = getResources().getIdentifier(imageName, "drawable", getPackageName());
            \end{javacode}
        \item \textbf{Built-in layout resource}: Android provides a set of common, basic layouts so you don't need to create XML files for simple lists.
            \begin{itemize}
                \item \textbf{android.R.simple\_list\_item\_1}: It is basically a single TextView, with predefined padding and styling. The XML looks something like
                    \bigbreak \noindent 
                    \begin{xmlcode}
                        <TextView xmlns:android="http://schemas.android.com/apk/res/android"
                            android:id="@android:id/text1"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:minHeight="?android:attr/listPreferredItemHeightSmall"
                            android:gravity="center_vertical"
                            android:paddingLeft="16dp"
                            android:paddingRight="16dp"
                            android:textAppearance="?android:attr/textAppearanceListItemSmall" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    Perfect for simple \texttt{ArrayAdapter<String>} lists.
                \item \textbf{android.R.layout.simple\_spinner\_item}: Used for the selected item in a Spinner. Also just one TextView
                    \bigbreak \noindent 
                    \begin{xmlcode}
                        <TextView
                            android:id="@android:id/text1"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:gravity="center_vertical"
                            android:padding="8dp" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    Suitable for
                    \bigbreak \noindent 
                    \begin{javacode}
                        new ArrayAdapter(this, android.R.layout.simple_spinner_item, data);
                    \end{javacode}
                \item \textbf{android.R.layout.simple\_dropdown\_item\_1line}: Used for dropdown lists:
                    \begin{itemize}
                        \item AutoCompleteTextView
                        \item Spinner dropdowns
                    \end{itemize}
                    Again, a single TextView:
                    \bigbreak \noindent 
                    \begin{xmlcode}
                        <TextView
                            android:id="@android:id/text1"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:singleLine="true"
                            android:padding="8dp" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    Used like this 
                    \bigbreak \noindent 
                    \begin{javacode}
                        adapter.setDropDownViewResource(android.R.layout.simple_dropdown_item_1line);
                    \end{javacode}

            \end{itemize}
        \item \textbf{Other Common Built-In Layouts}:
            \begin{itemize}
                \item \textbf{simple\_list\_item\_1}:	One TextView
                \item \textbf{simple\_list\_item\_2}:	Two stacked TextViews (text1 and text2)
                \item \textbf{simple\_list\_item\_checked}:	List item with checkmark
                \item \textbf{simple\_list\_item\_activated\_1}:	For activated/selected states
                \item \textbf{simple\_spinner\_item}:	Selected Spinner item
                \item \textbf{simple\_spinner\_dropdown\_item}:	Dropdown row view
                \item \textbf{simple\_dropdown\_item\_1line}: Single-line dropdown suggestion
            \end{itemize}



    \end{itemize}

    \pagebreak 
    \subsection{Screen size, resolution, density, pixels, and dips (dp)}
    \begin{itemize}
        \item \textbf{Screen size}: Screen size is measured diagonally from one corner of the display to the opposite corner. You measure from the bottom-left corner to the top-right corner (or bottom-right to top-left), the measurement is in inches.
        \item \textbf{Screen resolution}: Refers to the total number of pixels on the screen (width $\times$ height). Describes how many pixels the screen contains, not how big they are physically.
        \item \textbf{Screen density}: Refers to how tightly the pixels are packed into each inch of the screen, measured in dots per inch (dpi) or pixels per inch (ppi). Higher density = smaller pixels = sharper image. If a screen has a density of 300 dpi, then there are 300 pixels in one inch.
            \bigbreak \noindent 
            The density of a screen depends on the size of the screen and the screens resolution.
            \begin{align*}
                \text{dpi } \approx \text{ppi } &= \frac{\sqrt{\text{width}^{2} + \text{hight}^{2}}}{\text{screen size}}
            .\end{align*}
            So, if we increase our screen resolution (keep the screen size constant), the screen density increases. If we increase our screen size (keep the resolution constant), our screen density decreases.
            \bigbreak \noindent 
            \textbf{Note:} Screen density is measured in "dots per inch" (dpi) or pixels per inch (ppi). In most modern screens, a "dot" = a pixel, so dpi $\approx$ ppi.
        \item \textbf{Pixels}: The smallest dot of light on a screen, screens are made up of thousands or millions of pixels, more pixels equals more detail.
            \bigbreak \noindent 
            You can calculate the size of a pixel with
            \begin{align*}
                \text{px size (in) } &= \frac{1}{\text{ppi}}
            .\end{align*}
        \item \textbf{Density independent pixels (dp or dip)}: A virtual unit used in Android to keep UI elements the same physical size across devices. 1 dp = 1 pixel on a 160 dpi screen (the baseline screen density).
            \begin{align*}
                \text{px } &= \text{dp}\left(\frac{\text{dpi}}{160}\right)
            .\end{align*}
            Let $\rho = \text{ density factor } = \frac{\text{dpi}}{160}$, then
            \begin{align*}
                \text{px } &= \text{dp} \cdot \rho \\
                \text{dp } &= \text{px} / \rho
            .\end{align*}
            160 dpi (dots per inch) is considered the "baseline" or "medium density" screen in Android. This density is called mdpi. 
            Historically, early Android phone screens (like the first HTC/Google phones) had around 160 dpi.
            \bigbreak \noindent 
            Suppose you develop an app while working on a $360\; \text{dpi}$ device, then the density factor is $\rho = \frac{360}{160} = 2$. Thus, for one pixel,
            \begin{align*}
                \text{dp } &= \text{ px} / \rho = 1 / 2
            .\end{align*}
            So, $1 \text{ dp } = 2 \text{ px }$. Now, suppose our device is now 720 dpi. Then, $ \rho = 4$ and for one pixel,
            \begin{align*}
                \text{dp } &=  1 / 4
            .\end{align*}
            So, $1 \text{ dp } = 4 \text{ px } $. Thus, as our density increases, the number of pixels per dp increases. As our density decreases, the number of pixels per dp decreases.
        \item \textbf{Getting screen resolution}:
            \bigbreak \noindent 
            \begin{javacode}
                Point p;
                getWindowManager().getDefaultDisplay.getSize(size)
                int width = p.x; int height = p.y;
            \end{javacode}
        \item \textbf{Getting screen density in java}:
            \bigbreak \noindent 
            \begin{javacode}
            float rho = getResources().getDisplayMetrics.density; // dpi/160
            \end{javacode}
        \item \textbf{Testing for screen sizes in java}: We can get screen size information through a Configuration object
            \bigbreak \noindent 
            \begin{javacode}
            Configuration config = getResources().getConfiguration();
            \end{javacode}
        \item \textbf{Get height of the action bar}
            \bigbreak \noindent 
            \begin{javacode}
                import android.util.TypedValue;
                ...

                TypedValue typedValue = new TypedValue();
                if (getTheme().resolveAttribute(android.R.attr.actionBarSize, typedValue, true)) {
                    int actionBarHeight = TypedValue.complexToDimensionPixelSize(
                    typedValue.data, getResources().getDisplayMetrics());
                }
            \end{javacode}
        \item \textbf{Move root layout under the actionbar}: For example, if a GridLayout is the root layout
            \bigbreak \noindent 
            \begin{javacode}
            ViewGroup.MarginLayoutParams mlp = new ViewGroup.MarginLayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            );
            mlp.setMargins(0,actionBarHeight*2,0,0);
            \end{javacode}


            
    \end{itemize}

    \pagebreak 
    \subsection{Units}
    \begin{itemize}
        \item \textbf{dp}: stands for density-independent pixels, or "dips" for short.
            \bigbreak \noindent 
            The most common unit for layout dimensions (width, height, margins, padding). Scales with screen density so UI looks consistent across devices.
        \item \textbf{sp}: stands for scalable pixels. Maybe we can call them "sips"?
            \bigbreak \noindent 
            Primarily for text size. Like dp, but also respects the user's font size settings (accessibility).
        \item \textbf{px (pixels)}: Actual screen pixels. Avoid using directly because it doesn't scale across different densities.
        \item \textbf{pt (points):} 1/72 of an inch. Rarely used, but supported.
        \item \textbf{in (inches)}: Physical size in inches (based on the screen's dpi).
        \item \textbf{mm (millimeter)}: Physical size in millimeters.
    \end{itemize}

    \pagebreak 
    \subsection{Files}
    \begin{itemize}
        \item \textbf{AndroidManifest.xml}: The app's blueprint. Declares package name, permissions, minimum SDK, app components (activities, services, etc.), and the launcher activity.
        \item \textbf{MainActivity.java}: The main Java class that runs when the app starts. Controls app logic and connects the UI (XML layouts) with backend code.
        \item \textbf{activity\_main.xml}: The layout file for MainActivity. Defines the UI elements (buttons, text, etc.) using XML.
        \item \textbf{colors.xml}: Central place for defining reusable color values. Used for themes, buttons, backgrounds, etc
        \item \textbf{strings.xml}: Stores all text strings (app name, labels, messages). Helps with reusability and localization (multi-language support).
        \item \textbf{dimens.xml}:  Defines dimensions like margins, padding, font sizes (e.g., 16dp). Ensures consistent spacing and scaling.
        \item \textbf{themes.xml}: Holds styles and themes (colors, fonts, appearances) applied app-wide or to individual components.
    \end{itemize}

    \pagebreak 
    \subsection{The Manifest (AndroidManifest.xml)}
    \begin{itemize}
        \item \textbf{<application>}: The <application> tag represents the entire Android app. It contains global settings for the app and includes all major components like activities, services, receivers, and providers.
            \bigbreak \noindent 
            Specifies app-level settings like:
            \begin{itemize}
                \item App icon (android:icon)
                \item App name (android:label)
                \item Default theme (android:theme)
                \item Backup rules, RTL support, permissions, etc.
            \end{itemize}
            Acts as a container for all components (<activity>, <service>, etc.)
        \item \textbf{<activity>}: An <activity> represents a single screen / page in your application — like an activity in Java corresponds to a UI screen. Each <activity> must be declared inside <application> so Android knows it exists.
        \item \textbf{android:configChanges}: In Android, the configChanges attribute in the AndroidManifest.xml is used to tell the system which configuration changes (like screen rotation, language change, keyboard type, etc.) your Activity will handle manually, instead of letting Android destroy and recreate it automatically.
            \bigbreak \noindent 
            When certain configuration changes happen (like rotating the screen), Android by default:
            \begin{itemize}
                \item Destroys the current Activity.
                \item Recreates it with the new configuration (restarts onCreate(), etc.).
                \item This allows the layout to be reloaded for the new screen size or orientation.
            \end{itemize}
            By adding configChanges to your Activity in the manifest:
            \bigbreak \noindent 
            \begin{javacode}
                <activity
                    android:name=".MainActivity"
                    android:configChanges="orientation|screenSize">
                </activity>
            \end{javacode}
            \bigbreak \noindent 
            You are telling Android "Don’t recreate the Activity when orientation or screen size changes - I will handle it myself."
            \bigbreak \noindent 
            So instead of restarting the Activity, it will call:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public void onConfigurationChanged(Configuration newConfig) {
                    super.onConfigurationChanged(newConfig);

                    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
                        // Handle landscape changes
                    } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) {
                        // Handle portrait changes
                    }
                }
            \end{javacode}
            \bigbreak \noindent 
            The configuration changes are
            \begin{itemize}
                \item \textbf{orientation}:	Screen rotated (portrait $\leftrightarrow$ landscape)
                \item \textbf{screenSize}:	Screen size changes (usually with orientation)
                \item \textbf{keyboardHidden}:	Hardware keyboard opened/closed
                \item \textbf{layoutDirection}:	RTL (Arabic/Hebrew) vs LTR languages
                \item \textbf{uiMode:}	Dark mode, car mode, TV mode
                \item \textbf{locale}:	Language changes
                \item \textbf{fontScale}:	System font size changes
                \item \textbf{density:}	Screen pixel density changes
                \item \textbf{keyboard}:	Keyboard type changes (physical/virtual)
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{themes.xml (items)}
    \begin{itemize}
        \item \textbf{Color attributes}
            \begin{itemize}
                \item \textbf{colorPrimary}:	Main brand color; app bar, button, toggle background
                \item \textbf{colorPrimaryVariant}:	Darker/lighter version for emphasis (status bar, etc.)
                \item \textbf{colorOnPrimary}:	Text/icon color on top of primary surfaces
                \item \textbf{colorSecondary}:	Accent color used for FABs, toggles, etc.
                \item \textbf{colorSecondaryVariant}:	Variant for the secondary color
                \item \textbf{colorOnSecondary}:	Text/icon color drawn over secondary surfaces
                \item \textbf{colorTertiary / colorOnTertiary}:	Used in Material 3 themes for additional tonal roles
                \item \textbf{colorSurface}:	Background color of surfaces like cards, menus
                \item \textbf{colorOnSurface}:	Text/icon color on surfaces
                \item \textbf{colorBackground}:	Activity window background
                \item \textbf{colorOnBackground}:	Text/icon color on backgrounds
                \item \textbf{colorError}:	Used for error indicators, text fields, etc.
                \item \textbf{colorOnError}:	Text/icon color on error backgrounds
                \item \textbf{colorOutline}:	Divider and border color (Material 3)
                \item \textbf{android:statusBarColor}:	Status bar color (system UI)
                \item \textbf{android:navigationBarColor}:	Navigation bar color
                \item \textbf{android:windowBackground}:	Root background for the entire window
            \end{itemize}
        \item \textbf{Typography and text appearance}
            \begin{itemize}
                \item \textbf{android:fontFamily}:	Default font for the app
                \item \textbf{textAppearanceBody1}:	Default text style for body text
                \item \textbf{textAppearanceBody2}:	Smaller body text style
                \item \textbf{textAppearanceButton}:	Button text style
                \item \textbf{textAppearanceHeadline1 $\to$ Headline6}:	Large to small headline text
                \item \textbf{textAppearanceSubtitle1,}: textAppearanceSubtitle2	Subtitle text
                \item \textbf{textAppearanceCaption}:	Caption/small label text
                \item \textbf{textAppearanceOverline}:	Overline (uppercase) small text
                \item \textbf{android:textColorPrimary}:	Primary text color on light/dark backgrounds
                \item \textbf{android:textColorSecondary}:	Secondary text color
            \end{itemize}
        \item \textbf{Shape and corner styling (Material Components)}
            \begin{itemize}
                \item \textbf{shapeAppearanceSmallComponent}:	Shape for small widgets like buttons
                \item \textbf{shapeAppearanceMediumComponent}:	Medium-sized components (e.g., text fields)
                \item \textbf{shapeAppearanceLargeComponent}:	Large components like cards
                \item \textbf{shapeAppearanceCornerSmall}:	Controls corner radii of shapes
                \item \textbf{shapeAppearanceCornerExtraLarge}:	Very rounded shapes (chips, FABs)
                \item \textbf{shapeAppearanceOverlay}:	Used for overlaying corner radius configs
            \end{itemize}
        \item \textbf{Window and system bar attributes}
            \begin{itemize}
                \item \textbf{android:windowBackground}:	Background drawable or color for the window
                \item \textbf{android:windowFullscreen}:	Whether activity draws behind status bar
                \item \textbf{android:windowLightStatusBar}:	Use dark icons on light status bar
                \item \textbf{android:statusBarColor}:	Status bar color
                \item \textbf{android:navigationBarColor}:	Navigation bar color
                \item \textbf{android:windowTranslucentStatus}:	Make status bar translucent
                \item \textbf{android:windowTranslucentNavigation}:	Make navigation bar translucent
                \item \textbf{android:windowLayoutInDisplayCutoutMode}:	Handle notches (cutouts)
                \item \textbf{android:windowContentOverlay}:	Overlay drawable between title bar and content
            \end{itemize}
        \item \textbf{Widget and control styles}: Each of these points to another <style> resource defining widget looks.
            \begin{itemize}
                \item \textbf{buttonStyle}:	Default style for <Button>
                \item \textbf{buttonStyleSmall}:	Small button variant
                \item \textbf{android:buttonStyleToggle}:	Toggle button style
                \item \textbf{switchStyle}:	Default style for switches
                \item \textbf{checkboxStyle}:	Default style for checkboxes
                \item \textbf{radioButtonStyle}:	Default style for radio buttons
                \item \textbf{editTextStyle}:	Style for EditText
                \item \textbf{textInputStyle}:	Style for TextInputLayout (Material)
                \item \textbf{spinnerStyle}:	Default dropdown/spinner
                \item \textbf{toolbarStyle}:	Default Toolbar style
                \item \textbf{materialButtonStyle}:	Default Material Button style
                \item \textbf{materialCardViewStyle}:	Default CardView style
                \item \textbf{floatingActionButtonStyle}:	Default FAB style
                \item \textbf{snackbarStyle}:	Snackbar appearance
                \item \textbf{bottomNavigationStyle}:	Bottom nav bar
                \item \textbf{navigationViewStyle}:	Drawer navigation view
                \item \textbf{appBarLayoutStyle}:	App bar layout
                \item \textbf{chipStyle}:	Default Chip
                \item \textbf{chipGroupStyle}:	Default ChipGroup
            \end{itemize}
        \item \textbf{Theme structure and inheritance}
            \begin{itemize}
                \item \textbf{android:colorAccent}:	(Pre-Material) old accent color (replaced by colorSecondary)
                \item \textbf{android:colorControlHighlight}:	Ripple color for controls
                \item \textbf{android:colorControlActivated}:	Color of activated controls
                \item \textbf{android:colorControlNormal}:	Default tint for controls
                \item \textbf{android:colorButtonNormal}:	Default background for buttons
                \item \textbf{android:colorEdgeEffect}:	Glow color when overscrolling
                \item \textbf{android:alertDialogTheme}:	Theme for dialogs
                \item \textbf{android:popupMenuStyle}:	Style for popup menus
                \item \textbf{android:listViewStyle}:	Default ListView
                \item \textbf{android:progressBarStyle}:	Progress bar
                \item \textbf{android:seekBarStyle}:	SeekBar
                \item \textbf{android:ratingBarStyle}:	RatingBar
                \item \textbf{android:editTextColor}:	EditText color (older)
            \end{itemize}
        \item \textbf{Material 3 (Material You) dynamic color attributes}: If you’re using a Material 3 theme (Theme.Material3.*):
            \begin{itemize}
                \item \textbf{colorPrimaryContainer}:	Container for primary UI elements
                \item \textbf{colorOnPrimaryContainer}:	Text/icons on primary container
                \item \textbf{colorSecondaryContainer, colorOnSecondaryContainer}:	Same but for secondary surfaces
                \item \textbf{colorTertiaryContainer, colorOnTertiaryContainer}:	Third tonal role
                \item \textbf{colorSurfaceVariant}:	Background for secondary surfaces
                \item \textbf{colorInverseSurface, colorOnInverseSurface}:	For inverted surfaces
                \item \textbf{colorOutlineVariant}:	Muted divider color
                \item \textbf{colorScrim}:	Used for modal overlays
                \item \textbf{android:colorErrorContainer}:	Error background tone
                \item \textbf{android:colorOnErrorContainer}:	Foreground on error container
            \end{itemize}
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \subsection{XML tags}
    \begin{itemize}
        \item \textbf{XML Declaration}: Android's resource compiler can usually parse XML without it. But it is strongly recommended to include it for consistency and to avoid encoding issues 
            \bigbreak \noindent 
            \begin{xmlcode}
                <?xml version="1.0" encoding="utf-8"?>
            \end{xmlcode}
        \item \textbf{Resources}: The root element of an XML resource file in the res/values/ directory (like strings.xml, colors.xml, styles.xml, etc.).
            \bigbreak \noindent 
            \begin{xmlcode}
            <resources>
                ...
            </resources>
            \end{xmlcode}
        \item \textbf{String}: 
            \bigbreak \noindent 
            \begin{xmlcode}
            <string name=""> ... </string>
            \end{xmlcode}
        \item \textbf{Color}:
            \bigbreak \noindent 
            \begin{xmlcode}
            <color name=""> hex </color>
            \end{xmlcode}
        \item \textbf{Dimen}:
            \bigbreak \noindent 
            \begin{xmlcode}
            <dimen name=""> ... </dimen>
            \end{xmlcode}
        \item \textbf{Manifest}
            \bigbreak \noindent 
            \begin{xmlcode}
            <manifest>
                ...
            </manifest>
            \end{xmlcode}
        \item \textbf{Style}: used to define styles and themes for your Android app
            \bigbreak \noindent 
            \begin{xmlcode}
            <style name="" parent="">
                <item name=""> ... </item>
            </style>
            \end{xmlcode}
    \end{itemize}

    \pagebreak 
    \subsection{Components}
    \begin{itemize}
        \item \textbf{ConstraintLayout}: In Android Studio, ConstraintLayout is a powerful and flexible layout manager used to design UIs. It's often the default choice in modern Android projects. 
            \bigbreak \noindent 
            It is a \textbf{ViewGroup} (container) that positions and sizes its child views based on constraints you define.
            \begin{itemize}
                \item \textbf{Constraints:} Each view needs at least one horizontal and one vertical constraint (e.g., align left to parent, center in parent, align top to another view).
                \item \textbf{No deep nesting:} Unlike LinearLayout or RelativeLayout, you can achieve complex designs without nesting multiple layouts, which improves performance.
                \item \textbf{Flexible positioning:} You can center, chain, bias (percent-based positioning), or even set aspect ratios.
            \end{itemize}
            \bigbreak \noindent 
            \begin{xmlcode}
            <androidx.constraintlayout.widget.ConstraintLayout 
            xmlns:android="http://schemas.android.com/apk/res/android" 
            xmlns:app="http://schemas.android.com/apk/res-auto"
            xmlns:tools="http://schemas.android.com/tools"
            ...
            tools:context=".MainActivity">
                ...
            </androidx.constraintlayout.widget.ConstraintLayout>
            \end{xmlcode}
            \bigbreak \noindent 
            \textbf{Note:} xmlns stands for \textbf{XML Namespace}. 
            \bigbreak \noindent 
            \texttt{tools:context=".MainActivity"} tells the Layout Editor which Activity will load this layout. It's a design-time hint for Android Studio (not used at runtime).
        \item \textbf{TextView}: is a basic Android UI widget used to display text to the user. It's read-only by default (unlike EditText, which allows input). It can show plain text, styled text, or even links.
            \bigbreak \noindent 
            \begin{xmlcode}
                <TextView ...>
                    ...
                </TextView
            \end{xmlcode}
        \item \textbf{EditText}: Subclass of TextView that allows the user to enter and edit text. It's the standard widget for text input in Android (like forms, search boxes, chat inputs)
            \bigbreak \noindent 
            \begin{xmlcode}
                <EditText ...>
                ...
                </EditText>
            \end{xmlcode}

    \end{itemize}


    \pagebreak 
    \subsection{Managing orientation}
    \begin{itemize}
        \item \textbf{Manage orientation}: To manage an app's orientation on a device, we must 
            \begin{enumerate}
                \item retrieve the screen dimensions of a device dynamically,
                \item retrieve the height of both the status and action bars (if there),
                \item be able to detect orientation changes on the device, and
                \item manage the UI of the app when the user rotates the device.
            \end{enumerate}
        \item \textbf{Device rotations}: When we run an app and rotate the device that the app is running on, the UI may or may not rotate.
            \bigbreak \noindent 
            Some apps, in particular games, are best run in one orientation only, often horizontal. Sometimes, we want to build an app that works in both horizontal and vertical orientations. 
        \item \textbf{Locking apps to only one orientation}:
            \begin{itemize}
                \item \textbf{Portrait only}:
                    \bigbreak \noindent 
                    \begin{xmlcode}
                        <!-- AndroidManifest.xml -->
                        <activity
                            android:name=".MainActivity"
                            android:screenOrientation="portrait" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    To allow reverse landscape (upside down),
                    \bigbreak \noindent 
                    \begin{xmlcode}
                    <activity
                        android:name=".MainActivity"
                        android:screenOrientation="sensorPortrait" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    Or in code (at runtime):
                    \bigbreak \noindent 
                    \begin{javacode}
                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
                    \end{javacode}
                \item \textbf{Reverse portrait only}:
                    \bigbreak \noindent 
                    \begin{xmlcode}
                     <activity
                        android:name=".MainActivity"
                        android:screenOrientation="reversePortrait" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    In java,
                    \bigbreak \noindent 
                    \begin{javacode}
                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
                    \end{javacode}
                \item \textbf{Landscape only}
                    \bigbreak \noindent 
                    \begin{xmlcode}
                        <activity
                            android:name=".MainActivity"
                            android:screenOrientation="landscape" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    If you want to allow both landscape directions (normal + reverse), use:
                    \bigbreak \noindent 
                    \begin{xmlcode}
                    <activity
                        android:name=".MainActivity"
                        android:screenOrientation="sensorLandscape" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    In java,
                    \bigbreak \noindent 
                    \begin{javacode}
                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
                    \end{javacode}
                \item \textbf{Reverse landscape}
                    \bigbreak \noindent 
                    \begin{xmlcode}
                     <activity
                        android:name=".MainActivity"
                        android:screenOrientation="reverseLandscape" />
                    \end{xmlcode}
                    \bigbreak \noindent 
                    In java,
                    \bigbreak \noindent 
                    \begin{javacode}
                        ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
                    \end{javacode}
            \end{itemize}
        \item \textbf{Allow any orientation}:
            To allow only landscape and portrait,
            \bigbreak \noindent 
            \begin{xmlcode}
                <activity
                    android:name=".MainActivity"
                    android:screenOrientation="sensor" />
            \end{xmlcode}
            \bigbreak \noindent 
            This allows both portrait and landscape. If we want to include reverse landscape and reverse portrait,
            \bigbreak \noindent 
            \begin{xmlcode}
                 <activity
                    android:name=".MainActivity"
                    android:screenOrientation="fullSensor" />
            \end{xmlcode}
        \item \textbf{Default behavior}: By default, neither sensor nor fullSensor is explicitly used. If you do not set android:screenOrientation in the manifest and do not call setRequestedOrientation() in code, then Android uses:
            \bigbreak \noindent 
            \begin{xmlcode}
                android:screenOrientation="unspecified"
            \end{xmlcode}
            \bigbreak \noindent 
            The app follows the device orientation sensor, but only within the orientations allowed by the user's system settings, typically supports portrait and landscape (not reverse portrait/landscape unless the device/user allows it). So, it behaves similar to sensor — not fullSensor.
        \item \textbf{Getting resolution}: We can fill a \texttt{Point} object using the \texttt{getSize(Point p)} method in the Display object.
            \bigbreak \noindent 
            \begin{javacode}
                Point size = new point();
                getWindowManager().getDefaultDisplay.getSize(size)
                int width = size.x;
                int height = size.y;
            \end{javacode}
        \item \textbf{Getting resolution in dp}: Through a Configuration object,
            \bigbreak \noindent 
            \begin{javacode}
            Configuration config = getResources().getConfiguration();
            int width_dp = config.screenWidthDp;
            int height_dp = config.screenHeighthDp;
            \end{javacode}
        \item \textbf{Getting density}: We can get the screen density factor $\rho$ (logical pixel density) through the DisplayMetrics object
            \bigbreak \noindent 
            \begin{javacode}
            DisplayMetrics metrics = getResources().getDisplayMetrics();
            float rho = metrics.density;
            \end{javacode}
        \item \textbf{Testing for size type}: First, we get a Configuration object
            \bigbreak \noindent 
            \begin{javacode}
                Configuration config = getResources().getConfiguration();
            \end{javacode}
            \bigbreak \noindent 
            Then,
            \bigbreak \noindent 
            \begin{javacode}
                if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE))
                    Log.w(MA, "Extra large size screen");
                else if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_LARGE))
                    Log.w(MA, "Large size screen");
                else if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_NORMAL))
                    Log.w(MA, "Normal size screen");
                else if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_SMALL))
                    Log.w(MA, "Small size screen");
                else
                    Log.w(MA, "Unknown size screen");
            \end{javacode}
        \item \textbf{Getting orientation information}: We get a Configuration object reference through the Resources object reference, the Configuration object holds information about orientation
            \bigbreak \noindent 
            \begin{javacode}
                Configuration config = getResources().getConfiguration();
                int orientation = config.orientation;
            \end{javacode}
        \item \textbf{Managing orientation change outside onCreate()}: By default, method onCreate() of the MainActivity.java class is called when the user rotates the device. However, method onCreate() typically does more than just handling orientation changes. Thus, it could be a waste of CPU resources to let method onCreate() execute every time the user rotates the device.
            \bigbreak \noindent 
            We can specify \texttt{android:configChanges="orientation|screenSize"} to handle rotations manually, instead of the default behavior.
            \bigbreak \noindent 
            Then, we can override \texttt{onConfigurationChanged(Configuration newConfig)}. For example, 
            \bigbreak \noindent 
            \begin{javacode}
                public void onConfigurationChanged(Configuration newConfig) {
                    super.onConfigurationChanged(newConfig);
                    Log.w(MA, "Height: " + newConfig.screenHeightDp);
                    Log.w(MA, "Width: " + newConfig.screenWidthDp);

                    Log.w(MA, "Orientation: " + newConfig.orientation);
                    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE)
                        Log.w(MA, "Horizontal position");
                    else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)
                        Log.w(MA, "Vertical position");
                    else
                        Log.w(MA, "Undetermined position");
                } 
            \end{javacode}
            \bigbreak \noindent 
            Method onCreate() is only called when the user starts the app and no longer called when the user rotates the device.
        \item \textbf{Display correct UI based on orientation}: We can do it one of three ways.
            \begin{enumerate}
                \item We can create one layout XML file per orientation and inflate it whenever the user rotates the device
                \item We can create one layout XML file for both orientations and modify the characteristics of some of the UI components whenever the user rotates the device 
                \item We can manage layouts 100\% by code and make the appropriate modifications whenever the user rotates the device
            \end{enumerate}
        \item \textbf{One layout file per orientation}: We can have \texttt{activity\_main.xml} for portrait, and \texttt{activity\_main\_landscape.xml} for landscape. In the manifest, we write
            \bigbreak \noindent 
            \begin{xmlcode}
                android:configChanges="orientation|screenSize"
            \end{xmlcode}
            \bigbreak \noindent 
            Then in java, we can override the activity method \texttt{onConfigurationChanged}
            \bigbreak \noindent 
            \begin{javacode}
               public void onConfigurationChanged(Configuration newConfig) {
                   Log.w("MainActivity", "Inside onConfigurationChanged");
                   super.onConfigurationChanged(newConfig);
                   modifyLayout(newConfig);
               }
            \end{javacode}
            \bigbreak \noindent 
            This function will be called when the configuration changes. Our modifyLayout function could look like 
            \bigbreak \noindent 
            \begin{javacode}
                public void modifyLayout(Configuration newConfig) {
                    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE)
                        setContentView(R.layout.activity_main_landscape);
                    else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)
                        setContentView(R.layout.activity_main);
                }
            \end{javacode}
            \bigbreak \noindent 
            We also need our \texttt{onCreate} to have a few details as well,
            \bigbreak \noindent 
            \begin{javacode}
                protected void onCreate(Bundle savedInstanceState)
                {
                    Log.w("MainActivity", "Inside onCreate");
                    super.onCreate(savedInstanceState);
                    Configuration config = getResources().getConfiguration();
                    modifyLayout(config);
                }
            \end{javacode}
            \bigbreak \noindent 
            This way we inflate the correct layout when the app first starts.




    \end{itemize}

    \pagebreak 
    \subsection{Menus}
    \begin{itemize}
        \item \textbf{Menu Resource directory}: Menus are defined in \texttt{res/menu}
        \item \textbf{Menu types}
            \begin{itemize}
                \item \textbf{Options menu}: Defined in the action bar / app bar, or in the overflow menu if there's no room.
                \item \textbf{Context menu}: Appears when the user long-presses an item. Appears next to the pressed item OR as a floating context bar
                \item \textbf{Popup menu}: A tiny menu that pops up anchored to a button, Triggered by tapping a specific UI element (not long-press)
            \end{itemize}
        \item \textbf{Options menu}
            \bigbreak \noindent 
            \fig{.6}{./figures/1037.png}
            \bigbreak \noindent 
            We need to override the \texttt{onCreateOptionsMenu} method
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    getMenuInflater().inflate(R.menu.menu_main, menu);
                    return true;
                }
            \end{javacode}
            \bigbreak \noindent 
            The menu parameter is an empty Menu object created by Android. It represents the Action Bar options menu that will be shown to the user.
            \bigbreak \noindent 
            Your job in this method is to add items into this menu, usually done by inflating XML into it
            \bigbreak \noindent 
            Returning true means yes, we successfully created and want to show this menu.
            \bigbreak \noindent 
            To handle clicks, we override
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onOptionsItemSelected(MenuItem item) {
                    if (item.getItemId() == R.id.action_settings) {
                        // action here
                        return true;
                    }
                    return super.onOptionsItemSelected(item);
                }
            \end{javacode}
            \bigbreak \noindent 
            Calling the super version lets the default Android behavior run when your code doesn’t handle the menu click. If it’s not your menu item, let the Android system decide what to do.

        \item \textbf{Context Menu}: We first need to register the view
            \bigbreak \noindent 
            \begin{javacode}
                registerForContextMenu(myView);
            \end{javacode}
            \bigbreak \noindent 
            Then, override
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public void onCreateContextMenu(ContextMenu menu, View v,
                ContextMenu.ContextMenuInfo menuInfo) {
                    getMenuInflater().inflate(R.menu.context_menu, menu);
                }
            \end{javacode}
            \bigbreak \noindent 
            To handle clicks, override
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onContextItemSelected(MenuItem item) {
                    if (item.getItemId() == R.id.action_delete) {
                        // do delete
                        return true;
                    }
                    return super.onContextItemSelected(item);
                }
            \end{javacode}


        \item \textbf{Popup menu}: First, create in code where needed
            \bigbreak \noindent 
            \begin{javacode}
                PopupMenu popup = new PopupMenu(this, myButton);
                popup.getMenuInflater().inflate(R.menu.popup_menu, popup.getMenu());
                popup.show();
            \end{javacode}
            \bigbreak \noindent 
            Handle clicks using a listener
            \bigbreak \noindent 
            \begin{javacode}
                popup.setOnMenuItemClickListener(item -> {
                    if (item.getItemId() == R.id.action_share) {
                        // do share
                        return true;
                    }
                    return false;
                });

            \end{javacode}
    
        \item \textbf{Menu attributes}
            \begin{itemize}
                \item \textbf{android:id="Resource ID"}:. A unique resource ID. To create a new resource ID for this item, use the form: "@+id/name". The plus symbol indicates that this is created as a new ID.
                \item \textbf{android:title="String resource"}:. The menu title as a string resource or raw string.
                \item \textbf{android:titleCondensed="String resource"}:. A condensed title as a string resource or a raw string. This title is used for situations in which the normal title is too long.
                \item \textbf{android:icon="Drawable resource"}:. An image to be used as the menu item icon.
                \item \textbf{android:onClick="Method name"}:. The method to call when this menu item is clicked. The method must be declared in the activity as public. It accepts a MenuItem as its only parameter, which indicates the item clicked. This method takes precedence over the standard callback to onOptionsItemSelected(). See the example at the end of this page.
                \item \textbf{android:showAsAction="Keyword."}: When and how this item appears as an action item in the app bar. A menu item can appear as an action item only when the activity includes an app bar. Valid values:
                    \begin{itemize}
                        \item \textbf{ifRoom}:	Only place this item in the app bar if there is room for it. If there isn't room for all the items marked "ifRoom", the items with the lowest orderInCategory values are displayed as actions, and the remaining items are displayed in the overflow menu.
                        \item \textbf{withText}:	Also include the title text (defined by android:title) with the action item. You can include this value along with one of the others as a flag set by separating them with a pipe |.
                        \item \textbf{never}:	Never place this item in the app bar. Instead, list the item in the app bar's overflow menu.
                        \item \textbf{always}:	Always place this item in the app bar. Avoid using this unless it's critical that the item always appear in the action bar. Setting multiple items to always appear as action items can result in them overlapping with other UI in the app bar.
                        \item \textbf{collapseActionView}:	The action view associated with this action item (as declared by android:actionLayout or android:actionViewClass) is collapsible. Introduced in API level 14.
                    \end{itemize}
                \item \textbf{android:actionLayout="Layout resource"}:. A layout to use as the action view.
                \item \textbf{android:actionViewClass="Class name"}:. A fully-qualified class name for the View to use as the action view. For example, "android.widget.SearchView" to use SearchView as an action view.
                \item \textbf{android:actionProviderClass="Class name"}:. A fully qualified class name for the ActionProvider to use in place of the action item. For example, "android.widget.ShareActionProvider" to use ShareActionProvider.
                \item \textbf{android:alphabeticShortcut="Char."}: A character for the alphabetic shortcut key.
                \item \textbf{android:numericShortcut="Integer."}: A number for the numeric shortcut key.
                \item \textbf{android:alphabeticModifiers="Keyword."}: A modifier for the menu item's alphabetic shortcut. The default value corresponds to the Control key. Valid values:
                    \begin{itemize}
                        \item \textbf{META}:	Corresponds to the Meta meta key.
                        \item \textbf{CTRL}:	Corresponds to the Control meta key.
                        \item \textbf{ALT}:	Corresponds to the Alt meta key.
                        \item \textbf{SHIFT}:	Corresponds to the Shift meta key.
                        \item \textbf{SYM}:	Corresponds to the Sym meta key.
                        \item \textbf{FUNCTION}:	Corresponds to the Function meta key.
                    \end{itemize}
                    You can use the setAlphabeticShortcut() method to set the attribute values programmatically. For more information about the alphabeticModifier attribute
                \item \textbf{android:numericModifiers="Keyword"}:. A modifier for the menu item's numeric shortcut. The default value corresponds to the Control key. Valid values:
                    \begin{itemize}
                        \item \textbf{META}:	Corresponds to the Meta meta key.
                        \item \textbf{CTRL}:	Corresponds to the Control meta key.
                        \item \textbf{ALT}:	Corresponds to the Alt meta key.
                        \item \textbf{SHIFT}:	Corresponds to the Shift meta key.
                        \item \textbf{SYM}:	Corresponds to the Sym meta key.
                        \item \textbf{FUNCTION}:	Corresponds to the Function meta key.
                    \end{itemize}
                    You can use the setNumericShortcut() method to set the attribute values programmatically. For more information about the numericModifier attribute
                \item \textbf{android:checkable="Boolean"}:. True if the item is checkable.
                \item \textbf{android:checked="Boolean"}:. True if the item is checked by default.
                \item \textbf{android:visible="Boolean"}:. True if the item is visible by default.
                \item \textbf{android:enabled="Boolean"}:. True if the item is enabled by default.
                \item \textbf{android:menuCategory="Keyword"}:. Value corresponding to the Menu CATEGORY\_* constants, which define the item's priority. Valid values:
                    \begin{itemize}
                        \item \textbf{container}:	For items that are part of a container.
                        \item \textbf{system}:	For items that are provided by the system.
                        \item \textbf{secondary}:	For items that are user-supplied secondary (infrequently used) options.
                        \item \textbf{alternative}:	For items that are alternative actions on the data that is currently displayed.  
                    \end{itemize}
                \item \textbf{android:orderInCategory="Integer"}:. The order of importance of the item within a group.
            \end{itemize}
        \item \textbf{<group>}: A menu group, to create a collection of items that share traits, such as whether they are visible, enabled, or selectable. Contains one or more <item> elements. Must be a child of a <menu> element.
        \item \textbf{<group> attributes}:
            \begin{itemize}
                \item \textbf{android:id="Resource ID"}: A unique resource ID. To create a new resource ID for this item, use the form: "@+id/name". The plus symbol indicates that this is created as a new ID.
                \item \textbf{android:checkableBehavior="Keyword"}:. The type of selectable behavior for the group. Valid values:
                    \begin{itemize}
                        \item \textbf{none}:	Not selectable.
                        \item \textbf{all}:	All items can be selected (use checkboxes).
                        \item \textbf{single}:	Only one item can be selected (use radio buttons).
                    \end{itemize}
                \item \textbf{android:visible="Boolean"}:. True if the group is visible.
                \item \textbf{android:enabled="Boolean"}:. True if the group is enabled.
                \item \textbf{android:menuCategory="Keyword"}:. Value corresponding to the Menu CATEGORY\_* constants, which define the group's priority. Valid values:
                    \begin{itemize}
                        \item \textbf{container}:	For groups that are part of a container.
                        \item \textbf{system}:	For groups that are provided by the system.
                        \item \textbf{secondary}:	For groups that are user-supplied secondary (infrequently used) options.
                        \item \textbf{alternative}:	For groups that are alternative actions on the data that is currently displayed.
                    \end{itemize}
                \item \textbf{android:orderInCategory}: Integer. The default order of the items within the category.
            \end{itemize}
        
    \end{itemize}

    \pagebreak 
    \subsection{SQLite}
    \begin{itemize}
        \item \textbf{Extending SQLiteOpenHelper}: We can create a \texttt{DatebaseManager} class file, in which we extend \texttt{SQLiteOpenHelper}. That’s Android’s built-in helper for:
            \begin{itemize}
                \item \textbf{Creating tables}:	onCreate(SQLiteDatabase db)
                \item \textbf{Upgrading schema versions}:	onUpgrade(SQLiteDatabase db, int oldV, int newV)
                \item \textbf{Opening / closing the DB safely}:	handled by the parent class
            \end{itemize}
            Android automatically calls onCreate() the first time your app accesses the database.
        \item \textbf{Define name and version}: For example,
            \bigbreak \noindent 
            \begin{javacode}
                private static final String DATABASE_NAME = "recordDB";
                private static final int DATABASE_VERSION = 1;
            \end{javacode}
            \bigbreak \noindent 
            Stored in your app’s private folder:
            \bigbreak \noindent 
            \begin{bashcode}
                /data/data/<your-package>/databases/recordDB
            \end{bashcode}
            \bigbreak \noindent 
            Version controls schema changes; bumping it triggers onUpgrade().
        \item \textbf{Table creation}: For example,
            \bigbreak \noindent 
            \begin{javacode}
                public void onCreate(SQLiteDatabase db) {
                    String sqlCreate = "create table record(" +
                        "id integer primary key autoincrement, " +
                        "name text, price real)";
                    db.execSQL(sqlCreate);
                }
            \end{javacode}
            \bigbreak \noindent 
            Called automatically the first time the database is created. Builds one table named record with:
            \begin{itemize}
                \item \textbf{id}: primary key (auto-increment)
                \item \textbf{name}: text column
                \item \textbf{price}: real (floating-point number)
            \end{itemize}
        \item \textbf{Upgrading the schema}: For example, 
            \bigbreak \noindent 
            \begin{javacode}
                public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                    db.execSQL("drop table if exists record");
                    onCreate(db);
                }
            \end{javacode}
            \bigbreak \noindent 
            When you increment DATABASE\_VERSION, Android calls this. It drops the old table and recreates it. (In production you’d use ALTER TABLE instead of dropping data.)
        \item \textbf{Inserting data}: For example, 
            \bigbreak \noindent 
            \begin{javacode}
                public void insert(Record record) {
                    SQLiteDatabase db = this.getWritableDatabase();
                    String sqlInsert = "insert into record values(null, '" +
                                        record.getName() + "', '" + record.getPrice() + "')";
                    db.execSQL(sqlInsert);
                    db.close();
                }
            \end{javacode}
            \bigbreak \noindent 
            Opens a writable connection, Executes a raw SQL INSERT statement, Uses null for the auto-incrementing ID, Closes the database
            \bigbreak \noindent 
            \textbf{Note:} In real apps, you’d use ContentValues to avoid SQL injection.
        \item \textbf{Deleting data}: For example,
            \bigbreak \noindent 
            \begin{javacode}
                public void deleteById(int id) {
                    SQLiteDatabase db = this.getWritableDatabase();
                    db.execSQL("delete from record where id = " + id);
                    db.close();
                }
            \end{javacode}
            \bigbreak \noindent 
            Removes one row where the ID matches.
        \item \textbf{Updating data}
            \bigbreak \noindent 
            \begin{javacode}
                public void updateById(int id, String name, double price) {
                    SQLiteDatabase db = this.getWritableDatabase();
                    db.execSQL("update record set name = '" + name + "', price = '" + price + "' where id = " + id);
                    db.close();
                }
            \end{javacode}
            \bigbreak \noindent 
            Changes both name and price columns for the selected record.
        \item \textbf{Querying one record}
            \bigbreak \noindent 
            \begin{javacode}
                public Record selectById(int id) {
                    String sqlQuery = "select * from record where id = " + id;
                    SQLiteDatabase db = this.getWritableDatabase();
                    Cursor cursor = db.rawQuery(sqlQuery, null);

                    Record record = null;
                    if (cursor.moveToFirst())
                        record = new Record(
                            Integer.parseInt(cursor.getString(0)),
                            cursor.getString(1),
                            cursor.getDouble(2));
                    return record;
                }
            \end{javacode}
            \begin{itemize}
                \item Executes a SELECT query
                \item Returns a Cursor (a pointer over result rows)
                \item Reads columns using indices (0=id, 1=name, 2=price)
                \item Builds and returns a Record object
            \end{itemize}
            A Cursor in Android is a data access object that points to the result set (rows and columns) returned from a database query. It works like an iterator that lets you move across each row of the query result and read each column’s value.
            \begin{itemize}
                \item sqlQuery = a plain SQL command to get 1 row (SELECT * FROM record WHERE id = ?).
                \item db.rawQuery(sqlQuery, null) executes the SQL and returns a Cursor.
                \item The cursor now contains the query result (in memory, inside SQLite).
            \end{itemize}
            \textbf{Important methods}
            \begin{itemize}
                \item \textbf{moveToFirst()}	Moves the cursor to the first row of the result set. Returns false if there are no rows.
                \item \textbf{moveToNext()}	Moves the cursor forward one row. Returns false if there are no more rows.
                \item \textbf{moveToPrevious()}	Moves the cursor back one row.
                \item \textbf{moveToLast()}	Moves the cursor to the last row.
                \item \textbf{move(int offset)}	Moves the cursor relative to its current position.
                \item \textbf{moveToPosition(int position)}	Moves to an exact row index (0-based). Returns false if out of range.
                \item \textbf{isFirst() / isLast()}	Returns true if the cursor is at the first/last row.
                \item \textbf{isBeforeFirst() / isAfterLast()}	Returns true if the cursor hasn’t started or has finished iterating.
                \item \textbf{getPosition()}	Returns the current row index.
                \item \textbf{getInt(int columnIndex)}:	Reads an int value.
                \item \textbf{getLong(int columnIndex)}:	Reads a long.
                \item \textbf{getDouble(int columnIndex)}:	Reads a double.
                \item \textbf{getFloat(int columnIndex)}:	Reads a float.
                \item \textbf{getString(int columnIndex)}:	Reads a String.
                \item \textbf{getBlob(int columnIndex)}:	Reads a byte[] (for images or binary data).
                \item \textbf{isNull(int columnIndex)}:	Returns true if the column’s value is NULL.
                \item \textbf{getColumnCount()}:	Returns number of columns in the result.
                \item \textbf{getColumnName(int index)}:	Returns the name of the column at a given index.
                \item \textbf{getColumnNames()}:	Returns a String[] of all column names.
                \item \textbf{getColumnIndex(String columnName)}:	Returns the column’s index (or -1 if not found).
                \item \textbf{getColumnIndexOrThrow(String columnName)}:	Same as above, but throws IllegalArgumentException if not found.
                \item \textbf{getCount()}:	Returns how many rows are in the result set.
                \item \textbf{isClosed()}:	Returns true if the cursor is already closed.
                \item \textbf{getPosition()}:	Returns current row index (0 = first).
                \item \textbf{close()}: Frees database and native resources. Always call when done!
            \end{itemize}
        \item \textbf{Query all records}
            \bigbreak \noindent 
            \begin{javacode}
                public ArrayList<Record> selectAll() {
                    String sqlQuery = "select * from record";
                    SQLiteDatabase db = this.getWritableDatabase();
                    Cursor cursor = db.rawQuery(sqlQuery, null);

                    ArrayList<Record> records = new ArrayList<>();
                    while (cursor.moveToNext()) {
                        Record current = new Record(
                            Integer.parseInt(cursor.getString(0)),
                            cursor.getString(1),
                            cursor.getDouble(2));
                        records.add(current);
                    }
                    db.close();
                    return records;
                }
            \end{javacode}
        \item \textbf{Impotant SQLiteDatabase methods}
            \begin{itemize}
                \item \textbf{getReadableDatabase()}:	Opens the database in read-only mode.
                \item \textbf{getWritableDatabase()}:	Opens the database in read/write mode (creates it if needed).
                \item \textbf{close()}:	Closes the database connection.
                \item \textbf{isOpen()}:	Returns true if the DB is currently open.
                \item \textbf{getPath()}:	Returns the absolute file path of the database.
                \item \textbf{execSQL(String sql)}:	Executes a single SQL statement (no results returned). For example: db.execSQL("DELETE FROM record WHERE id=5");
                \item \textbf{insert(String table, String nullColumnHack, ContentValues values)}:	Inserts a new row. Returns the new row ID.
                \item \textbf{update(String table, ContentValues values, String whereClause, String[] whereArgs)}:	Updates existing rows matching a condition. Returns number of rows affected.
                \item \textbf{delete(String table, String whereClause, String[] whereArgs)}:	Deletes rows matching the condition. Returns number of rows deleted.
                \item \textbf{beginTransaction()}:	Starts a new transaction.
                \item \textbf{setTransactionSuccessful()}:	Marks the transaction to commit.
                \item \textbf{endTransaction()}:	Ends the transaction (commits if marked successful, rolls back otherwise).
                \item \textbf{inTransaction()}:	Returns true if currently inside a transaction.
                \item \textbf{execSQL(String sql)}:	Run any SQL (CREATE, DROP, etc.).
                \item \textbf{getVersion()}: / setVersion(int version)	Read or change DB version number.
                \item \textbf{getMaximumSize()}: / setMaximumSize(long numBytes)	Check or set max DB file size.
                \item \textbf{needUpgrade(int newVersion)}:	Returns true if the database version is lower than the given version.
                \item \textbf{isDatabaseIntegrityOk()}:	Verifies database file integrity.
                \item \textbf{isReadOnly()}:	Returns true if database is opened read-only.
                \item \textbf{isWriteAheadLoggingEnabled()}:	Returns true if WAL mode is active.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Styles}
    \begin{itemize}
        \item \textbf{How to style}: We can use many attributes to specify how a UI component will look. For example, we can specify the background color of a component.
            \bigbreak \noindent 
            We can specify its text size and color and whether the text is centered or not. We can also specify the component's size and the padding inside it
            \bigbreak \noindent 
            We use styles and themes to organize our project better
            \bigbreak \noindent 
            Themes and styles enable us to separate the look and feel of a View from its content. This is similar to the concept of CSS (Cascading Style Sheets) in web design.
            \bigbreak \noindent 
            We can define more styles in the file named themes.xml in the res > values directory.
        \item \textbf{Define a style} The syntax for defining a style is 
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="nameOfStyle"
                    [parent="styleThisStyleInheritsFrom"]>
                    <item name="attributeName" parent="styleThisStyleInheritsFrom">attributeValue</item>
                    ...
                </style>
            \end{xmlcode}
            \bigbreak \noindent 
            The (optional) parent attribute allows us to create a hierarchy of styles, i.e., styles can inherit from other styles.
        \item \textbf{Example style}: For example, this style specifies width, height, text size, and padding
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="TextStyle"
                    parent="@android:style/TextAppearance">
                    <item name="android:layout_width">wrap_content</item>
                    <item name="android:layout_height">wrap_content</item>
                    <item name="android:textSize">32sp</item>
                    <item name="android:padding">10dp</item>
                </style>
            \end{xmlcode}
        \item \textbf{Apply a style}: We give the style attribute to a component. For example,
            \bigbreak \noindent 
            \begin{xmlcode}
            <button style="@style/styleName" ...> ... </button> 
            \end{xmlcode}
        \item \textbf{TextView Styles}:
            \begin{itemize}
                \item \textbf{android:layout\_width}
                \item \textbf{android:layout\_height}
                \item \textbf{android:layout\_margin}
                \item \textbf{android:layout\_gravity}
                \item \textbf{android:ellipsize}: how text is cut off (none, start, middle, end, marquee)
                \item \textbf{android:singleLine}: (deprecated, use maxLines="1")
                \item \textbf{android:textSize}: font size (e.g. 16sp)
                \item \textbf{android:textColor}: text color (e.g. @color/black)
                \item \textbf{android:textColorHint}: color of the hint text
                \item \textbf{android:textColorHighlight}: color of text selection highlight
                \item \textbf{android:textColorLink}: color of hyperlinks
                \item \textbf{android:textStyle}: normal, bold, italic
                \item \textbf{android:fontFamily}: font family (e.g. sans-serif, serif, or custom font from res/font/)
                \item \textbf{android:typeface}: older way of setting (normal, sans, serif, monospace)
                \item \textbf{android:lineSpacingExtra}: add extra space between lines
                \item \textbf{android:lineSpacingMultiplier}: scale spacing between lines
                \item \textbf{android:letterSpacing}: adjust space between characters
                \item \textbf{android:gravity}: how text is positioned inside its box (top, bottom, left, right, center)
                \item \textbf{android:textAlignment}: alignment relative to parent (gravity, center, viewStart, etc.)
                \item \textbf{android:includeFontPadding}: extra font padding (default true)
                \item \textbf{android:scrollHorizontally}: allow horizontal scroll if needed
                \item \textbf{android:ems}: width in "M" units
                \item \textbf{android:shadowColor}: color of text shadow
                \item \textbf{android:shadowDx, android:shadowDy}: shadow offset
                \item \textbf{android:shadowRadius}: shadow blur radius
            \end{itemize}
        \item \textbf{EditText}: Since EditText is a subclass of TextView, it inherits all of TextView's styling attributes
            \begin{itemize}
                \item \textbf{android:textCursorDrawable}: lets you set a custom drawable for the blinking cursor.
                \item \textbf{android:textSelectHandle}: base selection handle drawable.
                \item \textbf{android:textSelectHandleLeft}: left handle for text selection.
                \item \textbf{android:textSelectHandleRight}: right handle for text selection.
                \item \textbf{android:colorControlActivated}: (theme attr, but affects EditText focus underline in Material/AppCompat).
                \item \textbf{android:colorControlNormal}: normal underline/tint when unfocused.
                \item \textbf{android:colorControlHighlight}: ripple/highlight color when focused.
            \end{itemize}
        \item \textbf{Button}: Button is another subclass of TextView, so it inherits all of TextView’s styling attributes
            \begin{itemize}
                \item \textbf{android:text}: label text.
                \item \textbf{android:textSize}: text size (14sp, 18sp).
                \item \textbf{android:textColor}: text color.
                \item \textbf{android:textStyle}: normal, bold, italic.
                \item \textbf{android:fontFamily}: custom font (@font/roboto\_bold).
                \item \textbf{android:letterSpacing}: adjust spacing between characters.
                \item \textbf{android:lineSpacingExtra / android:lineSpacingMultiplier}: line spacing.
                \item \textbf{android:textAllCaps}: force all caps (default true on Material buttons).
                \item \textbf{android:ellipsize}: how text is cut off if too long.
                \item \textbf{android:background}: drawable for button background (e.g. custom shape).
                \item \textbf{android:foreground}: optional overlay (e.g. ripple).
                \item \textbf{android:insetLeft, android:insetRight, android:insetTop, android:insetBottom}: padding inside button background (mostly for legacy Button).
                \item \textbf{android:padding, android:paddingStart, android:paddingEnd}: space inside button.
                \item \textbf{android:layout\_width, android:layout\_height}: sizing.
                \item \textbf{android:minWidth, android:minHeight}: minimum size (Material buttons have built-in minimums).
                \item \textbf{android:backgroundTint}: tint for the button background.
                \item \textbf{android:backgroundTintMode}: blend mode for tint.
                \item \textbf{android:drawableTint}: tint icons/drawables inside button.
                \item \textbf{android:drawableTintMode}: blending for icon tint.
                \item \textbf{android:drawableStart / android:drawableLeft}: icon at start.
                \item \textbf{android:drawableEnd / android:drawableRight}: icon at end.
                \item \textbf{android:drawableTop, android:drawableBottom}: icons above/below text.
                \item \textbf{android:drawablePadding}: space between icon and text
                \item \textbf{android:elevation}: z-depth shadow (Material design).
                \item \textbf{android:translationZ}: raised elevation when pressed.
                \item \textbf{android:shadowColor, android:shadowDx, android:shadowDy, android:shadowRadius}: text shadow.
                \item \textbf{app:cornerRadius}: rounded corners.
                \item \textbf{app:strokeColor}: outline color.
                \item \textbf{app:strokeWidth}: outline width.
                \item \textbf{app:icon}: set an icon.
                \item \textbf{app:iconPadding}: space between icon and text.
                \item \textbf{app:iconGravity}: where the icon appears (start, end, textStart, textEnd).
                \item \textbf{app:iconTint}: tint icon color.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Events}
    \begin{itemize}
        \item \textbf{View (XML)}
            \begin{itemize}
                \item \textbf{android:onClick}: name of a method in your Activity that gets called when the button is clicked
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Java event listeners}
    \begin{itemize}
        \item \textbf{Views:}
            \begin{itemize}
                \item \textbf{void setOnClickListener(OnClickListener l)}: Registers a listener to be invoked when the view is clicked (short tap).
                \item \textbf{void setOnLongClickListener(OnLongClickListener l)}: Registers a listener to be invoked when the view is long-pressed.
                \item \textbf{void setOnFocusChangeListener(OnFocusChangeListener l)}: Sets a listener that is called whenever the view gains or loses input focus.
                \item \textbf{void setOnTouchListener(OnTouchListener l)}: Sets a listener to receive touch events (e.g., finger down, move, lift) before they are processed by \texttt{onTouchEvent()}.
                \item \textbf{void setOnKeyListener(OnKeyListener l)}: Sets a listener to receive key events (e.g., hardware button presses) before they are passed to \texttt{onKeyDown()} or \texttt{onKeyUp()}.
                \item \textbf{boolean onKeyDown(int keyCode, KeyEvent event)}: Called when a hardware key is pressed down while the view has focus.
                \item \textbf{boolean onKeyUp(int keyCode, KeyEvent event)}: Called when a hardware key is released while the view has focus.
                \item \textbf{boolean onTouchEvent(MotionEvent event)}: Handles touch screen interaction with the view (default implementation supports clicks, scrolls, etc.).
                \item \textbf{boolean onGenericMotionEvent(MotionEvent event)}: Handles non-touch input events such as mouse, joystick, or stylus actions.
                \item \textbf{boolean onKeyPreIme(int keyCode, KeyEvent event)}: Called when a key event occurs before it reaches the input method (useful for intercepting Back button presses while an IME is visible).
                \item \textbf{boolean onTrackballEvent(MotionEvent event)}: Handles trackball events (legacy input for older devices).
            \end{itemize}
        \item \textbf{TextView} 
            \begin{itemize}
                \item \textbf{void addTextChangedListener(TextWatcher watcher)}: Registers a TextWatcher to receive callbacks when the text changes (before, during, or after editing).
                \item \textbf{void removeTextChangedListener(TextWatcher watcher)}: Unregisters a previously added TextWatcher so it no longer receives callbacks.
                \item \textbf{void setOnEditorActionListener(TextView.OnEditorActionListener l)}: Sets a listener to handle editor actions from the soft keyboard (e.g., pressing "Done", "Next", or "Search").
                \item \textbf{void setOnClickListener(View.OnClickListener l)}: Assigns a listener to handle click events when the view is tapped.
                \item \textbf{void setOnLongClickListener(View.OnLongClickListener l)}: Assigns a listener to handle long-click (press-and-hold) events on the view.
                \item \textbf{void setOnFocusChangeListener(View.OnFocusChangeListener l)}: Sets a listener that is triggered when the view gains or loses input focus.
            \end{itemize}
        \item \textbf{EditText}:
            \begin{itemize}
                \item \textbf{void addTextChangedListener(TextWatcher watcher)}: Registers a listener for text changes.
                \item \textbf{void removeTextChangedListener(TextWatcher watcher)}: Unregisters a text change listener.
                \item \textbf{void setOnEditorActionListener(TextView.OnEditorActionListener l)}: Sets a listener for handling IME action events (e.g., pressing Enter, Done, Search).
            \end{itemize}
        \item \textbf{Button:} Subclass of TextView, which is a subclass of View, so all the ones listed above
    \end{itemize}

    \pagebreak 
    \subsection{Java event listeners (2)}
    \begin{itemize}
        \item \textbf{TextWatcher}: The \texttt{TextWatcher} interface, from the android.text package, provides three methods to handle key events.
            \bigbreak \noindent 
            You can attach a TextWatcher to any view that implements Editable text content — meaning subclasses of TextView that allow editing.
            \bigbreak \noindent 
            \begin{javacode}
                import android.text.TextWatcher;
                import android.text.Editable;
                import java.lang.CharSequence;

                .
                .
                .


                private class TextChangeHandler implements TextWatcher {
                    public void beforeTextChanged(CharSequence s, int start, int count, int after )

                    public void onTextChanged(CharSequence s, int start, int before, int after)

                    public void afterTextChanged(Editable e)
                }
            \end{javacode}
            Where (\texttt{beforeTextChanged})
            \begin{itemize}
                \item \textbf{CharSequence s}: The text before the change.
                \item \textbf{int start}: The position (index) in the text where the change will begin.
                \item \textbf{int count}: How many characters are about to be replaced (i.e., how many will be removed).
                \item \textbf{int after}: How many characters will replace the old ones (i.e., how many will be added).
            \end{itemize}
            (onTextChanged)
            \begin{itemize}
                \item \textbf{CharSequence s}: The text after the change (current state).
                \item \textbf{int start}: The position in the text where the change happened.
                \item \textbf{int before}: Number of characters that were replaced (removed).
                \item \textbf{int count}: Number of new characters added.
            \end{itemize}
            \bigbreak \noindent 
            (afterTextChanged)
            \begin{itemize}
                \item \textbf{Editable:}  Represents the text content of the EditText after a change has occurred.
            \end{itemize}
            \bigbreak \noindent 
            Instantiate an instance of the class and attach it to a view with \texttt{.addTextChangedListener()}

        \item \textbf{onClick listener}: Create a private inner class that implements View.OnClickListener, and overrides the function onClick with signature
            \bigbreak \noindent 
            \begin{javacode}
            public void onClick(View v)
            \end{javacode}
            \bigbreak \noindent 
            Create an instance of the inner class and use the function \texttt{setOnClickListener()} to add it to a view.
            \bigbreak \noindent 
            Or, use an anonymous inner class
            \bigbreak \noindent 
            \begin{javacode}
                myView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        ...
                    }
                });
            \end{javacode}

    \end{itemize}


\pagebreak 
    \subsection{Code examples}
    \begin{itemize}
        \item \textbf{Minimum code for controller}:
            \bigbreak \noindent 
            \begin{javacode}
                package com.example.test3;

                import androidx.appcompat.app.AppCompatActivity;

                import android.os.Bundle;

                public class MainActivity extends AppCompatActivity {

                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        setContentView(R.layout.activity_main);
                    }
                }
            \end{javacode}
        \item \textbf{Base theme:} 
            \bigbreak \noindent 
            \begin{xmlcode}
                <style name="Base.Theme.TipCalculator" parent="Theme.Material3.DayNight.NoActionBar">
                    <!-- Customize your light theme here. -->
                    <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
                </style>
            \end{xmlcode}
    \end{itemize}

    \pagebreak 
    \unsect{Java reference}
    \subsection{Activity}
    \begin{itemize}
        \item \textbf{Lifecycle methods}
            \begin{itemize}
                \item \textbf{onCreate(Bundle)}:	Initialize activity (UI layout, variables, listeners). Most important one.
                \item \textbf{onStart()}:	Activity is becoming visible.
                \item \textbf{onResume()}:	Activity is now in the foreground and interactive.
                \item \textbf{onPause()}:	Partially visible — pause resources, stop animations. called when Android starts or resumes another
                \item \textbf{onStop()}:	No longer visible — release resources.
                \item \textbf{onRestart()}:	Called before restarting after being stopped.
                \item \textbf{onDestroy()}:	Final cleanup before activity is removed from memory.
            \end{itemize}
        \item \textbf{Transitions}
            \begin{itemize}
                \item \textbf{overridePendingTransition(int enterAnim, int exitAnim)}:	Overrides the default transition right after calling startActivity() or finish()
                \item \textbf{finishAfterTransition()}: 	Finishes the Activity after shared-element transitions complete
                \item \textbf{postponeEnterTransition()}: 	Waits before running transition (useful while loading images)
                \item \textbf{startPostponedEnterTransition()}: 	Resumes the delayed enter transition
                \item \textbf{setEnterSharedElementCallback(SharedElementCallback)}: 	Customize shared element mapping during enter transition
                \item \textbf{setExitSharedElementCallback(SharedElementCallback)}: 	Same as above, but for exit transitions
            \end{itemize}
        \item \textbf{Transition constants}
            \begin{itemize}
                \item \textbf{TRANSITION\_NONE}:	No animation
                \item \textbf{TRANSITION\_OPEN}:	When an Activity is opened
                \item \textbf{TRANSITION\_CLOSE}:	When an Activity is closed
            \end{itemize}
        \item  \textbf{UI and layout management}
            \begin{itemize}
                \item \textbf{setContentView(int layoutResId)}:	Sets the XML layout for the Activity.
                \item \textbf{findViewById(int id)}:	Get references to UI elements.
            \end{itemize}
        \item \textbf{Navigation and intents}
            \begin{itemize}
                \item \textbf{startActivity(Intent)}:	Launch another Activity.
                \item \textbf{startActivityForResult(Intent, int)}:	Launch an Activity and get returned data. (Deprecated in favor of ActivityResult API, but still widely used.)
                \item \textbf{finish()}:	Close the current Activity.
                \item \textbf{getIntent()}:	Retrieve the Intent that started the Activity.
            \end{itemize}
        \item \textbf{State Preservation}: When configuration changes happen (like screen rotation):
            \begin{itemize}
                \item \textbf{onSaveInstanceState(Bundle)}:	Save UI state before destruction.
                \item \textbf{onRestoreInstanceState(Bundle)}:	Restore saved state after recreation.
            \end{itemize}
        \item \textbf{Menu / UI controls}
            \begin{itemize}
                \item \textbf{onCreateOptionsMenu(Menu)}:	Initialize menu options.
                \item \textbf{onOptionsItemSelected(MenuItem)}:	Handle menu selections.
            \end{itemize}
        \item \textbf{Context-provided Methods}
            \begin{itemize}
                \item \textbf{getApplicationContext()}:	Access app-level context.
                \item \textbf{getSystemService(String)}:	Access system services (e.g., LOCATION\_SERVICE).
                \item \textbf{getSharedPreferences(name, mode)}:	App storage for small data.
            \end{itemize}
        \item \textbf{Dialogs, toasts, and interaction}
            \begin{itemize}
                \item \textbf{runOnUiThread(Runnable)}:	Update UI from a background thread.
                \item \textbf{requestPermissions(String[], int)}:	Ask for runtime permissions.
                \item \textbf{onRequestPermissionsResult(...)}:	Handle permission results.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Context}
    \begin{itemize}
        \item \textbf{What is it}: Context is an interface to global information about your application environment. It gives you access to:
            \begin{itemize}
                \item App resources (colors, strings, layouts, drawables, etc.)
                \item System services (e.g. LayoutInflater, PowerManager, NotificationManager, etc.)
                \item Permissions
                \item Starting new Activities, Services, etc.
            \end{itemize}
            \bigbreak \noindent 
            When you create a View in code:
            \bigbreak \noindent 
            \begin{javacode}
                Button btn = new Button(this);
                GridLayout grid = new GridLayout(this);
            \end{javacode}
            \bigbreak \noindent 
            That this is a Context. In an Activity, this works because Activity is a subclass of Context.
            \bigbreak \noindent 
            The View needs a Context to:
            \begin{itemize}
                \item Know which theme/style to apply
                \item Access resources (e.g., strings, colors, dimensions)
                \item Hook into the Android system for rendering
            \end{itemize}
            Without a Context, a View has no "connection" to the running Android app environment.
    \end{itemize}


    \pagebreak \bigbreak \noindent 
    \subsection{ConstraintLayout}
    \begin{itemize}
        \item \textbf{Needed includes}:
            \bigbreak \noindent 
            \begin{javacode}
                import androidx.constraintlayout.widget.ConstraintLayout;
                import androidx.constraintlayout.widget.ConstraintSet;
                import android.view.ViewGroup;
            \end{javacode}
        \item \textbf{Create ConstraintLayout}:
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout layout = new ConstraintLayout(this);
            \end{javacode}
            The argument \textit{this} is the \textbf{context}, which in this case is the activity.
        \item \textbf{Constraints}: Constraints are essentially sets of rules that dictate the way in which a widget is aligned and distanced in relation to other widgets. The sides of the containing ConstraintLayout and special elements are called \textbf{guidelines}.
            \bigbreak \noindent 
            Constraints also dictate how the user interface layout of an activity will respond to changes in device orientation, or when displayed on devices of differing screen sizes. In order to be adequately configured, a widget must have sufficient constraint connections such that it’s position can be resolved by the ConstraintLayout layout engine in both the horizontal and vertical planes.
        \item \textbf{Margins}: A margin is a form of constraint that specifies a fixed distance. 
        \item \textbf{Opposing Constraints}: Two constraints operating along the same axis on a single widget are referred to as opposing constraints. In other words, a widget with constraints on both its left and right-hand sides is considered to have horizontally opposing constraints. 
            \bigbreak \noindent 
            The key point to understand here is that once opposing constraints are implemented on a particular axis, the positioning of the widget is now based on percentages of the overall dimensions of the ConstraintLayout rather than coordinate based.
            \bigbreak \noindent 
            \fig{.9}{./figures/1008.png}
            \bigbreak \noindent 
            Instead of being fixed at 20dp from the top of the layout, for example, the widget is now positioned at a point 30\% from the top of the layout, regardless of the physical dimensions of the container, or parent layout.
            \bigbreak \noindent 
            In different orientations and when running on larger or smaller screens, the Button will always be in the same location relative to the dimensions of the parent layout.
        \item \textbf{Constraint Bias}: By default, opposing constraints are equal, resulting in the corresponding widget being centered along the axis of opposition. 
            \bigbreak \noindent 
            To allow for the adjustment of widget position in the case of opposing constraints, the ConstraintLayout implements a feature known as constraint bias. Constraint bias allows the positioning of a widget along the axis of opposition to be biased by a specified percentage in favor of one constraint.
            \bigbreak \noindent 
            \fig{.9}{./figures/1009.png}
            \bigbreak \noindent 
            Figure 2b-4, for example, shows the previous constraint layout with a 75\% horizontal bias and 10\% vertical bias:
        \item \textbf{Chains}: ConstraintLayout chains provide a way for the layout behavior of two or more widgets to be defined as a group.
            \bigbreak \noindent 
            Chains can be declared in either the vertical or horizontal axis and configured to define how the widgets in the chain are spaced and sized. Widgets are chained when connected together by bi-directional constraints.
            \bigbreak \noindent 
            \fig{.7}{./figures/1010.png}
            \bigbreak \noindent 
            Figure 2b-5, for example, illustrates three widgets chained in this way
            \bigbreak \noindent 
            The first element in the chain is the chain head which translates to the top widget in a vertical chain or, in the case of a horizontal chain, the left-most widget.
            \bigbreak \noindent 
            The layout behavior of the entire chain is primarily configured by setting attributes on the chain head widget.
        \item \textbf{Chain Styles}: The layout behavior of a ConstraintLayout chain is dictated by the chain style setting applied to the chain head widget; these are as described next.
            \begin{itemize}
                \item \textbf{Spread Chain}: The widgets contained within the chain are distributed evenly across the available space which is the default behavior for chains.
                    \bigbreak \noindent 
                    \fig{.7}{./figures/1011.png}
                \item \textbf{Spread Inside Chain}: The widgets contained within the chain are spread evenly between the chain head and the last widget in the chain. The head and last widgets are not included in the distribution of spacing
                    \fig{.7}{./figures/1012.png}
                \item \textbf{Weighted Chain}: Allows the space taken up by each widget in the chain to be defined via weighting properties.
                    \fig{.7}{./figures/1013.png}
                \item \textbf{Packed Chain}: The widgets that make up the chain are packed together without any spacing. A bias may be applied to control the horizontal or vertical positioning of the chain in relation to the parent container.
                    \fig{.7}{./figures/1014.png}
            \end{itemize}


        \item \textbf{Creating chains with java code}: You do it by manually setting constraints directly on each view’s ConstraintLayout.LayoutParams, using the leftToRight, rightToLeft, topToBottom, etc. fields.
            \bigbreak \noindent 
            Suppose we have three buttons in a ConstraintLayout, 
            \bigbreak \noindent 
            \begin{javacode}
                // --- Button 1 constraints ---
                ConstraintLayout.LayoutParams lp1 = new ConstraintLayout.LayoutParams(
                        ViewGroup.LayoutParams.WRAP_CONTENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp1.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.rightToLeft = btn2.getId();    // Chain with Button 2
                lp1.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.horizontalChainStyle = ConstraintLayout.LayoutParams.CHAIN_SPREAD;
                btn1.setLayoutParams(lp1);

                // --- Button 2 constraints ---
                ConstraintLayout.LayoutParams lp2 = new ConstraintLayout.LayoutParams(
                        ViewGroup.LayoutParams.WRAP_CONTENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp2.leftToRight = btn1.getId();
                lp2.rightToLeft = btn3.getId();
                lp2.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
                lp2.bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID;
                btn2.setLayoutParams(lp2);

                // --- Button 3 constraints ---
                ConstraintLayout.LayoutParams lp3 = new ConstraintLayout.LayoutParams(
                        ViewGroup.LayoutParams.WRAP_CONTENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp3.leftToRight = btn2.getId();
                lp3.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID;
                lp3.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
                lp3.bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID;
                btn3.setLayoutParams(lp3);
            \end{javacode}
        \item \textbf{Chain styles in java}:
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout.LayoutParams.CHAIN_SPREAD
                ConstraintLayout.LayoutParams.CHAIN_SPREAD_INSIDE
                ConstraintLayout.LayoutParams.CHAIN_PACKED
            \end{javacode}
            \bigbreak \noindent 
            Notice that in the above example, we give \texttt{ConstraintLayout.LayoutParams.CHAIN\_SPREAD} to the head button in the chain.
        \item \textbf{Weighted chain in java}: To make a weighted chain, you must:
            \begin{enumerate}
                \item Use \texttt{MATCH\_CONSTRAINT} (0dp) for the dimension you want to weight (width in a horizontal chain, height in a vertical one).
                \item Assign a weight to each view using layoutParams.horizontalWeight or layoutParams.verticalWeight.
                \item Use either \texttt{CHAIN\_SPREAD} or \texttt{CHAIN\_SPREAD\_INSIDE} style.
            \end{enumerate}
            \bigbreak \noindent 
            For example, consider again those three buttons
            \bigbreak \noindent 
            \begin{javacode}
                // ---- Button 1 ----
                ConstraintLayout.LayoutParams lp1 = new ConstraintLayout.LayoutParams(
                        0,  // MATCH_CONSTRAINT for weighted width
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp1.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID;
                lp1.rightToLeft = btn2.getId();
                lp1.horizontalWeight = 1f; // weight = 1
                lp1.horizontalChainStyle = ConstraintLayout.LayoutParams.CHAIN_SPREAD;
                btn1.setLayoutParams(lp1);

                // ---- Button 2 ----
                ConstraintLayout.LayoutParams lp2 = new ConstraintLayout.LayoutParams(
                        0,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp2.leftToRight = btn1.getId();
                lp2.rightToLeft = btn3.getId();
                lp2.horizontalWeight = 2f; // weight = 2
                btn2.setLayoutParams(lp2);

                // ---- Button 3 ----
                ConstraintLayout.LayoutParams lp3 = new ConstraintLayout.LayoutParams(
                        0,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                );
                lp3.leftToRight = btn2.getId();
                lp3.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID;
                lp3.horizontalWeight = 1f; // weight = 1
                btn3.setLayoutParams(lp3);
            \end{javacode}
        \item \textbf{MATCH\_CONSTRAINT}: Let’s break down what MATCH\_CONSTRAINT means, how it differs from WRAP\_CONTENT and MATCH\_PARENT, and when you use it.
            \bigbreak \noindent 
            MATCH\_CONSTRAINT is a special size mode in ConstraintLayout that tells a view:
            \bigbreak \noindent 
            \begin{center}
                "Size yourself dynamically based on your constraints, rather than fixed content or parent size."
            \end{center}
            \bigbreak \noindent 
            In Java, it’s specified by setting the dimension (width or height) to 0 in the layout params:
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout.LayoutParams params = new ConstraintLayout.LayoutParams(0, WRAP_CONTENT);
            \end{javacode}
            \bigbreak \noindent 
            View size is flexible and determined by the constraints and optionally by weights or ratios
        \item \textbf{Baseline Alignment}: So far,  we have only  referred to constraints that dictate alignment relative to the sides of a widget (typically referred to as side constraints).
            \bigbreak \noindent 
            A common requirement, however, is for a widget to be aligned relative to the content that it displays rather than the boundaries of the widget itself. To address this need, ConstraintLayout provides baseline alignment support.
            \bigbreak \noindent 
            Every view that displays text (e.g. TextView, EditText, Button) has a \textbf{text baseline} - the imaginary horizontal line upon which the text "sits."
            \bigbreak \noindent 
            Baseline alignment means you’re aligning two or more views based on that text baseline, instead of their tops or bottoms.
            \bigbreak \noindent 
            Suppose we require a TextView widget to be positioned 40dp to the left of the Button. 
            \bigbreak \noindent 
            In this case, the TextView needs to be baseline aligned with the Button view.
            \bigbreak \noindent 
            This means that the text within the Button needs to be vertically aligned with the text within the TextView.
            \bigbreak \noindent 
            \fig{.8}{./figures/1015.png}
            \bigbreak \noindent 
            The TextView is now aligned vertically along the baseline of the Button and positioned 40dp horizontally from the Button object’s left-hand edge.
            \bigbreak \noindent 
            In Java, you connect one view’s baseline to another view’s baseline using:
            \bigbreak \noindent 
            \begin{javacode}
            params.baselineToBaseline = otherView.getId();
            \end{javacode}
            \bigbreak \noindent 
            You can combine this with other constraints like leftToLeft, topToTop, etc.
        \item \textbf{Working with Guidelines}: Guidelines are special elements available within the ConstraintLayout that provide an additional target to which constraints may be connected.
            \bigbreak \noindent 
            Multiple guidelines may be added to a ConstraintLayout instance which may, in turn, be configured in horizontal or vertical orientations.
            \bigbreak \noindent 
            Once added, constraint connections may be established from widgets in the layout to the guidelines. This is particularly useful when multiple widgets need to be aligned along an axis. 
            \bigbreak \noindent 
            \fig{.8}{./figures/1016.png}
        \item \textbf{Guidelines in java}: First we create a \texttt{Guideline} object, then configure \texttt{ConstraintLayout.LayoutParams} for it.
            \bigbreak \noindent 
            \begin{javacode}
                import androidx.constraintlayout.widget.Guideline 

                // 1) Make the guideline
                Guideline vGuide = new Guideline(this);
                vGuide.setId(View.generateViewId());

                ConstraintLayout.LayoutParams vgLP = new ConstraintLayout.LayoutParams(
                        ConstraintLayout.LayoutParams.WRAP_CONTENT,
                        ConstraintLayout.LayoutParams.WRAP_CONTENT
                );
                vgLP.orientation = ConstraintLayout.LayoutParams.VERTICAL;
                // Choose ONE of these three ways to position it:
                vgLP.guidePercent = 0.30f;   // 30% from the left (0..1)
                // vgLP.guideBegin  = 120;    // 120px from the left
                // vgLP.guideEnd    = 16;     // 16px from the right

                vGuide.setLayoutParams(vgLP);
                layout.addView(vGuide);

                // 2) Constrain a view to the guideline
                TextView tv = new TextView(this);
                tv.setId(View.generateViewId());
                tv.setText("Hello");
                ConstraintLayout.LayoutParams tvLP = new ConstraintLayout.LayoutParams(
                0,  // MATCH_CONSTRAINT width so it can expand between guideline and parent
                ConstraintLayout.LayoutParams.WRAP_CONTENT
                );
                tvLP.leftToRight = vGuide.getId();                       // to the right of guideline
                tvLP.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID;
                tvLP.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;

                tv.setLayoutParams(tvLP);
                layout.addView(tv);

                setContentView(layout);
            \end{javacode}
            \bigbreak \noindent 
            \textbf{Note:} \texttt{ConstraintLayout.LayoutParams.orientation} is a property that only applies to Guidelines, not to regular Views.
            \bigbreak \noindent 
            \texttt{ConstraintLayout.LayoutParams.orientation} tells the ConstraintLayout whether a Guideline is:
            \begin{itemize}
                \item \textbf{Vertical}: divides the layout left $\leftrightarrow $ right
                \item \textbf{Horizontal}: divides the layout top $\leftrightarrow$ bottom
            \end{itemize}
        \item \textbf{Working with Barriers}: Rather like guidelines, barriers are virtual views that can be used to constrain views within a layout
            \bigbreak \noindent 
            As with guidelines, a barrier can be vertical or horizontal and one or more views may be constrained to it (to avoid confusion, these will be referred to as constrained views).
            \bigbreak \noindent 
            Unlike guidelines where the guideline remains at a fixed position within the layout, however, the position of a barrier is defined by a set of so called reference views.
            \bigbreak \noindent 
            Barriers were introduced to address an issue that occurs with some frequency involving overlapping views.
            \bigbreak \noindent 
            Consider the following example
            \bigbreak \noindent 
            \fig{.8}{./figures/1017.png}
            \bigbreak \noindent 
            The key points to note about the above layout is that the width of View 3 is set to match constraint mode, and the left-hand edge of the view is connected to the right hand edge of View 1.
            \bigbreak \noindent 
            As currently implemented, an increase in width of View 1 will have the desired effect of reducing the width of View 3:
            \bigbreak \noindent 
            \fig{.8}{./figures/1018.png}
            \bigbreak \noindent 
            A problem arises, however, if View 2 increases in width instead of View 1:
            \bigbreak \noindent 
            \fig{.8}{./figures/1019.png}
            \bigbreak \noindent 
            Clearly because View 3 is only constrained by View 1, it does not resize to accommodate the increase in width of View 2 causing the views to overlap.
            \bigbreak \noindent 
            A solution to this problem is to add a vertical barrier and assign Views 1 and 2 as the barrier’s reference views so that they control the barrier position.
            \bigbreak \noindent 
            The left-hand edge of View 3 will then be constrained in relation to the barrier, making it a constrained view.
            \bigbreak \noindent 
            Now when either View 1 or View 2 increase in width, the barrier will move to accommodate the widest of the two views, causing the width of View 3 change in relation to the new barrier position:
            \bigbreak \noindent 
            \fig{.6}{./figures/1020.png}
            \bigbreak \noindent 
            When working with barriers there is no limit to the number of reference views and constrained views that can be associated with a single barrier.
        \item \textbf{Barriers in java}: A Barrier is a virtual helper object in ConstraintLayout that positions itself dynamically based on the position of other views. It’s like a movable guideline that automatically adjusts to the furthest edge of a group of views.
            \bigbreak \noindent 
            Assume we have two TextViews
            \bigbreak \noindent 
            \begin{javacode}
                import androidx.constraintlayout.widget.Barrier;

                // --- Create a barrier ---
                Barrier barrier = new Barrier(this);
                barrier.setId(View.generateViewId());
                barrier.setType(Barrier.END); // or LEFT, RIGHT, START, TOP, BOTTOM
                barrier.setReferencedIds(new int[]{label1.getId(), label2.getId()});
                layout.addView(barrier);

                // Create a button that stays to the right of both text views
                Button btn = new Button(this);
                btn.setId(View.generateViewId());
                btn.setText("Aligned with longest");
                ConstraintLayout.LayoutParams lp3 = new ConstraintLayout.LayoutParams(
                        ConstraintLayout.LayoutParams.WRAP_CONTENT,
                        ConstraintLayout.LayoutParams.WRAP_CONTENT
                );
                lp3.startToEnd = barrier.getId(); // use barrier directly
                lp3.topToTop = t1.getId();       // align top with first label
                lp3.leftMargin = 16;
                btn.setLayoutParams(lp3);

                layout.addView(btn);

                ...
            \end{javacode}

        \item \textbf{Barrier types}: Barrier types you can use:
            \begin{itemize}
                \item Barrier.START
                \item Barrier.END
                \item Barrier.LEFT
                \item Barrier.RIGHT
                \item Barrier.TOP
                \item Barrier.BOTTOM
            \end{itemize}
            Which are explained in the following table
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{4cm}|p{3cm}|p{2cm}|p{3cm}}
                    Constant	&Tracks the...	&Moves toward...	&Typical Use \\
                    \hline \\
                    Barrier.START	&Start edges (left in LTR, right in RTL)	&Start side	&Keep something to the left of the leftmost view \\ && \\
                    Barrier.END	End &edges (right in LTR, left in RTL)	&End side	&Keep something to the right of the rightmost view \\&& \\ 
                    Barrier.LEFT	&Left edges (absolute)	&Left side	&Same as START but ignores layout direction \\ && \\
                    Barrier.RIGHT	&Right edges (absolute)	&Right side	&Same as END but ignores layout direction \\ && \\
                    Barrier.TOP	&Top edges	&Upward	&Keep something below the topmost/tallest view \\ && \\
                    Barrier.BOTTOM	&Bottom edges	&Downward	&Keep something below the lowest/bottommost view 
                \end{tabular}
            \end{center}






        \item \textbf{ConstraintLayout.LayoutParams}: Has constructor
            \bigbreak \noindent 
            \begin{javacode}
            ConstraintLayout.LayoutParams(int width, int height)
            \end{javacode}
            Lets you define width and height (MATCH\_PARENT, WRAP\_CONTENT, or px).
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent 
            \begin{javacode}
                ConstraintLayout.LayoutParams lp =
                    new ConstraintLayout.LayoutParams(
                    ViewGroup.LayoutParams.WRAP_CONTENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT
                );
            \end{javacode}
            Then, we can add constraints, Each field takes an ID of another view (or PARENT\_ID):
            \begin{itemize}
                \item \textbf{leftToLeft}: Align the left edge of this view to the left edge of another view (or parent).
                \item \textbf{leftToRight}: Align the left edge of this view to the right edge of another view.
                \item \textbf{rightToLeft}: Align the right edge of this view to the left edge of another view.
                \item \textbf{rightToRight}: Align the right edge of this view to the right edge of another view.
                \item \textbf{topToTop}: Align the top edge of this view to the top edge of another view.
                \item \textbf{topToBottom}: Align the top edge of this view to the bottom edge of another view.
                \item \textbf{bottomToTop}: Align the bottom edge of this view to the top edge of another view.
                \item \textbf{bottomToBottom}: Align the bottom edge of this view to the bottom edge of another view.
                \item \textbf{startToStart}: Align the start edge of this view to the start edge of another view.
                \item \textbf{startToEnd}: Align the start edge of this view to the end edge of another view.
                \item \textbf{endToStart}: Align the end edge of this view to the start edge of another view.
                \item \textbf{endToEnd}: Align the end edge of this view to the end edge of another view.
                \item \textbf{horizontalBias(float b)}: $b \times 100$ percent from left
                \item \textbf{verticalBias(float b)}: $b \times 100$ percent from top
            \end{itemize}
            \bigbreak \noindent 
            \textbf{Note:}
            \begin{itemize}
                \item left/right = physical edges (always left/right of the screen).
                \item start/end = logical edges (switch meaning in RTL layouts).
            \end{itemize}
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent 
            \begin{javacode}
            lp.topToTop = ConstraintLayout.LayoutParams.PARENT_ID;
            \end{javacode}
            \bigbreak \noindent 
            We also have chains, for arranging multiple views in a line with flexible spacing:
        \item \textbf{Retrieve and update LayoutParams}:
            \bigbreak \noindent 
            \begin{javacode}
            ConstraintLayout.LayoutParams lp = (ConstraintLayout.LayoutParams) view.getLayoutParams();
            ...
            view.setLayoutParams(lp);
            \end{javacode}





    \end{itemize}

    \pagebreak 
    \subsection{GridLayout}
    \bigbreak \noindent 
    GridLayout is a type of ViewGroup that arranges its children in a grid of rows and columns.
    \bigbreak \noindent 
    Each child view is placed into a "cell" defined by its row and column. You can make a child span multiple rows or columns. It’s similar to a table layout but more flexible (alignments, spans, etc.).
    \begin{itemize}
        \item \textbf{Needed Includes}:
            \bigbreak \noindent 
            \begin{javacode}
                import android.content.Context;
                import android.view.ViewGroup;
                import android.widget.GridLayout;
            \end{javacode}
        \item \textbf{Create GridLayout}: You can make a GridLayout in code just like any other layout:
            \bigbreak \noindent 
            \begin{javacode}
                GridLayout grid = new GridLayout(this);   // "this" = Context, usually Activity
                grid.setRowCount(3);                      // number of rows
                grid.setColumnCount(3);                   // number of columns
            \end{javacode}
        \item \textbf{Setting LayoutParams for GridLayout}: We use ViewGroup.LayoutParams to set the layout params for the entire grid container.
            \bigbreak \noindent 
            \begin{javacode}
                grid.setLayoutParams(
                    new ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT
                    )
                );
            \end{javacode}
            
        \item \textbf{GridLayout.LayoutParams}: You need GridLayout.LayoutParams for child views placed inside a GridLayout. GridLayout.LayoutParams is the special layout parameter class that children of a GridLayout must use.
            \bigbreak \noindent 
         It tells the GridLayout parent:
            \begin{itemize}
                \item Which row and column this child belongs to
                \item How many cells to span
                \item How to align inside those cells
                \item How much margin space it should have
            \end{itemize}
            For example,
            \bigbreak \noindent 
            \begin{javacode}
                Button btn = new Button(this);
                btn.setText("Hi");

                GridLayout.LayoutParams btnLp = new GridLayout.LayoutParams(
                        GridLayout.spec(0),  // row 0
                        GridLayout.spec(1)   // column 1
                );
                btnLp.width = GridLayout.LayoutParams.WRAP_CONTENT;
                btnLp.height = GridLayout.LayoutParams.WRAP_CONTENT;

                btn.setLayoutParams(btnLp);
                grid.addView(btn);
            \end{javacode}
            \bigbreak \noindent 
            \texttt{GridLayout.spec(int index)} creates a Spec object. A Spec describes a position in either rows or columns. Here, GridLayout.spec(0) means row 0 (the first row), and GridLayout.spec(1) means the first column.
        \item \textbf{GridLayout.spec overloads}:
            \bigbreak \noindent 
            \begin{javacode}
                GridLayout.spec(int index) // Single index, default span=1, default alignment = UNDEFINED
                GridLayout.spec(int index, int size) // Index + span
                GridLayout.spec(int index, Alignment align) // Index + alignment
                GridLayout.spec(int index, int size, Alignment align) // Index + span + alignment
            \end{javacode}
            You can pass these alignment constants:
            \begin{itemize}
                \item \textbf{GridLayout.START}: align to start (left or top).
                \item \textbf{GridLayout.END}: align to end (right or bottom).
                \item \textbf{GridLayout.CENTER}: center inside the cell.
                \item \textbf{GridLayout.FILL}: expand to fill the cell.
            \end{itemize}
            (BASELINE exists for aligning text baselines in rows.)

        \item \textbf{Rule of thumb}: 
            Use ViewGroup.LayoutParams when sizing a container relative to its parent.
            \bigbreak \noindent 
            Use the container’s own LayoutParams subclass (GridLayout.LayoutParams, LinearLayout.LayoutParams, etc.) when adding children inside that container.
        \item \textbf{Using MarginLayoutParams on GridLayout.setLayoutParams}: This affects the GridLayout as a whole, not its children.
            \bigbreak \noindent 
            For example, 
            \bigbreak \noindent 
            \begin{javacode}
                ViewGroup.MarginLayoutParams lp =
                new ViewGroup.MarginLayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT
                );

                lp.setMargins(20, 40, 20, 40); // left, top, right, bottom in px

                grid.setLayoutParams(lp);
            \end{javacode}

    \end{itemize}

    \pagebreak 
    \subsection{Button}
    \begin{itemize}
        \item \textbf{Subclass}: Buttons are a subclass of TextView, which is a subclass of View 
        \item \textbf{Creating buttons}: There are basically 3 parts:
            \begin{enumerate}
                \item Construct the Button (needs a Context)
                \item Customize it (text, size, colors, etc.)
                \item Add it to a parent layout (like GridLayout, LinearLayout, etc.) with proper LayoutParams.
            \end{enumerate}
            To create the button,
            \bigbreak \noindent 
            \begin{javacode}
            Button myButton = new Button(context);
            \end{javacode}
        \item \textbf{Button methods}:
            \begin{itemize}
                \item setTextSize(int size)
                \item setOnClickListener(listener)
                \item setEnabled(boolean status)
                \item setText(string text)
                \item setLayoutParams(lp)
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{TextView and EditText}
    \begin{itemize}
        \item \textbf{Creating TextView}: TextView is a subclass of View
            \bigbreak \noindent 
            \begin{javacode}
            TextView textView = new TextView(context);
            \end{javacode}
        \item \textbf{TextView methods}:
            \begin{itemize}
                \item setWidth(int w)
                \item setHeight(int h)
                \item setGravity(Gravity g)
                \item setBackgroundColor(Color c)
                \item setTextSize(int size)
                \item setText(string text)
                \item setBackgroundColor(Color c)
                \item setLayoutParams(lp)
                \item setTypeFace(Typeface font, int style)
            \end{itemize}
        \item \textbf{Creating EditText}: EditText is a subclass of TextView, which is a subclass of View
            \bigbreak \noindent 
            \begin{javacode}
            EditText editText = new EditText(context);
            \end{javacode}
        \item \textbf{EditText methods}:
            \begin{itemize}
                \item setWidth(int w)
                \item setHeight(int h)
                \item setHint(String)
                \item setGravity(Gravity g)
                \item setBackgroundColor(Color c)
                \item setTextSize(int size)
                \item setText(string text)
                \item setBackgroundColor(Color c)
                \item setLayoutParams(lp)
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{AutoCompleteTextView}
    \begin{itemize}
        \item \textbf{Intro}: AutoCompleteTextView is just an EditText with a dropdown list of suggestions. Those suggestions come from an Adapter (usually ArrayAdapter).
        \item \textbf{XML}
            \bigbreak \noindent 
            \begin{xmlcode}
                <AutoCompleteTextView
                android:id="@+id/autoTextView"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Type something"
                android:completionThreshold="1" />
            \end{xmlcode}
            \bigbreak \noindent 
            \texttt{android:completionThreshold="1"} means start showing suggestions after typing 1 character.
        \item \textbf{Java}
            \bigbreak \noindent 
            \begin{javacode}
                AutoCompleteTextView autoText = findViewById(R.id.autoTextView);

                // List of suggestions
                String[] courses = {
                    "CSCI 240",
                    "CSCI 241",
                    "CSCI 330",
                    "CSCI 340",
                    "MATH 240",
                    "MATH 350"
                };

                // Adapter
                ArrayAdapter<String> adapter = new ArrayAdapter<>(
                this,
                android.R.layout.simple_dropdown_item_1line,
                courses
                );

                autoText.setAdapter(adapter);
            \end{javacode}
        \item \textbf{Handling clicks}
            \bigbreak \noindent 
            \begin{javacode}
                autoText.setOnItemClickListener(new AdapterView.OnItemClickListener() {
                    @Override
                    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                        String selected = parent.getItemAtPosition(position).toString();
                        Toast.makeText(MainActivity.this, "You chose: " + selected, Toast.LENGTH_SHORT).show();
                    }
                });
            \end{javacode}
        \item \textbf{With SQLite DB}
            \bigbreak \noindent 
            \begin{javacode}
                ArrayList<String> names = db.getAllNames();  // from SQLite
                ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_dropdown_item_1line, names);
                autoText.setAdapter(adapter);
            \end{javacode}


    \end{itemize}

    \pagebreak 
    \subsection{Color}
    \begin{itemize}
        \item \textbf{Color constants}: This class defines color constants and helper methods for working with colors.
            \bigbreak \noindent 
            \begin{javacode}
            Color.RED
            Color.BLUE
            Color.BLACK
            Color.WHITE
            \end{javacode}
            \bigbreak \noindent 
            These are just integer values representing ARGB colors.
        \item \textbf{Create colors}:
            \begin{itemize}
                \item ARGB values (alpha, red, green, blue):
                \bigbreak \noindent 
                \begin{javacode}
                int myColor = Color.argb(255, 100, 200, 150);
                \end{javacode}
                \bigbreak \noindent 
                Here, 255 = fully opaque.
            \item RGB values (no alpha, alpha = 255):
                \bigbreak \noindent 
                \begin{javacode}
                int myColor = Color.rgb(100, 200, 150);
                \end{javacode}
            \item Parse from string:
                \bigbreak \noindent 
                \begin{javacode}
                int myColor = Color.parseColor("#FF5722");  // hex code
                \end{javacode}
            \end{itemize}

    \end{itemize}


    \pagebreak
    \subsection{Context}
    \begin{itemize}

    \end{itemize}

    \pagebreak
    \subsection{Configuration}
    \begin{itemize}

    \end{itemize}

    \pagebreak
    \subsection{Resources}
    \begin{itemize}

    \end{itemize}

    \pagebreak
    \subsection{Resources.Theme}
    \begin{itemize}

    \end{itemize}

    \pagebreak
    \subsection{TypedValue}
    \begin{itemize}
        \item \textbf{What is it}: TypedValue is a lightweight container class in the Android framework. It holds the raw, unresolved, low-level data for a resource value after the system loads it from XML, resources, or themes.
            \bigbreak \noindent 
            It is used internally whenever Android needs to interpret a resource, and it is used by developers when retrieving resource attributes dynamically (for example, via resolveAttribute, getValue, or theme-based lookups).
        \item \textbf{What TypedValue stores}: A TypedValue instance contains:
            \begin{itemize}
                \item \textbf{type:} the kind of resource (dimension, string, color, integer, reference, attribute, etc.).
                \item \textbf{data:} the raw value, usually a packed integer containing the actual information.
                \item \textbf{density:} density information for images or units.
                \item \textbf{string:} the string content when the resource is a text value.
                \item \textbf{resourceId:} the ID of the referenced resource, if applicable.
            \end{itemize}
            \textbf{Note:} The important point is that TypedValue does not interpret the data itself; it simply stores what the system loaded, and you then use helper methods to convert or resolve it.
        \item \textbf{Resolving a theme attribute}: This is the most common usage in application code:
            \bigbreak \noindent 
            \begin{javacode}
                TypedValue tv = new TypedValue();
                if (getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
                    int px = TypedValue.complexToDimensionPixelSize(
                        tv.data,
                        getResources().getDisplayMetrics()
                    );
                }
            \end{javacode}
            \begin{itemize}
                \item \texttt{resolveAttribute} fills the TypedValue with the raw data from the current theme.
                \item \texttt{complexToDimensionPixelSize} interprets the packed dimension stored in tv.data.
            \end{itemize}
        \item \textbf{Retrieving primitive resource values}: 
            \bigbreak \noindent 
            \begin{javacode}
                getResources().getValue(R.dimen.padding_large, tv, true);
            \end{javacode}
        \item \textbf{Complex data format}: A complex data value is something stored in the binary form defined in TypedValue. It represents:
            \begin{itemize}
                \item dimensions (e.g., 16dp, 24sp)
                \item fractions (e.g., 50\%p)
                \item other packed values with units
            \end{itemize}
            The internal integer layout looks like:
            \begin{itemize}
                \item \textbf{high 8 bits:} unit type (dp, sp, px, in, mm)
                \item \textbf{next bits:} radix (how the number was represented)
                \item \textbf{last 23 bits:} mantissa
            \end{itemize}
        \item \textbf{Why the Data Is “Complex”}: Most of Android’s dimensions, colors, and numbers are not stored as simple integers. They are stored in a compact binary form called a complex data format.
            \bigbreak \noindent 
            For example, 
            \begin{itemize}
                \item 16dp
                \item 14sp
                \item #FF00FF
                \item ?attr/colorPrimary
            \end{itemize}
    \end{itemize}

    \pagebreak
    \subsection{DisplayMetrics}
    \begin{itemize}

    \end{itemize}

    \pagebreak
    \subsection{Log}
    \begin{itemize}

    \end{itemize}

    \pagebreak
    \subsection{WindowManager (Interface)}
    \begin{itemize}

    \end{itemize}

    \pagebreak
    \subsection{Display}
    \begin{itemize}

    \end{itemize}




    \pagebreak 
    \subsection{Gravity}
    \begin{itemize}
        \item \textbf{Intro}: This class defines constants used to position or align content inside a View.
            \bigbreak \noindent 
            It doesn’t move the view itself — it controls how the content inside a view (like text in a TextView) or a child inside a parent layout is aligned.
            \begin{itemize}
                \item Gravity.LEFT / Gravity.RIGHT
                \item Gravity.TOP / Gravity.BOTTOM
                \item Gravity.CENTER (both horizontally + vertically)
                \item Gravity.CENTER\_HORIZONTAL
                \item Gravity.CENTER\_VERTICAL
                \item Gravity.FILL (stretch to fill)
            \end{itemize}
            Use bitwise OR (|) to combine:
            \bigbreak \noindent 
            \begin{javacode}
            textView.setGravity(Gravity.CENTER | Gravity.BOTTOM);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsection{DiaglogInterface and AlertDialog}
    \begin{itemize}
        \item \textbf{AlertDialog}: A subclass of Dialog. Used to show a modal pop-up window on top of the activity — typically for alerts, confirmations, or choices
            It can have:
            \begin{itemize}
                \item A title
                \item A message
                \item Optional icon
                \item Up to 3 buttons (Positive, Negative, Neutral)
                \item Custom layouts (if you want more than just text)
            \end{itemize}
        \item \textbf{Create an alert}:
            \bigbreak \noindent 
            \begin{javacode}
            AlertDialog.Builder alert = new AlertDialog.Builder(this);
            ...
            AlertDialog dialog = alert.create();
            dialog.show();
            \end{javacode}
        \item \textbf{AlertDialog.builder methods}
            \begin{itemize}
                \item alert.setTitle(string title);
                \item alert.setMessage(string message);
                \item alert.setPositiveButton(string buttonText, DialogInterface.onClickListener);
                \item alert.setNegativeButton(string buttonText, DialogInterface.onClickListener);
                \item alert.show();
            \end{itemize}
        \item \textbf{DialogInterface}: This is just an interface. Many dialog-related classes (including AlertDialog) implement it.
            \bigbreak \noindent 
            \begin{javacode}
                public interface DialogInterface {
                    void cancel();
                    void dismiss();

                    interface OnCancelListener {
                        void onCancel(DialogInterface dialog);
                    }

                    interface OnDismissListener {
                        void onDismiss(DialogInterface dialog);
                    }

                    interface OnClickListener {
                        void onClick(DialogInterface dialog, int which);
                    }

                    // ... and others like OnKeyListener, OnMultiChoiceClickListener
                }
            \end{javacode}
            \bigbreak \noindent 
            It gives you common methods to control the dialog:
            \begin{itemize}
                \item \textbf{dismiss()}: close the dialog
                \item \textbf{cancel()}: cancel the dialog (triggers onCancel() callback)
            \end{itemize}
            It’s also used in listeners for button clicks.
        \item \textbf{DialogInterface.OnClickListener}: We can use this interface to show the alert when something is clicked.
            \bigbreak \noindent 
            \begin{javacode}
                private class MyDialog implements DialogInterface.OnClickListener
                {

                    public void onClick(DialogInterface dialog, int which)
                    {
                        
                    }
                }
            \end{javacode}
            \bigbreak \noindent 
            The which parameter in listeners
            \begin{itemize}
                \item DialogInterface.BUTTON\_POSITIVE (-1)
                \item DialogInterface.BUTTON\_NEGATIVE (-2)
                \item DialogInterface.BUTTON\_NEUTRAL (-3)
            \end{itemize}
            So you know which button was pressed.
            \bigbreak \noindent 
            The dialog parameter is a reference to the dialog that triggered the click. Its type is the interface DialogInterface, but in practice it will usually be an instance of a concrete class like AlertDialog.
            You can use this reference to control the dialog inside the callback:
            \begin{itemize}
                \item \textbf{dialog.dismiss()}: close the dialog immediately.
                \item \textbf{dialog.cancel()}: cancel the dialog (triggers OnCancelListener if one is set).
            \end{itemize}
            \bigbreak \noindent 
            \begin{javacode}
                builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int id) {
                        // dialog is the AlertDialog, typed as DialogInterface
                        dialog.dismiss();   // closes it
                    }
                });
            \end{javacode}

    \end{itemize}

    \pagebreak 
    \subsection{GradientDrawable}
    \begin{itemize}
        \item \textbf{Includes}:
            \bigbreak \noindent 
            \begin{javacode}
                import android.graphics.drawable.GradientDrawable;
            \end{javacode}
        \item \textbf{GradientDrawable}: A GradientDrawable is a drawable object (something you can use as a background or graphic) that can display:
            \begin{itemize}
                \item Solid colors, or Gradients (color transitions),
            \end{itemize}
            and can have:
            \begin{itemize}
                \item Rounded corners,
                \item Borders (strokes),
                \item Different shapes (rectangle, oval, line, ring).
            \end{itemize}
            Essentially, it’s Android’s built-in shape painter
        \item \textbf{Creation}:
            \bigbreak \noindent 
            \begin{javacode}
            GradientDrawable shape = new GradientDrawable();
            \end{javacode}
        \item \textbf{Methods}:
            \begin{center}
                \begin{tabular}{p{4cm}|p{4cm}|p{4cm}}
                    \hline
                    \textbf{Method} & \textbf{Description} & \textbf{Example Usage} \\
                    \hline
                    \texttt{setShape(int shape)} & Sets the type: \texttt{RECTANGLE}, \texttt{OVAL}, \texttt{LINE}, \texttt{RING} & \texttt{setShape(GradientDrawable.OVAL)} \\
                    \hline
                    \texttt{setCornerRadius(float radius)} & Rounds the corners (only works for rectangles) & \texttt{setCornerRadius(30f)} \\
                    \hline
                    \texttt{setCornerRadii(float[] radii)} & Gives each corner a different roundness & \texttt{setCornerRadii(new float[]{20,20,0,0,20,20,0,0})} \\
                    \hline
                    \texttt{setColor(int color)} & Fills with a solid color & \texttt{setColor(Color.BLUE)} \\
                    \hline
                    \texttt{setStroke(int width, int color)} & Adds a border & \texttt{setStroke(3, Color.WHITE)} \\
                    \hline
                    \texttt{setGradientType(int type)} & Chooses gradient: \texttt{LINEAR}, \texttt{RADIAL}, \texttt{SWEEP} & \texttt{setGradientType(GradientDrawable.LINEAR\_GRADIENT)} \\
                    \hline
                    \texttt{setColors(int[] colors)} & Defines colors for gradient transitions & \texttt{setColors(new int[]{Color.RED, Color.YELLOW})} \\
                    \hline
                \end{tabular}
            \end{center}
        \item \textbf{Using GradientDrawable}: We can then call .setBackground() on a view, passing in our GradientDrawable.
        \item \textbf{Giving a button rounded edges}:
            \bigbreak \noindent 
            \begin{javacode}
                Button b = new Button();

                GradientDrawable button_shape = new GradientDrawable();
                button_shape.setShape(GradientDrawable.RECTANGLE);
                button_shape.setCornerRadius(35f);
                button_shape.setColor(PURPLE);

                b.setBackground(button_shape);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsection{android.graphics.Typeface}
    \begin{itemize}
        \item \textbf{Typeface class}: the Typeface class in Android is the foundation for all text styling related to fonts and weight (bold, italic, etc.). It represents the font face used to render text on screen — in a TextView, Canvas, or anywhere text is drawn.
            \bigbreak \noindent 
            A \texttt{Typeface} is an object that describes the style and family of a font. It defines how text looks — e.g. whether it’s serif or sans-serif, bold or italic, or even a custom font you loaded.
        \item \textbf{Font family constants}:
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{4cm}|p{4cm}|p{4cm}}
                    Constant	&Font family	&Appearance \\
                    \hline \\[0.01cm]
                    Typeface.DEFAULT	&Default system font (usually Roboto on newer Androids)	&Plain \\[2ex]
                    Typeface.SANS\_SERIF	&Sans-serif	&Clean, modern \\[2ex]
                    Typeface.SERIF	&Serif	&Classic (like Times New Roman) \\[2ex]
                    Typeface.MONOSPACE	&Monospace	&Fixed-width (like Courier New)
                \end{tabular}
            \end{center}
        \item \textbf{Weight constants}:
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{4cm}|p{1cm}}
                    Constant	&Style \\ 
                    \hline \\[0.01cm]
                    Typeface.NORMAL	&0 \\[2ex]
                    Typeface.BOLD	&1 \\[2ex]
                    Typeface.ITALIC	&2 \\[2ex]
                    Typeface.BOLD\_ITALIC	&3
                \end{tabular}
            \end{center}
        \item \textbf{Using with setTypeFace}
            \bigbreak \noindent 
            \begin{javacode}
            label.setTypeface(Typeface.SERIF, Typeface.BOLD);
            \end{javacode}
        \item \textbf{Null as a parameter}: We can set the font family but not weight
            \bigbreak \noindent 
            \begin{javacode}
            label.setTypeface(null, Typeface.BOLD);
            \end{javacode}
            \bigbreak \noindent 
            We can set the family but not weight by using the overload that only accepts a family
            \bigbreak \noindent 
            \begin{javacode}
            label.setTypeface(Typeface.SERIF);
            \end{javacode}
        \item \textbf{Loading custom font from res/font}: If you have \texttt{res/font/roboto\_bold.ttf}, you can load it like:
            \bigbreak \noindent 
            \begin{javacode}
                Typeface roboto = ResourcesCompat.getFont(this, R.font.roboto_bold);
                textView.setTypeface(roboto);
            \end{javacode}
            \bigbreak \noindent 
            or programmatically from assets:
            \bigbreak \noindent 
            \begin{javacode}
                Typeface tf = Typeface.createFromAsset(getAssets(), "fonts/CustomFont.ttf");
                textView.setTypeface(tf);
            \end{javacode}
        \item \textbf{Methods}:
            \bigbreak \noindent 
            \begin{center}
                \begin{tabular}{p{6cm}|p{6cm}}
                    Method	&Description \\
                    \hline \\[0.01cm]
                    \texttt{create(Typeface family, int style)}	&Returns a new Typeface based on an existing family and style. \\[2ex]
                    \texttt{createFromAsset(AssetManager mgr, String path)}:	&Loads a Typeface from an asset file (assets/fonts/...). \\[2ex]
                    \texttt{createFromFile(File path)}:	&Loads from a file on disk. \\[2ex]
                    \texttt{defaultFromStyle(int style)}:	&Returns the default Typeface for a style (e.g. Typeface.defaultFromStyle(Typeface.BOLD)). \\[2ex]
                    \texttt{equals(Object obj)}:	&Compares two typefaces. \\[2ex]
                    \texttt{hashCode()}:	&Hash for comparison.
                \end{tabular}
            \end{center}

    \end{itemize}

    \pagebreak 
    \subsection{Relative layout}
    \begin{itemize}
        \item \textbf{Include}
            \bigbreak \noindent 
            \begin{javacode}
                android.widget.RelativeLayout
            \end{javacode}
        \item \textbf{Relative layout}: RelativeLayout is a ViewGroup that lets you position child views relative to each other or to the parent container.
            \bigbreak \noindent 
            Each child view can be placed relative to the parent (top, bottom, left, right, center, etc.) or relative to another view (above, below, to the left/right of another widget).
        \item \textbf{Create a RelativeLayout}:
            \bigbreak \noindent 
            \begin{javacode}
                RelativeLayout layout = new RelativeLayout(this);
                layout.setLayoutParams(new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT
                ));
            \end{javacode}
        \item \textbf{Create RelativeLayout.LayoutParams}
            \bigbreak \noindent 
            \begin{javacode}
            RelativeLayout.LayoutParams rlp = new RelativeLayout.LayoutParams(new ViewGroup.LayoutParams(
                RelativeLayout.LayoutParams.WRAP_CONTENT,
                RelativeLayout.LayoutParams.WRAP_CONTENT
            ));
            \end{javacode}
        \item \textbf{.addRule()}: Adds a layout rule to be interpreted by the RelativeLayout. There are two versions
            \bigbreak \noindent 
            \begin{javacode}
                void addRule(int verb, int subject)
                void addRule(int verb)
            \end{javacode}
            \bigbreak \noindent 
            The first version applies a standalone rule - one that does not reference another view.
            \bigbreak \noindent 
            \begin{javacode}
                params.addRule(RelativeLayout.CENTER_IN_PARENT);
            \end{javacode}
            The rule means: "center this view both horizontally and vertically inside the parent"
            \bigbreak \noindent 
            The second version defines a relationship between this view and another view (by ID).


    \end{itemize}

    \pagebreak 
    \subsection{Linear layout}
    \begin{itemize}
        \item \textbf{Creating linear layout with layout params}:
            \bigbreak \noindent 
            \begin{javacode}
                LinearLayout root = new LinearLayout(this);
                root.setOrientation(LinearLayout.VERTICAL);
                root.setPadding(dp(16), dp(16), dp(16), dp(16));
                root.setLayoutParams(new LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.MATCH_PARENT
                ));
                root.setGravity(Gravity.START);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsection{Table layout and Table row}
    \begin{itemize}
        \item \textbf{TableLayout}: TableLayout arranges children into rows and columns. But unlike HTML tables, it only positions elements, it does not:
            \begin{itemize}
                \item Draw borders
                \item Automatically size columns evenly
                \item Support row/column spanning without special params
            \end{itemize}
            Each row must be a TableRow, and each TableRow contains children like TextView, EditText, Button, etc.
        \item \textbf{Creating TableLayout}
            \bigbreak \noindent 
            \begin{javacode}
                TableLayout table = new TableLayout(this);
                table.setLayoutParams(new TableLayout.LayoutParams(
                        TableLayout.LayoutParams.MATCH_PARENT,
                        TableLayout.LayoutParams.MATCH_PARENT
                ));
                table.setStretchAllColumns(true); // Makes columns expand evenly
            \end{javacode}
        \item \textbf{Creating rows}:
            \bigbreak \noindent 
            \begin{javacode}
            // Create TableRows and Views (cells)
            for (int i = 0; i < 3; i++) {
                TableRow row = new TableRow(this);
                row.setLayoutParams(new TableLayout.LayoutParams(
                        TableLayout.LayoutParams.MATCH_PARENT,
                        TableLayout.LayoutParams.WRAP_CONTENT
                ));

                for (int j = 0; j < 3; j++) {
                    TextView cell = new TextView(this);
                    cell.setText("R" + i + " C" + j);
                    cell.setPadding(dp(8), dp(8), dp(8), dp(8));
                    cell.setGravity(Gravity.CENTER);

                    row.addView(cell);
                }

                // Add row to table
                table.addView(row);
            }
            \end{javacode}
    \end{itemize}


    \pagebreak 
    \subsection{Frame layout}

    \pagebreak 
    \subsection{ListView}
    \begin{itemize}
        \item \textbf{Intro}: A ListView is a UI component that displays a vertical scrolling list of items. 
            It's an AdapterView that shows one row per item, must use an Adapter to supply the row data
            \bigbreak \noindent 
            It does \textbf{not} know:
            \begin{itemize}
                \item how many items you have
                \item how each row looks
                \item how to convert your data (Strings, objects, etc.) into a row view
            \end{itemize}
            The Adapter handles those things.
        \item \textbf{Example}:
            \bigbreak \noindent 
            \begin{javacode}
            ListView listView = findViewById(R.id.listView);

            String[] animals = {"Dog", "Cat", "Bird"};

            ArrayAdapter<String> adapter = new ArrayAdapter<>(
                    this,
                    android.R.layout.simple_list_item_1,
                    animals
            );

            listView.setAdapter(adapter);
            \end{javacode}
            \bigbreak \noindent 
            ArrayAdapter expects the layout to contain a TextView with id @android:id/text1, which is what the built-in android.R.layout.simple\_list\_item\_1 provides
    \end{itemize}

    \pagebreak 
    \subsection{Adapter, AdapterView, ArrayAdapter, BaseAdapter}
    \begin{itemize}
        \item \textbf{Adapter}: 
            An Adapter is an object in Android that acts as a bridge between a data source and an AdapterView (such as a ListView, GridView, Spinner, or AutoCompleteTextView).
            \bigbreak \noindent 
            Its primary responsibility is to provide access to the data and create views for each data item so the AdapterView can display them on the screen.
            \bigbreak \noindent 
            Adapters allow data of any kind—arrays, lists, database results, custom objects—to be converted into uniform, displayable views.
        \item \textbf{Purposes of an Adapter}: The Adapter serves two main purposes:
            \begin{enumerate}
                \item \textbf{Supplies Data}: The Adapter tells the AdapterView how many items exist (\texttt{getCount()}), what data is at a given position (\texttt{getItem(position)})
                \item \textbf{Supplies Views}: The Adapter is responsible for producing a View that represents each item, usually through converting data into TextViews, or inflating custom row layouts
                    \bigbreak \noindent 
                    It does this through the method:
                    \bigbreak \noindent 
                    \begin{javacode}
                        getView(int position, View convertView, ViewGroup parent)
                    \end{javacode}
                    \bigbreak \noindent 
                    This method returns the actual row or grid cell that appears on screen.
            \end{enumerate}
        \item \textbf{AdapterView}:
            An AdapterView is an abstract view in Android that displays a collection of items by binding the view to an Adapter. It provides the framework for presenting data in a structured, scrollable layout, such as a list or a grid.
            \bigbreak \noindent 
            The AdapterView itself does not store or manage the data; instead, it relies on an Adapter to supply both the data and the corresponding child views.
        \item \textbf{Purpose of an AdapterView}: The purpose of an AdapterView is to:
            \begin{itemize}
                \item \textbf{Display multiple data items} (e.g., a list of strings, objects, etc.)
                \item \textbf{Create and manage views} for each item using an Adapter
                \item \textbf{Handle user interaction} with the individual items (such as clicks)
            \end{itemize}
        \item \textbf{Common AdapterView subclasses}: Examples of views that extend AdapterView include:
            \begin{itemize}
                \item \textbf{ListView:} displays items in a vertically scrollable list
                \item \textbf{GridView:} displays items in a grid of rows and columns
                \item \textbf{Spinner:} displays a dropdown list of choices
                \item \textbf{AutoCompleteTextView:} provides suggestions based on user input
            \end{itemize}
        \item \textbf{ArrayAdapter}: An ArrayAdapter is a concrete subclass of the Adapter class in Android that binds an array or list of objects to an AdapterView, such as a ListView, Spinner, or AutoCompleteTextView. It provides a simple way to convert each element of a Java array or List<T> into a View—typically a single TextView.
        \item \textbf{ArrayAdapter purpose}: The ArrayAdapter is designed to:
            \begin{itemize}
                \item Store a collection of data items (usually Strings, but can be any object type)
                \item Provide the number of items to the AdapterView
                \item Create a View for each item, typically using a standard Android layout
            \end{itemize}
        \item \textbf{Example}:
            \bigbreak \noindent 
            \begin{javacode}
                String[] colors = {"Red", "Green", "Blue"};
                ArrayAdapter<String> adapter = new ArrayAdapter<>(
                        this,
                        android.R.layout.simple_list_item_1,
                        colors
                );
                listView.setAdapter(adapter);
            \end{javacode}
            \bigbreak \noindent 
            Where the arguments are
            \begin{itemize}
                \item \textbf{Context}: The Activity or Application context.
                \item \textbf{Resource ID for the row layout}: Usually a layout with a single TextView, e.g. android.R.layout.simple\_list\_item\_1
                \item \textbf{Data source}: An array (String[]) or a list (ArrayList<String>)
            \end{itemize}
            Internally, ArrayAdapter’s job is to take each data item and convert it into a View.
            \bigbreak \noindent 
            For simple layouts:
            \begin{itemize}
                \item It inflates the row layout (e.g., simple\_list\_item\_1)
                \item It finds the TextView
                \item It sets the text to the item’s string value
            \end{itemize}
            If the data is not a string, it uses the item’s toString() method.
            \bigbreak \noindent 
            ArrayAdapter works best with layouts that contain one TextView or contain a TextView as the root element
        \item \textbf{Adapter vs ArrayAdapter}: Adapter is an interface / abstract concept in Android.
            \bigbreak \noindent 
            It describes:
            \begin{itemize}
                \item What an adapter must do
                \item How it supplies data to an AdapterView
            \end{itemize}
            An Adapter must provide methods such as:
            \begin{itemize}
                \item \textbf{getCount()}: how many items
                \item \textbf{getItem(position)}: return data at position
                \item \textbf{getView(position, convertView, parent)}: return a View for the item
            \end{itemize}
            You almost never create an Adapter yourself because it is too general. Instead, you use one of its concrete subclasses, like ArrayAdapter.
            \bigbreak \noindent 
            ArrayAdapter is a specific class that implements the Adapter contract. It works with arrays and ArrayLists

    \end{itemize}


    \pagebreak 
    \subsection{Image view}

    \pagebreak 
    \subsection{Compound Button}

    \pagebreak 
    \subsection{Check box}

    \pagebreak 
    \subsection{RadioGroup and Radio Buttons}


    \pagebreak 
    \subsection{Abs spinner}

    \pagebreak 
    \subsection{Spinner}

    \pagebreak 
    \subsection{Progress bar}

    \pagebreak 
    \subsection{Abs seek bar}

    \pagebreak 
    \subsection{Seek bar}

    \pagebreak 
    \subsection{AttributeSet}

    \pagebreak 
    \subsection{Constraint set}

    \pagebreak 
    \subsection{defStyleAttr}

    \pagebreak 
    \subsection{defStyleRes}

    \pagebreak 
    \subsection{android.content.Intent}
    \begin{itemize}
        \item \textbf{Intent}: An Intent is an Android messaging object used to: 
            \begin{itemize}
                \item Start a new Activity
                \item Start a Service
                \item Deliver a broadcast to other apps or system components
                \item Request an action from another app (e.g., open browser, camera)
            \end{itemize}
            An Intent is how Android apps request actions, move between screens, and share data.
        \item \textbf{Explicit intent}: You specify the exact component (Activity) you want to start.
            \bigbreak \noindent 
            \begin{javacode}
                Intent intent = new Intent(MainActivity.this, SecondActivity.class);
                startActivity(intent);
            \end{javacode}
            \bigbreak \noindent 
            Start SecondActivity from MainActivity:
        \item \textbf{Implicit intent}: You ask the system to find an app that can handle the requested action, used to interact with other apps.
            \bigbreak \noindent 
            \begin{javacode}
                Uri url = Uri.parse("https://www.google.com");
                Intent intent = new Intent(Intent.ACTION_VIEW, url);
                startActivity(intent);
            \end{javacode}
            \bigbreak \noindent 
            Here, Android opens whatever browser the user chooses.
        \item \textbf{Passing data with an intent}: To send data to another Activity:
            \bigbreak \noindent 
            \begin{javacode}
                Intent intent = new Intent(MainActivity.this, SecondActivity.class);
                intent.putExtra("username", "Nathan");
                intent.putExtra("age", 21);
                startActivity(intent);
            \end{javacode}
            \bigbreak \noindent 
            Retrieve it in SecondActivity:
            \bigbreak \noindent 
            \begin{javacode}
                String name = getIntent().getStringExtra("username");
                int age = getIntent().getIntExtra("age", 0);
            \end{javacode}
        \item \textbf{Updating AndroidManifest}: When we add an activity to an app, we need to add a corresponding activity element to the AndroidManifest.xml file
            \bigbreak \noindent 
            \begin{javacode}
                <activity
                    android:name=".classname"
                    android:screenOrientation="portrait">
                </activity>
            \end{javacode}
    \end{itemize}


    \pagebreak 
    \subsection{android.view.Display}
    \begin{itemize}
        \item \textbf{Display class}: The android.view.Display class represents a physical screen or display device that your app’s UI can be shown on. It provides detailed information about the screen your app is running on — such as its size, refresh rate, orientation, and pixel density.
            \bigbreak \noindent 
            It is useful when adapting layouts, scaling graphics, or handling multi-screen setups
        \item \textbf{Getting a display object}: You usually don’t create Display yourself. Instead, you retrieve it from a system service like \texttt{WindowManager}
            \bigbreak \noindent 
            \begin{javacode}
                WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
                Display display = wm.getDefaultDisplay();
            \end{javacode}
            \bigbreak \noindent 
            Or, with
            \bigbreak \noindent 
            \begin{javacode}
            Display display = getWindowManager().getDefaultDisplay();
            \end{javacode}
            \bigbreak \noindent 
            or, in newer Android versions (API 30+):
            \bigbreak \noindent 
            \begin{javacode}
            Display display = getDisplay();  // available from any Activity or View
            \end{javacode}
            \bigbreak \noindent 
            If you’re in a non-Activity class (like a helper or controller class), you can get it through a Context:
            \bigbreak \noindent 
            \begin{javacode}
                WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
                Display display = wm.getDefaultDisplay();
            \end{javacode}

        \item \textbf{Getting display size}: To get the size of the usable screen in pixels:
            \bigbreak \noindent 
            \begin{javacode}
                Display display = getWindowManager().getDefaultDisplay();

                Point size = new Point();
                display.getSize(size);

                int width = size.x;
                int height = size.y;
            \end{javacode}
        \item \textbf{Getting Real Screen Size}: To include everything (status bar, navigation bar):
            \bigbreak \noindent 
            \begin{javacode}
                Point realSize = new Point();
                display.getRealSize(realSize);
            \end{javacode}
        \item \textbf{Getting Refresh Rate}: Returns how many times per second the screen updates:
            \bigbreak \noindent 
            \begin{javacode}
                float refreshRate = display.getRefreshRate();
            \end{javacode}
        \item \textbf{Getting Display Rotation}: Tells you how the screen is currently rotated relative to its "natural" orientation:
            \bigbreak \noindent 
            \begin{javacode}
            int rotation = display.getRotation();
            \end{javacode}
            \bigbreak \noindent 
            where the possible values are
            \begin{itemize}
                \item \textbf{Surface.ROTATION\_0}:  natural orientation
                \item \textbf{Surface.ROTATION\_90}:  rotated right
                \item \textbf{Surface.ROTATION\_180}:  upside down
                \item \textbf{Surface.ROTATION\_270}:  rotated left
            \end{itemize}
        \item \textbf{Getting Display Metrics}: To obtain screen density and scaling info:
            \bigbreak \noindent 
            \begin{javacode}
                DisplayMetrics metrics = new DisplayMetrics();
                display.getMetrics(metrics);

                int densityDpi = metrics.densityDpi;
                float density = metrics.density;  // Scale factor for dp → px
                float scaledDensity = metrics.scaledDensity;  // Scale for sp → px
            \end{javacode}
        \item \textbf{In Multi-Display or External Display Scenarios}: Starting from Android 4.2+, a device can have multiple displays (like casting to a TV or projector). You can access all of them with:
            \bigbreak \noindent 
            \begin{javacode}
                DisplayManager dm = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
                Display[] displays = dm.getDisplays();
            \end{javacode}
        \item \textbf{Methods}:
            \begin{itemize}
                \item \textbf{getSize(Point)}:	Gets the app-usable screen size (in pixels).
                \item \textbf{getRealSize(Point)}:	Gets the full physical display size.
                \item \textbf{getRotation()}:	Returns the screen rotation (0, 90, 180, 270).
                \item \textbf{getRefreshRate()}:	Returns display refresh rate in Hz.
                \item \textbf{getMetrics(DisplayMetrics)}:	Returns logical density and scaling info.
                \item \textbf{getName()}:	Returns display name (useful in multi-display setups).
            \end{itemize}
    \end{itemize}

    % \pagebreak 
    % \subsection{android.hardware.display.DisplayManager}
    % \begin{itemize}
    %     
    % \end{itemize}

    % \pagebreak 
    % \subsection{android.view.WindowManager}
    % \begin{itemize}
    %     
    % \end{itemize}

    % \pagebreak 
    % \subsection{android.util.DisplayMetrics}
    % \begin{itemize}
    %     
    % \end{itemize}

    \pagebreak 
    \subsection{android.view.KeyEvent}
    \begin{itemize}
        \item \textbf{KeyEvent}: \texttt{android.view.KeyEvent} represents a hardware key press or release event — like when the user presses or releases a key on the device’s keyboard, a game controller, or a button such as Volume Up, Back, or Enter.
            \bigbreak \noindent 
            KeyEvent objects are delivered to your app whenever a key action happens.
            \bigbreak \noindent 
            They describe:
            \begin{itemize}
                \item Which key was pressed (keyCode)
                \item Whether it was a press or release
                \item The time, source, modifiers (Shift, Ctrl, etc.)
                \item The Unicode character it represents (if any)
            \end{itemize}
        \item \textbf{Lifecycle}
            \begin{center}
                \begin{tabular}{p{4cm}|p{4cm}|p{4cm}}
                    Stage	&Event Type	&Constant \\
                    \hline \\[0.01cm]
                    Key pressed down	&ACTION\_DOWN	&KeyEvent.ACTION\_DOWN \\[2ex]
                    Key released	&ACTION\_UP	&KeyEvent.ACTION\_UP \\[2ex]
                    Key held (repeats)	&multiple ACTION\_DOWN events	&with getRepeatCount() > 0
                \end{tabular}
            \end{center}
        \item \textbf{Getting a KeyEvent object}: In Android, you don’t manually create KeyEvent objects in most cases. Instead, the Android framework automatically provides them to your app when a user presses or releases a hardware or software key.
            \bigbreak \noindent 
            When a key is pressed, the system calls your Activity, View, or Dialog methods and passes a KeyEvent object as a parameter.
            \begin{itemize}
                \item In an Activity:
                    \bigbreak \noindent 
                    \begin{javacode}
                        @Override
                        public boolean onKeyDown(int keyCode, KeyEvent event) {
                            Log.d("KeyEvent", "Pressed key: " + event.getKeyCode());
                            return super.onKeyDown(keyCode, event);
                        }

                        @Override
                        public boolean onKeyUp(int keyCode, KeyEvent event) {
                            Log.d("KeyEvent", "Released: " + event.getKeyCode());
                            return true;
                        }
                    \end{javacode}
                    \bigbreak \noindent 
                    Here, the system creates and passes the KeyEvent object automatically.
                \item In a View:
                    \bigbreak \noindent 
                    \begin{javacode}
                        @Override
                        public boolean onKeyDown(int keyCode, KeyEvent event) {
                            // Handle key press inside your custom view
                            return true;
                        }
                    \end{javacode}
                    \bigbreak \noindent 
                    Or use a listener:
                    \bigbreak \noindent 
                    \begin{javacode}
                        view.setOnKeyListener(new View.OnKeyListener() {
                            @Override
                            public boolean onKey(View v, int keyCode, KeyEvent event) {
                                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                                    Log.d("KeyEvent", "Key pressed: " + event.getKeyCode());
                                    return true;
                                }
                                return false;
                            }
                        });
                    \end{javacode}

            \end{itemize}
            \bigbreak \noindent 
            \textbf{Note:}  onKeyDown() and onKeyUp() return a boolean because the return value tells the Android framework whether your code has consumed (handled) the key event or no
            \bigbreak \noindent 
            When you return true, it means "I've handled this key event — don’t send it anywhere else."
            \bigbreak \noindent 
            Returning false means: "I didn't handle this — let the system or another component handle it." Then Android passes the event along:
            \begin{itemize}
                \item From the current View up to its parent
                \item From the Activity to the Window
                \item Or eventually to the system (for default behavior)
            \end{itemize}
            super.onKeyDown() calls the default handler in the base Activity class, which performs standard Android behaviors (like handling BACK or MENU keys).
        \item \textbf{Getting the action}
            \bigbreak \noindent 
            \begin{javacode}
            MotionEvent event.getAction()
            \end{javacode}
        \item \textbf{Action constants}:
            \begin{itemize}
                \item \textbf{ACTION\_DOWN}: Key was pressed down
                \item \textbf{ACTION\_UP}: Key was released
                \item \textbf{ACTION\_MULTIPLE}: Multiple repeated key events (e.g., long press)
            \end{itemize}
            \bigbreak \noindent 
            For example,
            \bigbreak \noindent 
            \begin{javacode}
            if (event.getAction() == KeyEvent.ACTION_DOWN) { ... }
            \end{javacode}
        \item \textbf{Getting the key code}:
            \bigbreak \noindent 
            \begin{javacode}
            int event.getKeyCode();
            \end{javacode}
        \item \textbf{Key Code Constants}: These tell you which key was pressed.
            \bigbreak \noindent 
            There are hundreds of these - a few common groups:
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_A, KEYCODE_B, ..., KEYCODE_Z
                KEYCODE_0, KEYCODE_1, ..., KEYCODE_9
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_ENTER
                KEYCODE_DEL           // Backspace
                KEYCODE_TAB
                KEYCODE_ESCAPE
                KEYCODE_SPACE
                KEYCODE_BACK
                KEYCODE_MENU
                KEYCODE_HOME
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_VOLUME_UP
                KEYCODE_VOLUME_DOWN
                KEYCODE_MUTE
                KEYCODE_MEDIA_PLAY_PAUSE
                KEYCODE_MEDIA_NEXT
                KEYCODE_MEDIA_PREVIOUS
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_DPAD_UP
                KEYCODE_DPAD_DOWN
                KEYCODE_DPAD_LEFT
                KEYCODE_DPAD_RIGHT
                KEYCODE_BUTTON_A
                KEYCODE_BUTTON_B
            \end{javacode}
            \bigbreak \noindent 
            \begin{javacode}
                KEYCODE_POWER
                KEYCODE_SLEEP
                KEYCODE_WAKEUP
            \end{javacode}
        \item \textbf{Checking if shift was pressed}:
            \bigbreak \noindent 
            \begin{javacode}
            boolean event.isShiftPressed()
            \end{javacode}
        \item \textbf{Getting meta state}
            \bigbreak \noindent 
            \begin{javacode}
            event.getMetaState()
            \end{javacode}
        \item \textbf{Meta / modifier key flags}: Used for Shift, Alt, Ctrl, etc. These can be combined using bitwise OR (|).
            \begin{itemize}
                \item \textbf{META\_SHIFT\_ON}:	Shift key active
                \item \textbf{META\_ALT\_ON}:	Alt key active
                \item \textbf{META\_CTRL\_ON}:	Control key active
                \item \textbf{META\_META\_ON}:	Meta/Command key active
                \item \textbf{META\_SYM\_ON}:	Symbol modifier active
                \item \textbf{META\_CAPS\_LOCK\_ON}:	Caps lock active
                \item \textbf{META\_NUM\_LOCK\_ON}:	Num lock active
                \item \textbf{META\_SCROLL\_LOCK\_ON}:	Scroll lock active
            \end{itemize}
        \item \textbf{KeyEvent Methods}
            \begin{itemize}
                \item \textbf{getAction()}:	int	Down, Up, or Multiple
                \item \textbf{getKeyCode()}:	int	Which key was pressed
                \item \textbf{getMetaState()}:	int	Modifier flags
                \item \textbf{getRepeatCount()}:	int	How many times repeated
                \item \textbf{getEventTime()}:	long	Time when event occurred
                \item \textbf{getDownTime()}:	long	Time when key was first pressed
                \item \textbf{getDeviceId()}:	int	ID of the input device (keyboard/gamepad)
                \item \textbf{getScanCode()}:	int	Raw hardware scan code
                \item \textbf{getUnicodeChar()}:	int	Unicode value (e.g., 'A' → 65)
                \item \textbf{getFlags()}:	int	Internal system flags
                \item \textbf{getSource()}:	int	Input source (keyboard, gamepad, etc.)
                \item \textbf{isShiftPressed()}:	boolean	True if Shift active
                \item \textbf{isCtrlPressed()}:	boolean	True if Ctrl active
                \item \textbf{isAltPressed()}:	boolean	True if Alt active 
            \end{itemize}
        \item \textbf{Other useful constants}
            \begin{itemize}
                \item \textbf{Action Constants}:	ACTION\_DOWN, ACTION\_UP
                \item \textbf{Key Codes}:	KEYCODE\_A, KEYCODE\_ENTER, KEYCODE\_BACK
                \item \textbf{Meta Flags}:	META\_SHIFT\_ON, META\_CTRL\_ON
                \item \textbf{Event Data Members}:	getAction(), getKeyCode(), getDownTime(), getRepeatCount(), etc.
                \item \textbf{Flags}:	FLAG\_LONG\_PRESS, FLAG\_SOFT\_KEYBOARD, etc.
            \end{itemize}

    \end{itemize}
    
    \pagebreak 
    \subsection{Animations}
    \begin{itemize}
        \item \textbf{Create AnimationSet}:
            \bigbreak \noindent 
            \begin{javacode}
            AnimationSet animation = new AnimationSet(boolean shareInterpolator)
            \end{javacode}
            \bigbreak \noindent 
            An Interpolator controls the animation speed pattern over time:
            \begin{itemize}
                \item \textbf{true}: (default)	All animations inside AnimationSet use the same interpolator (the one set on the AnimationSet itself)
                \item \textbf{false}:	Each animation can define its own interpolator
            \end{itemize}
            \bigbreak \noindent 
            \begin{javacode}
                AnimationSet set = new AnimationSet(true); // true = share interpolator

                // Fade-in animation
                AlphaAnimation alpha = new AlphaAnimation(0f, 1f);
                alpha.setDuration(1000);

                // Move-up animation
                TranslateAnimation move = new TranslateAnimation(
                0, 0,
                50f, 0f
                );
                move.setDuration(1000);

                // Add animations to set
                set.addAnimation(alpha);
                set.addAnimation(move);

                // Start the animation
                view.startAnimation(set);
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsection{SharedPreferences, SharedPreferences.Editor, and PreferencesManager}
    \begin{itemize}
        \item \textbf{Get a SharedPreferences object}
            \bigbreak \noindent 
            \begin{javacode}
                SharedPreferences prefs = getSharedPreferences("MyPrefs", MODE_PRIVATE);
            \end{javacode}
            \begin{itemize}
                \item \textbf{"MyPrefs"}: the filename to store in
                \item \textbf{MODE\_PRIVATE}: → only your app can access it
            \end{itemize}
        \item \textbf{Write / save data}:
            \bigbreak \noindent 
            \begin{javacode}
                SharedPreferences.Editor editor = prefs.edit();
                editor.putString("username", "Nate");
                editor.putBoolean("isDarkMode", true);
                editor.apply(); // async (recommended)
            \end{javacode}
            \begin{itemize}
                \item \textbf{.apply()}: saves in the background
                \item \textbf{.commit()}: saves immediately but blocks the thread — only use if you must know the result instantly
            \end{itemize}
        \item \textbf{Read data}
            \bigbreak \noindent 
            \begin{javacode}
                String username = prefs.getString("username", "Guest");
                boolean darkMode = prefs.getBoolean("isDarkMode", false);
            \end{javacode}
            \bigbreak \noindent 
            The second argument is the default value if the key does not exist
        \item \textbf{Remove data}
            \bigbreak \noindent 
            \begin{javacode}
                prefs.edit().remove("username").apply();
            \end{javacode}
        \item \textbf{Wipe everything}
            \bigbreak \noindent 
            \begin{javacode}
                prefs.edit().clear().apply();
            \end{javacode}
        \item \textbf{Where is the data stored}: SharedPreferences saves to:
            \bigbreak \noindent 
            \begin{bashcode}
                /data/data/<your package name>/shared_prefs/MyPrefs.xml
            \end{bashcode}

    \end{itemize}

    \pagebreak 
    \subsection{Menu and MenuItem}
    \begin{itemize}
        \item \textbf{Which menu type?}: We use the Menu and MenuItem class to create an \textbf{Options Menu}.
        \item \textbf{Creating an options menu}: We override \texttt{onCreateOptionsMenu()}. Android automatically calls this when the Activity starts. Here, you’ll use the Menu object (passed as a parameter) to add items manually.
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    // groupId, itemId, order, title
                    menu.add(0, 101, 0, "Settings");
                    menu.add(0, 102, 1, "Help");
                    menu.add(0, 103, 2, "Exit");

                    // You can also configure each item after adding it
                    MenuItem settingsItem = menu.findItem(101);
                    settingsItem.setIcon(android.R.drawable.ic_menu_preferences);
                    settingsItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);

                    return true;  // tells Android to display this menu
                }
            \end{javacode}
            \bigbreak \noindent 
            menu is the Menu interface object, menu.add(...) returns a MenuItem object. You can customize each MenuItem afterward.
        \item \textbf{Handle clicks}: When the user taps a menu item, Android passes a MenuItem object representing what was clicked.
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onOptionsItemSelected(MenuItem item) {
                    switch (item.getItemId()) {
                        case 101:
                        Toast.makeText(this, "Settings clicked", Toast.LENGTH_SHORT).show();
                        return true;
                        case 102:
                        Toast.makeText(this, "Help clicked", Toast.LENGTH_SHORT).show();
                        return true;
                        case 103:
                        finish(); // close app
                        return true;
                        default:
                        return super.onOptionsItemSelected(item);
                    }
                }
            \end{javacode}



    \end{itemize}

    \pagebreak 
    \subsection{SubMenu}
    \begin{itemize}
        \item \textbf{What is a SubMenu}: A SubMenu is basically a menu nested inside another menu item. SubMenu is an interface that extends Menu, you don’t instantiate it directly — instead, you get it from a Menu object using addSubMenu()
            \bigbreak \noindent 
        \item \textbf{Example, creating SubMenu}:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onCreateOptionsMenu(Menu menu) {
                    // Create a regular menu item
                    menu.add(0, 1, 0, "Settings");

                    // Create a submenu under "File"
                    SubMenu fileSubMenu = menu.addSubMenu("File");

                    // Add items to that submenu
                    fileSubMenu.add(0, 2, 0, "New");
                    fileSubMenu.add(0, 3, 1, "Open");
                    fileSubMenu.add(0, 4, 2, "Save");

                    // Another normal menu item
                    menu.add(0, 5, 3, "Help");

                    return true;
                }
            \end{javacode}
        \item \textbf{Handle clicks}: You handle clicks the same way as normal menu items:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onOptionsItemSelected(MenuItem item) {
                    switch (item.getItemId()) {
                        case 1:
                            Toast.makeText(this, "Settings clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 2:
                            Toast.makeText(this, "New clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 3:
                            Toast.makeText(this, "Open clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 4:
                            Toast.makeText(this, "Save clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 5:
                            Toast.makeText(this, "Help clicked", Toast.LENGTH_SHORT).show();
                            return true;
                    }
                    return super.onOptionsItemSelected(item);
                }
            \end{javacode}
        \item \textbf{SubMenus in XML}: Example,
            \bigbreak \noindent 
            \begin{xmlcode}
                <menu xmlns:android="http://schemas.android.com/apk/res/android">
                    <item android:title="File">
                        <menu>
                            <item android:id="@+id/action_new" android:title="New" />
                            <item android:id="@+id/action_open" android:title="Open" />
                            <item android:id="@+id/action_save" android:title="Save" />
                        </menu>
                    </item>
                    <item android:id="@+id/action_help" android:title="Help" />
                </menu>
            \end{xmlcode}
            \bigbreak \noindent 
            Same structure; you just nest a <menu> inside an <item>.
    \end{itemize}

    \pagebreak 
    \subsection{ContextMenu}
    \begin{itemize}
        \item \textbf{What is it}: Context menus appear when you long-press a View — like text, a button, or a list item. They’re used for actions specific to that item, not the whole Activity.
        \item \textbf{Register a view for a Context Menu}: We use \texttt{registerForContextMenu(view v)}
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onCreate(Bundle savedInstanceState) {
                    super.onCreate(savedInstanceState);
                    setContentView(R.layout.activity_main);

                    TextView myTextView = findViewById(R.id.myTextView);

                    // Tell Android this view should show a context menu on long-press
                    registerForContextMenu(myTextView);
                }
            \end{javacode}
        \item \textbf{Override onCreateContextMenu}: This method is called automatically when the user long-presses the registered view. Here you use the Menu interface to build the menu in code.
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public void onCreateContextMenu(ContextMenu menu, View v,
                                                ContextMenu.ContextMenuInfo menuInfo) {
                    super.onCreateContextMenu(menu, v, menuInfo);

                    // You can set a header or title
                    menu.setHeaderTitle("Choose an action");

                    // Add items programmatically
                    menu.add(0, 101, 0, "Edit");
                    menu.add(0, 102, 1, "Share");
                    menu.add(0, 103, 2, "Delete");
                }
            \end{javacode}
            \bigbreak \noindent 
            \begin{itemize}
                \item \textbf{ContextMenu Menu}: This is the menu object that you fill with items.
                \item \textbf{View v}: The view that was long pressed
                \item \textbf{ContextMenu.ContextMenuInfo menuInfo}: Provides extra context information about the view that was pressed. It’s often null unless the view supports structured data — e.g., a ListView or RecyclerView.
                    \bigbreak \noindent 
                    For lists, it contains which row was long-pressed:
            \end{itemize}
            You call super to allow the parent class (AppCompatActivity) to perform its own setup logic before or after you modify the menu.
        \item \textbf{Handle clicks}:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public boolean onContextItemSelected(MenuItem item) {
                    switch (item.getItemId()) {
                        case 101:
                            Toast.makeText(this, "Edit clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 102:
                            Toast.makeText(this, "Share clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        case 103:
                            Toast.makeText(this, "Delete clicked", Toast.LENGTH_SHORT).show();
                            return true;
                        default:
                            return super.onContextItemSelected(item);
                    }
                }
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \subsection{PopupMenu}
    \begin{itemize}
        \item \textbf{What is it}: A PopupMenu is a small floating menu that appears anchored to a specific View — for example, when you tap a button with “$\vdots$” or “More options.”
            It’s a temporary dropdown menu used for quick actions — not tied to the Action Bar or long-press events.
            \bigbreak \noindent 
        \item \textbf{Example}:
            \bigbreak \noindent 
            \begin{javacode}
                Button button = findViewById(R.id.myButton);

                button.setOnClickListener(v -> {
                    // Create the popup menu, anchored to the button
                    PopupMenu popup = new PopupMenu(MainActivity.this, v);

                    // Get the Menu object inside the popup
                    Menu menu = popup.getMenu();

                    // Add items manually
                    menu.add(0, 101, 0, "Edit");
                    menu.add(0, 102, 1, "Share");
                    menu.add(0, 103, 2, "Delete");

                    // Handle clicks on the popup items
                    popup.setOnMenuItemClickListener(item -> {
                        switch (item.getItemId()) {
                            case 101:
                                Toast.makeText(MainActivity.this, "Edit clicked", Toast.LENGTH_SHORT).show();
                                return true;
                            case 102:
                                Toast.makeText(MainActivity.this, "Share clicked", Toast.LENGTH_SHORT).show();
                                return true;
                            case 103:
                                Toast.makeText(MainActivity.this, "Delete clicked", Toast.LENGTH_SHORT).show();
                                return true;
                            default:
                                return false;
                        }
                    });

                    // Finally, show the popup
                    popup.show();
                });
            \end{javacode}
            
    \end{itemize}

    \pagebreak 
    \subsection{Toast}
    \begin{itemize}
        \item \textbf{What is it}: A Toast is a small popup message that briefly appears at the bottom (or top/center) of the screen. It automatically disappears after a short time. 
        \item \textbf{Basic syntax}:
            \bigbreak \noindent 
            \begin{javacode}
                Toast.makeText(context, "Hello, world!", Toast.LENGTH_SHORT).show();
            \end{javacode}
            \begin{itemize}
                \item \textbf{context}:	Usually this, or getApplicationContext() — tells Android which app is showing the Toast
                \item \textbf{Toast.LENGTH\_SHORT}:	How long it shows (LENGTH\_SHORT $\approx$ 2s, LENGTH\_LONG $\approx$3.5s)
                \item \textbf{.show()}:	Displays the Toast
            \end{itemize}
        \item \textbf{Duration options}
            \begin{itemize}
                \item \textbf{Toast.LENGTH\_SHORT}:	$\sim$2 seconds
                \item \textbf{Toast.LENGTH\_LONG}:	$\sim$3.5 seconds
            \end{itemize}
        \item \textbf{Changing position}: You can move them using setGravity():
            \bigbreak \noindent 
            \begin{javacode}
            Toast toast = Toast.makeText(this, "Top toast!", Toast.LENGTH_SHORT);
            toast.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL, 0, 200);
            toast.show();
            \end{javacode}
            \bigbreak \noindent 
            The last two numbers (xOffset, yOffset) adjust the offset in pixels
        \item \textbf{Custom Layout Toast}: You can even use a custom XML layout instead of plain text:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutInflater inflater = getLayoutInflater();
                View layout = inflater.inflate(R.layout.custom_toast, findViewById(R.id.toastRoot));

                Toast toast = new Toast(getApplicationContext());
                toast.setDuration(Toast.LENGTH_LONG);
                toast.setView(layout);
                toast.show();
            \end{javacode}
            \bigbreak \noindent 
            And res/layout/custom\_toast.xml might look like:
            \bigbreak \noindent 
            \begin{xmlcode}
                <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    android:id="@+id/toastRoot"
                    android:background="#AA000000"
                    android:padding="10dp"
                    android:orientation="horizontal">
                    <ImageView android:src="@android:drawable/ic_dialog_info" />
                    <TextView
                        android:text="Custom Toast"
                        android:textColor="#fff"
                        android:paddingStart="10dp"/>
                </LinearLayout>
            \end{xmlcode}
    \end{itemize}

    \pagebreak 
    \subsection{LayoutInflator}
    \begin{itemize}
        \item \textbf{What is it}: LayoutInflater is a class that converts XML layout files (.xml) into actual View objects in memory — that your app can display or interact with.
            \bigbreak \noindent 
            Your XML layout is like a blueprint for a house. LayoutInflater is the builder that reads that blueprint and constructs the actual house (View hierarchy) in Java.
            \bigbreak \noindent 
            Suppose you have a layout file: \texttt{res/layout/my\_custom\_view.xml}
            \bigbreak \noindent 
            \begin{xmlcode}
                <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    android:orientation="horizontal"
                    android:padding="10dp">
                    <ImageView android:src="@android:drawable/ic_menu_info_details"/>
                    <TextView android:text="Hello LayoutInflater!" android:paddingStart="8dp"/>
                </LinearLayout>
            \end{xmlcode}
            \bigbreak \noindent 
            You can load it into memory like this:
            \bigbreak \noindent 
            \begin{javacode}
                LayoutInflater inflater = getLayoutInflater();   // or LayoutInflater.from(context)
                View view = inflater.inflate(R.layout.my_custom_view, null);
            \end{javacode}
            \bigbreak \noindent 
            Now view is a fully constructed View object tree — a LinearLayout containing an ImageView and TextView.
            \bigbreak \noindent 
            You can then:
            \begin{itemize}
                \item Add it dynamically to another layout
                \item Use it in a custom Toast
                \item Return it from an adapter (for example, in a ListView)
            \end{itemize}
        \item \textbf{inflate()}
            \bigbreak \noindent 
            \begin{javacode}
                View inflate(int resource, ViewGroup root, boolean attachToRoot)
            \end{javacode}
            \bigbreak \noindent 
            Where 
            \begin{itemize}
                \item \textbf{resource}:	The XML layout resource to inflate (e.g., R.layout.my\_view)
                \item \textbf{root}:	Optional parent layout to attach to
                \item \textbf{attachToRoot}:	Whether to attach the inflated layout to root immediately
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{ScrollView}
    \begin{itemize}
       \item \textbf{What is it}: A ScrollView is a layout container that provides vertical scrolling for its single child view. 
           \bigbreak \noindent 
           If your content doesn’t fit on the screen (too tall), wrapping it inside a ScrollView lets the user scroll up and down to see the rest.
        \item \textbf{Key Rules}:
            \begin{itemize}
                \item \textbf{Only one direct child}:	A ScrollView can host only one child view. If you need multiple items, put them inside a container like LinearLayout or ConstraintLayout inside the ScrollView.
                \item \textbf{Vertical only}:	ScrollView scrolls vertically. For horizontal scrolling, use HorizontalScrollView.
                \item \textbf{The child must be taller than the screen}: Otherwise, it won’t scroll because everything fits on screen already.
            \end{itemize}
        \item \textbf{Example}:
            \bigbreak \noindent 
            \begin{javacode}
                ScrollView scrollView = new ScrollView(this);
                LinearLayout layout = new LinearLayout(this);
                layout.setOrientation(LinearLayout.VERTICAL);

                // Add some child views
                for (int i = 1; i <= 20; i++) {
                    TextView tv = new TextView(this);
                    tv.setText("Item " + i);
                    layout.addView(tv);
                }

                // Add layout inside scrollview
                scrollView.addView(layout);

                // Set as activity content
                setContentView(scrollView);

            \end{javacode}
        \item \textbf{Scrolling programmatically}
            \bigbreak \noindent 
            \begin{javacode}
                scrollView.fullScroll(View.FOCUS_DOWN); // scroll to bottom
                scrollView.fullScroll(View.FOCUS_UP);   // scroll to top
                scrollView.scrollTo(0, 500);            // scroll to specific Y position
                scrollView.smoothScrollBy(0, 100);      // scroll smoothly
            \end{javacode}
        \item \textbf{Common XML attributes}
            \begin{itemize}
                \item \textbf{android:fillViewport="true"}:	Forces the child view to expand to fill the screen height (even if content is short).
                \item \textbf{android:scrollbars="none"}:	Hide scrollbars.
                \item \textbf{android:fadeScrollbars="false"}:	Keep scrollbars always visible.
                \item \textbf{android:overScrollMode="never"}:	Disable the “stretch” overscroll glow effect.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \unsect{Styling widgets with java}
    \subsection{View}
    \begin{itemize}
        % --- Styling and Appearance ---
        \item \textbf{void setBackgroundColor(int color)}: Fills the view’s background with a solid color.
        \item \textbf{void setBackground(Drawable background)}: Sets a Drawable as the background.
        \item \textbf{Drawable getBackground()}: Returns the current background drawable.
        \item \textbf{void setForeground(Drawable foreground)}: Draws a Drawable on top of the view’s content.
        \item \textbf{void setPadding(int left, int top, int right, int bottom)}: Sets the padding inside the view.
        \item \textbf{int getPaddingLeft() / getPaddingTop() / getPaddingRight() / getPaddingBottom()}: Returns padding values.
        \item \textbf{void setElevation(float elevation)}: Adds shadow depth to the view for visual layering.
        \item \textbf{void setClipToOutline(boolean clipToOutline)}: Clips the view’s drawing to its outline (e.g., rounded corners).
        \item \textbf{void setOutlineProvider(ViewOutlineProvider provider)}: Defines the outline shape for shadows and clipping.
        \item \textbf{void setBackgroundTintList(ColorStateList tint)}: Applies tint coloring to the background.
        \item \textbf{void setBackgroundTintMode(PorterDuff.Mode mode)}: Defines how the background tint blends with the original color.
        \item \textbf{void setForegroundTintList(ColorStateList tint)}: Applies tint coloring to the foreground.
        \item \textbf{void setOutlineSpotShadowColor(int color)}: Sets the color of the view’s spot shadow.
        \item \textbf{void setOutlineAmbientShadowColor(int color)}: Sets the color of the view’s ambient shadow.
        \item \textbf{void setRotationX(float rotationX) / setRotationY(float rotationY)}: Rotates the view around the X or Y axis.
        \item \textbf{void setCameraDistance(float distance)}: Adjusts the 3D perspective depth for rotation effects.
    \end{itemize}

    \pagebreak 
    \subsection{TextView}
    \begin{itemize}
        \item \textbf{Color, size, typeface}
            \begin{itemize}
                \item \textbf{void setTextColor(int color)}: Sets the text color.
                \item \textbf{void setTextColor(ColorStateList colors)}: Sets text colors for different states.
                \item \textbf{void setHighlightColor(int color)}: Sets selection highlight color.
                \item \textbf{void setLinkTextColor(int color)}: Sets link color.
                \item \textbf{void setLinkTextColor(ColorStateList colors)}: Sets link colors for states.
                \item \textbf{void setTextSize(float size)}: Sets text size in scaled pixels.
                \item \textbf{void setTextSize(int unit, float size)}: Sets text size with unit.
                \item \textbf{void setTextScaleX(float size)}: Horizontal text scale.
                \item \textbf{void setTypeface(Typeface tf)}: Sets typeface.
                \item \textbf{void setTypeface(Typeface tf, int style)}: Sets typeface and style.
                \item \textbf{void setAllCaps(boolean allCaps)}: Transforms input to ALL CAPS display.
                \item \textbf{void setTextAppearance(int resId)}: Applies a text appearance style.
                \item \textbf{void setTextAppearance(Context context, int resId)}: \textit{Deprecated} in API 23.
            \end{itemize}

        \item \textbf{Auto-size text}
            \begin{itemize}
                \item \textbf{void setAutoSizeTextTypeWithDefaults(int autoSizeTextType)}: Enables default auto-size.
                \item \textbf{void setAutoSizeTextTypeUniformWithConfiguration(int min, int max, int step, int unit)}: Uniform auto-size config.
                \item \textbf{void setAutoSizeTextTypeUniformWithPresetSizes(int[] presetSizes, int unit)}: Uniform auto-size with presets.
            \end{itemize}

        \item \textbf{Typography, wrapping, justification}
            \begin{itemize}
                \item \textbf{void setLetterSpacing(float letterSpacing)}: Sets letter spacing.
                \item \textbf{void setLineSpacing(float add, float mult)}: Extra and multiplier.
                \item \textbf{void setLineHeight(int lineHeight)}: Explicit line height (px).
                \item \textbf{void setLineHeight(int unit, float lineHeight)}: Explicit line height with unit.
                \item \textbf{void setEllipsize(TextUtils.TruncateAt where)}: Ellipsize strategy.
                \item \textbf{void setBreakStrategy(int breakStrategy)}: Paragraph line-break strategy.
                \item \textbf{void setLineBreakStyle(int lineBreakStyle)}: Line-break style.
                \item \textbf{void setLineBreakWordStyle(int lineBreakWordStyle)}: Word-break style.
                \item \textbf{void setHyphenationFrequency(int hyphenationFrequency)}: Hyphenation setting.
                \item \textbf{void setJustificationMode(int justificationMode)}: Text justification.
                \item \textbf{void setFallbackLineSpacing(boolean enabled)}: Respect fallback font metrics.
                \item \textbf{void setIncludeFontPadding(boolean includepad)}: Include extra ascent/descent padding.
                \item \textbf{void setFirstBaselineToTopHeight(int px)}: Align first baseline to top padding.
                \item \textbf{void setLastBaselineToBottomHeight(int px)}: Align last baseline to bottom padding.
                \item \textbf{void setLocalePreferredLineHeightForMinimumUsed(boolean flag)}: Locale-preferred min line height.
            \end{itemize}

        \item \textbf{Compound drawables and tints}
            \begin{itemize}
                \item \textbf{void setCompoundDrawables(Drawable left, Drawable top, Drawable right, Drawable bottom)}: L/T/R/B drawables.
                \item \textbf{void setCompoundDrawablesWithIntrinsicBounds(Drawable left, Drawable top, Drawable right, Drawable bottom)}: With intrinsic bounds.
                \item \textbf{void setCompoundDrawablesWithIntrinsicBounds(int left, int top, int right, int bottom)}: By resource IDs.
                \item \textbf{void setCompoundDrawablesRelative(Drawable start, Drawable top, Drawable end, Drawable bottom)}: Start/End variants.
                \item \textbf{void setCompoundDrawablesRelativeWithIntrinsicBounds(Drawable start, Drawable top, Drawable end, Drawable bottom)}: With intrinsic bounds.
                \item \textbf{void setCompoundDrawablesRelativeWithIntrinsicBounds(int start, int top, int end, int bottom)}: By resource IDs.
                \item \textbf{void setCompoundDrawablePadding(int pad)}: Space between text and drawables.
                \item \textbf{void setCompoundDrawableTintList(ColorStateList tint)}: Drawable tint list.
                \item \textbf{void setCompoundDrawableTintMode(PorterDuff.Mode mode)}: Porter-Duff tint mode.
                \item \textbf{void setCompoundDrawableTintBlendMode(BlendMode blendMode)}: BlendMode tinting.
            \end{itemize}

        \item \textbf{Hint \& cursor/selection visuals}
            \begin{itemize}
                \item \textbf{void setHint(CharSequence hint)}: Hint text.
                \item \textbf{void setHint(int resid)}: Hint from resource.
                \item \textbf{void setHintTextColor(int color)}: Hint color.
                \item \textbf{void setHintTextColor(ColorStateList colors)}: Hint color states.
                \item \textbf{void setTextCursorDrawable(Drawable d)}: Cursor drawable.
                \item \textbf{void setTextCursorDrawable(int resId)}: Cursor drawable by resource.
                \item \textbf{void setTextSelectHandle(int resId)}: Selection handle (resource).
                \item \textbf{void setTextSelectHandle(Drawable d)}: Selection handle.
                \item \textbf{void setTextSelectHandleLeft(int resId)}: Left handle (resource).
                \item \textbf{void setTextSelectHandleLeft(Drawable d)}: Left handle.
                \item \textbf{void setTextSelectHandleRight(int resId)}: Right handle (resource).
                \item \textbf{void setTextSelectHandleRight(Drawable d)}: Right handle.
            \end{itemize}

        \item \textbf{Shadows, transforms, and paint flags}
            \begin{itemize}
                \item \textbf{void setShadowLayer(float radius, float dx, float dy, int color)}: Text shadow.
                \item \textbf{final void setTransformationMethod(TransformationMethod method)}: Visual text transformation (e.g., password).
                \item \textbf{void setPaintFlags(int flags)}: Underline/strike-through, etc.
                \item \textbf{void setElegantTextHeight(boolean elegant)}: Use elegant height metrics.
                \item \textbf{void setFontFeatureSettings(String settings)}: OpenType features.
                \item \textbf{boolean setFontVariationSettings(String settings)}: Font variations (axes).
            \end{itemize}

        \item \textbf{Alignment / layout-affecting (often part of style guides)}
            \begin{itemize}
                \item \textbf{void setGravity(int gravity)}: Horizontal/vertical alignment within the view.
                \item \textbf{void setEms(int ems)}: Exact width in ems (typographic sizing).
                \item \textbf{void setLines(int lines)}: Exact number of lines (tight control of layout look).
            \end{itemize}

        \item \textbf{Styling-related getters (useful to read current style)}
            \begin{itemize}
                \item \textbf{int getCurrentTextColor()}, \textbf{ColorStateList getTextColors()}, \textbf{int getHighlightColor()}, \textbf{ColorStateList getHintTextColors()}, \textbf{ColorStateList getLinkTextColors()}
                \item \textbf{float getTextSize()}, \textbf{Typeface getTypeface()}, \textbf{float getLetterSpacing()}, \textbf{int getLineHeight()}
                \item \textbf{TextUtils.TruncateAt getEllipsize()}, \textbf{int getBreakStrategy()}, \textbf{int getHyphenationFrequency()}, \textbf{int getJustificationMode()}
                \item \textbf{String getFontFeatureSettings()}, \textbf{String getFontVariationSettings()}
                \item \textbf{Drawable[] getCompoundDrawables()}, \textbf{Drawable[] getCompoundDrawablesRelative()}, \textbf{int getCompoundDrawablePadding()}, \textbf{ColorStateList getCompoundDrawableTintList()}, \textbf{PorterDuff.Mode getCompoundDrawableTintMode()}, \textbf{BlendMode getCompoundDrawableTintBlendMode()}
            \end{itemize}

        \item \textbf{Advanced styling hooks (from the \emph{other} list)}
            \begin{itemize}
                \item \textbf{void drawableStateChanged()}: React to state changes that affect drawables/tints.
                \item \textbf{int[] onCreateDrawableState(int extraSpace)}: Customize drawable state for styling.
                \item \textbf{void onDraw(Canvas canvas)}: Custom rendering of text/effects.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{EditText (Use TextView methods)}
    \begin{itemize}
        \item \textbf{boolean isStyleShortcutEnabled()}: Returns true if style shortcuts (e.g., \texttt{Ctrl+B} for bold) are enabled.
        \item \textbf{void setStyleShortcutsEnabled(boolean enabled)}: Enables or disables style shortcuts such as \texttt{Ctrl+B}, \texttt{Ctrl+I}, etc.
        \item \textbf{void setEllipsize(TextUtils.TruncateAt ellipsis)}: Specifies how overflowing text should be ellipsized (e.g., at the end or middle) instead of wrapped.
        \item \textbf{void setText(CharSequence text, TextView.BufferType type)}: Sets the text and determines how it’s stored (e.g., as plain, styled, or editable text), affecting styling.
    \end{itemize}


    \pagebreak 
    \subsection{Button (Use TextView methods)}

    \pagebreak 
    \subsection{ListView}
    \begin{itemize}
        \item \textbf{Drawable getDivider()}: Returns the drawable that is drawn between each list item.
        \item \textbf{int getDividerHeight()}: Returns the height of the divider between list items.
        \item \textbf{Drawable getOverscrollFooter()}: Returns the drawable drawn below all list content during overscroll.
        \item \textbf{Drawable getOverscrollHeader()}: Returns the drawable drawn above all list content during overscroll.
        \item \textbf{boolean areFooterDividersEnabled()}: Returns whether footer dividers are currently enabled.
        \item \textbf{boolean areHeaderDividersEnabled()}: Returns whether header dividers are currently enabled.
        \item \textbf{void setCacheColorHint(int color)}: Sets a hint color indicating the solid background behind the list, improving appearance on transparent backgrounds.
        \item \textbf{void setDivider(Drawable divider)}: Sets the drawable that will be drawn between list items.
        \item \textbf{void setDividerHeight(int height)}: Sets the height of the divider drawn between list items.
        \item \textbf{void setFooterDividersEnabled(boolean footerDividersEnabled)}: Enables or disables drawing dividers for footer views.
        \item \textbf{void setHeaderDividersEnabled(boolean headerDividersEnabled)}: Enables or disables drawing dividers for header views.
        \item \textbf{void setOverscrollFooter(Drawable footer)}: Sets the drawable to be drawn below all list content during overscroll.
        \item \textbf{void setOverscrollHeader(Drawable header)}: Sets the drawable to be drawn above all list content during overscroll.
        \item \textbf{void dispatchDraw(Canvas canvas)}: (Protected) Called to draw all child views — can be overridden for custom list-item rendering effects.
        \item \textbf{boolean drawChild(Canvas canvas, View child, long drawingTime)}: (Protected) Draws a single list item onto the canvas; used to customize per-item drawing style.
    \end{itemize}


    \pagebreak 
    \subsection{ImageView}
    \begin{itemize}
        \item \textbf{void animateTransform(Matrix matrix)}: Applies a temporary transformation matrix for animation or visual effects.
        \item \textbf{final void clearColorFilter()}: Removes any color filter or tint applied to the image.
        \item \textbf{ColorFilter getColorFilter()}: Returns the active color filter used for tinting or blending.
        \item \textbf{int getImageAlpha()}: Returns the current alpha (transparency) level of the image.
        \item \textbf{Matrix getImageMatrix()}: Returns the current transformation matrix applied to the image.
        \item \textbf{BlendMode getImageTintBlendMode()}: Returns the blending mode used for applying tints.
        \item \textbf{ColorStateList getImageTintList()}: Returns the color tint list applied to the image drawable.
        \item \textbf{PorterDuff.Mode getImageTintMode()}: Returns the blending mode used for applying the tint.
        \item \textbf{ImageView.ScaleType getScaleType()}: Returns the scale type that defines how the image fits within the view bounds.
        \item \textbf{void setAlpha(int alpha)}: \textit{Deprecated in API 16.} Sets the overall opacity of the view (use \texttt{setImageAlpha(int)} instead).
        \item \textbf{final void setColorFilter(int color, PorterDuff.Mode mode)}: Applies a tint color and blending mode to the image.
        \item \textbf{void setColorFilter(ColorFilter cf)}: Applies a custom color filter to modify image appearance.
        \item \textbf{final void setColorFilter(int color)}: Applies a tint color to the image using the default blending mode.
        \item \textbf{void setCropToPadding(boolean cropToPadding)}: Determines whether the image is cropped to the view’s padding.
        \item \textbf{void setImageAlpha(int alpha)}: Sets the transparency level for the image drawable.
        \item \textbf{void setImageBitmap(Bitmap bm)}: Sets a bitmap as the content of the ImageView.
        \item \textbf{void setImageDrawable(Drawable drawable)}: Sets a drawable as the image content.
        \item \textbf{void setImageIcon(Icon icon)}: Sets an icon as the content.
        \item \textbf{void setImageMatrix(Matrix matrix)}: Applies a transformation matrix to the image drawable.
        \item \textbf{void setImageResource(int resId)}: Sets an image resource by its resource ID.
        \item \textbf{void setImageTintBlendMode(BlendMode blendMode)}: Sets how the tint blends with the image.
        \item \textbf{void setImageTintList(ColorStateList tint)}: Applies a color tint list to the image drawable.
        \item \textbf{void setImageTintMode(PorterDuff.Mode tintMode)}: Defines the blending mode for the tint.
        \item \textbf{void setScaleType(ImageView.ScaleType scaleType)}: Defines how the image should be scaled or cropped to fit within the view.
        \item \textbf{void onDraw(Canvas canvas)}: (Protected) Allows custom drawing of the image—useful for advanced visual effects.
    \end{itemize}

    \pagebreak 
    \subsection{CompoundButton}
    \begin{itemize}
        \item \textbf{Drawable getButtonDrawable()}: Returns the drawable used as the button image (e.g., checkmark or radio indicator).
        \item \textbf{BlendMode getButtonTintBlendMode()}: Returns the blending mode used to apply the tint to the button drawable.
        \item \textbf{ColorStateList getButtonTintList()}: Returns the color tint list applied to the button drawable.
        \item \textbf{PorterDuff.Mode getButtonTintMode()}: Returns the blending mode used for tinting.
        \item \textbf{void setButtonDrawable(int resId)}: Sets a drawable resource as the button image.
        \item \textbf{void setButtonDrawable(Drawable drawable)}: Sets a drawable object as the button image.
        \item \textbf{void setButtonIcon(Icon icon)}: Sets an icon as the visual button image.
        \item \textbf{void setButtonTintBlendMode(BlendMode tintMode)}: Defines how the tint color blends with the drawable.
        \item \textbf{void setButtonTintList(ColorStateList tint)}: Applies a tint list (different colors for different states) to the button image.
        \item \textbf{void setButtonTintMode(PorterDuff.Mode tintMode)}: Specifies the tint blending mode.
        \item \textbf{void drawableStateChanged()}: (Protected) Called when the state of the view changes in a way that affects drawable appearance (e.g., pressed, focused, checked).
        \item \textbf{int[] onCreateDrawableState(int extraSpace)}: (Protected) Generates the drawable state array — affects how state-based drawables (like selectors) are drawn.
        \item \textbf{void onDraw(Canvas canvas)}: (Protected) Used for custom drawing — allows overriding default appearance.
        \item \textbf{boolean verifyDrawable(Drawable who)}: (Protected) Ensures the drawable being displayed belongs to this view; relevant for custom visual drawables.
    \end{itemize}

    \pagebreak 
    \subsection{CheckBox (Use Button and CompoundButton styles)}

    \pagebreak 
    \subsection{RadioButton (Use button and CompoundButton styles)}

    \pagebreak 
    \subsection{Spinner}
    \begin{itemize}
        \item \textbf{int getDropDownHorizontalOffset()}: Returns the horizontal offset in pixels for positioning the dropdown popup.
        \item \textbf{int getDropDownVerticalOffset()}: Returns the vertical offset in pixels for positioning the dropdown popup.
        \item \textbf{int getDropDownWidth()}: Returns the configured width of the dropdown popup window.
        \item \textbf{int getGravity()}: Returns how the selected item view is positioned within the spinner (e.g., left, center, right).
        \item \textbf{Drawable getPopupBackground()}: Returns the background drawable used for the spinner’s dropdown popup.
        \item \textbf{void setDropDownHorizontalOffset(int pixels)}: Sets the horizontal offset in pixels for the spinner’s dropdown popup.
        \item \textbf{void setDropDownVerticalOffset(int pixels)}: Sets the vertical offset in pixels for the spinner’s dropdown popup.
        \item \textbf{void setDropDownWidth(int pixels)}: Sets the width in pixels for the spinner’s dropdown popup window.
        \item \textbf{void setGravity(int gravity)}: Defines how the selected item is positioned within the spinner (e.g., \texttt{Gravity.CENTER}).
        \item \textbf{void setPopupBackgroundDrawable(Drawable background)}: Sets a drawable as the background for the dropdown popup.
        \item \textbf{void setPopupBackgroundResource(int resId)}: Sets a background resource for the dropdown popup.
        \item \textbf{CharSequence getPrompt()}: Returns the prompt text displayed when the dialog version of the spinner is shown.
        \item \textbf{void setPrompt(CharSequence prompt)}: Sets custom prompt text for the spinner dialog.
        \item \textbf{void setPromptId(int promptId)}: Sets the prompt text by its string resource ID.
        \item \textbf{int getBaseline()}: Returns the text baseline offset (useful when aligning the spinner with other text views visually).
        \item \textbf{void onLayout(boolean changed, int l, int t, int r, int b)}: (Protected) Handles positioning of spinner items — can affect visual alignment.
        \item \textbf{void onMeasure(int widthMeasureSpec, int heightMeasureSpec)}: (Protected) Determines size and layout — affects how the spinner and dropdown appear.
    \end{itemize}
    \textbf{Styles from AdapterView}
    \begin{itemize}
        \item \textbf{void setSelection(int position)}: Visually highlights the selected item.
        \item \textbf{void setEmptyView(View emptyView)}: Specifies a view to display when the adapter is empty.
    \end{itemize}



    \pagebreak 
    \subsection{ProgessBar}
    \begin{itemize}
        \item \textbf{void drawableHotspotChanged(float x, float y)}: Called when the view hotspot changes and must be propagated to drawables or child views.
        \item \textbf{Drawable getCurrentDrawable()}: Returns the drawable currently used to draw the progress bar.
        \item \textbf{Drawable getIndeterminateDrawable()}: Returns the drawable used to draw the progress bar in indeterminate mode.
        \item \textbf{BlendMode getIndeterminateTintBlendMode()}: Returns the blending mode used to apply the tint to the indeterminate drawable.
        \item \textbf{ColorStateList getIndeterminateTintList()}: Returns the color tint list applied to the indeterminate drawable.
        \item \textbf{PorterDuff.Mode getIndeterminateTintMode()}: Returns the blending mode used to apply the tint to the indeterminate drawable.
        \item \textbf{Interpolator getInterpolator()}: Gets the acceleration curve for the indeterminate animation.
        \item \textbf{BlendMode getProgressBackgroundTintBlendMode()}: Returns the blending mode used to apply the tint to the progress background.
        \item \textbf{ColorStateList getProgressBackgroundTintList()}: Returns the tint list applied to the progress background.
        \item \textbf{PorterDuff.Mode getProgressBackgroundTintMode()}: Returns the blending mode used to apply the tint to the progress background.
        \item \textbf{Drawable getProgressDrawable()}: Returns the drawable used to draw the progress bar in progress mode.
        \item \textbf{BlendMode getProgressTintBlendMode()}: Returns the blending mode used to apply the tint to the progress drawable.
        \item \textbf{ColorStateList getProgressTintList()}: Returns the color tint list applied to the progress drawable.
        \item \textbf{PorterDuff.Mode getProgressTintMode()}: Returns the blending mode used to apply the tint to the progress drawable.
        \item \textbf{BlendMode getSecondaryProgressTintBlendMode()}: Returns the blending mode used to apply the tint to the secondary progress drawable.
        \item \textbf{ColorStateList getSecondaryProgressTintList()}: Returns the color tint list applied to the secondary progress drawable.
        \item \textbf{PorterDuff.Mode getSecondaryProgressTintMode()}: Returns the blending mode used to apply the tint to the secondary progress drawable.
        \item \textbf{void invalidateDrawable(Drawable dr)}: Invalidates the specified drawable, forcing a redraw.
        \item \textbf{void jumpDrawablesToCurrentState()}: Jumps all drawables to their current state instantly, skipping animations.
        \item \textbf{void setIndeterminateDrawable(Drawable d)}: Defines the drawable used to draw the progress bar in indeterminate mode.
        \item \textbf{void setIndeterminateDrawableTiled(Drawable d)}: Defines a tileable drawable for the indeterminate mode.
        \item \textbf{void setIndeterminateTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for applying the indeterminate tint.
        \item \textbf{void setIndeterminateTintList(ColorStateList tint)}: Applies a color tint to the indeterminate drawable.
        \item \textbf{void setIndeterminateTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the indeterminate tint.
        \item \textbf{void setInterpolator(Interpolator interpolator)}: Sets the acceleration curve for the indeterminate animation.
        \item \textbf{void setProgressBackgroundTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the progress background tint.
        \item \textbf{void setProgressBackgroundTintList(ColorStateList tint)}: Applies a tint to the progress background.
        \item \textbf{void setProgressBackgroundTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the progress background tint.
        \item \textbf{void setProgressDrawable(Drawable d)}: Defines the drawable used to draw the progress bar in progress mode.
        \item \textbf{void setProgressDrawableTiled(Drawable d)}: Defines a tileable drawable for the progress bar in progress mode.
        \item \textbf{void setProgressTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the progress indicator tint.
        \item \textbf{void setProgressTintList(ColorStateList tint)}: Applies a tint to the progress indicator.
        \item \textbf{void setProgressTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the progress indicator tint.
        \item \textbf{void setSecondaryProgressTintBlendMode(BlendMode blendMode)}: Specifies the blending mode for the secondary progress tint.
        \item \textbf{void setSecondaryProgressTintList(ColorStateList tint)}: Applies a tint to the secondary progress indicator.
        \item \textbf{void setSecondaryProgressTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode for the secondary progress tint.
        \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects drawable appearance.
        \item \textbf{void onDraw(Canvas canvas)}: Used to perform custom drawing for the progress bar.
        \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true if the specified drawable is managed and displayed by this view.
    \end{itemize}

    \pagebreak 
    \subsection{AbsSeekBar}
    \begin{itemize}
        \item \textbf{void drawableHotspotChanged(float x, float y)}: Called whenever the view hotspot changes and must be propagated to drawables or child views.
        \item \textbf{boolean getSplitTrack()}: Returns whether the track is visually split by the thumb.
        \item \textbf{Drawable getThumb()}: Returns the drawable representing the thumb — the draggable component indicating progress.
        \item \textbf{int getThumbOffset()}: Returns the amount by which the thumb extends beyond the track.
        \item \textbf{BlendMode getThumbTintBlendMode()}: Returns the blending mode used to apply the tint to the thumb drawable.
        \item \textbf{ColorStateList getThumbTintList()}: Returns the tint color list applied to the thumb drawable.
        \item \textbf{PorterDuff.Mode getThumbTintMode()}: Returns the blending mode used to apply the tint to the thumb drawable.
        \item \textbf{Drawable getTickMark()}: Returns the drawable used as the tick mark for each progress position.
        \item \textbf{BlendMode getTickMarkTintBlendMode()}: Returns the blending mode used to apply tint to the tick mark drawable.
        \item \textbf{ColorStateList getTickMarkTintList()}: Returns the tint color list applied to the tick mark drawable.
        \item \textbf{PorterDuff.Mode getTickMarkTintMode()}: Returns the blending mode used to apply tint to the tick mark drawable.
        \item \textbf{void jumpDrawablesToCurrentState()}: Immediately updates all drawables associated with this view to their current state.
        \item \textbf{void setSplitTrack(boolean splitTrack)}: Specifies whether the track should be visually split by the thumb.
        \item \textbf{void setThumb(Drawable thumb)}: Sets the drawable used as the thumb in the progress meter.
        \item \textbf{void setThumbOffset(int thumbOffset)}: Sets the offset allowing the thumb to extend beyond the track visually.
        \item \textbf{void setThumbTintBlendMode(BlendMode blendMode)}: Defines the blending mode used when applying tint to the thumb drawable.
        \item \textbf{void setThumbTintList(ColorStateList tint)}: Applies a tint color list to the thumb drawable.
        \item \textbf{void setThumbTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used with the thumb tint.
        \item \textbf{void setTickMark(Drawable tickMark)}: Sets the drawable used as tick marks at each progress position.
        \item \textbf{void setTickMarkTintBlendMode(BlendMode blendMode)}: Specifies the blending mode used to apply tint to the tick mark drawable.
        \item \textbf{void setTickMarkTintList(ColorStateList tint)}: Applies a tint color list to the tick mark drawable.
        \item \textbf{void setTickMarkTintMode(PorterDuff.Mode tintMode)}: Specifies the blending mode used with the tick mark tint.
        \item \textbf{void drawableStateChanged()}: Called whenever the state of the view changes in a way that affects drawable appearance.
        \item \textbf{void onDraw(Canvas canvas)}: Implement this method to perform custom drawing operations for the view.
        \item \textbf{boolean verifyDrawable(Drawable who)}: Returns true if the specified drawable is being displayed by this view; subclasses override when managing custom drawables.
    \end{itemize}



    \pagebreak 
    \subsection{SeekBar (Use styles from ProgessBar and AbsSeekBar)}


    \pagebreak 
    \unsect{Used Methods, constants, and fields}
    \subsection{Activity}
    \begin{itemize}
        \item \textbf{Methods}:
            \begin{itemize}
                \item \textbf{setContentView(int view)} 
                \item \textbf{Intent getIntent()}: Returns the intent that started this activity.
                \item \textbf{void startActivity(Intent)}: Starts an activity from an Intent object.
                \item \textbf{WindowManager getWindowManager()}: Retrieve the window manager for showing custom windows.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent \pagebreak \noindent
    \subsection{View}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{setVisibility(int) / getVisibility()}:	Show, hide (INVISIBLE), or remove (GONE) a view.
                \item \textbf{findViewById(int)}:	Get a view inside another view or layout.
                \item \textbf{getId() / setId(int)}:	Get or assign a unique view ID.
                \item \textbf{setOnClickListener(...)}:	Handle click actions.
                \item \textbf{setEnabled(boolean) / isEnabled()}:	Enable/disable a view.
                \item \textbf{setAlpha(float)}:	Adjust transparency.
                \item \textbf{getX(), getY()}:	View’s position relative to its parent.
                \item \textbf{setX(), setY()}:	Move a view.
                \item \textbf{void measure(int widthMeasureSpec, int heightMeasureSpec)}: Determines the measured size of the view.
                \item \textbf{final int	getMeasuredHeight()}: Like getMeasuredHeightAndState(), but only returns the raw height component (that is the result is masked by MEASURED_SIZE_MASK).
                \item \textbf{final int	getMeasuredWidth()}: Like getMeasuredWidthAndState(), but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK).

                \item \textbf{getWidth(), getHeight()}:	View’s measured width/height.
                \item \textbf{setLayoutParams(ViewGroup.LayoutParams)}:	Change width, height, margins programmatically.
                \item \textbf{getLayoutParams()}:	Access current layout parameters.
                \item \textbf{requestLayout()}:	Ask parent to re-measure and re-layout (after size change).
                \item \textbf{setTranslationX/Y(float)}:	Move view without changing layout.
                \item \textbf{setScaleX/Y(float)}:	Scale the view.
                \item \textbf{setRotation(float)}:	Rotate the view.
                \item \textbf{public void setBackground (Drawable background)}: Set the background to a given Drawable, or remove the background
                \item \textbf{setBackgroundColor(int color)}: Set the background to a given Drawable, or remove the background
                \item \textbf{public void setBackgroundResource (int resid)}: Set the background to a given resource. The resource should refer to a Drawable object or 0 to remove the background.
                \item \textbf{public void setPadding (int left, int top, int right, int bottom)}: Sets the padding.
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsection{ViewGroup}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{addView(View) / addView(View, int) / addView(View, LayoutParams)}: Add children quickly.
                \item \textbf{removeView(View) / removeViewAt(int) / removeAllViews()}: Remove children.
                \item \textbf{removeAllViewsInLayout()}: Called by a ViewGroup subclass to remove child views from itself
                \item \textbf{getChildCount(), getChildAt(int), indexOfChild(View)}: Inspect/manage children.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{ViewGroup.LayoutParams}
    \begin{itemize}
        \item \textbf{Fields} 
            \begin{itemize}
                \item \textbf{public int	height}: Information about how tall the view wants to be.
                \item \textbf{public int	width}: Information about how wide the view wants to be.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	FILL\_PARENT}: Special value for the height or width requested by a View.
                \item \textbf{int	MATCH\_PARENT}: Special value for the height or width requested by a View.
                \item \textbf{int	WRAP\_CONTENT}: Special value for the height or width requested by a View.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{ViewGroup.MarginLayoutParams}
    \begin{itemize}
        \item \textbf{XML}
            \begin{itemize}
                \item \textbf{android:layout\_marginTop}
                \item \textbf{android:layout\_marginBottom}
                \item \textbf{android:layout\_marginLeft}
                \item \textbf{android:layout\_marginRight}
            \end{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{int	getLayoutDirection()}: Retuns the layout direction.
                \item \textbf{int	getMarginEnd()}: Returns the end margin in pixels.
                \item \textbf{int	getMarginStart()}: Returns the start margin in pixels.
                \item \textbf{void	setLayoutDirection(int layoutDirection)}: Set the layout direction
                \item \textbf{void	setMarginEnd(int end)}: Sets the relative end margin.
                \item \textbf{void	setMarginStart(int start)}: Sets the relative start margin.
                \item \textbf{void	setMargins(int left, int top, int right, int bottom)}: Sets the margins, in pixels.
            \end{itemize}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public int	bottomMargin}: The bottom margin in pixels of the child.
                \item \textbf{public int	leftMargin}: The left margin in pixels of the child.
                \item \textbf{public int	rightMargin}: The right margin in pixels of the child.
                \item \textbf{public int	topMargin}: The top margin in pixels of the child.
            \end{itemize}
    \end{itemize}

    \pagebreak \noindent
    \subsection{Context}
    \begin{itemize}
        \item \textbf{Methods} 
            \begin{itemize}
                \item \textbf{Resources getResources()}: Provides access to the app’s resources (layouts, strings, drawables, etc.).
                \item \textbf{Resources.Theme getTheme()}: : Returns the current theme for styling and inflation.
            \end{itemize}
    \end{itemize}


    \pagebreak 
    \subsection{Configuration}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{public boolean isLayoutSizeAtLeast(int size)}: Checks whether the device’s screen is at least a given size.
            \end{itemize}
        \item \textbf{Fields}
            \begin{itemize}
                \item \textbf{public int keyboard}: Keyboard for the device.
                \item \textbf{public Locale locale}: User preference for the locale.
                \item \textbf{public int orientation}: An integer value representing the orientation of the screen.
                \item \textbf{public int screenHeightDp}: Height of the screen, not including the status bar, in dp units (density independent pixels).
                \item \textbf{public int screenWidthDp}: Width of the screen in dp units.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{ORIENTATION\_PORTRAIT}: (1)
                \item \textbf{ORIENTATION\_LANDSCAPE}: (2)
                \item \textbf{SCREENLAYOUT_SIZE_UNDEFINED}: (0)
                \item \textbf{SCREENLAYOUT\_SIZE\_SMALL}: (1) Smartphones
                \item \textbf{SCREENLAYOUT\_SIZE\_NORMAL}: (2) Smartphones
                \item \textbf{SCREENLAYOUT\_SIZE\_LARGE}: (3) Tablets
                \item  \textbf{SCREENLAYOUT\_SIZE\_XLARGE}: (4) Tablets
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Resources}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{Configuration getConfiguration()}: Return the current configuration that is
                \item \textbf{DisplayMetrics getDisplayMetrics()}: Returns the current display metrics that are in effect for this resource object
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Resources.Theme}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{boolean	resolveAttribute(int resid, TypedValue outValue, boolean resolveRefs)}: Retrieve the value of an attribute in the Theme.
            \end{itemize}

    \end{itemize}

    \pagebreak 
    \subsection{TypedValue}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{static int	complexToDimensionPixelSize(int data, DisplayMetrics metrics)}: Converts a complex data value holding a dimension to its final value as an integer pixel size.
            \end{itemize}
    \end{itemize}


    \pagebreak 
    \subsection{DisplayMetrics}
    \begin{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Log}
    \begin{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{WindowManager}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{abstract Display getDefaultDisplay()}: This method was deprecated in API level 30. Use Context.getDisplay() instead.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Display}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{void	getSize(Point outSize)}: This method was deprecated in API level 30. Use WindowMetrics instead. Obtain a WindowMetrics instance by calling WindowManager.getCurrentWindowMetrics(), then call WindowMetrics.getBounds() to get the dimensions of the application window.
            \end{itemize}
    \end{itemize}



    \pagebreak 
    \subsection{Color}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{static int	parseColor(String colorString)}: Parse the color string, and return the corresponding color-int.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int	BLACK}:
                \item \textbf{int	BLUE}:
                \item \textbf{int	CYAN}:
                \item \textbf{int	DKGRAY}:
                \item \textbf{int	GRAY}:
                \item \textbf{int	GREEN}:
                \item \textbf{int	LTGRAY}:
                \item \textbf{int	MAGENTA}:
                \item \textbf{int	RED}:
                \item \textbf{int	TRANSPARENT}:
                \item \textbf{int	WHITE}:
                \item \textbf{int	YELLOW}:
            \end{itemize}

    \end{itemize}



    \pagebreak \noindent
    \subsection{ConstraintLayout}


    \pagebreak \noindent
    \subsection{ConstraintLayout.LayoutParams}


    \pagebreak \noindent
    \subsection{RelativeLayout}


    \pagebreak \noindent
    \subsection{RelativeLayout.LayoutParams}


    \pagebreak \noindent
    \subsection{LinearLayout}
    \begin{itemize}
        \item \textbf{XML attributes}
            \begin{itemize}
                \item \textbf{android:gravity}
                    \begin{itemize}
                        \item center
                    \end{itemize}
                \item \textbf{android:orientation}
                    \begin{itemize}
                        \item horizontal
                        \item vertical
                    \end{itemize}
            \end{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{void setOrientation(int orientation)}: Should the layout be a column or a row.
                \item \textbf{void setGravity(int gravity)}: Describes how the child views are positioned.
                \item \textbf{void setHorizontalGravity(int horizontalGravity)}: Sets the horizontal gravity of the layout.
                \item \textbf{void setVerticalGravity(int verticalGravity)}: Sets the vertical gravity of the layout.
                \item \textbf{int getGravity()}: Returns the current gravity.
                \item \textbf{int getOrientation()}: Returns the current orientation.
            \end{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{int HORIZONTAL}: Constant indicating a horizontal orientation for the layout.
                \item \textbf{int VERTICAL}: Constant indicating a vertical orientation for the layout.
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsection{LinearLayout.LayoutParams}


    \pagebreak \noindent
    \subsection{GridLayout}
    \begin{itemize}
        \item \textbf{Methods} 
            \begin{itemize}
                \item \textbf{setRowCount(int rows)}
                \item \textbf{setColumnCount(int cols)}
                \item \textbf{static GridLayout.Spec	spec(int start, int size)}: Return a Spec, spec, where:
                    spec.span = [start, start + size]. To leave the start index undefined, use the value UNDEFINED.
                \item \textbf{static GridLayout.Spec	spec(int start)}: Return a Spec, spec, where:
                    spec.span = [start, start + 1]. To leave the start index undefined, use the value UNDEFINED.
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsection{GridLayout.LayoutParams}

    \pagebreak 
    \subsection{GridLayout.Spec}
    \begin{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsection{TableLayout}


    \pagebreak \noindent
    \subsection{TableLayout.LayoutParams}


    \pagebreak \noindent
    \subsection{TableRow}


    \pagebreak \noindent
    \subsection{FrameLayout}


    \pagebreak \noindent
    \subsection{FrameLayout.LayoutParams}


    \pagebreak \noindent
    \subsection{ListView}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{Adapter}
    \begin{itemize}
        \item \textbf{Methods} 
            \begin{itemize}
                \item \textbf{abstract int	getCount():} How many items are in the data set represented by this Adapter.
                \item \textbf{abstract Object	getItem(int position)}: Get the data item associated with the specified position in the data set.
                \item \textbf{abstract boolean	isEmpty()}:
                \item \textbf{abstract View	getView(int position, View convertView, ViewGroup parent)}: Get a View that displays the data at the specified position in the data set.
                \item \textbf{long getItemId(int position)}:
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{AdapterView (Abstract)}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{abstract T	getAdapter()}: Returns the adapter currently associated with this widget.
                \item \textbf{abstract void	setAdapter(T adapter)}: Sets the adapter that provides the data and the views to represent the data in this widget.
                \item \textbf{void	setEmptyView(View emptyView)}: Sets the view to show if the adapter is empty
                \item \textbf{View	getEmptyView()}: When the current adapter is empty, the AdapterView can display a special view called the empty view.
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{ArrayAdapter}

    \pagebreak 
    \subsection{BaseAdapter}



    \pagebreak \noindent
    \subsection{TextView}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{void	setInputType(int type)}: Set the type of the content with a constant as defined for EditorInfo.inputType.
                \item \textbf{int	getInputType()}: Get the type of the editable content.
                \item \textbf{public void setTextSize (float size)}:
                \item \textbf{void	setGravity(int gravity)}: Sets the horizontal alignment of the text and the vertical gravity that will be used when there is extra space in the TextView beyond what is required for the text itself.
                \item \textbf{void	setTypeface(Typeface tf)}: Sets the typeface and style in which the text should be displayed.
                \item \textbf{void	setTypeface(Typeface tf, int style)}: Sets the typeface and style in which the text should be displayed, and turns on the fake bold and italic bits in the Paint if the Typeface that you provided does not have all the bits in the style that you specified.
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsection{EditText}
    \begin{itemize}
        \item \textbf{Methods}
    \end{itemize}

    \pagebreak 
    \subsection{InputType}
    \begin{itemize}
        \item \textbf{Constants}
            \begin{itemize}
                \item \textbf{TYPE\_CLASS\_TEXT}:	Plain text input.
                \item \textbf{TYPE\_CLASS\_NUMBER}:	Numeric input (digits 0-9).
                \item \textbf{TYPE\_CLASS\_PHONE}:	Phone number input.
                \item \textbf{TYPE\_CLASS\_DATETIME}:	Date/time input field.
                \item \textbf{TYPE\_TEXT\_VARIATION\_NORMAL}:	Default plain text.
                \item \textbf{TYPE\_TEXT\_VARIATION\_PASSWORD}:	Password (hidden input).
                \item \textbf{TYPE\_TEXT\_VARIATION\_VISIBLE\_PASSWORD}:	Password but visible.
                \item \textbf{TYPE\_TEXT\_VARIATION\_EMAIL\_ADDRESS}:	Email input.
                \item \textbf{TYPE\_TEXT\_VARIATION\_PERSON\_NAME}:	Person’s name.
                \item \textbf{TYPE\_TEXT\_VARIATION\_URI}:	URL/website.
                \item \textbf{TYPE\_TEXT\_VARIATION\_POSTAL\_ADDRESS}:	Mailing address.
                \item \textbf{TYPE\_TEXT\_VARIATION\_SHORT\_MESSAGE}:	SMS/chat message.
                \item \textbf{TYPE\_TEXT\_VARIATION\_LONG\_MESSAGE}:	Long message or email body.
                \item \textbf{TYPE\_TEXT\_VARIATION\_WEB\_EMAIL\_ADDRESS}:	Email in web form.
                \item \textbf{TYPE\_TEXT\_VARIATION\_WEB\_PASSWORD}:	Web password field.
                \item \textbf{TYPE\_TEXT\_FLAG\_CAP\_SENTENCES}:	Capitalize first letter of sentences.
                \item \textbf{TYPE\_TEXT\_FLAG\_CAP\_WORDS}:	Capitalize first letter of words.
                \item \textbf{TYPE\_TEXT\_FLAG\_CAP\_CHARACTERS}:	All caps.
                \item \textbf{TYPE\_TEXT\_FLAG\_MULTI\_LINE}:	Allows multiple lines.
                \item \textbf{TYPE\_TEXT\_FLAG\_NO\_SUGGESTIONS}:	Disable suggestions/autocorrect.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_COMPLETE}:	Enable auto-complete.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_CORRECT}:	Enable auto-correct.
                \item \textbf{TYPE\_NUMBER\_FLAG\_DECIMAL}:	Allows decimal point (e.g., 3.14).
                \item \textbf{TYPE\_NUMBER\_FLAG\_SIGNED}:	Allows + or – at start.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_NORMAL}:	Normal number input.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_PASSWORD}:	Number password (hidden).
                \item \textbf{TYPE\_DATETIME\_VARIATION\_NORMAL}:	Default date & time.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_DATE}:	Only date input.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_TIME}:	Only time input.
                \item \textbf{TYPE\_TEXT\_FLAG\_MULTI\_LINE}:	Allows multiple lines.
                \item \textbf{TYPE\_TEXT\_FLAG\_NO\_SUGGESTIONS}:	Disable suggestions/autocorrect.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_COMPLETE}:	Enable auto-complete.
                \item \textbf{TYPE\_TEXT\_FLAG\_AUTO\_CORRECT}:	Enable auto-correct.
                \item \textbf{TYPE\_NUMBER\_FLAG\_DECIMAL}:	Allows decimal point (e.g., 3.14).
                \item \textbf{TYPE\_NUMBER\_FLAG\_SIGNED}:	Allows + or – at start.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_NORMAL}:	Normal number input.
                \item \textbf{TYPE\_NUMBER\_VARIATION\_PASSWORD}:	Number password (hidden).
                \item \textbf{TYPE\_DATETIME\_VARIATION\_NORMAL}:	Default date & time.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_DATE}:	Only date input.
                \item \textbf{TYPE\_DATETIME\_VARIATION\_TIME}:	Only time input.
                \item \textbf{TYPE\_NULL}:	No input type specified.
                \item \textbf{TYPE\_MASK\_CLASS}:	Mask to extract base class (text/number/etc.).
                \item \textbf{TYPE\_MASK\_FLAGS}:	Mask to extract all flags.
                \item \textbf{TYPE\_MASK\_VARIATION}:	Mask to extract variation (like email/password).
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsection{Button}


    \pagebreak \noindent
    \subsection{ImageView, ImageView.ScaleType}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{setImageResource(int resource)}
                \item \textbf{setScaleType(ImageView.ScaleType scaleType)}
                \item \textbf{public void setAdjustViewBounds (boolean adjustViewBounds)}: Set this to true if you want the ImageView to adjust its bounds to preserve the aspect ratio of its drawable.
                \item \textbf{public boolean getAdjustViewBounds ()}: True when ImageView is adjusting its bounds to preserve the aspect ratio of its drawable
            \end{itemize}
        \item \textbf{Enum values}
            \begin{itemize}
                \item \textbf{ImageView.ScaleType 	CENTER}: Center the image in the view, but perform no scaling. 
                \item \textbf{ImageView.ScaleType 	CENTER\_CROP}: Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding). 
                \item \textbf{ImageView.ScaleType 	CENTER\_INSIDE}: Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding). 
                \item \textbf{ImageView.ScaleType 	FIT\_CENTER}: Scale the image using Matrix.ScaleToFit.CENTER. 
                \item \textbf{ImageView.ScaleType 	FIT\_END}: Scale the image using Matrix.ScaleToFit.END. 
                \item \textbf{ImageView.ScaleType 	FIT\_START}: Scale the image using Matrix.ScaleToFit.START. 
                \item \textbf{ImageView.ScaleType 	FIT\_XY}: Scale the image using Matrix.ScaleToFit.FILL. 
                \item \textbf{ImageView.ScaleType 	MATRIX}: Scale using the image matrix when drawing. 
            \end{itemize}
    \end{itemize}

    \pagebreak 
    \subsection{ImageButton}
    \begin{itemize}
        
    \end{itemize}


    \pagebreak \noindent
    \subsection{CompoundButton}


    \pagebreak \noindent
    \subsection{CheckBox}


    \pagebreak \noindent
    \subsection{RadioGroup}


    \pagebreak \noindent
    \subsection{RadioGroup.LayoutParams}


    \pagebreak \noindent
    \subsection{RadioButton}


    \pagebreak \noindent
    \subsection{AbsSpinner}


    \pagebreak \noindent
    \subsection{Spinner}


    \pagebreak \noindent
    \subsection{Progessbar}


    \pagebreak \noindent
    \subsection{AbsSeekBar}


    \pagebreak \noindent
    \subsection{SeekBar}


    \pagebreak \noindent
    \subsection{Drawable}


    \pagebreak \noindent
    \subsection{GradientDrawable}


    \pagebreak \noindent
    \subsection{Intent}
    \begin{itemize}
        \item \textbf{Methods}
            \begin{itemize}
                \item \textbf{putExtra(String key, type value)}:	Attach data to the Intent (String, int, boolean, etc.).
                \item \textbf{getStringExtra(String key)}:	Retrieve a String sent via Intent.
                \item \textbf{getIntExtra(String key, int default)}:	Retrieve an int extra.
                \item \textbf{getBooleanExtra(String key, boolean default)}:	Retrieve a boolean extra.
                \item \textbf{getSerializableExtra(String key):}	Retrieve custom objects implementing Serializable.
                \item \textbf{getParcelableExtra(String key)}:	Retrieve objects implementing Parcelable (faster than Serializable).
                \item \textbf{getExtras()}:	Get all extras as a Bundle.
            \end{itemize}
    \end{itemize}


    \pagebreak \noindent
    \subsection{Animation}


    \pagebreak \noindent
    \subsection{AnimationSet}


    \pagebreak \noindent
    \subsection{AlphaAnimation}


    \pagebreak \noindent
    \subsection{RotateAnimation}


    \pagebreak \noindent
    \subsection{ScaleAnimation}


    \pagebreak \noindent
    \subsection{TranslateAnimation}


    \pagebreak \noindent
    \subsection{PreferenceManager}


    \pagebreak \noindent
    \subsection{SharedPreferences (interface)}


    \pagebreak \noindent
    \subsection{SharedPreferences.Editor (Interface)}


    \pagebreak \noindent
    \subsection{Menu (Interface)}


    \pagebreak \noindent
    \subsection{MenuItem (Interface)}


    \pagebreak \noindent
    \subsection{ContextMenu (interface)}


    \pagebreak \noindent
    \subsection{PopupMenu}


    \pagebreak \noindent
    \subsection{SubMenu (interface)}


    \pagebreak \noindent
    \subsection{MenuInflator}


    \pagebreak \noindent
    \subsection{Toast}


    \pagebreak \noindent
    \subsection{LayoutInflator (Abstract class)}


    \pagebreak \noindent
    \subsection{SQLiteDatabase}


    \pagebreak \noindent
    \subsection{Cursor (Interface)}


    \pagebreak \noindent
    \subsection{ScrollView}


    \pagebreak \noindent
    \subsection{HorizontalScrollView}

    \pagebreak 
    \unsect{Activity overloads}
    \begin{itemize}
        \item \textbf{onCreate(Bundle savedInstanceState)}: When activity is first created (before UI is shown), Set layout, initialize variables, listeners, start essential components 
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onCreate(Bundle savedInstanceState) {
                    super.onCreate(savedInstanceState);
                    setContentView(R.layout.activity_main);  // Load UI
                    // Initialize variables, buttons, adapters, listeners, etc.
                }
            \end{javacode}
        \item \textbf{onStart()}: Just before the activity becomes visible, Start tasks that make the activity visible (but not interactive)
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onStart() {
                    super.onStart();
                    // Activity is now visible (but not yet interactive)
                }
            \end{javacode}
        \item \textbf{onResume()}: Activity is visible and user can interact, Resume animations, sensors, camera, audio, start foreground logic
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onResume() {
                    super.onResume();
                    // Activity is in foreground and user can interact
                    // Resume animations, sensors, cameras, music, etc.
                }
            \end{javacode}
        \item \textbf{onPause()}: Another activity is starting or partially covering this one, Save data, pause animations, release sensors/camera/audio
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onPause() {
                    super.onPause();
                    // Another activity is in front, but this one might still be visible
                    // Pause animations, save data to SharedPreferences, stop camera/audio
                }
            \end{javacode}
        \item \textbf{onStop()}: Activity is completely hidden (not visible), Release heavy resources, stop background tasks, unregister receivers
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onStop() {
                    super.onStop();
                    // Activity is no longer visible
                    // Release resources that aren’t needed while hidden
                }
            \end{javacode}
        \item \textbf{onRestart()}: When activity is coming back after being stopped, Re-initialize components if needed before onStart() is called again
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onRestart() {
                    super.onRestart();
                    // Called before activity restarts after being stopped
                    // Re-initialize UI elements if needed
                }
            \end{javacode}
        \item \textbf{onDestroy()}: Before the activity is removed from memory (finish or system kill), Final cleanup (close database, threads, etc.)
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                protected void onDestroy() {
                    super.onDestroy();
                    // Final cleanup: close databases, threads, sensors
                }
            \end{javacode}
        \item \textbf{When do these get called}: 
            \begin{center}
                \begin{tabular}{l|l}
                    Situation	&Lifecycle methods triggered\\
                    \hline\\[0.1cm]
                    Open app	&onCreate() $\to$ onStart() $\to$ onResume()\\[2ex]
                    Press Home button	&onPause() $\to$ onStop()\\[2ex]
                    Return to app	&onRestart() $\to$ onStart() $\to$ onResume()\\[2ex]
                    Rotate screen	&onPause() $\to$ onStop() $\to$ onDestroy() $\to$ onCreate()...\\[2ex]
                    Open new Activity	&Old: onPause() $\to$ new Activity starts $\to$ maybe onStop()\\[2ex]
                    Press back (exit app)	&onPause() $\to$ onStop() $\to$ onDestroy()
                \end{tabular}
            \end{center}
        \item \textbf{With Intents, $A \to B$}:
            \begin{center}
                \begin{tabular}{p{4cm}|p{4cm}|p{4cm}}
                    Event	&Activity $A$	&Activity $B$ \\
                    \hline\\[0.1cm]
                    $A$ starts initially	&onCreate() $\to$ onStart() $\to$ onResume()&	—\\[2ex]
                    $A$ $\to$ $B$ 	& onPause()  $\to$ onStop()& 	onCreate() $\to$ onStart() $\to$ onResume()\\[2ex]
                    $B$ $\to$ $A$ 	& onRestart() $\to$ onStart() $\to$ onResume()&	onPause() $\to$ onStop() $\to$ onDestroy()
                \end{tabular}
            \end{center}
        \item \textbf{onConfigurationChanged}:
            \bigbreak \noindent 
            \begin{javacode}
                @Override
                public void onConfigurationChanged(Configuration newConfig) {
                    super.onConfigurationChanged(newConfig);
                    ...
                }
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \unsect{Event responded to}
    \begin{itemize}
        \item \textbf{View.OnClickListener} 
            \bigbreak \noindent 
            \begin{javacode}
                private class ButtonHandler implements View.OnClickListener {
                    public void onClick(View v) {
                        ...
                    }
                }

            \end{javacode}
        \item \textbf{RadioGroup.OnCheckedChangeListener}
            \bigbreak \noindent 
            \begin{javacode}
                private class RadioButtonHandler implements RadioGroup.OnCheckedChangeListener {
                    public void onCheckedChanged(RadioGroup group, int checkedId) {
                        ...
                    }
                }
            \end{javacode}
    \end{itemize}

    \pagebreak 
    \unsect{Created Transitions}
    \begin{itemize}
        
    \end{itemize}


    \pagebreak 
    \unsect{Notes}
    \subsection{View}
    \begin{itemize}
        \item \textbf{Measuring views}: measure() is part of the layout pass in Android. It tells a View how big it wants to be given the constraints provided by its parent.
            \bigbreak \noindent 
            When you call measure(widthSpec, heightSpec) yourself, you are manually triggering its measurement phase.
            \bigbreak \noindent 
            A measurement includes:
            \begin{itemize}
                \item the parent’s constraints (the measure specs),
                \item the view’s own content and layout parameters,
                \item and any minimum/maximum size rules.
            \end{itemize}
            measure() does not set the final size for drawing. It only calculates the desired size. The final size is set later by layout().
            \bigbreak \noindent 
            After measure() runs, the view stores the results internally. We retrieve them using
            \bigbreak \noindent 
            \begin{javacode}
                int w = view.getMeasuredWidth();
                int h = view.getMeasuredHeight();
            \end{javacode}
            These values represent the size the view calculated for itself based on the constraints given in measure().
            \bigbreak \noindent 
            They are not the final displayed size on screen, they are the measured size that the view wants.
            \bigbreak \noindent 
            The true on-screen size is obtained from:
            \bigbreak \noindent 
            \begin{javacode}
                view.getWidth();
                view.getHeight();
            \end{javacode}
            \bigbreak \noindent 
            Consider the example
            \bigbreak \noindent 
            \begin{xmlcode}
                <?xml version="1.0" encoding="utf-8"?>
                <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    android:id="@+id/root"
                    android:layout_width="200dp"     <!-- Parent is ONLY 200dp wide -->
                    android:layout_height="wrap_content"
                    android:orientation="vertical">

                    <Button
                        android:id="@+id/myButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="THIS IS A VERY LONG BUTTON TEXT" />

                </LinearLayout>
            \end{xmlcode}
            \bigbreak \noindent 
            A Button inside a narrow LinearLayout tries to become very wide (because of its text), but the parent forces it to fit into a smaller width.
            \bigbreak \noindent 
            The Button measures itself by looking at the text. It may report a measured width of, say, 600px (because the text is long), but the parent is only 200dp wide, and it must fit inside it. So, the parent forces the Button to 200dp – padding – margin.
            \bigbreak \noindent 
            \textbf{Note:} We can use this information about measuring views to get the size of a view that has yet to be displayed.
            
    \end{itemize}


    \pagebreak 
    \subsection{LinearLayout}
    \begin{itemize}
        \item \textbf{Specifying where all children go}: The \texttt{LinearLayout} has an XML attribute 
            \bigbreak \noindent 
            \begin{xmlcode}
                android:gravity
            \end{xmlcode}
            \bigbreak \noindent 
            With possible values
            \begin{center}
                \begin{tabularx}{\textwidth}{@{}llX@{}}
                    \toprule
                    \textbf{Constant}&	\textbf{Value}&	\textbf{Description} \\
                    \midrule
                    bottom	&50	&Push object to the bottom of its container, not changing its size.\\[2ex]
                    center	&11	&Place the object in the center of its container in both the vertical and horizontal axis, not changing its size.\\[2ex]
                    center\_horizontal	&1&	Place object in the horizontal center of its container, not changing its size.\\[2ex]
                    center\_vertical	&10&	Place object in the vertical center of its container, not changing its size.\\[2ex]
                    clip\_horizontal	&8&	Additional option that can be set to have the left and/or right edges of the child clipped to its container's bounds. The clip will be based on the horizontal gravity: a left gravity will clip the right edge, a right gravity will clip the left edge, and neither will clip both edges.\\[2ex]
                    clip\_vertical	&80&	Additional option that can be set to have the top and/or bottom edges of the child clipped to its container's bounds. The clip will be based on the vertical gravity: a top gravity will clip the bottom edge, a bottom gravity will clip the top edge, and neither will clip both edges.\\[2ex]
                    end	&800005&	Push object to the end of its container, not changing its size.\\[2ex]
                    fill	&77&	Grow the horizontal and vertical size of the object if needed so it completely fills its container.\\[2ex]
                    fill\_horizontal	&7&	Grow the horizontal size of the object if needed so it completely fills its container.\\[2ex]
                    fill\_vertical	&70&	Grow the vertical size of the object if needed so it completely fills its container.\\[2ex]
                    left	&3&	Push object to the left of its container, not changing its size.\\[2ex]
                    right	&5&	Push object to the right of its container, not changing its size.\\[2ex]
                    start	&800003&	Push object to the beginning of its container, not changing its size.\\[2ex]
                    top	&30&	Push object to the top of its container, not changing its size. \\
                    \bottomrule
                \end{tabularx}
            \end{center}
            The \texttt{android:gravity} attribute in a \texttt{LinearLayout} controls how the layout positions its own children inside itself. This is different from layout\_gravity, which controls how the view itself is positioned inside its parent.
        \item \textbf{Specifying where a specific child view goes}: For this, we use the 
            \bigbreak \noindent 
            \begin{xmlcode}
            android:layout_gravity
            \end{xmlcode}
            \bigbreak \noindent 
            attribute on the child view. This attribute is part of \texttt{LinearLayout.LayoutParams}
        
    \end{itemize}










    
\end{document}
