\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Javascript notes}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Javascript Notes}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 

    \unsect{Getting started}
    \bigbreak \noindent 
    \subsection{Javascript directly in HTML}
    \bigbreak \noindent 
    Here is an example of how to write a very simple web page that will give a pop-up box saying Hi there!:
    \bigbreak \noindent 
    \begin{htmlcode}
        <html>
            <script type="text/javascript"> alert("Hi there!");
            </script>
        </html>
    \end{htmlcode}
    \bigbreak \noindent 


    \bigbreak \noindent 
    \subsection{External file}
    \bigbreak \noindent 
    First, we are going to create a separate JavaScript file. These files have the postfix .js. I'm going to call it ch1\_alert.js. This will be the content of our file:
    \bigbreak \noindent 
    \begin{jscode}
        alert("Saying hi from a different file!");
    \end{jscode}
    \bigbreak \noindent
    Then, in an html file
    \bigbreak \noindent 
    \begin{htmlcode}
        <html>
            <script type="text/javascript" src="ch1_alert.js"></script>
        </html>
    \end{htmlcode}

    \bigbreak \noindent 
    \subsection{Running javascript like a script with node}
    \bigbreak \noindent 
    You can run JavaScript code in the terminal using Node.js.
    \bigbreak \noindent 
    \begin{jscode}
    console.log("Hello world")
    \end{jscode}
    \bigbreak \noindent 
    \begin{bashcode}
    node script.js
    \end{bashcode}



    \bigbreak \noindent 
    \subsection{Semicolons}
    \bigbreak \noindent 
    After every statement, you should insert a semicolon. JavaScript is very forgiving and will understand many situations in which you have forgotten one
    \bigbreak \noindent 
    \subsection{Comments}
    \bigbreak \noindent 
    Js has two types of comments, single line // and multi line /* */

    \bigbreak \noindent 
    \subsection{Prompts}
    \bigbreak \noindent 
    Another thing we would like to show you here is also a command prompt. It works very much like an alert, but instead, it takes input from the user
    \bigbreak \noindent 
    \begin{jscode}
    prompt("Enter something")
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Random}
    \bigbreak \noindent 
    We can generate random reals between 0 and 1 with
    \bigbreak \noindent 
    \begin{jscode}
    Math.random()
    \end{jscode}
    \bigbreak \noindent 
    Multiply by 100 to get reals between 0 and 100
    \bigbreak \noindent 
    \begin{jscode}
    Math.random() * 100
    \end{jscode}
    \bigbreak \noindent 
    Use the floor function to truncate to integers
    \bigbreak \noindent 
    \begin{jscode}
    Math.floor(Math.random() * 100)
    \end{jscode}

    \pagebreak 
    \unsect{Essentials}
    \bigbreak \noindent 
    \subsection{Variables}
    \bigbreak \noindent 
    \subsubsection{let, var, and const}
    \bigbreak \noindent 
    A variable definition consists of three parts: a variable-defining keyword (let, var, or const), a name, and a value. Let's start with the difference between let, var, or const. Here you can see some examples of variables using the different keywords:
    \bigbreak \noindent 
    \begin{jscode}
        let nr1 = 12;
        var nr2 = 8;
        const PI = 3.14159;
    \end{jscode}
    \bigbreak \noindent 
    let and var are both used for variables that might have a new value assigned to them somewhere in the program. The difference between let and var is complex. It is related to scope.
    \bigbreak \noindent 
    var has global scope and let has block scope. var's global scope means that you can use the variables defined with var in the entire script. On the other hand, let's block scope means you can only use variables defined with let in the specific block of code in which they were defined
    \bigbreak \noindent 
    On the other hand, const is used for variables that only get a value assigned onceâ€” for example, the value of pi, which will not change. If you try reassigning a value declared with const, you will get an error:

    \bigbreak \noindent 
    \subsection{Types}
    \bigbreak \noindent 
    \subsubsection{Strings}
    \bigbreak \noindent 
    \begin{itemize}
        \item Double quotes
        \item Single quotes
        \item \textbf{Backticks:} special template strings in which you can use variables directly
            \bigbreak \noindent 
            Aka string interpolation
            \bigbreak \noindent 
            \begin{jscode}
            name = "Nate"
            console.log(`Hello ${name}`)
            \end{jscode}
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Number}
    \bigbreak \noindent 
    The number data type is used to represent, well, numbers. In many languages, there
    is a very clear difference between different types of numbers. The developers of
    JavaScript decided to go for one data type for all these numbers: number. To be more
    precise, they decided to go for a 64-bit floating-point number. This means that it can
    store rather large numbers and both signed and unsigned numbers, numbers with
    decimals, and more.

    \bigbreak \noindent 
    \subsubsection{BigInt}
    \bigbreak \noindent 
    A BigInt data type can be recognized by the postfix n:
    \bigbreak \noindent 
    \begin{jscode}
    let big = 123n
    \end{jscode}
    \bigbreak \noindent 
    Cannot mix BigInt and other types, use explicit conversions

    \bigbreak \noindent 
    \subsubsection{Boolean}
    \bigbreak \noindent 
    true or false

    \bigbreak \noindent 
    \subsubsection{Undefined}
    \bigbreak \noindent 
    It has a special data type for a variable that has not been assigned a value. And this data type is undefined:
    \bigbreak \noindent 
    \begin{jscode}
        let unassigned;
        console.log(unassigned);
    \end{jscode}
    \bigbreak \noindent 
    We can also purposefully assign an undefined value. It is important you know that it is possible, but it is even more important that you know that manually assigning undefined is a bad practice:
    \bigbreak \noindent 
    \begin{jscode}
    let x = undefined
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{null}
    \bigbreak \noindent 
    \begin{jscode}
    let empty = null;
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{Getting type}
    \bigbreak \noindent 
    We use typeof

    \bigbreak \noindent 
    \subsubsection{Converting data types}
    \bigbreak \noindent 
    We have String(), Number(), and Boolean()

    \pagebreak 
    \unsect{Operators}
    \begin{itemize}
        \item \textbf{+,-,/,*, **, \%}
        \item \textbf{Postfix, Prefix}
        \item \textbf{==}: Compares value and does type conversions
        \item \textbf{===}: Compares value and type, does not do any conversions
        \item \textbf{!=}
        \item \textbf{!==}
        \item \textbf{<, >, <=, >=}
        \item \textbf{\&\&}: And
        \item \textbf{||}: Or
        \item \textbf{!}: Not
        \item \textbf{[]}: Index operator
    \end{itemize}


    \pagebreak 
    \unsect{Arrays and their properties}
    \bigbreak \noindent 
    Arrays are lists of values. These values can be of all data types and one array can even contain different data types
    \bigbreak \noindent 
    \subsection{Creating arrays}
    \bigbreak \noindent 
    \begin{jscode}
        let arr = [1,2,3]
        let arr = new Array(3)  // Array of three undefined values
    \end{jscode}

    \bigbreak \noindent 
    \begin{jscode}
        let arr = [1,2,3,4]
        console.log(arr[-1]) // Undefined

        arr[-1] = "What?"
        console.log(arr[-1]) // What?
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{Methods and member variables}
    \bigbreak \noindent 
    \textbf{Member variables:}
    \begin{itemize}
        \item \textbf{.length}
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Methods}
    \begin{itemize}
        \item \textbf{push(...items)}: Adds one or more elements to the end of the array.
        \item \textbf{pop()}: Removes the last element from the array and returns that element.
        \item \textbf{shift()}: Removes the first element from the array and returns that element.
        \item \textbf{unshift(...items)}: Adds one or more elements to the beginning of the array.
        \item \textbf{splice(start, deleteCount, ...items)}: Adds or removes items from the array at the specified index.
        \item \textbf{sort(compareFunction?)}: Sorts the elements of the array in place and returns the sorted array.
        \item \textbf{reverse()}: Reverses the order of the array elements in place.
        \item \textbf{fill(value, start?, end?)}: Fills elements in the array with the specified value.
        \item \textbf{copyWithin(target, start, end?)}: Copies a sequence of elements within the array to another position within the same array.
        \item \textbf{concat(...arrays)}: Returns a new array that is the result of merging two or more arrays.
        \item \textbf{slice(begin?, end?)}: Returns a shallow copy of a portion of an array into a new array.
        \item \textbf{join(separator?)}: Joins all elements of an array into a string using the specified separator.
        \item \textbf{toString()}: Returns a string representing the specified array and its elements.
        \item \textbf{toLocaleString()}: Returns a localized string representing the array and its elements.
        \item \textbf{forEach(callback(currentValue, index, array))}: Executes a provided function once for each array element.
        \item \textbf{map(callback(currentValue, index, array))}: Creates a new array with the results of calling a provided function on every element.
        \item \textbf{filter(callback(currentValue, index, array))}: Creates a new array with all elements that pass the test implemented by the provided function.
        \item \textbf{reduce(callback(accumulator, currentValue, index, array), initialValue?)}: Applies a function against an accumulator and each element to reduce the array to a single value.
        \item \textbf{reduceRight(callback(accumulator, currentValue, index, array), initialValue?)}: Same as reduce(), but processes the array from right-to-left.
        \item \textbf{every(callback(currentValue, index, array))}: Tests whether all elements pass the provided test function.
        \item \textbf{some(callback(currentValue, index, array))}: Tests whether at least one element passes the provided test function.
        \item \textbf{find(callback(currentValue, index, array))}: Returns the first element that satisfies the provided testing function.
        \item \textbf{findIndex(callback(currentValue, index, array))}: Returns the index of the first element that satisfies the provided testing function.
        \item \textbf{indexOf(searchElement, fromIndex?)}: Returns the first index at which a given element can be found.
        \item \textbf{lastIndexOf(searchElement, fromIndex?)}: Returns the last index at which a given element can be found.
        \item \textbf{includes(searchElement, fromIndex?)}: Determines whether an array includes a certain element, returning true or false.
        \item \textbf{flat(depth?)}: Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
        \item \textbf{flatMap(callback(currentValue, index, array))}: First maps each element using a mapping function, then flattens the result into a new array.
        \item \textbf{at(index)}: Returns the item at the given index, supporting negative indices to count back from the end (introduced in ES2022).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Iterators}
    \begin{itemize}
        \item \textbf{entries()}: Returns a new Array Iterator object that contains key/value pairs.
        \item \textbf{keys()}: Returns a new Array Iterator object that contains the keys for each index.
        \item \textbf{values()}: Returns a new Array Iterator object that contains the values for each index.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Array Static Methods}: These methods are called on the Array constructor itself rather than on an instance:
    \begin{itemize}
        \item \textbf{Array.from(iterable, mapFunction?, thisArg?)}: Creates a new, shallow-copied Array instance from an array-like or iterable object.
        \item \textbf{Array.isArray(value)}: Determines whether the passed value is an Array.
        \item \textbf{Array.of(...elements)}: Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.
    \end{itemize}

    \pagebreak 
    \unsect{String properties}























    
\end{document}
