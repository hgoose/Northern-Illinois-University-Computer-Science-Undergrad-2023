\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Javascript notes}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Javascript Notes}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 

    \unsect{Getting started}
    \bigbreak \noindent 
    \subsection{Javascript directly in HTML}
    \bigbreak \noindent 
    Here is an example of how to write a very simple web page that will give a pop-up box saying Hi there!:
    \bigbreak \noindent 
    \begin{htmlcode}
        <html>
            <script type="text/javascript"> alert("Hi there!");
            </script>
        </html>
    \end{htmlcode}
    \bigbreak \noindent 


    \bigbreak \noindent 
    \subsection{External file}
    \bigbreak \noindent 
    First, we are going to create a separate JavaScript file. These files have the postfix .js. I'm going to call it ch1\_alert.js. This will be the content of our file:
    \bigbreak \noindent 
    \begin{jscode}
        alert("Saying hi from a different file!");
    \end{jscode}
    \bigbreak \noindent
    Then, in an html file
    \bigbreak \noindent 
    \begin{htmlcode}
        <html>
            <script type="text/javascript" src="ch1_alert.js"></script>
        </html>
    \end{htmlcode}

    \bigbreak \noindent 
    \subsection{Running javascript like a script with node}
    \bigbreak \noindent 
    You can run JavaScript code in the terminal using Node.js.
    \bigbreak \noindent 
    \begin{jscode}
    console.log("Hello world")
    \end{jscode}
    \bigbreak \noindent 
    \begin{bashcode}
    node script.js
    \end{bashcode}



    \bigbreak \noindent 
    \subsection{Semicolons}
    \bigbreak \noindent 
    After every statement, you should insert a semicolon. JavaScript is very forgiving and will understand many situations in which you have forgotten one
    \bigbreak \noindent 
    \subsection{Comments}
    \bigbreak \noindent 
    Js has two types of comments, single line // and multi line /* */

    \bigbreak \noindent 
    \subsection{Prompts}
    \bigbreak \noindent 
    Another thing we would like to show you here is also a command prompt. It works very much like an alert, but instead, it takes input from the user
    \bigbreak \noindent 
    \begin{jscode}
    prompt("Enter something")
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Random}
    \bigbreak \noindent 
    We can generate random reals between 0 and 1 with
    \bigbreak \noindent 
    \begin{jscode}
    Math.random()
    \end{jscode}
    \bigbreak \noindent 
    Multiply by 100 to get reals between 0 and 100
    \bigbreak \noindent 
    \begin{jscode}
    Math.random() * 100
    \end{jscode}
    \bigbreak \noindent 
    Use the floor function to truncate to integers
    \bigbreak \noindent 
    \begin{jscode}
    Math.floor(Math.random() * 100)
    \end{jscode}

    \pagebreak 
    \unsect{Essentials}
    \bigbreak \noindent 
    \subsection{Variables}
    \bigbreak \noindent 
    \subsubsection{let, var, and const}
    \bigbreak \noindent 
    A variable definition consists of three parts: a variable-defining keyword (let, var, or const), a name, and a value. Let's start with the difference between let, var, or const. Here you can see some examples of variables using the different keywords:
    \bigbreak \noindent 
    \begin{jscode}
        let nr1 = 12;
        var nr2 = 8;
        const PI = 3.14159;
    \end{jscode}
    \bigbreak \noindent 
    let and var are both used for variables that might have a new value assigned to them somewhere in the program. The difference between let and var is complex. It is related to scope.
    \bigbreak \noindent 
    var has global scope and let has block scope. var's global scope means that you can use the variables defined with var in the entire script. On the other hand, let's block scope means you can only use variables defined with let in the specific block of code in which they were defined
    \bigbreak \noindent 
    On the other hand, const is used for variables that only get a value assigned once— for example, the value of pi, which will not change. If you try reassigning a value declared with const, you will get an error:

    \bigbreak \noindent 
    \subsection{Types}
    \bigbreak \noindent 
    \subsubsection{Strings}
    \bigbreak \noindent 
    \begin{itemize}
        \item Double quotes
        \item Single quotes
        \item \textbf{Backticks:} special template strings in which you can use variables directly
            \bigbreak \noindent 
            Aka string interpolation
            \bigbreak \noindent 
            \begin{jscode}
            name = "Nate"
            console.log(`Hello ${name}`)
            \end{jscode}
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Number}
    \bigbreak \noindent 
    The number data type is used to represent, well, numbers. In many languages, there
    is a very clear difference between different types of numbers. The developers of
    JavaScript decided to go for one data type for all these numbers: number. To be more
    precise, they decided to go for a 64-bit floating-point number. This means that it can
    store rather large numbers and both signed and unsigned numbers, numbers with
    decimals, and more.

    \bigbreak \noindent 
    \subsubsection{BigInt}
    \bigbreak \noindent 
    A BigInt data type can be recognized by the postfix n:
    \bigbreak \noindent 
    \begin{jscode}
    let big = 123n
    \end{jscode}
    \bigbreak \noindent 
    Cannot mix BigInt and other types, use explicit conversions

    \bigbreak \noindent 
    \subsubsection{Boolean}
    \bigbreak \noindent 
    true or false

    \bigbreak \noindent 
    \subsubsection{Undefined}
    \bigbreak \noindent 
    It has a special data type for a variable that has not been assigned a value. And this data type is undefined:
    \bigbreak \noindent 
    \begin{jscode}
        let unassigned;
        console.log(unassigned);
    \end{jscode}
    \bigbreak \noindent 
    We can also purposefully assign an undefined value. It is important you know that it is possible, but it is even more important that you know that manually assigning undefined is a bad practice:
    \bigbreak \noindent 
    \begin{jscode}
    let x = undefined
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{null}
    \bigbreak \noindent 
    \begin{jscode}
    let empty = null;
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{Getting type}
    \bigbreak \noindent 
    We use typeof

    \bigbreak \noindent 
    \subsubsection{Converting data types}
    \bigbreak \noindent 
    We have String(), Number(), and Boolean()

    \pagebreak 
    \unsect{Operators}
    \begin{itemize}
        \item \textbf{+,-,/,*, **, \%}
        \item \textbf{Postfix, Prefix}
        \item \textbf{==}: Compares value and does type conversions
        \item \textbf{===}: Compares value and type, does not do any conversions
        \item \textbf{!=}
        \item \textbf{!==}
        \item \textbf{<, >, <=, >=}
        \item \textbf{\&\&}: And
        \item \textbf{||}: Or
        \item \textbf{!}: Not
        \item \textbf{[]}: Index operator
    \end{itemize}


    \pagebreak 
    \unsect{Arrays and their properties}
    \bigbreak \noindent 
    Arrays are lists of values. These values can be of all data types and one array can even contain different data types
    \bigbreak \noindent 
    \subsection{Creating arrays}
    \bigbreak \noindent 
    \begin{jscode}
        let arr = [1,2,3]
        let arr = new Array(3)  // Array of three undefined values
    \end{jscode}

    \bigbreak \noindent 
    \begin{jscode}
        let arr = [1,2,3,4]
        console.log(arr[-1]) // Undefined

        arr[-1] = "What?"
        console.log(arr[-1]) // What?
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{Methods and member variables}
    \bigbreak \noindent 
    \textbf{Member variables:}
    \begin{itemize}
        \item \textbf{.length}
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Methods}
    \begin{itemize}
        \item \textbf{push(...items)}: Adds one or more elements to the end of the array.
        \item \textbf{pop()}: Removes the last element from the array and returns that element.
        \item \textbf{shift()}: Removes the first element from the array and returns that element.
        \item \textbf{unshift(...items)}: Adds one or more elements to the beginning of the array.
        \item \textbf{splice(start, deleteCount, ...items)}: Adds or removes items from the array at the specified index.
        \item \textbf{sort(compareFunction?)}: Sorts the elements of the array in place and returns the sorted array.
        \item \textbf{reverse()}: Reverses the order of the array elements in place.
        \item \textbf{fill(value, start?, end?)}: Fills elements in the array with the specified value.
        \item \textbf{copyWithin(target, start, end?)}: Copies a sequence of elements within the array to another position within the same array.
        \item \textbf{concat(...arrays)}: Returns a new array that is the result of merging two or more arrays.
        \item \textbf{slice(begin?, end?)}: Returns a shallow copy of a portion of an array into a new array.
        \item \textbf{join(separator?)}: Joins all elements of an array into a string using the specified separator.
        \item \textbf{toString()}: Returns a string representing the specified array and its elements.
        \item \textbf{toLocaleString()}: Returns a localized string representing the array and its elements.
        \item \textbf{forEach(callback(currentValue, index, array))}: Executes a provided function once for each array element.
        \item \textbf{map(callback(currentValue, index, array))}: Creates a new array with the results of calling a provided function on every element.
        \item \textbf{filter(callback(currentValue, index, array))}: Creates a new array with all elements that pass the test implemented by the provided function.
        \item \textbf{reduce(callback(accumulator, currentValue, index, array), initialValue?)}: Applies a function against an accumulator and each element to reduce the array to a single value.
        \item \textbf{reduceRight(callback(accumulator, currentValue, index, array), initialValue?)}: Same as reduce(), but processes the array from right-to-left.
        \item \textbf{every(callback(currentValue, index, array))}: Tests whether all elements pass the provided test function.
        \item \textbf{some(callback(currentValue, index, array))}: Tests whether at least one element passes the provided test function.
        \item \textbf{find(callback(currentValue, index, array))}: Returns the first element that satisfies the provided testing function.
        \item \textbf{findIndex(callback(currentValue, index, array))}: Returns the index of the first element that satisfies the provided testing function.
        \item \textbf{indexOf(searchElement, fromIndex?)}: Returns the first index at which a given element can be found.
        \item \textbf{lastIndexOf(searchElement, fromIndex?)}: Returns the last index at which a given element can be found.
        \item \textbf{includes(searchElement, fromIndex?)}: Determines whether an array includes a certain element, returning true or false.
        \item \textbf{flat(depth?)}: Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
        \item \textbf{flatMap(callback(currentValue, index, array))}: First maps each element using a mapping function, then flattens the result into a new array.
        \item \textbf{at(index)}: Returns the item at the given index, supporting negative indices to count back from the end (introduced in ES2022).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Iterators}
    \begin{itemize}
        \item \textbf{entries()}: Returns a new Array Iterator object that contains key/value pairs.
        \item \textbf{keys()}: Returns a new Array Iterator object that contains the keys for each index.
        \item \textbf{values()}: Returns a new Array Iterator object that contains the values for each index.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Array Static Methods}: These methods are called on the Array constructor itself rather than on an instance:
    \begin{itemize}
        \item \textbf{Array.from(iterable, mapFunction?, thisArg?)}: Creates a new, shallow-copied Array instance from an array-like or iterable object.
        \item \textbf{Array.isArray(value)}: Determines whether the passed value is an Array.
        \item \textbf{Array.of(...elements)}: Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.
    \end{itemize}

    \pagebreak 
    \unsect{String properties}

    \pagebreak 
    \unsect{Objects}
    \bigbreak \noindent 
    Objects in javascript can be created with curly braces, for example
    \bigbreak \noindent 
    \begin{jscode}
        let dog = { dogName: "JavaScript",
            weight: 2.4,
            color: "brown",
            breed: "chihuahua",
            age: 3,
            burglarBiter: true
        };
    \end{jscode}
    \bigbreak \noindent 
    There are two main ways to index objects,
    \bigbreak \noindent 
    \begin{jscode}
        console.log(dog["weight"]);
        console.log(dog.weight);
    \end{jscode}

    \pagebreak 
    \unsect{Logic statements}
    \bigbreak \noindent 
    \subsection{If, else if, else}
    \bigbreak \noindent 
    Uses C syntax
    \bigbreak \noindent 
    \begin{jscode}
        if (...) {

        } else if (...) {

        } else {

        }
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Ternary statements (conditional operator)}
    \bigbreak \noindent 
    Also uses C syntax
    \bigbreak \noindent 
    \begin{jscode}
    flag = true

    console.log(flag ? "True!" : "False!")
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Switch}
    \bigbreak \noindent 
    Also uses $C$ syntax
    \bigbreak \noindent 
    \begin{jscode}
        switch (expression) {
            case value1:
                ...
                break;
            ...
            default:
                ...
                break;
        }
    \end{jscode}


    \pagebreak 
    \unsect{Loops}
    \bigbreak \noindent 
    \subsection{While and do while loops}
    \bigbreak \noindent 
    Uses $C$ syntax
    \bigbreak \noindent 
    \begin{jscode}
    let tt = 5, t =0;
    while (tt--) {
        console.log(t++);
    }
    \end{jscode}
    \bigbreak \noindent 
    And
    \bigbreak \noindent 
    \begin{jscode}
    let flag = true
    do {
        console.log("Hello world");
        flag = false;
    } while (flag);
    \end{jscode}

    \bigbreak \noindent 
    \subsection{For loops}
    \bigbreak \noindent 
    Uses $C$ syntax
    \bigbreak \noindent 
    \begin{jscode}
        for (let i=0; i<5; ++i) {
            console.log(i);
        }
    \end{jscode}

    \bigbreak \noindent 
    \subsection{For of loop}
    \bigbreak \noindent 
    There is another loop we can use to iterate over the elements of an array: the for of loop. It cannot be used to change the value associated with the index as we can do with the regular loop, but for processing values it is a very nice and readable loop.
    \bigbreak \noindent 
    \begin{jscode}
        let A = [1,2,3]
        for (let e of A) {
            console.log(e)
        }
    \end{jscode}
    \bigbreak \noindent 
    \begin{jscode}
        let A = [1,2,3]
        for (let e of A) {
            ++e;
        }

        for (let e of A) {
            console.log(e);
        }

        /*
        1
        2
        3
        */
    \end{jscode}

    \bigbreak \noindent 
    \subsection{For in loop}
    \bigbreak \noindent 
    The \texttt{for in} loop gives us the indices of an array, or in the case of an object, the keys
    \bigbreak \noindent 
    \begin{jscode}
        let A = {
            name: "Nate",
            lang: "js",
            x: 10
        };

        for (let e in A) {
            console.log(e, ":", A[e]);
        }
    \end{jscode}

    \bigbreak \noindent 
    \begin{jscode}
        let A = [1,2,3]

        for (let e in A) {
            console.log(e)
        }

        /*
        0
        1
        2
        *
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Looping over objects with C++ structured binding syntax}
    \bigbreak \noindent 
    \begin{jscode}
        let A = {
            name: "Nate",
            lang: "js",
            x: 10
        };


        for (let [k,v] of Object.entries(A)) {
            console.log(k, ":", v);
        }
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Labels with breaking}
    \bigbreak \noindent 
    In js we can give labels to an area in the program, then specify the name of those labels as the argument of a break statement. 
    \bigbreak \noindent 
    \begin{jscode}
        outer:
        for (let i=0; i<5; ++i) {
            inner:
            console.log("i:", i);
            for (let j=0; j<5; ++j) {
                console.log("j:", j);
                if (j == 2) break outer;
            }
        }

        /* 
        i: 0
        j: 0
        j: 1
        j: 2
        */
    \end{jscode}

    \pagebreak 
    \unsect{Functions}
    \bigbreak \noindent 
    \subsection{Simple functions}
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y) {
            console.log(x+y);
        }
        f(1,2); // 3
    \end{jscode}
    \bigbreak \noindent 
    We can define functions inside of functions
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y) {
            function g() {
                console.log(x+y);
            }
            g();
        }
        f(1,2); // 3
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Assigning functions to variables}
    \bigbreak \noindent 
    We can also initialize a variable with a function definition, for example
    \bigbreak \noindent 
    \begin{jscode}
        let f = function() {
            console.log("Hello world");
        }
        f()
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Functions missing arguments}
    \bigbreak \noindent 
    Javascript does not complain, it simply gives NaN
    \bigbreak \noindent 
    \begin{cppcode}
        function f(x,y) {
            console.log(x+y);
        }
        f(1) // NaN
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Arrow functions (Lambdas)}
    \bigbreak \noindent 
    For one line lambdas
    \bigbreak \noindent 
    \begin{jscode}
        let f = x => x + 5; // One parameter
        let g = (x,y) => x+y; // Multiple parameters
        let h = () => console.log("Hello World"); // No parameters

        (() => console.log("Hello world"))();
    \end{jscode}
    \bigbreak \noindent 
    For multi line lambdas
    \bigbreak \noindent 
    \begin{jscode}
        (x => {
            console.log("Some function");
            console.log("x is", x);
        })(5);

        let f = x => {
            return x + 10;
        };
        let x = f(5);
        console.log(x); // 15
    \end{jscode}
    \bigbreak \noindent 
    Notice the set of parenthesis around the top function, this is required for immediately invoked lambdas.

    \bigbreak \noindent 
    \subsection{The spread operator}
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y,z) {
            return x + y + z;
        }

        let A = [1,2,3];
        console.log(f(...A)) // 6;
    \end{jscode}
    \bigbreak \noindent 
    or
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y,a,b) {
            return (x*y) + (a*b);
        }

        let A = [1,2];
        let B = [3,4]
        console.log(f(...A, ...B)) // 14;
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Rest parameter}
    \bigbreak \noindent 
    \begin{jscode}
        function f(...args) {
            for (let arg of args) {
                console.log(arg);
            }
            console.log(typeof(args)); // Object
        }
        f(1,2,3,4);
    \end{jscode}
    \bigbreak \noindent 
    \begin{jscode}
        function f(arg1, ...other) {
            console.log("Arg1 is", arg1);
            for (let arg of other) {
                console.log(arg);
            }
        }
        f(1,2,3,4);
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Hoisting}
    \bigbreak \noindent 
    Hoisting is a process during the compilation phase where JavaScript moves the declarations of functions (and variables, if using var) to the top of their scope. For functions, both the name and the function body are hoisted.
    \bigbreak \noindent 
    \begin{jscode}
        f(); // Works because f is hoisted

        function f() {
            console.log("Hello world");
        }
    \end{jscode}
    \bigbreak \noindent 
    In the above code, the entire function f is hoisted. That means the JavaScript engine is aware of the function f from the very start, allowing it to be called even before the line where f is defined.
    \bigbreak \noindent 
    \subsection{setTimeout and setInterval}
    \bigbreak \noindent 
    \texttt{setTimeout(callback, delay, param1?, param2?, ... paramN)} takes a  function and a time in milliseconds, it calls the callback, but only after the specified time has elapsed. The optional arguments at the end are passed to the function after the delay.
    \bigbreak \noindent 
    \texttt{setInterval(callback, delay, param1, param2?, ..., paramN)} works similarly to setTimeout, repeatedly calls a function or executes a code snippet, with a fixed time delay between each call.

    \bigbreak \noindent 
    \subsection{Restructuring function return values}
    \bigbreak \noindent 
    For a function that returns an array, 
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return [1,2,3];
        }

        let [a,b,c] = f();
        console.log(a,b,c);
    \end{jscode}
    \bigbreak \noindent 
    We can also retrieve only some of the values
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return [1,2,3];
        }

        let [a,b] = f();
        console.log(a,b);
    \end{jscode}
    \bigbreak \noindent 
    For objects, 
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return {name: "Nate", lang: "Javascript"};
        }

        let {name, lang} = f();
        console.log(name, lang);
        /*
        Nate Javascript
        */
    \end{jscode}
    \bigbreak \noindent 
    and we can also alias the variables
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return {name: "Nate", lang: "Javascript"};
        }

        let {name: n, lang: l} = f();
        console.log(n, l);
        /*
        Nate Javascript
        */
    \end{jscode}
    \bigbreak \noindent 
    We can even get only some of the values
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return {name: "Nate", lang: "Javascript"};
        }

        let {name} = f();
        console.log(name);
        /*
        Nate
        */
    \end{jscode}

    \pagebreak 
    \unsect{Classes}
    \bigbreak \noindent 
    We can create a class with the syntax
    \bigbreak \noindent 
    \begin{jscode}
        class className {
            ...
        }
    \end{jscode}
    \bigbreak \noindent 
    We can create constructors with 
    \bigbreak \noindent 
    \begin{jscode}
        class name {
            constructor(a1,a2,...an) {
                ...
            }
        }
    \end{jscode}
    \bigbreak \noindent 
    and create instances of our class with the \textit{new} keyword
    \bigbreak \noindent 
    \begin{jscode}
    let obj = new className(a1,a2,...,an)
    \end{jscode}
    \bigbreak \noindent 
    To give a class member variables, we can define them in the constructor, and with the \textit{this} keyword
    \bigbreak \noindent 
    \begin{jscode}
        class C {
            constructor() {
                this.x = 15;
            }
        };
        let c = new C();
        console.log(c.x);
    \end{jscode}
    \bigbreak \noindent 
    To create methods, we use the normal function syntax but drop the \textit{function} keyword. We can also define member variables inside methods.
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            constructor() {
                this.x = 15;
            }

            g() {
                this.y = 20;
            }
        };

        let f = new foo();
        console.log(f.x, f.y); // 15 Undefined
        f.g();
        console.log(f.x, f.y); // 15 20
    \end{jscode}
    \bigbreak \noindent 
    We can only declare member variables (fields) outside of a constructor or method, we cannot define them.
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            x;
            constructor() {
                this.x = 15;
            }
        };
        let f = new foo();
        console.log(f.x);
    \end{jscode}
    \bigbreak \noindent 
    We cannot use \textit{let, var, } or \textit{const} in declaring or defining class fields.


    \bigbreak \noindent 
    \subsection{Private}
    \bigbreak \noindent 
    We can create private fields with the \# syntax
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            #x;
            constructor() {
                this.#x = 15;
            }
        };
        let f = new foo();
        console.log(f.x); // Undefined
    \end{jscode}
    \bigbreak \noindent 
    We can also use this syntax to make methods private
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            #print() {
                console.log("Hello world");
            }
        };
        let f = new foo();
        f.print(); // Error
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Getters and setters}
    \bigbreak \noindent 
    Getters and setters are special properties that we can use to get data from a class and
    to set data fields on the class. Getters and setters are computed properties. So, they
    are more like properties than they are like functions. We call them accessors. They do
    look a bit like functions, because they have () behind them, but they are not! These accessors start with the get and set keywords.
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            #name;

            set name(name) {
                this.#name = name;
            }

            get name() {
                return this.#name;
            }
        };
        let f = new foo();
        f.x = "Nate";
        console.log(f.x); // Nate
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Inheritence}
    \bigbreak \noindent 
    We implement inheritance with the \textit{extends} keyword
    \bigbreak \noindent 
    \begin{jscode}
        class A {
            x;
            constructor() {
                this.x = 20;
            }

            print() {
                console.log("Hello world");
            }
        };

        class B extends A {
        };

        let b = new B();
        console.log(b.x); // 20
        b.print(); // Hello world
    \end{jscode}
    \bigbreak \noindent 
    Private fields and methods in $A$ are not visible in $B$
    \bigbreak \noindent 
    \begin{jscode}
        class A {
            #x;
            constructor() {
                this.#x = 20;
            }

            print() {
                console.log("Hello world");
            }
        };

        class B extends A {
        };

        let b = new B();
        console.log(b.x); // Undefined
        b.print(); // Hello world
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Prototypes}
    \bigbreak \noindent 
    A prototype is the mechanism in JavaScript that makes it possible to have objects.
    When nothing is specified when creating a class, the objects inherit from the
    Object.prototype prototype. This is a rather complex built-in JavaScript class that
    we can use. We don't need to look at how this is implemented in JavaScript, as
    we can consider it the base object that is always on top of the inheritance tree and
    therefore always present in our objects
    \bigbreak \noindent 
    There is a \textit{prototype} property available on all classes, and it is always named
    "prototype."
    \bigbreak \noindent 
    Here is how to add a function to this class using prototype
    \bigbreak \noindent 
    \begin{jscode}
        class Person {
            constructor(firstname, lastname) {
                this.firstname = firstname;
                this.lastname = lastname;
            }
            greet() {
                console.log("Hi there!");
            }
        }

        Person.prototype.introduce = function () {
            console.log("Hi, I'm", this.firstname);
        };

        let p1 = new Person("Bob", "Smith");
        p1.introduce(); // Hi, I'm Bob
    \end{jscode}
    \bigbreak \noindent 
    prototype is a property holding all the properties and methods of an object. So,
    adding a function to prototype is adding a function to the class. You can use
    prototype to add properties or methods to an object, like we did in the above
    example in our code with the introduce function. You can also do this for properties
    \bigbreak \noindent 
    \begin{jscode}
        Person.prototype.favoriteColor = "green";
    \end{jscode}
    \bigbreak \noindent 
    So the methods and properties defined via prototype are really as if they were defined in the class. 
    \bigbreak \noindent 
    This is something you should not be using when you have control over the class
    code and you want to change it permanently. In that case, just change the class.
    However, you can expand existing objects like this and even expand existing objects
    conditionally. It is also important to know that the JavaScript built-in objects have
    prototypes and inherit from Object.prototype. However, be sure not to modify this
    prototype since it will affect how our JavaScript works.

    \pagebreak 
    \unsect{The Document Object Model}
    \bigbreak \noindent 
    \subsection{The BOM}
    \bigbreak \noindent 
    The BOM, sometimes also called the window browser object, is the amazing "magic"
    element that makes it possible for your JavaScript code to communicate with the
    browser.
    \bigbreak \noindent 
    The window object contains all the properties required to represent the window of
    the browser, so for example, the size of the window and the history of previously
    visited web pages. The window object has global variables and functions, and these
    can all be seen when we explore the window object. The exact implementation of the
    BOM depends on the browser and the version of the browser. This is important to
    keep in mind while working your way through these sections.
    \bigbreak \noindent 
    Some of the most important objects of the BOM we will look into in this chapter are:
    \begin{itemize}
        \item History
        \item Navigator
        \item Location
    \end{itemize}
    \bigbreak \noindent 
    You can type the following command in the browser console and press Enter to get information about the window object:
    \bigbreak \noindent 
    \begin{jscode}
        console.dir(window);
    \end{jscode}
    \bigbreak \noindent 
    The console.dir() method shows a list of all the properties of the specified object.
    You can click on the little triangles to open the objects and inspect them even more.
    \bigbreak \noindent 
    The BOM contains many other objects. We can access these like we saw when
    we dealt with objects, so for example, we can get the length of the history (in my
    browser) accessing the history object of the window and then the length of the
    history object, like this
    \bigbreak \noindent 
    \begin{jscode}
        window.history.length;
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{BOM Objects}
    \bigbreak \noindent 
    We have
    \begin{itemize}
        \item \textbf{window}: The window object is the top-level object in a browser and serves as the global context for JavaScript running in the browser. All global variables and functions become properties of the window object.
        \item \textbf{history}: The history object allows you to navigate back and forth through the user's session history.
        \item \textbf{location}: The location object provides information about the current URL and allows you to redirect the browser to a new URL or reload the current page.
        \item \textbf{navigator}: The navigator object exposes properties that provide information about the browser and the underlying operating system.
        \item \textbf{screen}: The navigator object exposes properties that provide information about the browser and the underlying operating system.The screen object contains information about the physical screen of the device. This includes properties like screen.width, screen.height, and screen.availHeight.
        \item \textbf{frames}: Although not an independent object per se, window.frames is a collection that refers to the child windows (or frames) if your document is split into different frames or iframes.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Common window properties and methods}
    \bigbreak \noindent 
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{window.document}: Provides access to the DOM (Document Object Model) of the current page.
        \item \textbf{window.location}: References the location object, which provides details about the current URL (see Location section below).
        \item \textbf{window.history}: Gives access to the history object to navigate user history (see History section below).
        \item \textbf{window.navigator}: Provides details about the browser and the operating system (see Navigator section below).
        \item \textbf{window.innerWidth \& window.innerHeight}: Represents the viewport’s width and height. Useful for responsive designs and adapting layouts dynamically.
        \item \textbf{window.outerWidth \& window.outerHeight}: Offers the total width and height of the browser window including interface elements like toolbars and scrollbars.
        \item \textbf{window.localStorage \& window.sessionStorage}: Allow you to store data on the client side persistently or for the session duration, respectively.
        \item \textbf{window.console}: Provides access to the browser’s debugging console for logging purposes.
        \item \textbf{window.frames}: Holds a collection of all the frames (or iframes) embedded in the window (further discussed under Frames).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Common Methods}:
    \begin{itemize}
        \item \textbf{window.alert(message)}: Displays an alert dialog with the specified message.
        \item \textbf{window.confirm(message)}: Opens a modal dialog with OK and Cancel buttons, returning a Boolean based on the user's choice.
        \item \textbf{window.prompt(message, defaultText)}: Shows a dialog prompting the user for input.
        \item \textbf{window.setTimeout(callback, delay)}: Executes a function once after a specified delay (in milliseconds).
        \item \textbf{window.setInterval(callback, interval)}: Repeatedly executes a function with a fixed time delay between each call.
        \item \textbf{window.clearTimeout(timeoutID) \& window.clearInterval(intervalID)} Cancel pending timeouts or intervals.
        \item \textbf{window.open(url, name, specs)}: Opens a new browser window or tab.
        \item \textbf{window.close()}: Closes the current window (typically works only if the window was opened by a script).
        \item \textbf{window.addEventListener(event, handler)}: Attaches an event handler to the window (and similarly, removeEventListener to detach).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{History Objecti properties and methods}
    \bigbreak \noindent 
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{history.length}: Returns the number of URL entries in the session history.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Methods:}
    \begin{itemize}
        \item \textbf{history.back()}: Equivalent to clicking the browser’s Back button. It moves backward by one in the history stack.
        \item \textbf{history.forward()}: Moves forward by one, similar to clicking the Forward button.
        \item \textbf{history.go(delta)}: Loads a specific page relative to the current page. For example, history.go(-1) is like calling history.back().
        \item \textbf{history.pushState(state, title, url)}: Adds a new state to the browser’s session history without reloading the page. This is essential in Single Page Applications (SPAs) for creating navigable states.
        \item \textbf{history.replaceState(state, title, url)}: Modifies the current history entry instead of creating a new one, which is useful for updating the URL or state without affecting the history stack.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Location Object properties and methods}
    \bigbreak \noindent 
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{location.href}: A string containing the full URL of the current page.
        \item \textbf{location.protocol}: The protocol scheme of the URL (e.g., "http:" or "https:").
        \item \textbf{location.host}: Combines the hostname and port (if specified).
        \item \textbf{location.hostname}: The domain name of the web host.
        \item \textbf{location.port}: The port number used by the URL.
        \item \textbf{location.pathname}: The path (directory and file name) part of the URL.
        \item \textbf{location.search}: Contains the query string part of the URL (the portion following the ?).
        \item \textbf{location.hash}: Holds the anchor or fragment identifier of the URL (the portion following the #).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Methods:}
    \begin{itemize}
        \item \textbf{location.assign(url)}: Loads the resource at the specified URL, similar to clicking a link.
        \item \textbf{location.replace(url)}: Loads a new document, replacing the current document in the history. This means the current page won’t be available via the Back button.
        \item \textbf{location.reload(forceReload)}: Reloads the current page. Using a truthy value for forceReload forces the page to reload from the server rather than the cache.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Navigator Object properties and methods}
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{navigator.appName}: Provides the name of the browser (though its use is generally discouraged due to its lack of reliability).
        \item \textbf{navigator.appVersion}: A version string for the browser.
        \item \textbf{navigator.userAgent}: A string that contains details about the browser, its version, and the operating system. This is often used for browser detection.
        \item \textbf{navigator.platform}: Indicates the operating system platform (e.g., "Win32", "MacIntel").
        \item \textbf{navigator.language}: The default language of the browser.
        \item \textbf{navigator.languages}: An array that lists the user's preferred languages.
        \item \textbf{navigator.onLine}: A Boolean indicating whether the browser is online.
        \item \textbf{navigator.cookieEnabled}: Indicates whether cookies are enabled in the browser. 
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Methods:}
    \begin{itemize}
        \item \textbf{navigator.javaEnabled()}: Returns a Boolean indicating if the Java plugin is enabled in the browser.
        \item \textbf{navigator.sendBeacon(url, data)}: Used to asynchronously send data to a server, often employed for sending analytics data without blocking unloading of the document.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Screen Object}
    \textbf{Properties}
    \begin{itemize}
        \item \textbf{screen.width}: The total width of the visitor’s screen in pixels.
        \item \textbf{screen.height}: The total height of the visitor’s screen in pixels.
        \item \textbf{screen.availWidth}: The width of the screen available for the window (excluding interface elements like the taskbar).
        \item \textbf{screen.availHeight}: The height of the screen available for the window.
        \item \textbf{screen.colorDepth}: The number of bits used to display one color (usually 24 or 32).
        \item \textbf{screen.pixelDepth}: Similar to colorDepth, representing the actual color resolution.
    \end{itemize}




     





















    
\end{document}
