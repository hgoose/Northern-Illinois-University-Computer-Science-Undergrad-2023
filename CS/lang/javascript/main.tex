\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Javascript notes}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Javascript Notes}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 

    \unsect{Getting started}
    \bigbreak \noindent 
    \subsection{Javascript directly in HTML}
    \bigbreak \noindent 
    Here is an example of how to write a very simple web page that will give a pop-up box saying Hi there!:
    \bigbreak \noindent 
    \begin{htmlcode}
        <html>
            <script type="text/javascript"> alert("Hi there!");
            </script>
        </html>
    \end{htmlcode}
    \bigbreak \noindent 


    \bigbreak \noindent 
    \subsection{External file}
    \bigbreak \noindent 
    First, we are going to create a separate JavaScript file. These files have the postfix .js. I'm going to call it ch1\_alert.js. This will be the content of our file:
    \bigbreak \noindent 
    \begin{jscode}
        alert("Saying hi from a different file!");
    \end{jscode}
    \bigbreak \noindent
    Then, in an html file
    \bigbreak \noindent 
    \begin{htmlcode}
        <html>
            <script type="text/javascript" src="ch1_alert.js"></script>
        </html>
    \end{htmlcode}

    \bigbreak \noindent 
    \subsection{Running javascript like a script with node}
    \bigbreak \noindent 
    You can run JavaScript code in the terminal using Node.js.
    \bigbreak \noindent 
    \begin{jscode}
    console.log("Hello world")
    \end{jscode}
    \bigbreak \noindent 
    \begin{bashcode}
    node script.js
    \end{bashcode}



    \bigbreak \noindent 
    \subsection{Semicolons}
    \bigbreak \noindent 
    After every statement, you should insert a semicolon. JavaScript is very forgiving and will understand many situations in which you have forgotten one
    \bigbreak \noindent 
    \subsection{Comments}
    \bigbreak \noindent 
    Js has two types of comments, single line // and multi line /* */

    \bigbreak \noindent 
    \subsection{Prompts}
    \bigbreak \noindent 
    Another thing we would like to show you here is also a command prompt. It works very much like an alert, but instead, it takes input from the user
    \bigbreak \noindent 
    \begin{jscode}
    prompt("Enter something")
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Random}
    \bigbreak \noindent 
    We can generate random reals between 0 and 1 with
    \bigbreak \noindent 
    \begin{jscode}
    Math.random()
    \end{jscode}
    \bigbreak \noindent 
    Multiply by 100 to get reals between 0 and 100
    \bigbreak \noindent 
    \begin{jscode}
    Math.random() * 100
    \end{jscode}
    \bigbreak \noindent 
    Use the floor function to truncate to integers
    \bigbreak \noindent 
    \begin{jscode}
    Math.floor(Math.random() * 100)
    \end{jscode}

    \pagebreak 
    \unsect{Essentials}
    \bigbreak \noindent 
    \subsection{Variables}
    \bigbreak \noindent 
    \subsubsection{let, var, and const}
    \bigbreak \noindent 
    A variable definition consists of three parts: a variable-defining keyword (let, var, or const), a name, and a value. Let's start with the difference between let, var, or const. Here you can see some examples of variables using the different keywords:
    \bigbreak \noindent 
    \begin{jscode}
        let nr1 = 12;
        var nr2 = 8;
        const PI = 3.14159;
    \end{jscode}
    \bigbreak \noindent 
    let and var are both used for variables that might have a new value assigned to them somewhere in the program. The difference between let and var is complex. It is related to scope.
    \bigbreak \noindent 
    var has global scope and let has block scope. var's global scope means that you can use the variables defined with var in the entire script. On the other hand, let's block scope means you can only use variables defined with let in the specific block of code in which they were defined
    \bigbreak \noindent 
    On the other hand, const is used for variables that only get a value assigned once— for example, the value of pi, which will not change. If you try reassigning a value declared with const, you will get an error:

    \bigbreak \noindent 
    \subsection{Types}
    \bigbreak \noindent 
    \subsubsection{Strings}
    \bigbreak \noindent 
    \begin{itemize}
        \item Double quotes
        \item Single quotes
        \item \textbf{Backticks:} special template strings in which you can use variables directly
            \bigbreak \noindent 
            Aka string interpolation
            \bigbreak \noindent 
            \begin{jscode}
            name = "Nate"
            console.log(`Hello ${name}`)
            \end{jscode}
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Number}
    \bigbreak \noindent 
    The number data type is used to represent, well, numbers. In many languages, there
    is a very clear difference between different types of numbers. The developers of
    JavaScript decided to go for one data type for all these numbers: number. To be more
    precise, they decided to go for a 64-bit floating-point number. This means that it can
    store rather large numbers and both signed and unsigned numbers, numbers with
    decimals, and more.

    \bigbreak \noindent 
    \subsubsection{BigInt}
    \bigbreak \noindent 
    A BigInt data type can be recognized by the postfix n:
    \bigbreak \noindent 
    \begin{jscode}
    let big = 123n
    \end{jscode}
    \bigbreak \noindent 
    Cannot mix BigInt and other types, use explicit conversions

    \bigbreak \noindent 
    \subsubsection{Boolean}
    \bigbreak \noindent 
    true or false

    \bigbreak \noindent 
    \subsubsection{Undefined}
    \bigbreak \noindent 
    It has a special data type for a variable that has not been assigned a value. And this data type is undefined:
    \bigbreak \noindent 
    \begin{jscode}
        let unassigned;
        console.log(unassigned);
    \end{jscode}
    \bigbreak \noindent 
    We can also purposefully assign an undefined value. It is important you know that it is possible, but it is even more important that you know that manually assigning undefined is a bad practice:
    \bigbreak \noindent 
    \begin{jscode}
    let x = undefined
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{null}
    \bigbreak \noindent 
    \begin{jscode}
    let empty = null;
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{Getting type}
    \bigbreak \noindent 
    We use typeof

    \bigbreak \noindent 
    \subsubsection{Converting data types}
    \bigbreak \noindent 
    We have String(), Number(), and Boolean()

    \pagebreak 
    \unsect{Operators}
    \begin{itemize}
        \item \textbf{+,-,/,*, **, \%}
        \item \textbf{Postfix, Prefix}
        \item \textbf{==}: Compares value and does type conversions
        \item \textbf{===}: Compares value and type, does not do any conversions
        \item \textbf{!=}
        \item \textbf{!==}
        \item \textbf{<, >, <=, >=}
        \item \textbf{\&\&}: And
        \item \textbf{||}: Or
        \item \textbf{!}: Not
        \item \textbf{[]}: Index operator
    \end{itemize}


    \pagebreak 
    \unsect{Arrays and their properties}
    \bigbreak \noindent 
    Arrays are lists of values. These values can be of all data types and one array can even contain different data types
    \bigbreak \noindent 
    \subsection{Creating arrays}
    \bigbreak \noindent 
    \begin{jscode}
        let arr = [1,2,3]
        let arr = new Array(3)  // Array of three undefined values
    \end{jscode}

    \bigbreak \noindent 
    \begin{jscode}
        let arr = [1,2,3,4]
        console.log(arr[-1]) // Undefined

        arr[-1] = "What?"
        console.log(arr[-1]) // What?
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{Methods and member variables}
    \bigbreak \noindent 
    \textbf{Member variables:}
    \begin{itemize}
        \item \textbf{.length}
    \end{itemize}

    \bigbreak \noindent 
    \textbf{Methods}
    \begin{itemize}
        \item \textbf{push(...items)}: Adds one or more elements to the end of the array.
        \item \textbf{pop()}: Removes the last element from the array and returns that element.
        \item \textbf{shift()}: Removes the first element from the array and returns that element.
        \item \textbf{unshift(...items)}: Adds one or more elements to the beginning of the array.
        \item \textbf{splice(start, deleteCount, ...items)}: Adds or removes items from the array at the specified index.
        \item \textbf{sort(compareFunction?)}: Sorts the elements of the array in place and returns the sorted array.
        \item \textbf{reverse()}: Reverses the order of the array elements in place.
        \item \textbf{fill(value, start?, end?)}: Fills elements in the array with the specified value.
        \item \textbf{copyWithin(target, start, end?)}: Copies a sequence of elements within the array to another position within the same array.
        \item \textbf{concat(...arrays)}: Returns a new array that is the result of merging two or more arrays.
        \item \textbf{slice(begin?, end?)}: Returns a shallow copy of a portion of an array into a new array.
        \item \textbf{join(separator?)}: Joins all elements of an array into a string using the specified separator.
        \item \textbf{toString()}: Returns a string representing the specified array and its elements.
        \item \textbf{toLocaleString()}: Returns a localized string representing the array and its elements.
        \item \textbf{forEach(callback(currentValue, index, array))}: Executes a provided function once for each array element.
        \item \textbf{map(callback(currentValue, index, array))}: Creates a new array with the results of calling a provided function on every element.
        \item \textbf{filter(callback(currentValue, index, array))}: Creates a new array with all elements that pass the test implemented by the provided function.
        \item \textbf{reduce(callback(accumulator, currentValue, index, array), initialValue?)}: Applies a function against an accumulator and each element to reduce the array to a single value.
        \item \textbf{reduceRight(callback(accumulator, currentValue, index, array), initialValue?)}: Same as reduce(), but processes the array from right-to-left.
        \item \textbf{every(callback(currentValue, index, array))}: Tests whether all elements pass the provided test function.
        \item \textbf{some(callback(currentValue, index, array))}: Tests whether at least one element passes the provided test function.
        \item \textbf{find(callback(currentValue, index, array))}: Returns the first element that satisfies the provided testing function.
        \item \textbf{findIndex(callback(currentValue, index, array))}: Returns the index of the first element that satisfies the provided testing function.
        \item \textbf{indexOf(searchElement, fromIndex?)}: Returns the first index at which a given element can be found.
        \item \textbf{lastIndexOf(searchElement, fromIndex?)}: Returns the last index at which a given element can be found.
        \item \textbf{includes(searchElement, fromIndex?)}: Determines whether an array includes a certain element, returning true or false.
        \item \textbf{flat(depth?)}: Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
        \item \textbf{flatMap(callback(currentValue, index, array))}: First maps each element using a mapping function, then flattens the result into a new array.
        \item \textbf{at(index)}: Returns the item at the given index, supporting negative indices to count back from the end (introduced in ES2022).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Iterators}
    \begin{itemize}
        \item \textbf{entries()}: Returns a new Array Iterator object that contains key/value pairs.
        \item \textbf{keys()}: Returns a new Array Iterator object that contains the keys for each index.
        \item \textbf{values()}: Returns a new Array Iterator object that contains the values for each index.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Array Static Methods}: These methods are called on the Array constructor itself rather than on an instance:
    \begin{itemize}
        \item \textbf{Array.from(iterable, mapFunction?, thisArg?)}: Creates a new, shallow-copied Array instance from an array-like or iterable object.
        \item \textbf{Array.isArray(value)}: Determines whether the passed value is an Array.
        \item \textbf{Array.of(...elements)}: Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.
    \end{itemize}

    \pagebreak 
    \unsect{String properties}

    \pagebreak 
    \unsect{Objects}
    \bigbreak \noindent 
    Objects in javascript can be created with curly braces, for example
    \bigbreak \noindent 
    \begin{jscode}
        let dog = { dogName: "JavaScript",
            weight: 2.4,
            color: "brown",
            breed: "chihuahua",
            age: 3,
            burglarBiter: true
        };
    \end{jscode}
    \bigbreak \noindent 
    There are two main ways to index objects,
    \bigbreak \noindent 
    \begin{jscode}
        console.log(dog["weight"]);
        console.log(dog.weight);
    \end{jscode}

    \pagebreak 
    \unsect{Logic statements}
    \bigbreak \noindent 
    \subsection{If, else if, else}
    \bigbreak \noindent 
    Uses C syntax
    \bigbreak \noindent 
    \begin{jscode}
        if (...) {

        } else if (...) {

        } else {

        }
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Ternary statements (conditional operator)}
    \bigbreak \noindent 
    Also uses C syntax
    \bigbreak \noindent 
    \begin{jscode}
    flag = true

    console.log(flag ? "True!" : "False!")
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Switch}
    \bigbreak \noindent 
    Also uses $C$ syntax
    \bigbreak \noindent 
    \begin{jscode}
        switch (expression) {
            case value1:
                ...
                break;
            ...
            default:
                ...
                break;
        }
    \end{jscode}


    \pagebreak 
    \unsect{Loops}
    \bigbreak \noindent 
    \subsection{While and do while loops}
    \bigbreak \noindent 
    Uses $C$ syntax
    \bigbreak \noindent 
    \begin{jscode}
    let tt = 5, t =0;
    while (tt--) {
        console.log(t++);
    }
    \end{jscode}
    \bigbreak \noindent 
    And
    \bigbreak \noindent 
    \begin{jscode}
    let flag = true
    do {
        console.log("Hello world");
        flag = false;
    } while (flag);
    \end{jscode}

    \bigbreak \noindent 
    \subsection{For loops}
    \bigbreak \noindent 
    Uses $C$ syntax
    \bigbreak \noindent 
    \begin{jscode}
        for (let i=0; i<5; ++i) {
            console.log(i);
        }
    \end{jscode}

    \bigbreak \noindent 
    \subsection{For of loop}
    \bigbreak \noindent 
    There is another loop we can use to iterate over the elements of an array: the for of loop. It cannot be used to change the value associated with the index as we can do with the regular loop, but for processing values it is a very nice and readable loop.
    \bigbreak \noindent 
    \begin{jscode}
        let A = [1,2,3]
        for (let e of A) {
            console.log(e)
        }
    \end{jscode}
    \bigbreak \noindent 
    \begin{jscode}
        let A = [1,2,3]
        for (let e of A) {
            ++e;
        }

        for (let e of A) {
            console.log(e);
        }

        /*
        1
        2
        3
        */
    \end{jscode}

    \bigbreak \noindent 
    \subsection{For in loop}
    \bigbreak \noindent 
    The \texttt{for in} loop gives us the indices of an array, or in the case of an object, the keys
    \bigbreak \noindent 
    \begin{jscode}
        let A = {
            name: "Nate",
            lang: "js",
            x: 10
        };

        for (let e in A) {
            console.log(e, ":", A[e]);
        }
    \end{jscode}

    \bigbreak \noindent 
    \begin{jscode}
        let A = [1,2,3]

        for (let e in A) {
            console.log(e)
        }

        /*
        0
        1
        2
        *
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Looping over objects with C++ structured binding syntax}
    \bigbreak \noindent 
    \begin{jscode}
        let A = {
            name: "Nate",
            lang: "js",
            x: 10
        };


        for (let [k,v] of Object.entries(A)) {
            console.log(k, ":", v);
        }
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Labels with breaking}
    \bigbreak \noindent 
    In js we can give labels to an area in the program, then specify the name of those labels as the argument of a break statement. 
    \bigbreak \noindent 
    \begin{jscode}
        outer:
        for (let i=0; i<5; ++i) {
            inner:
            console.log("i:", i);
            for (let j=0; j<5; ++j) {
                console.log("j:", j);
                if (j == 2) break outer;
            }
        }

        /* 
        i: 0
        j: 0
        j: 1
        j: 2
        */
    \end{jscode}

    \pagebreak 
    \unsect{Functions}
    \bigbreak \noindent 
    \subsection{Simple functions}
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y) {
            console.log(x+y);
        }
        f(1,2); // 3
    \end{jscode}
    \bigbreak \noindent 
    We can define functions inside of functions
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y) {
            function g() {
                console.log(x+y);
            }
            g();
        }
        f(1,2); // 3
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Assigning functions to variables}
    \bigbreak \noindent 
    We can also initialize a variable with a function definition, for example
    \bigbreak \noindent 
    \begin{jscode}
        let f = function() {
            console.log("Hello world");
        }
        f()
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Functions missing arguments}
    \bigbreak \noindent 
    Javascript does not complain, it simply gives NaN
    \bigbreak \noindent 
    \begin{cppcode}
        function f(x,y) {
            console.log(x+y);
        }
        f(1) // NaN
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Arrow functions (Lambdas)}
    \bigbreak \noindent 
    For one line lambdas
    \bigbreak \noindent 
    \begin{jscode}
        let f = x => x + 5; // One parameter
        let g = (x,y) => x+y; // Multiple parameters
        let h = () => console.log("Hello World"); // No parameters

        (() => console.log("Hello world"))();
    \end{jscode}
    \bigbreak \noindent 
    For multi line lambdas
    \bigbreak \noindent 
    \begin{jscode}
        (x => {
            console.log("Some function");
            console.log("x is", x);
        })(5);

        let f = x => {
            return x + 10;
        };
        let x = f(5);
        console.log(x); // 15
    \end{jscode}
    \bigbreak \noindent 
    Notice the set of parenthesis around the top function, this is required for immediately invoked lambdas.

    \bigbreak \noindent 
    \subsection{The spread operator}
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y,z) {
            return x + y + z;
        }

        let A = [1,2,3];
        console.log(f(...A)) // 6;
    \end{jscode}
    \bigbreak \noindent 
    or
    \bigbreak \noindent 
    \begin{jscode}
        function f(x,y,a,b) {
            return (x*y) + (a*b);
        }

        let A = [1,2];
        let B = [3,4]
        console.log(f(...A, ...B)) // 14;
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Rest parameter}
    \bigbreak \noindent 
    \begin{jscode}
        function f(...args) {
            for (let arg of args) {
                console.log(arg);
            }
            console.log(typeof(args)); // Object
        }
        f(1,2,3,4);
    \end{jscode}
    \bigbreak \noindent 
    \begin{jscode}
        function f(arg1, ...other) {
            console.log("Arg1 is", arg1);
            for (let arg of other) {
                console.log(arg);
            }
        }
        f(1,2,3,4);
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Hoisting}
    \bigbreak \noindent 
    Hoisting is a process during the compilation phase where JavaScript moves the declarations of functions (and variables, if using var) to the top of their scope. For functions, both the name and the function body are hoisted.
    \bigbreak \noindent 
    \begin{jscode}
        f(); // Works because f is hoisted

        function f() {
            console.log("Hello world");
        }
    \end{jscode}
    \bigbreak \noindent 
    In the above code, the entire function f is hoisted. That means the JavaScript engine is aware of the function f from the very start, allowing it to be called even before the line where f is defined.
    \bigbreak \noindent 
    \subsection{setTimeout and setInterval}
    \bigbreak \noindent 
    \texttt{setTimeout(callback, delay, param1?, param2?, ... paramN)} takes a  function and a time in milliseconds, it calls the callback, but only after the specified time has elapsed. The optional arguments at the end are passed to the function after the delay.
    \bigbreak \noindent 
    \texttt{setInterval(callback, delay, param1, param2?, ..., paramN)} works similarly to setTimeout, repeatedly calls a function or executes a code snippet, with a fixed time delay between each call.

    \bigbreak \noindent 
    \subsection{Restructuring function return values}
    \bigbreak \noindent 
    For a function that returns an array, 
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return [1,2,3];
        }

        let [a,b,c] = f();
        console.log(a,b,c);
    \end{jscode}
    \bigbreak \noindent 
    We can also retrieve only some of the values
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return [1,2,3];
        }

        let [a,b] = f();
        console.log(a,b);
    \end{jscode}
    \bigbreak \noindent 
    For objects, 
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return {name: "Nate", lang: "Javascript"};
        }

        let {name, lang} = f();
        console.log(name, lang);
        /*
        Nate Javascript
        */
    \end{jscode}
    \bigbreak \noindent 
    and we can also alias the variables
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return {name: "Nate", lang: "Javascript"};
        }

        let {name: n, lang: l} = f();
        console.log(n, l);
        /*
        Nate Javascript
        */
    \end{jscode}
    \bigbreak \noindent 
    We can even get only some of the values
    \bigbreak \noindent 
    \begin{jscode}
        function f() {
            return {name: "Nate", lang: "Javascript"};
        }

        let {name} = f();
        console.log(name);
        /*
        Nate
        */
    \end{jscode}

    \pagebreak 
    \unsect{Classes}
    \bigbreak \noindent 
    We can create a class with the syntax
    \bigbreak \noindent 
    \begin{jscode}
        class className {
            ...
        }
    \end{jscode}
    \bigbreak \noindent 
    We can create constructors with 
    \bigbreak \noindent 
    \begin{jscode}
        class name {
            constructor(a1,a2,...an) {
                ...
            }
        }
    \end{jscode}
    \bigbreak \noindent 
    and create instances of our class with the \textit{new} keyword
    \bigbreak \noindent 
    \begin{jscode}
    let obj = new className(a1,a2,...,an)
    \end{jscode}
    \bigbreak \noindent 
    To give a class member variables, we can define them in the constructor, and with the \textit{this} keyword
    \bigbreak \noindent 
    \begin{jscode}
        class C {
            constructor() {
                this.x = 15;
            }
        };
        let c = new C();
        console.log(c.x);
    \end{jscode}
    \bigbreak \noindent 
    To create methods, we use the normal function syntax but drop the \textit{function} keyword. We can also define member variables inside methods.
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            constructor() {
                this.x = 15;
            }

            g() {
                this.y = 20;
            }
        };

        let f = new foo();
        console.log(f.x, f.y); // 15 Undefined
        f.g();
        console.log(f.x, f.y); // 15 20
    \end{jscode}
    \bigbreak \noindent 
    We can only declare member variables (fields) outside of a constructor or method, we cannot define them.
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            x;
            constructor() {
                this.x = 15;
            }
        };
        let f = new foo();
        console.log(f.x);
    \end{jscode}
    \bigbreak \noindent 
    We cannot use \textit{let, var, } or \textit{const} in declaring or defining class fields.


    \bigbreak \noindent 
    \subsection{Private}
    \bigbreak \noindent 
    We can create private fields with the \# syntax
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            #x;
            constructor() {
                this.#x = 15;
            }
        };
        let f = new foo();
        console.log(f.x); // Undefined
    \end{jscode}
    \bigbreak \noindent 
    We can also use this syntax to make methods private
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            #print() {
                console.log("Hello world");
            }
        };
        let f = new foo();
        f.print(); // Error
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Getters and setters}
    \bigbreak \noindent 
    Getters and setters are special properties that we can use to get data from a class and
    to set data fields on the class. Getters and setters are computed properties. So, they
    are more like properties than they are like functions. We call them accessors. They do
    look a bit like functions, because they have () behind them, but they are not! These accessors start with the get and set keywords.
    \bigbreak \noindent 
    \begin{jscode}
        class foo {
            #name;

            set name(name) {
                this.#name = name;
            }

            get name() {
                return this.#name;
            }
        };
        let f = new foo();
        f.x = "Nate";
        console.log(f.x); // Nate
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Inheritence}
    \bigbreak \noindent 
    We implement inheritance with the \textit{extends} keyword
    \bigbreak \noindent 
    \begin{jscode}
        class A {
            x;
            constructor() {
                this.x = 20;
            }

            print() {
                console.log("Hello world");
            }
        };

        class B extends A {
        };

        let b = new B();
        console.log(b.x); // 20
        b.print(); // Hello world
    \end{jscode}
    \bigbreak \noindent 
    Private fields and methods in $A$ are not visible in $B$
    \bigbreak \noindent 
    \begin{jscode}
        class A {
            #x;
            constructor() {
                this.#x = 20;
            }

            print() {
                console.log("Hello world");
            }
        };

        class B extends A {
        };

        let b = new B();
        console.log(b.x); // Undefined
        b.print(); // Hello world
    \end{jscode}

    \bigbreak \noindent 
    \subsection{Prototypes}
    \bigbreak \noindent 
    A prototype is the mechanism in JavaScript that makes it possible to have objects.
    When nothing is specified when creating a class, the objects inherit from the
    Object.prototype prototype. This is a rather complex built-in JavaScript class that
    we can use. We don't need to look at how this is implemented in JavaScript, as
    we can consider it the base object that is always on top of the inheritance tree and
    therefore always present in our objects
    \bigbreak \noindent 
    There is a \textit{prototype} property available on all classes, and it is always named
    "prototype."
    \bigbreak \noindent 
    Here is how to add a function to this class using prototype
    \bigbreak \noindent 
    \begin{jscode}
        class Person {
            constructor(firstname, lastname) {
                this.firstname = firstname;
                this.lastname = lastname;
            }
            greet() {
                console.log("Hi there!");
            }
        }

        Person.prototype.introduce = function () {
            console.log("Hi, I'm", this.firstname);
        };

        let p1 = new Person("Bob", "Smith");
        p1.introduce(); // Hi, I'm Bob
    \end{jscode}
    \bigbreak \noindent 
    prototype is a property holding all the properties and methods of an object. So,
    adding a function to prototype is adding a function to the class. You can use
    prototype to add properties or methods to an object, like we did in the above
    example in our code with the introduce function. You can also do this for properties
    \bigbreak \noindent 
    \begin{jscode}
        Person.prototype.favoriteColor = "green";
    \end{jscode}
    \bigbreak \noindent 
    So the methods and properties defined via prototype are really as if they were defined in the class. 
    \bigbreak \noindent 
    This is something you should not be using when you have control over the class
    code and you want to change it permanently. In that case, just change the class.
    However, you can expand existing objects like this and even expand existing objects
    conditionally. It is also important to know that the JavaScript built-in objects have
    prototypes and inherit from Object.prototype. However, be sure not to modify this
    prototype since it will affect how our JavaScript works.

    \pagebreak 
    \unsect{The Document Object Model}
    \bigbreak \noindent 
    \subsection{The BOM}
    \bigbreak \noindent 
    The BOM, sometimes also called the window browser object, is the amazing "magic"
    element that makes it possible for your JavaScript code to communicate with the
    browser.
    \bigbreak \noindent 
    The window object contains all the properties required to represent the window of
    the browser, so for example, the size of the window and the history of previously
    visited web pages. The window object has global variables and functions, and these
    can all be seen when we explore the window object. The exact implementation of the
    BOM depends on the browser and the version of the browser. This is important to
    keep in mind while working your way through these sections.
    \bigbreak \noindent 
    Some of the most important objects of the BOM we will look into in this chapter are:
    \begin{itemize}
        \item History
        \item Navigator
        \item Location
    \end{itemize}
    \bigbreak \noindent 
    You can type the following command in the browser console and press Enter to get information about the window object:
    \bigbreak \noindent 
    \begin{jscode}
        console.dir(window);
    \end{jscode}
    \bigbreak \noindent 
    The console.dir() method shows a list of all the properties of the specified object.
    You can click on the little triangles to open the objects and inspect them even more.
    \bigbreak \noindent 
    The BOM contains many other objects. We can access these like we saw when
    we dealt with objects, so for example, we can get the length of the history (in my
    browser) accessing the history object of the window and then the length of the
    history object, like this
    \bigbreak \noindent 
    \begin{jscode}
        window.history.length;
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{BOM Objects}
    \bigbreak \noindent 
    We have
    \begin{itemize}
        \item \textbf{window}: The window object is the top-level object in a browser and serves as the global context for JavaScript running in the browser. All global variables and functions become properties of the window object.
        \item \textbf{history}: The history object allows you to navigate back and forth through the user's session history.
        \item \textbf{location}: The location object provides information about the current URL and allows you to redirect the browser to a new URL or reload the current page.
        \item \textbf{navigator}: The navigator object exposes properties that provide information about the browser and the underlying operating system.
        \item \textbf{screen}: The navigator object exposes properties that provide information about the browser and the underlying operating system.The screen object contains information about the physical screen of the device. This includes properties like screen.width, screen.height, and screen.availHeight.
        \item \textbf{frames}: Although not an independent object per se, window.frames is a collection that refers to the child windows (or frames) if your document is split into different frames or iframes.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Common window properties and methods}
    \bigbreak \noindent 
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{window.document}: Provides access to the DOM (Document Object Model) of the current page.
        \item \textbf{window.location}: References the location object, which provides details about the current URL (see Location section below).
        \item \textbf{window.history}: Gives access to the history object to navigate user history (see History section below).
        \item \textbf{window.navigator}: Provides details about the browser and the operating system (see Navigator section below).
        \item \textbf{window.innerWidth \& window.innerHeight}: Represents the viewport’s width and height. Useful for responsive designs and adapting layouts dynamically.
        \item \textbf{window.outerWidth \& window.outerHeight}: Offers the total width and height of the browser window including interface elements like toolbars and scrollbars.
        \item \textbf{window.localStorage \& window.sessionStorage}: Allow you to store data on the client side persistently or for the session duration, respectively.
        \item \textbf{window.console}: Provides access to the browser’s debugging console for logging purposes.
        \item \textbf{window.frames}: Holds a collection of all the frames (or iframes) embedded in the window (further discussed under Frames).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Common Methods}:
    \begin{itemize}
        \item \textbf{window.alert(message)}: Displays an alert dialog with the specified message.
        \item \textbf{window.confirm(message)}: Opens a modal dialog with OK and Cancel buttons, returning a Boolean based on the user's choice.
        \item \textbf{window.prompt(message, defaultText)}: Shows a dialog prompting the user for input.
        \item \textbf{window.setTimeout(callback, delay)}: Executes a function once after a specified delay (in milliseconds).
        \item \textbf{window.setInterval(callback, interval)}: Repeatedly executes a function with a fixed time delay between each call.
        \item \textbf{window.clearTimeout(timeoutID) \& window.clearInterval(intervalID)} Cancel pending timeouts or intervals.
        \item \textbf{window.open(url, name, specs)}: Opens a new browser window or tab.
        \item \textbf{window.close()}: Closes the current window (typically works only if the window was opened by a script).
        \item \textbf{window.addEventListener(event, handler)}: Attaches an event handler to the window (and similarly, removeEventListener to detach).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{History Objecti properties and methods}
    \bigbreak \noindent 
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{history.length}: Returns the number of URL entries in the session history.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Methods:}
    \begin{itemize}
        \item \textbf{history.back()}: Equivalent to clicking the browser’s Back button. It moves backward by one in the history stack.
        \item \textbf{history.forward()}: Moves forward by one, similar to clicking the Forward button.
        \item \textbf{history.go(delta)}: Loads a specific page relative to the current page. For example, history.go(-1) is like calling history.back().
        \item \textbf{history.pushState(state, title, url)}: Adds a new state to the browser’s session history without reloading the page. This is essential in Single Page Applications (SPAs) for creating navigable states.
        \item \textbf{history.replaceState(state, title, url)}: Modifies the current history entry instead of creating a new one, which is useful for updating the URL or state without affecting the history stack.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Location Object properties and methods}
    \bigbreak \noindent 
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{location.href}: A string containing the full URL of the current page.
        \item \textbf{location.protocol}: The protocol scheme of the URL (e.g., "http:" or "https:").
        \item \textbf{location.host}: Combines the hostname and port (if specified).
        \item \textbf{location.hostname}: The domain name of the web host.
        \item \textbf{location.port}: The port number used by the URL.
        \item \textbf{location.pathname}: The path (directory and file name) part of the URL.
        \item \textbf{location.search}: Contains the query string part of the URL (the portion following the ?).
        \item \textbf{location.hash}: Holds the anchor or fragment identifier of the URL (the portion following the #).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Methods:}
    \begin{itemize}
        \item \textbf{location.assign(url)}: Loads the resource at the specified URL, similar to clicking a link.
        \item \textbf{location.replace(url)}: Loads a new document, replacing the current document in the history. This means the current page won’t be available via the Back button.
        \item \textbf{location.reload(forceReload)}: Reloads the current page. Using a truthy value for forceReload forces the page to reload from the server rather than the cache.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Navigator Object properties and methods}
    \textbf{Properties:}
    \begin{itemize}
        \item \textbf{navigator.appName}: Provides the name of the browser (though its use is generally discouraged due to its lack of reliability).
        \item \textbf{navigator.appVersion}: A version string for the browser.
        \item \textbf{navigator.userAgent}: A string that contains details about the browser, its version, and the operating system. This is often used for browser detection.
        \item \textbf{navigator.platform}: Indicates the operating system platform (e.g., "Win32", "MacIntel").
        \item \textbf{navigator.language}: The default language of the browser.
        \item \textbf{navigator.languages}: An array that lists the user's preferred languages.
        \item \textbf{navigator.onLine}: A Boolean indicating whether the browser is online.
        \item \textbf{navigator.cookieEnabled}: Indicates whether cookies are enabled in the browser. 
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Methods:}
    \begin{itemize}
        \item \textbf{navigator.javaEnabled()}: Returns a Boolean indicating if the Java plugin is enabled in the browser.
        \item \textbf{navigator.sendBeacon(url, data)}: Used to asynchronously send data to a server, often employed for sending analytics data without blocking unloading of the document.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Screen Object}
    \textbf{Properties}
    \begin{itemize}
        \item \textbf{screen.width}: The total width of the visitor’s screen in pixels.
        \item \textbf{screen.height}: The total height of the visitor’s screen in pixels.
        \item \textbf{screen.availWidth}: The width of the screen available for the window (excluding interface elements like the taskbar).
        \item \textbf{screen.availHeight}: The height of the screen available for the window.
        \item \textbf{screen.colorDepth}: The number of bits used to display one color (usually 24 or 32).
        \item \textbf{screen.pixelDepth}: Similar to colorDepth, representing the actual color resolution.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{The DOM}
    \bigbreak \noindent 
    The DOM is actually not very complicated to understand. It is a way of displaying the structure of an HTML document as a logical tree
    \bigbreak \noindent 
    We can inspect the DOM in a similar fashion as we did the others. We execute
    the following command in the console of our website (again, the document object
    is globally accessible, so accessing it through the window object is possible but not
    necessary):
    \bigbreak \noindent 
    \begin{jscode}
        console.dir(document)
    \end{jscode}

    \bigbreak \noindent 
    \subsubsection{Selecting page elements}
    \bigbreak \noindent 
    The document object contains many properties and methods. In order to work with elements on the page, you'll first have to find them. If you need to change the value of a certain paragraph, you'll have to grab this paragraph first. We call this selecting the paragraph. After selecting, we can start changing it.
    \bigbreak \noindent 
    To select page elements to use within your JavaScript code and in order to manipulate elements, you can use either the querySelector() or querySelectorAll() method. Both of these can be used to select page elements either by tag name, ID, or class
    \bigbreak \noindent 
    The document.querySelector() method will return the first element within the document that matches the specified selectors. If no matching page elements are found, the result null is returned. To return multiple matching elements, you can use the method document.querySelectorAll().
    \bigbreak \noindent 
    The querySelectorAll() method will return a static NodeList, which represents a list of the document's elements that match the specified group of selectors. We will demonstrate the usage of both querySelector() and querySelectorAll() with the following HTML snippet:
    \bigbreak \noindent 
    \begin{htmlcode}
        <!doctype html>
        <html>
            <head>
                <title>JS Tester</title>
            </head>
            <body>
                <h1 class="output">Hello World</h1>
                <div class="output">Test</div>
            </body>
        </html>
    \end{htmlcode}
    \bigbreak \noindent 
    We are going to select the h1 element with querySelector(). Therefore, if there is more than one, it will just grab the first
    \bigbreak \noindent 
    \begin{jscode}
        const ele1 = document.querySelector("h1");
        console.dir(ele1);
    \end{jscod}
    \bigbreak \noindent 
    If you want to select multiple elements, you can use querySelectorAll(). This
    method is going to return all the elements that match the selector in an array. In this
    example, we are going to look for instances of the output class, which is done by
    prepending the class name with a dot.
    \bigbreak \noindent 
    \begin{jscode}
    const eles = document.querySelectorAll(".output");
    console.log(eles);
    \end{jscode}
    \bigbreak \noindent 
    After selecting, you can start using the dynamic features of the DOM: you can manipulate the elements using JavaScript. Content can be changed in the same way a variable's contents can be, elements can be removed or added, and styles can be adjusted. This can all be done with JavaScript and the way the user interacts with the page can affect this. We have seen the two most common methods to select in the DOM here, querySelector() and querySelectorAll(). You can actually select any element you might need with these

    \bigbreak \noindent 
    \subsubsection{Basic DOM traversing}
    \bigbreak \noindent
    We can traverse the DOM using the document object that we saw in the previous chapter. This document object contains all the HTML and is a representation of the web page. Traversing over these elements can get you to the element you need in order to manipulate it
    \bigbreak \noindent 
    Even for a simple HTML piece there are already multiple ways to traverse the DOM
    \bigbreak \noindent 
    \begin{htmlcode}
        <!DOCTYPE html>
        <html>
            <body>
                <h1>Let's find the treasure</h1>
                <div id="forest">
                    <div id="tree1">
                        <div id="squirrel"></div>
                        <div id="flower"></div>
                    </div>
                    <div id="tree2">
                        <div id="shrubbery">
                            <div id="treasure"></div>
                        </div>
                        <div id="mushroom">
                            <div id="bug"></div>
                        </div>
                    </div>
                </div>
            </body>
        </html>
    \end{htmlcode}
    \bigbreak \noindent 
    We now want to traverse the DOM of this snippet to find the treasure. We can do this by stepping into the document object and navigating our way from there onwards
    \bigbreak \noindent 
    We can start by using the body property from the document. This contains everything that's inside the body element
    \bigbreak \noindent 
    \begin{jscode}
    console.dir(document.body);
    \end{jscode}
    \bigbreak \noindent 
    We should get a really long object. There are a few ways from this object to get to our treasure. To do so, let's discuss the children and childNodes property.
    \bigbreak \noindent 
    To get to the treasure using children you would have to use:
    \bigbreak \noindent 
    \begin{jscode}
    console.dir(document.body.children.forest.children.tree2.children. shrubbery.children.treasure);
    \end{jscode}
    \bigbreak \noindent 
    As you can see, on every element we select, we have to select the children again. So, first, we grab the children from the body, then we select forest from these children. Then from forest, we want to grab its children again, and from these children we want to select tree2. From tree2 we want to grab the children again, from these children we need shrubbery. And then finally, we can grab the children from shrubbery and select treasure.
    \bigbreak \noindent 
    To get to the treasure using childNodes you would have to use your console a lot
    because text and comment nodes are also in there. childNodes is an array, so you will
    have to select the right index to select the right child. There is one advantage here: it
    is a lot shorter because you won't need to select the name separately.
    \bigbreak \noindent 
    \begin{jscode}
    console.dir(document.body.childNodes[3].childNodes[3].childNodes[1]. childNodes[1]);
    \end{jscode}
    \bigbreak \noindent 
    You could also combine them:
    \bigbreak \noindent 
    \begin{jscode}
    console.dir(document.body.childNodes[3].childNodes[3].childNodes[1]. children.treasure);
    \end{jscode}
    \bigbreak \noindent 
    So far, we have seen how we can move down the DOM, but we can also move up. Every element knows its parent. We can use the parentElement property to move back up. For example, if we use the treasure HTML sample and type this into the console:
    \begin{jscode}
        document.body.children.forest.children.tree2.parentElement;
    \end{jscode}
    \bigbreak \noindent 
    We are back at forest, since that is the parent element of tree2. This can be very
useful, in particular when combined with functions such as getElementById(),
which we will see later in more detail
\bigbreak \noindent 
Not only can we move up and down, we can also move sideways. For example, if
we select tree2 like this:
\begin{jscode}
    document.body.children.forest.children.tree2;
\end{jscode}
\bigbreak \noindent 
We can get to tree1 using:
\bigbreak \noindent 
\begin{jscode}
document.body.children.forest.children.tree2.previousElementSibling;
\end{jscode}
\bigbreak \noindent 
And from tree1 we can get to tree2 using:
\bigbreak \noindent 
\begin{jscode}
document.body.children.forest.children.tree1.nextElementSibling;
\end{jscode}
\bigbreak \noindent 
As an alternative to nextElementSibling, which returns the next node that is an
element, you could use nextSibling, which will return the next node of any type.

\bigbreak \noindent 
\subsubsection{Selecting elements as objects}
\bigbreak \noindent 
Now we know how to traverse the DOM, we can make changes to the elements.
Instead of using console.dir(), we can just type in the path to the element we want
to change. We now have the element as a JavaScript object, and we can make changes
to all its properties. Let's use a simpler HTML page for this one
\bigbreak \noindent 
\begin{htmlcode}
    <!DOCTYPE html>
    <html>
        <body>
            <h1>Welcome page</h1>
            <p id="greeting"> Hi! </p>
        </body>
    </html>
\end{htmlcode}
\bigbreak \noindent 
We can traverse to the $p$ element, for example, by using this code:
\bigbreak \noindent 
\begin{jscode}
document.body.children.greeting;
\end{jscode}

\bigbreak \noindent 
\subsubsection{Changing innerText}
\bigbreak \noindent 
The innerText property focuses on the text between the opening and closing of the element, like so:
\bigbreak \noindent 
\begin{htmlcode}
<element>here</element>
\end{htmlcode}
\bigbreak \noindent 
The retrieved value would be here as plain text. For example, if we go to the console and we type
\bigbreak \noindent 
\begin{jscode}
document.body.children.greeting.innerText = "Bye!";
\end{jscode}
\bigbreak \noindent 
The message that is displayed on the page changes from Hi! to Bye! immediately.
innerText returns the content of the element as plain text, which is not a problem in
this case because there is only text in there. However, if there is any HTML inside
the element you need to select, or if you want to add HTML, you cannot use this
method. It will interpret the HTML as text and just output it on the screen. So if we
executed this:
\bigbreak \noindent 
\begin{jscode}
document.body.children.greeting.innerText = "<p>Bye!</p>";
\end{jscode}
\bigbreak \noindent 
It will output to the screen <p>Bye!</p>, with the HTML around it, as if it was intended as a text string. To get around this, you need to use innerHTML.

\bigbreak \noindent 
\subsubsection{Changing innerHTML}
\bigbreak \noindent 
If you did not only want to work with plain text, or perhaps specify some HTML
formatting with your value, you could use the innerHTML property instead. This
property doesn't just process be plain text, it can also be inner HTML elements
\bigbreak \noindent 
\begin{jscode}
document.body.children.greeting.innerHTML = "<b>Bye!</b>";
\end{jscode}

\bigbreak \noindent 
\subsubsection{Accessing elements in the DOM}
\bigbreak \noindent 
There are multiple methods to select elements from the DOM. After getting the
elements, we are able to modify them. In the following sections, we will discuss how
to get elements by their ID, tag name, and class name, and by CSS selector.
\bigbreak \noindent 
Instead of traversing it step by step as we just did, we are going to use built-in
methods that can go through the DOM and return the elements that match the
specifications
\bigbreak \noindent 
Consider 
\bigbreak \noindent 
\begin{htmlcode}
    <!DOCTYPE html>
    <html>
        <body>
            <h1>Just an example</h1>
            <div id="one" class="example">Hi!</div>
            <div id="two" class="example">Hi!</div>
            <div id="three" class="something">Hi!</div>
        </body>
    </html>
\end{htmlcode}
\bigbreak \noindent 
Let's start by accessing elements by ID.
\bigbreak \noindent 
\subsubsection{Accessing elements by ID}
\bigbreak \noindent 
We can grab elements by ID with the getElementById() method. This returns one
element with the specified ID. IDs should be unique, as only one result will be
returned from the HTML document
\bigbreak \noindent 
If we want to select the element with an ID of two right away, we could use:
\bigbreak \noindent 
\begin{jscode}
document.getElementById("two");
\end{jscode}
\bigbreak \noindent 
This would return the full HTML element:
\bigbreak \noindent 
\begin{htmlcode}
<div id="two" class="example">Hi!</div>
\end{htmlcode}
\bigbreak \noindent 
To reiterate, if you have more than one element with the same ID, it will just give
you back the first one it encounters. You should avoid this situation in your code
though.
\bigbreak \noindent 
\subsubsection{Accessing elements by tag name}
\bigbreak \noindent 
If we ask for elements by tag name, we get an array as a result. This is because there
could be more than one element with the same tag name. It will be a collection of
HTML elements, or HTMLCollection, which is a special JavaScript object. It's basically
just a list of nodes
\bigbreak \noindent 
\begin{jscode}
document.getElementsByTagName("div");
\end{jscode}
\bigbreak \noindent 
It returns
\bigbreak \noindent 
\begin{jscode}
// HTMLCollection(3) [div#one.example, div#two.example, div#three. something, one: div#one.example, two: div#two.example, three: div#three.something]
\end{jscode}
\bigbreak \noindent 
As you can see, all the elements in the DOM with the div tag are returned. You
can read what the ID is and what the class is from the syntax. The first ones in the
collection are the objects: div is the name, # specifies the ID, and . specifies the class.
If there are multiple dots, there are multiple classes. Then you can see the elements
again (namedItems), this time as key-value pairs with their ID as the key
\bigbreak \noindent 
We can access them using the item() method to access them by index, like this:
\bigbreak \noindent 
\begin{jscode}
document.getElementsByTagName("div").item(1);
\end{jscode}
\bigbreak \noindent 
This will return:
\bigbreak \noindent 
\begin{jscode}
<div id="two" class="example">Hi!</div>
\end{jscode}
\bigbreak \noindent 
We can also access them by name, using the namedItem() method, like this:
\bigbreak \noindent 
\begin{jscode}
document.getElementsByTagName("div").namedItem("one");
\end{jscode}
\bigbreak \noindent 
And this will return:
\bigbreak \noindent 
\begin{jscode}
<div id="one" class="example">Hi!</div>
\end{jscode}
\bigbreak \noindent 
When there is only one match, it will still return an HTMLCollection. There is only
one h1 tag, so let's demonstrate this behavior:
\bigbreak \noindent 
\begin{jscode}
document.getElementsByTagName("h1");
\end{jscode}
\bigbreak \noindent 
This will output:
\bigbreak \noindent 
\begin{jscode}
// HTMLCollection [h1]
\end{jscode}
\bigbreak \noindent 
Since h1 doesn't have an ID or class, it is only h1. And since it doesn't have an ID, it
is not a namedItem and is only in there once.

\bigbreak \noindent 
\subsubsection{Accessing elements by class name}
\bigbreak \noindent 
We can do something very similar for class names. In our example HTML, we have
two different class names: example and something. If you get elements by class name,
it gives back an HTMLCollection containing the results. The following will get all
the elements with the class example:
\bigbreak \noindent 
\begin{jscode}
    document.getElementsByClassName("example");
\end{jscode}
\bigbreak \noindent 
This returns:
\bigbreak \noindent 
\begin{jscode}
// HTMLCollection(2) [div#one.example, div#two.example, one: div#one. example, two: div#two.example]
\end{jscode}
\bigbreak \noindent 
As you can see, it only returned the div tags with the example class. It left out the div with the something class.
\bigbreak \noindent 
\subsubsection{Accessing elements with a CSS selector}
\bigbreak \noindent 
We can also access elements using a CSS selector. We do this with querySelector()
and querySelectorAll(). We then give the CSS selector as an argument, and this
will filter the items in the HTML document and only return the ones that satisfy the
CSS selector.
\bigbreak \noindent 
The CSS selector might look a bit different than you might think at first. Instead of
looking for a certain layout, we use the same syntax as we use when we want to
specify a layout for certain elements. We haven't discussed this yet, so we will cover
it here briefly.
\bigbreak \noindent 
If we state $p$ as a CSS selector, it means all the elements with tag $p$. This would look like this:
\bigbreak \noindent 
\begin{jscode}
document.querySelectorAll("p");
\end{jscode}
\bigbreak \noindent 
If we say p.example, it means all the p tag elements with example as the class. They can also have other classes; as long as example is in there, it will match. We can also say #one, which means select all with an ID of one.
\bigbreak \noindent 
This method is the same result as getElementById(). Which one to use is a matter
of taste when all you really need to do is select by ID—this is great input for a
discussion with another developer. querySelector() allows for more complicated
queries, and some developers will state that getElementById() is more readable.
Others will claim that you might as well use querySelector() everywhere for
consistency. It doesn't really matter at this point, but try to be consistent.
\bigbreak \noindent 
\subsubsection{Using querySelectorAll()}
\bigbreak \noindent 
Sometimes it is not enough to return only the first instance, but you want to select all
the elements that match the query. For example when you need to get all the input
boxes and empty them. This can be done with querySelectorAll():
\bigbreak \noindent 
\begin{jscode}
document.querySelectorAll("div");
\end{jscode}
\bigbreak \noindent 
This returns
\bigbreak \noindent 
\begin{jscode}
// NodeList(3) [div#one.example, div#two.example, div#three.something]
\end{jscode}
\bigbreak \noindent 
As you can see, it is of object type NodeList. It contains all the nodes that match the
CSS selector. With the item() method we can get them by index, just as we did for
the HTMLCollection

\bigbreak \noindent 
\subsubsection{Element click handler}
\bigbreak \noindent 
HTML elements can do something when they are clicked. This is because a
JavaScript function can be connected to an HTML element. Here is one snippet in
which the JavaScript function associated with the element is specified in the HTML
\bigbreak \noindent 
\begin{jscode}
    <!DOCTYPE html>
    <html>
        <body>
            <div id="one" onclick="alert('Ouch! Stop it!')">Don't click here! </div>
        </body>
    </html>
\end{jscode}
\bigbreak \noindent 
The onclick attribute is an HTML attribute used to attach JavaScript code to an element.  While the alert itself is a JavaScript function, the onclick attribute is an HTML event handler that embeds JavaScript code.
\bigbreak \noindent 
This method of linking HTML and JavaScript is known as using an "inline event handler." Although it's common and simple for small snippets, in larger applications it’s often recommended to separate JavaScript from HTML (for example, using the addEventListener method in JavaScript) for better maintainability and code organization.
\bigbreak \noindent 
Other HTML event handlers are
\begin{itemize}
    \item \textbf{ondblclick:} Fires when an element is double-clicked.
    \item \textbf{onmouseover:} Triggers when the mouse pointer moves over an element.
    \item \textbf{onmouseout:} Occurs when the mouse pointer moves off an element.
    \item \textbf{onmousedown:} Executes when a mouse button is pressed down over an element.
    \item \textbf{onmouseup:} Runs when a mouse button is released over an element.
    \item \textbf{onmousemove:} Fires as the mouse pointer moves within an element.
    \item \textbf{onkeydown:} Activates when the user presses a key down.
    \item \textbf{onkeyup:} Triggers when a key is released.
    \item \textbf{onkeypress:} Similar to onkeydown, but fires for keys that produce a character value (though it’s generally less recommended than the keydown/keyup events).
    \item \textbf{oninput:} Fires every time the value of an input or textarea changes—ideal for capturing real-time changes.
    \item \textbf{onchange:} Occurs when the value of an element (such as an input, select, or textarea) has been altered and the element loses focus.
    \item \textbf{onfocus:} Fires when an element, like an input field, gains focus (such as when clicked or tabbed into).
    \item \textbf{onblur:} Triggers when an element loses focus.
    \item \textbf{onload:} Executes when an object (often the window or an image) has completely loaded.
    \item \textbf{onunload:} Occurs when the user leaves the document (commonly used to clean up or save state).
    \item \textbf{onsubmit:} Specifically used with forms, triggering when the form is submitted.
    \item \textbf{onresize:} Fires when the document or an element is resized (this is typically applied to the window)
\end{itemize}

\bigbreak \noindent 
Next, consider the html code
\bigbreak \noindent 
\begin{htmlcode}
 <div id="one">Don't click here!</div>
\end{htmlcode}
\bigbreak \noindent 
This code is at the moment not doing anything if you click it. If we want to
dynamically add a click handler to the div element, we can select it and specify the
property via the console
\bigbreak \noindent 
\begin{jscode}
    document.getElementById("one").onclick = function () {
        alert("Auch! Stop!");
    }
\end{jscode}

\bigbreak \noindent 
\subsubsection{This and the DOM}
\bigbreak \noindent 
The this keyword always has a relative meaning; it depends on the exact context
it is in. In the DOM, the special this keyword refers to the element of the DOM it
belongs to. If we specify an onclick to send this in as an argument, it will send in
the element the onclick is in.
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" onclick="console.log(this)"> Don't click me </div>
\end{jscode}
\bigbreak \noindent 
logs in the console
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" onclick="console.log(this)"> Don't click me </div>
\end{jscode}
\bigbreak \noindent 
If we instead did the log via a function
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" onclick="f()"> Don't click me </div>

    <script>
        function f() {
            console.log(this);
        }
    </script>
\end{jscode}
\bigbreak \noindent 
We just get the \textit{window} object.
\bigbreak \noindent 
We instead need to pass \textit{this} to the function
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" onclick="f(this)"> Don't click me </div>
    <script> 
        function f(el) {
            console.log(el);
        }
    </script>
\end{jscode}
\bigbreak \noindent 
So, the this keyword is referring to the element, and from this element we can
traverse the DOM like we just learned. This can be very useful, for example, when
you need to get the value of an input box. If you send this, then you can read and
modify the properties of the element that triggered the function.

\bigbreak \noindent 
\subsubsection{Manipulating element style}
\bigbreak \noindent 
After selecting the right element from the DOM, we can change the CSS style that
applies to it. We can do this using the style property.
\bigbreak \noindent 
We are going to make a button that will toggle the appearing and disappearing of
a line of text. To hide something using CSS, we can set the display property of the
element to none.
\bigbreak \noindent 
\begin{htmlcode}
    <div class="ysm" id="someDiv" onclick="f()"> Don't click me </div>
    <script> 
        function f() {
            let div = document.getElementById("someDiv");
            if (div.style.display === "none") {
                div.style.display = "block";
            } else {
                div.style.display = "none";
            }
    }
    </script>
\end{htmlcode}

\bigbreak \noindent 
\subsubsection{Changing the classes of an element}
\bigbreak \noindent 
HTML elements can have classes, and as we have seen, we can select elements by the
name of the class. As you may remember, classes are used a lot for giving elements a
certain layout using CSS
\bigbreak \noindent 
With JavaScript, we can change the classes of HTML elements, and this might trigger
a certain layout that is associated with that class in CSS. We are going to have a look
at adding classes, removing classes, and toggling classes.

\bigbreak \noindent 
\subsubsection{Adding and removing classes to elements}
\bigbreak \noindent 
we use the classList property with the .add(classname) method.
\bigbreak \noindent 
\begin{jscode}
    <style> .big { transform: scale(2); } </style>

    <div class="ysm" id="someDiv" onclick="f()"> Click to make big </div>
    <script> 
    function f() {
        let p = document.querySelector("#someDiv").classList.add("big");
    }
    </script>
\end{jscode}
\bigbreak \noindent 
To remove, we use .remove(classname)
\bigbreak \noindent 
\begin{jscode}
    <style> .big { transform: scale(2); } </style>

    <div class="ysm" id="someDiv" onclick="f()"> Click to make big </div>
    <script> 
        function f() {
            let p = document.querySelector("#someDiv").classList.toggle("big");
        }
    </script>
\end{jscode}

\bigbreak \noindent 
\subsubsection{Toggling classes}
\bigbreak \noindent 
We can streamline the above system by using the .toggle method, which adds a class if it doesn't have it, and removes it if it does.
\bigbreak \noindent 
\begin{jscode}
    <style> .big { transform: scale(2); } </style>

    <div class="ysm" id="someDiv" onclick="f()"> Click to make big </div>
    <script> 
        function f() {
            let p = document.querySelector("#someDiv").classList.toggle("big");
        }
    </script>
\end{jscode}

\bigbreak \noindent 
\subsubsection{Manipulating attributes}
\bigbreak \noindent 
With the setAttribute() method, we can add or change attributes on an element.
This will change the HTML of the page
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" id="someDiv">  
        <input id="button" type="button" onclick="f()">
    </div>
    <script> 
        function f() {
            let el = document.querySelector("#button");
            el.setAttribute("type", "text");
        }
    </script>
\end{jscode}

\bigbreak \noindent 
\subsubsection{Event listeners on elements}
\bigbreak \noindent 
Events are things that happen on a web page, like clicking on something, moving the
mouse over an element, changing an element, and there are many more. We have
seen how to add an onclick event handler already. In the same way, you can add an
onchange handler, or an onmouseover handler. There is one special condition, though;
one element can only have one event handler as an HTML attribute. So, if it has an
onclick handler, it cannot have an onmouseover handler as well. At this point, we
have only seen how to add event listeners using HTML attributes
\bigbreak \noindent 
There is a way to register event handlers using JavaScript as well. We call these event
listeners. Using event listeners, we can add multiple events to one element. This way,
JavaScript is constantly checking, or listening, for certain events to the elements on
the page. Adding event listeners is a two-step process:
\begin{enumerate}
    \item Select the element you want to add an event to
    \item Use the addEventListener("event", function) syntax to add the event
\end{enumerate}
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" id="someDiv">  
        <input id="button" type="button">
    </div>
    <script> 
        document.getElementById("button").addEventListener("click", change);

        function change() {
            this.setAttribute("type", "text");
        }
    </script>
\end{jscode}

\bigbreak \noindent 
\subsubsection{Creating new elements}
\bigbreak \noindent 
We use createElement(), then use appendChild() to add to the document tree.
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" id="someDiv">  
        <input id="button" type="button">
    </div>
    <script> 
        window.onload = function() {
            document.getElementById("button").addEventListener("click", change);
        }

        function change() {
            let other = document.createElement("p");
            other.innerText = "Hello world";
            document.body.appendChild(other);
        }
    </script>
\end{jscode}


\pagebreak 
\unsect{Interactive Content and Event Listeners}
\bigbreak \noindent 
\subsection{Specifying events with JavaScript}
\bigbreak \noindent 
Here is the first way to do it using JavaScript.
\bigbreak \noindent 
\begin{jscode}
document.getElementById("unique").onclick = function() { magic(); };
\end{jscode}

\bigbreak \noindent 
\subsection{Specifying events with event listeners}
\bigbreak \noindent 
The last method is using the addEventListener() method to add an event to an
element. With this, we can specify multiple functions for the same event, for
example, when an element gets clicked.
\bigbreak \noindent 
\begin{jscode}
document.getElementById("unique").addEventListener("click", magic);
\end{jscode}

\bigbreak \noindent 
\subsection{The onload event handler}
\bigbreak \noindent 
We briefly saw this event handler in the previous chapter. The onload event gets
fired after a certain element is loaded. This can be useful for a number of reasons. For
example, if you want to select an element using getElementById, you'll have to be
sure this element is loaded in the DOM already. This event is most commonly used
on the window object, but it can be used on any element. When you use it on window,
this event gets started when the window object is done loading
\bigbreak \noindent 
\begin{jscode}
    window.onload = function() {
        // whatever needs to happen after the page loads goes here
    }
\end{jscode}
\bigbreak \noindent 
onload is similar, but it's different for the window and document objects. The
difference depends on the web browser you are using. The load event fires at the
end of the document loading process. Therefore, you will find that all the objects
in the document are in the DOM and the assets have finished loading
\bigbreak \noindent 
You can also use the addEventListener() method on any element to handle any
event. And it can also be used for the event that all the content in the DOM is loaded.
There is a special built-in event for this: DOMContentLoaded(). This event can be used
to handle the event of the DOM loading, which will get fired immediately after the
DOM for the page has been constructed when the event is set. Here is how to set it:
\bigbreak \noindent 
\begin{jscode}
    document.addEventListener("DOMContentLoaded", (e) => {
        console.log(e);
    });
\end{jscode}
\bigbreak \noindent 
This will log to the console when all the DOM content has been loaded. As an
alternative, you will also often see it in the body tag
\bigbreak \noindent 
\begin{jscode}
<body onload="unique()"></body>
\end{jscode}
\bigbreak \noindent 
This is assigning a function called unique() to the body, and it will fire off when
the body is done loading. You cannot combine addEventListener() and the HTML
by using them together. One will overwrite the other, depending on the order of
the web page. If you need two events to happen when the DOM is loaded, you will
need two addEventListener() calls in your JavaScript.
\bigbreak \noindent 
\subsection{Mouse event handlers}
\bigbreak \noindent 
There are different mouse event handlers. Mouse events are actions of the mouse.
These are the ones we have
\begin{itemize}
    \item \textbf{ondblclick:} when the mouse is double-clicked
    \item \textbf{onmousedown:} when the mouse clicks on top of an element without the click being released
    \item \textbf{onmouseup:} when the mouse click on top of an element is released
    \item \textbf{onmouseenter:} when the mouse moves onto an element
    \item \textbf{onmouseleave:} when the mouse leaves an element and all of its children
    \item \textbf{onmousemove:} when the mouse moves over an element
    \item \textbf{onmouseout:} when the mouse leaves an individual element
    \item \textbf{onmouseover:} when the mouse hovers over an element
\end{itemize}

\bigbreak \noindent 
\subsection{The event target property}
\bigbreak \noindent 
Whenever an event gets fired, an event variable becomes available. It has many
properties, and you can check it out by using this command in the function that
gets fired for the event
\bigbreak \noindent 
This will show many properties. One of the most interesting properties for now is the
target property. The target is the HTML element that fired the event. So, we can use
it to get information from a web page
\bigbreak \noindent 
\begin{jscode}
    <div class="ysm" id="someDiv">  
        <input id="button" type="button">
    </div>
    <script> 
        window.onload = function() {
            document.getElementById("button").addEventListener("click", change);
        }

        function change() {
            let p = document.createElement("p");
            p.innerText = "Hello world";
            // event.target is <input id="button" type="button">
            // parent->parent is document
            event.target.parentNode.parentNode.appendChild(p);

        }
    </script>
\end{jscode}

\bigbreak \noindent 
\subsection{DOM event flow}
\bigbreak \noindent 








     





















    
\end{document}
