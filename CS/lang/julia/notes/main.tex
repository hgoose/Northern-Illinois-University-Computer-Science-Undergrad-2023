\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Julia}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Programming in Julia}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Creating and running Julia scripts, and outputting}
    \bigbreak \noindent 
    First, make sure you have Julia (juliaup) downloaded on your machine. Create a .jl file and run it with 
    \bigbreak \noindent 
    \begin{bashcode}
    julia script.jl
    \end{bashcode}
    \bigbreak \noindent 
    Here is a simple Hello World! script written in julia
    \bigbreak \noindent 
    \begin{jlcode}
    # helloworld.jl 
    println("Hello World!")
    \end{jlcode}

    \bigbreak \noindent 
    \subsection{Outputting data}
    \bigbreak \noindent 
    \subsubsection{println}
    \bigbreak \noindent 
    Prints the value followed by a newline. Suitable for general-purpose printing
    \bigbreak \noindent 
    \begin{jlcode}
    println("Hello world")
    \end{jlcode}
    \bigbreak \noindent 
    \subsubsection{Print}
    \bigbreak \noindent 
    Similar to \texttt{println}, but does not append a newline

    \bigbreak \noindent 
    \subsubsection{Formatted output: @printf from the Printf module}
    \bigbreak \noindent 
    Prints the value followed by a newline. Suitable for general-purpose printing
    \bigbreak \noindent 
    \begin{jlcode}
    using Printf
        @printf("Pi to 3 decimal places: %.3f\n", pi)  # Output: Pi to 3 decimal places: 3.142
    \end{jlcode}
    \bigbreak \noindent 
    \subsubsection{Error and debugging output}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{@warn}: Logs a warning message.
            \bigbreak \noindent 
            \begin{jlcode}
                @warn "This is a warning message."
            \end{jlcode}
        \item \textbf{@info}: Logs an informational message.
            \bigbreak \noindent 
            \begin{jlcode}
            @info "This is an informational message."
            \end{jlcode}
        \item \textbf{@error}: Logs an error message.
            \bigbreak \noindent 
            \begin{jlcode}
            @error "This is an error message."
            \end{jlcode}
        \item \textbf{@show}: Prints the expression and its value. Useful for debugging.
            \bigbreak \noindent 
            \begin{jlcode}
                x = 42
                @show x  # Output: x = 42
            \end{jlcode}
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Display}
    \bigbreak \noindent 
    Displays a value using a richer representation (e.g., for plots or tables in Jupyter).
    \bigbreak \noindent 
    \begin{jlcode}
    display("Hello, World!")  # Output: "Hello, World!"
    \end{jlcode}



    \pagebreak 
    \unsect{The basics}
    \bigbreak \noindent 
    \subsection{Arithmetic operators}
    \bigbreak \noindent 
    Julia supports the following arithmetic operators
    \begin{itemize}
        \item \textbf{Addition:} \texttt{+} (e.g., \texttt{a + b})
        \item \textbf{Subtraction:} \texttt{-} (e.g., \texttt{a - b})
        \item \textbf{Multiplication:} \texttt{*} (e.g., \texttt{a * b})
        \item \textbf{Division:} \texttt{/} (e.g., \texttt{a / b})
        \item \textbf{Integer Division:} \texttt{div} (e.g., \texttt{div(a, b)})
        \item \textbf{Modulo (Remainder):} \texttt{\%} (e.g., \texttt{a \% b})
        \item \textbf{Floor Division:} \texttt{//} (e.g., \texttt{a // b})
        \item \textbf{Power:} \texttt{$^{\land}$} (e.g., \texttt{$a^{\land}b$})
        \item \textbf{Negation:} \texttt{-} (e.g., \texttt{-a})
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Data types}
    \bigbreak \noindent 
    Julia has the following data types
    \bigbreak \noindent 
    \subsubsection{Numerical Types}
    \begin{itemize}
        \item \textbf{Integers:}
            \begin{itemize}
                \item \texttt{Int8, Int16, Int32, Int64, Int128:} Signed integers with various bit sizes.
                \item \texttt{UInt8, UInt16, UInt32, UInt64, UInt128:} Unsigned integers.
                \item \texttt{Int:} Default signed integer type (dependent on the platform, typically Int64 or Int32).
            \end{itemize}
        \item \textbf{Floating-point numbers:} \texttt{Float16, Float32, Float64:} IEEE 754 floating-point numbers.
        \item \textbf{Big numbers:}
            \begin{itemize}
                \item \texttt{BigInt:} Arbitrary precision integers.
                \item \texttt{BigFloat:} Arbitrary precision floating-point numbers.
            \end{itemize}
        \item \textbf{Complex numbers:} \texttt{Complex\{T\}:} Complex numbers with real and imaginary parts of type T.
        \item \textbf{Rational numbers:} \texttt{Rational\{T\}:} Fractions represented as numerator//denominator.
    \end{itemize}
    \bigbreak \noindent 
    In Julia, the default type for a literal integer like 15 is Int (platform-dependent, typically Int64 on 64-bit systems). However, you can explicitly create integers of specific types (Int8, Int16, etc.) using constructors. For example,
    \bigbreak \noindent 
    \begin{jlcode}
     x = Int8(15)  # Creates an Int8 with value 15
    \end{jlcode}

    \bigbreak \noindent 
    \subsubsection{Boolean Type}
    \begin{itemize}
        \item \textbf{Bool}: true or false
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Characters and Strings}
    \begin{itemize}
        \item \textbf{Char:} Single Unicode character (e.g., 'a').
        \item \textbf{String:} A sequence of characters (e.g., "Hello, world!").
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Abstract Data Types}
    \begin{itemize}
        \item \textbf{Number:} Abstract type for all numbers.
        \item \textbf{Real:} Abstract type for real numbers (Int, Float64, etc.).
        \item \textbf{AbstractString:} Abstract type for string-like objects.
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Composite Types}
    \begin{itemize}
        \item \textbf{Tuples:} Fixed-size collections of values, e.g., (1, "hello", true).
        \item \textbf{NamedTuples:} Tuples with named fields, e.g., (a=1, b=2).
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Collection Types}
    \begin{itemize}
        \item \textbf{Arrays}:
            \begin{itemize}
                \item \textbf{1D arrays (vectors):} Vector\{T\} (e.g., [1, 2, 3]).
                \item \textbf{2D arrays (matrices):} Matrix\{T\} (e.g., [1 2; 3 4]).
                \item \textbf{Higher-dimensional arrays:} Array\{T, N\}.
            \end{itemize}
        \item \textbf{Ranges:}
            \begin{itemize}
                \item \textbf{1:10:} A range from 1 to 10.
                \item \textbf{1:2:10:} A range with a step of 2.
            \end{itemize}
        \item \textbf{Dictionaries:}
            \begin{itemize}
                \item \textbf{Dict\{K, V\}:} A collection of key-value pairs, e.g., Dict("a" => 1, "b" => 2).
            \end{itemize}
        \item \textbf{Sets}:
            \begin{itemize}
                \item \textbf{Set{T}:} An unordered collection of unique elements, e.g., Set([1, 2, 3])
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Nothing and Missing:}
    \begin{itemize}
        \item \textbf{Nothing:} Represents the absence of a value (similar to null in other languages).
        \item \textbf{Missing:} Represents missing data (useful in data analysis).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{User-defined Types }
    \begin{itemize}
        \item \textbf{struct:} Immutable composite types.
        \item \textbf{mutable struct:} Mutable composite types.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{typeof()}
    \bigbreak \noindent 
    We can use the \texttt{typeof()} function to retrieve the type of a variable
    \bigbreak \noindent 
    \begin{jlcode}
    x = 10
    println(typeof(x))
    \end{jlcode}
    \bigbreak \noindent 
    \subsection{Type conversions}
    \bigbreak \noindent 
    \subsubsection{Using Constructors}
    \bigbreak \noindent 
    Julia uses constructors to convert a value to a specific type. This is the most common way to perform type casting.
    \bigbreak \noindent 
    \begin{jlcode}
        # Convert to Integer Types
        x = Int8(42)       # Converts 42 to an Int8
        y = UInt16(300)    # Converts 300 to a UInt16
    \end{jlcode}

    \bigbreak \noindent 
    \subsubsection{Using convert Function}
    \bigbreak \noindent 
    The convert function explicitly converts a value to the desired type.
    \bigbreak \noindent 
    \begin{jlcode}
    convert(Type, value)
    \end{jlcode}
    \bigbreak \noindent 
    For example
    \bigbreak \noindent 
    \begin{jlcode}
        # Convert to Int
        x = convert(Int, 42.5)       # Converts 42.5 to 42 (truncates the decimal)

        # Convert to Float64
        y = convert(Float64, 42)     # Converts 42 to 42.0

        # Convert to String
        s = convert(String, 123)     # Converts 123 to "123"
    \end{jlcode}

    \bigbreak \noindent 
    \subsubsection{Parsing Strings}
    \bigbreak \noindent 
    To convert a string to a numerical type, use the parse function.
    \bigbreak \noindent 
    \begin{jlcode}
    parse(Type, string)
    \end{jlcode}
    \bigbreak \noindent 
    For example,
    \bigbreak \noindent 
    \begin{jlcode}
        # Parse to Integer
        x = parse(Int, "123")        # Converts "123" to 123

        # Parse to Float64
        y = parse(Float64, "3.14")   # Converts "3.14" to 3.14
    \end{jlcode}
    \bigbreak \noindent 
    \subsubsection{Automatic Conversion}
    \bigbreak \noindent 
    Some operations perform automatic type promotion or conversion.
    \bigbreak \noindent 
    \begin{jlcode}
        a = 3          # Int
        b = 2.5        # Float64
        c = a + b      # Automatically promotes `a` to Float64
        println(c)     # Output: 5.5
        println(typeof(c))  # Output: Float64
    \end{jlcode}

    \bigbreak \noindent 
    \subsection{Operator precedence}
    \bigbreak \noindent 
    Julia follows PEMDAS
    \bigbreak \noindent 
    \subsection{String Operations}
    \bigbreak \noindent 
    In general, you can’t perform mathematical operations on strings, even if the strings look like numbers. But there are two exceptions, * and $^{\land}$.
    \bigbreak \noindent 
    The * operator performs string concatenation, which means it joins the strings by linking them end-to-end. For example:
    \bigbreak \noindent 
    The $^{\land} $ operator also works on strings; it performs repetition. For example, "Spam"$^{\land}3$ is "SpamSpamSpam". If one of the values is a string, the other has to be an integer.
    \bigbreak \noindent 
    \subsection{Comments}
    \bigbreak \noindent 
    Julia uses the pound sign for comments
    \bigbreak \noindent 
    \begin{jlcode}
    # Comment
    \end{jlcode}

    \pagebreak 
    \unsect{Functions}
    \bigbreak \noindent 























    
\end{document}
