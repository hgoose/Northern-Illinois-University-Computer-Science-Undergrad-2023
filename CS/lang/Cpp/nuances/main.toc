\contentsline {section}{\numberline {1}Converting char to std::string}{10}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Constructor signature}{10}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Example}{10}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}std::string::npos}{11}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Example}{11}{subsection.0.2.1}%
\contentsline {section}{\numberline {3}Narrowing}{12}{section.0.3}%
\contentsline {section}{\numberline {4}Aggregate types}{13}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Aggregate initialization}{13}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Narrowing is not allowed in aggregate-initialization from an initializer list}{14}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}implicit conversion using a single-argument constructor}{14}{subsection.0.4.3}%
\contentsline {section}{\numberline {5}Floating point literals}{16}{section.0.5}%
\contentsline {section}{\numberline {6}Size of structs and classes}{17}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Padding}{18}{subsection.0.6.1}%
\contentsline {section}{\numberline {7}When is trailing return type useful}{19}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Decltype on template parameters}{19}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Nested structs}{19}{subsection.0.7.2}%
\contentsline {section}{\numberline {8}Most vexing parse}{20}{section.0.8}%
\contentsline {section}{\numberline {9}Notes about copy constructors}{21}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Copy constructors in inheritance}{21}{subsection.0.9.1}%
\contentsline {section}{\numberline {10}Exceptions during a call to new}{23}{section.0.10}%
\contentsline {subsection}{\numberline {10.1}Exceptions during constructors}{23}{subsection.0.10.1}%
\contentsline {section}{\numberline {11}Notes about polymorphism}{24}{section.0.11}%
\contentsline {subsection}{\numberline {11.1}Polymorphism with arrays and slicing}{25}{subsection.0.11.1}%
\contentsline {subsubsection}{\numberline {11.1.1}Object Slicing}{25}{subsubsection.0.11.1.1}%
\contentsline {subsubsection}{\numberline {11.1.2}Polymorphism with arrays}{26}{subsubsection.0.11.1.2}%
\contentsline {subsection}{\numberline {11.2}Runtime polymorphism, dynamic dispatch, dynamic binding, and the vtable}{27}{subsection.0.11.2}%
\contentsline {subsubsection}{\numberline {11.2.1}Dynamic dispatch and dynamic binding}{27}{subsubsection.0.11.2.1}%
\contentsline {subsubsection}{\numberline {11.2.2}The Vtable}{28}{subsubsection.0.11.2.2}%
\contentsline {subsection}{\numberline {11.3}Can you call pure virtual methods}{30}{subsection.0.11.3}%
\contentsline {subsection}{\numberline {11.4}Do the signatures need to exactly match on overridden functions}{30}{subsection.0.11.4}%
\contentsline {subsection}{\numberline {11.5}What happens if you forget the keyword virtual on base class methods}{30}{subsection.0.11.5}%
\contentsline {subsection}{\numberline {11.6}Do you need the keyword virtual on overridden methods?}{30}{subsection.0.11.6}%
\contentsline {subsection}{\numberline {11.7}What happens if you forget the override}{31}{subsection.0.11.7}%
\contentsline {subsection}{\numberline {11.8}Overrides with default args}{31}{subsection.0.11.8}%
\contentsline {subsection}{\numberline {11.9}Private and public with polymorphism}{32}{subsection.0.11.9}%
\contentsline {subsection}{\numberline {11.10}Virtual methods are implicitly inline}{33}{subsection.0.11.10}%
\contentsline {subsection}{\numberline {11.11}Base class pointer if the base class is abstract}{34}{subsection.0.11.11}%
\contentsline {subsection}{\numberline {11.12}Does the destructor need to be pure in an abstract class?}{34}{subsection.0.11.12}%
\contentsline {section}{\numberline {12}The existence of structs and classes}{35}{section.0.12}%
\contentsline {section}{\numberline {13}Note about heap allocated memory in vectors}{36}{section.0.13}%
\contentsline {section}{\numberline {14}Function that takes a const reference can accept rvalues}{37}{section.0.14}%
\contentsline {section}{\numberline {15}Notes about c++ casts}{38}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}Static\_cast}{38}{subsection.0.15.1}%
\contentsline {subsection}{\numberline {15.2}Dynamic\_cast}{38}{subsection.0.15.2}%
\contentsline {subsubsection}{\numberline {15.2.1}When to Use Dynamic Casting}{39}{subsubsection.0.15.2.1}%
\contentsline {subsubsection}{\numberline {15.2.2}RTTI}{39}{subsubsection.0.15.2.2}%
\contentsline {subsection}{\numberline {15.3}const\_cast}{39}{subsection.0.15.3}%
\contentsline {subsubsection}{\numberline {15.3.1}Modifying a non-const object that was passed as const}{40}{subsubsection.0.15.3.1}%
\contentsline {subsubsection}{\numberline {15.3.2}Removing const to use overloaded functions}{40}{subsubsection.0.15.3.2}%
\contentsline {subsection}{\numberline {15.4}reinterpret\_cast}{41}{subsection.0.15.4}%
\contentsline {subsection}{\numberline {15.5}Why are c casts unsafe?}{41}{subsection.0.15.5}%
\contentsline {section}{\numberline {16}The compiler and functions}{42}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Important: compile time constant variables and memory (constant propagation/constant folding)}{44}{subsection.0.16.1}%
\contentsline {section}{\numberline {17}Brace initialization vs Parenthesized Initialization}{45}{section.0.17}%
\contentsline {section}{\numberline {18}Are chars unsigned?}{46}{section.0.18}%
\contentsline {section}{\numberline {19}Size of types}{47}{section.0.19}%
\contentsline {section}{\numberline {20}Trivially copyable}{48}{section.0.20}%
\contentsline {section}{\numberline {21}POD types (Plain old data)}{49}{section.0.21}%
\contentsline {subsection}{\numberline {21.1}Trivial type}{49}{subsection.0.21.1}%
\contentsline {subsection}{\numberline {21.2}Standard layout}{49}{subsection.0.21.2}%
\contentsline {section}{\numberline {22}Notes about initialization}{50}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}How many names does brace initialization have?}{50}{subsection.0.22.1}%
\contentsline {subsubsection}{\numberline {22.1.1}Uniform Initialization (General Term)}{50}{subsubsection.0.22.1.1}%
\contentsline {subsubsection}{\numberline {22.1.2}List Initialization}{50}{subsubsection.0.22.1.2}%
\contentsline {subsubsection}{\numberline {22.1.3}Aggregate Initialization}{50}{subsubsection.0.22.1.3}%
\contentsline {subsubsection}{\numberline {22.1.4}Value Initialization}{50}{subsubsection.0.22.1.4}%
\contentsline {subsubsection}{\numberline {22.1.5}Direct List Initialization}{51}{subsubsection.0.22.1.5}%
\contentsline {subsubsection}{\numberline {22.1.6}Copy List Initialization}{51}{subsubsection.0.22.1.6}%
\contentsline {subsubsection}{\numberline {22.1.7}Narrowing Prevention Initialization}{51}{subsubsection.0.22.1.7}%
\contentsline {subsubsection}{\numberline {22.1.8} Default Member Initialization}{51}{subsubsection.0.22.1.8}%
\contentsline {subsubsection}{\numberline {22.1.9}Copy list initialization and direct list initialization in aggregate types}{51}{subsubsection.0.22.1.9}%
\contentsline {subsection}{\numberline {22.2}Other forms of initialization and their names}{52}{subsection.0.22.2}%
\contentsline {subsubsection}{\numberline {22.2.1} Direct Initialization}{53}{subsubsection.0.22.2.1}%
\contentsline {subsubsection}{\numberline {22.2.2}Copy Initialization }{53}{subsubsection.0.22.2.2}%
\contentsline {subsubsection}{\numberline {22.2.3} Default Initialization}{53}{subsubsection.0.22.2.3}%
\contentsline {subsection}{\numberline {22.3}Excess elements in scalar initialization}{53}{subsection.0.22.3}%
\contentsline {section}{\numberline {23}Notes about constructors and destructors}{55}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}Value initialized vs default initialized}{55}{subsection.0.23.1}%
\contentsline {subsection}{\numberline {23.2}What exactly is =default}{55}{subsection.0.23.2}%
\contentsline {subsubsection}{\numberline {23.2.1}Non-POD fields}{56}{subsubsection.0.23.2.1}%
\contentsline {subsubsection}{\numberline {23.2.2}With copy constructors}{56}{subsubsection.0.23.2.2}%
\contentsline {subsubsection}{\numberline {23.2.3}Copy Assignment}{57}{subsubsection.0.23.2.3}%
\contentsline {subsubsection}{\numberline {23.2.4}Move constructor}{57}{subsubsection.0.23.2.4}%
\contentsline {subsubsection}{\numberline {23.2.5} Move Assignment}{58}{subsubsection.0.23.2.5}%
\contentsline {subsubsection}{\numberline {23.2.6}Destructor}{58}{subsubsection.0.23.2.6}%
\contentsline {subsubsection}{\numberline {23.2.7}Do you need to write them?}{58}{subsubsection.0.23.2.7}%
\contentsline {subsection}{\numberline {23.3}=delete}{59}{subsection.0.23.3}%
\contentsline {subsection}{\numberline {23.4}Rule of five}{59}{subsection.0.23.4}%
\contentsline {subsection}{\numberline {23.5}A confused compiler}{59}{subsection.0.23.5}%
\contentsline {subsection}{\numberline {23.6}Which constructor will be called}{60}{subsection.0.23.6}%
\contentsline {subsection}{\numberline {23.7}Constructors are implicitly inline constexpr}{61}{subsection.0.23.7}%
\contentsline {subsection}{\numberline {23.8}Destructors are implicitly noexcept}{61}{subsection.0.23.8}%
\contentsline {subsection}{\numberline {23.9} When is an object "Fully constructed"}{62}{subsection.0.23.9}%
\contentsline {subsection}{\numberline {23.10}When is an object not fully constructed}{62}{subsection.0.23.10}%
\contentsline {subsection}{\numberline {23.11}Converting constructors (cast constructors)}{63}{subsection.0.23.11}%
\contentsline {subsection}{\numberline {23.12}operator void() overload}{64}{subsection.0.23.12}%
\contentsline {section}{\numberline {24}Dividing by zero}{65}{section.0.24}%
\contentsline {section}{\numberline {25}Notes about inheritance}{66}{section.0.25}%
\contentsline {subsection}{\numberline {25.1}Constructor chain}{66}{subsection.0.25.1}%
\contentsline {subsection}{\numberline {25.2}Destructor chain}{66}{subsection.0.25.2}%
\contentsline {subsection}{\numberline {25.3}So who needs a virtual destructor?}{66}{subsection.0.25.3}%
\contentsline {subsection}{\numberline {25.4}Default access modifier}{67}{subsection.0.25.4}%
\contentsline {subsection}{\numberline {25.5}Can a class inherit from a struct, or a struct inherit from a class?}{68}{subsection.0.25.5}%
\contentsline {section}{\numberline {26}Booleans under the hood: Adding two booleans}{69}{section.0.26}%
\contentsline {section}{\numberline {27}Type Promotion}{70}{section.0.27}%
\contentsline {subsection}{\numberline {27.1}Ranking}{70}{subsection.0.27.1}%
\contentsline {section}{\numberline {28}Notes about static}{72}{section.0.28}%
\contentsline {subsection}{\numberline {28.1}Static variables inside member functions}{72}{subsection.0.28.1}%
\contentsline {subsection}{\numberline {28.2}Using instances to call static methods}{72}{subsection.0.28.2}%
\contentsline {subsection}{\numberline {28.3}Can you make pure virtual methods static?}{72}{subsection.0.28.3}%
\contentsline {subsection}{\numberline {28.4}Inline Static methods?}{72}{subsection.0.28.4}%
\contentsline {subsection}{\numberline {28.5}Static and extern (linkage)}{73}{subsection.0.28.5}%
\contentsline {subsubsection}{\numberline {28.5.1}Using extern to declare a variable with the same name as a static variable from another translation unit}{73}{subsubsection.0.28.5.1}%
\contentsline {subsubsection}{\numberline {28.5.2}Forgetting to use extern}{74}{subsubsection.0.28.5.2}%
\contentsline {subsubsection}{\numberline {28.5.3}Forgetting to use keyword static}{74}{subsubsection.0.28.5.3}%
\contentsline {subsubsection}{\numberline {28.5.4}Constinit with extern}{74}{subsubsection.0.28.5.4}%
\contentsline {section}{\numberline {29}Trying to move const objects}{75}{section.0.29}%
\contentsline {section}{\numberline {30}Smart pointers in conjunction with raw ptrs}{76}{section.0.30}%
\contentsline {subsection}{\numberline {30.1}Shared\_ptr with raw ptrs}{76}{subsection.0.30.1}%
\contentsline {subsection}{\numberline {30.2}Unique\_ptr with raw ptrs}{76}{subsection.0.30.2}%
\contentsline {section}{\numberline {31}Calling delete on a nullptr}{77}{section.0.31}%
\contentsline {section}{\numberline {32}Notes about short circuits}{78}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}With ands}{78}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}With ors}{78}{subsection.0.32.2}%
\contentsline {section}{\numberline {33}Notes about types}{80}{section.0.33}%
\contentsline {section}{\numberline {34}Notes about inline functions}{81}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Inline functions in the context of multiple translation units}{81}{subsection.0.34.1}%
\contentsline {subsection}{\numberline {34.2}Class/Struct methods are implicitly inline}{82}{subsection.0.34.2}%
\contentsline {section}{\numberline {35}Notes about object creation}{83}{section.0.35}%
\contentsline {subsection}{\numberline {35.1}Default initialize const object (const default constructible)?}{83}{subsection.0.35.1}%
\contentsline {section}{\numberline {36}What is a "function signature"}{85}{section.0.36}%
\contentsline {subsection}{\numberline {36.1}Function Signature (Overriding Perspective)}{85}{subsection.0.36.1}%
\contentsline {subsection}{\numberline {36.2}What is NOT Part of a Function Signature? }{85}{subsection.0.36.2}%
\contentsline {subsection}{\numberline {36.3}noexcept?}{86}{subsection.0.36.3}%
\contentsline {section}{\numberline {37}Maximal munch principle}{87}{section.0.37}%
\contentsline {section}{\numberline {38}What happens if a noexcept function throws an exception?}{88}{section.0.38}%
\contentsline {section}{\numberline {39}Exception propogation}{89}{section.0.39}%
\contentsline {section}{\numberline {40}The catch all exception handler (...)}{90}{section.0.40}%
\contentsline {section}{\numberline {41}A typedef cannot be a template}{91}{section.0.41}%
\contentsline {section}{\numberline {42}Return value optimization}{92}{section.0.42}%
\contentsline {section}{\numberline {43}Using function templates in multiple files}{93}{section.0.43}%
\contentsline {section}{\numberline {44}Review of access modifiers in inheritance}{95}{section.0.44}%
\contentsline {section}{\numberline {45}Notes about the conditional operator}{96}{section.0.45}%
\contentsline {section}{\numberline {46}Notes about CTAD (Class template argument deduction)}{97}{section.0.46}%
\contentsline {subsection}{\numberline {46.1}const vs non-const template parameters}{97}{subsection.0.46.1}%
\contentsline {section}{\numberline {47}Strong types}{99}{section.0.47}%
\contentsline {subsection}{\numberline {47.1}Why Use Strong Types?}{99}{subsection.0.47.1}%
\contentsline {subsection}{\numberline {47.2}Strong typing in regards to readability}{99}{subsection.0.47.2}%
\contentsline {section}{\numberline {48}Argument dependent name lookup (ADL/Koenig lookup)}{101}{section.0.48}%
\contentsline {section}{\numberline {49}C vs c++ external linkage}{103}{section.0.49}%
\contentsline {subsection}{\numberline {49.1}C++ external linkage}{103}{subsection.0.49.1}%
\contentsline {subsection}{\numberline {49.2}C external linkage}{103}{subsection.0.49.2}%
\contentsline {section}{\numberline {50}Who cleans up the call stack, the caller or the callee}{105}{section.0.50}%
\contentsline {section}{\numberline {51}Notes about sizeof}{106}{section.0.51}%
\contentsline {subsection}{\numberline {51.1}non types in sizeof?}{106}{subsection.0.51.1}%
\contentsline {subsection}{\numberline {51.2}No side effects?}{106}{subsection.0.51.2}%
\contentsline {subsection}{\numberline {51.3}What is the output?}{106}{subsection.0.51.3}%
\contentsline {subsection}{\numberline {51.4}sizeof("")}{107}{subsection.0.51.4}%
\contentsline {section}{\numberline {52}Parenthesized declarators}{108}{section.0.52}%
\contentsline {section}{\numberline {53}Notes about classes and member variables}{109}{section.0.53}%
\contentsline {subsection}{\numberline {53.1}Const member variable assigned in constructor?}{109}{subsection.0.53.1}%
\contentsline {section}{\numberline {54}What is the type of a string literal?}{110}{section.0.54}%
\contentsline {section}{\numberline {55}Notes about const\_cast}{111}{section.0.55}%
\contentsline {subsubsection}{\numberline {55.0.1}Dangers of trying to modify string literals (const char*)}{111}{subsubsection.0.55.0.1}%
\contentsline {subsection}{\numberline {55.1}const\_cast is UB example}{111}{subsection.0.55.1}%
\contentsline {section}{\numberline {56}Notes about friend functions}{112}{section.0.56}%
\contentsline {subsection}{\numberline {56.1}Recall friend}{112}{subsection.0.56.1}%
\contentsline {subsubsection}{\numberline {56.1.1}Friend functions}{112}{subsubsection.0.56.1.1}%
\contentsline {subsubsection}{\numberline {56.1.2}Friend class}{113}{subsubsection.0.56.1.2}%
\contentsline {section}{\numberline {57}What is the value of argv[argc]?}{115}{section.0.57}%
\contentsline {section}{\numberline {58}Notes about const}{116}{section.0.58}%
\contentsline {subsection}{\numberline {58.1}Returning const?}{116}{subsection.0.58.1}%
\contentsline {subsection}{\numberline {58.2}is\_const\_v}{117}{subsection.0.58.2}%
\contentsline {subsection}{\numberline {58.3}Top-level and low-level cv-qualifiers}{117}{subsection.0.58.3}%
\contentsline {section}{\numberline {59}Mixed type references}{118}{section.0.59}%
\contentsline {section}{\numberline {60}The types of literals and builtin suffixes}{119}{section.0.60}%
\contentsline {subsection}{\numberline {60.1}Suffixes}{119}{subsection.0.60.1}%
\contentsline {section}{\numberline {61}Notes about perfect forwarding}{121}{section.0.61}%
\contentsline {section}{\numberline {62}lazy instantiation in templates}{122}{section.0.62}%
\contentsline {section}{\numberline {63}Notes about initializer\_list}{123}{section.0.63}%
\contentsline {section}{\numberline {64}Notes about operator precedence}{124}{section.0.64}%
\contentsline {subsection}{\numberline {64.1}Logical operators}{124}{subsection.0.64.1}%
\contentsline {section}{\numberline {65}Alternative tokens}{125}{section.0.65}%
\contentsline {section}{\numberline {66}Notes about C arrays}{126}{section.0.66}%
\contentsline {section}{\numberline {67}Notes about operator overloads}{127}{section.0.67}%
\contentsline {subsection}{\numberline {67.1}Manually calling operator overloads}{127}{subsection.0.67.1}%
\contentsline {section}{\numberline {68}Notes about pointers}{128}{section.0.68}%
\contentsline {subsection}{\numberline {68.1}The introduction of the nullptr}{129}{subsection.0.68.1}%
\contentsline {subsubsection}{\numberline {68.1.1}Ambiguity in Overloaded Functions}{129}{subsubsection.0.68.1.1}%
\contentsline {subsubsection}{\numberline {68.1.2}Type safety}{129}{subsubsection.0.68.1.2}%
\contentsline {subsubsection}{\numberline {68.1.3}The type of nullptr}{129}{subsubsection.0.68.1.3}%
\contentsline {subsubsection}{\numberline {68.1.4}nullptr vs void*}{130}{subsubsection.0.68.1.4}%
\contentsline {subsubsection}{\numberline {68.1.5}Zero is a nullptr?}{130}{subsubsection.0.68.1.5}%
\contentsline {subsection}{\numberline {68.2}What does an uninitialized pointer point to?}{130}{subsection.0.68.2}%
\contentsline {section}{\numberline {69}Notes about gotos}{131}{section.0.69}%
\contentsline {subsection}{\numberline {69.1}Scope}{131}{subsection.0.69.1}%
\contentsline {section}{\numberline {70}Notes about lambdas}{132}{section.0.70}%
\contentsline {subsection}{\numberline {70.1}Global variables}{132}{subsection.0.70.1}%
\contentsline {section}{\numberline {71}Notes about function types}{133}{section.0.71}%
\contentsline {subsection}{\numberline {71.1}Top-level cv-qualifiers}{133}{subsection.0.71.1}%
\contentsline {section}{\numberline {72}Notes about name resolution}{134}{section.0.72}%
\contentsline {section}{\numberline {73}Notes about default parameters}{135}{section.0.73}%
\contentsline {section}{\numberline {74}Notes about the this pointer}{136}{section.0.74}%
\contentsline {subsection}{\numberline {74.1}Can you delete the this pointer}{136}{subsection.0.74.1}%
\contentsline {section}{\numberline {75}Argument evaluation order: Indeterminately sequence}{138}{section.0.75}%
\contentsline {section}{\numberline {76}Do static members increase the size of a class or object?}{139}{section.0.76}%
\contentsline {section}{\numberline {77}Note about enums}{140}{section.0.77}%
\contentsline {subsection}{\numberline {77.1}cv-qualifiers?}{140}{subsection.0.77.1}%
\contentsline {section}{\numberline {78}Notes about templates}{141}{section.0.78}%
\contentsline {subsection}{\numberline {78.1}template templates}{141}{subsection.0.78.1}%
