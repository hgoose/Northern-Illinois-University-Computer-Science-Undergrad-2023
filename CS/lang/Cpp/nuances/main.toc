\contentsline {section}{\numberline {1}Converting char to std::string}{8}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Constructor signature}{8}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Example}{8}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}std::string::npos}{9}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Example}{9}{subsection.0.2.1}%
\contentsline {section}{\numberline {3}Narrowing}{10}{section.0.3}%
\contentsline {section}{\numberline {4}Aggregate types}{11}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Aggregate initialization}{11}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Narrowing is not allowed in aggregate-initialization from an initializer list}{12}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}implicit conversion using a single-argument constructor}{12}{subsection.0.4.3}%
\contentsline {section}{\numberline {5}Floating point literals}{14}{section.0.5}%
\contentsline {section}{\numberline {6}Size of structs and classes}{15}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Padding}{16}{subsection.0.6.1}%
\contentsline {section}{\numberline {7}When is trailing return type useful}{17}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Decltype on template parameters}{17}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Nested structs}{17}{subsection.0.7.2}%
\contentsline {section}{\numberline {8}Most vexing parse}{18}{section.0.8}%
\contentsline {section}{\numberline {9}Notes about copy constructors}{19}{section.0.9}%
\contentsline {section}{\numberline {10}Exceptions during a call to new}{20}{section.0.10}%
\contentsline {subsection}{\numberline {10.1}Exceptions during constructors}{20}{subsection.0.10.1}%
\contentsline {section}{\numberline {11}Notes about polymorphism}{21}{section.0.11}%
\contentsline {subsection}{\numberline {11.1}Polymorphism with arrays and slicing}{22}{subsection.0.11.1}%
\contentsline {subsubsection}{\numberline {11.1.1}Object Slicing}{22}{subsubsection.0.11.1.1}%
\contentsline {subsubsection}{\numberline {11.1.2}Polymorphism with arrays}{23}{subsubsection.0.11.1.2}%
\contentsline {subsection}{\numberline {11.2}Runtime polymorphism, dynamic dispatch, dynamic binding, and the vtable}{24}{subsection.0.11.2}%
\contentsline {subsubsection}{\numberline {11.2.1}Dynamic dispatch and dynamic binding}{24}{subsubsection.0.11.2.1}%
\contentsline {subsubsection}{\numberline {11.2.2}The Vtable}{25}{subsubsection.0.11.2.2}%
\contentsline {subsection}{\numberline {11.3}Can you call pure virtual methods}{27}{subsection.0.11.3}%
\contentsline {subsection}{\numberline {11.4}Do the signatures need to exactly match on overridden functions}{27}{subsection.0.11.4}%
\contentsline {subsection}{\numberline {11.5}What happens if you forget the keyword virtual on base class methods}{27}{subsection.0.11.5}%
\contentsline {subsection}{\numberline {11.6}Do you need the keyword virtual on overridden methods?}{27}{subsection.0.11.6}%
\contentsline {subsection}{\numberline {11.7}What happens if you forget the override}{28}{subsection.0.11.7}%
\contentsline {subsection}{\numberline {11.8}Overrides with default args}{28}{subsection.0.11.8}%
\contentsline {subsection}{\numberline {11.9}Private and public with polymorphism}{29}{subsection.0.11.9}%
\contentsline {subsection}{\numberline {11.10}Virtual methods are implicitly inline}{30}{subsection.0.11.10}%
\contentsline {subsection}{\numberline {11.11}Base class pointer if the base class is abstract}{31}{subsection.0.11.11}%
\contentsline {subsection}{\numberline {11.12}Does the destructor need to be pure in an abstract class?}{31}{subsection.0.11.12}%
\contentsline {section}{\numberline {12}The existence of structs and classes}{32}{section.0.12}%
\contentsline {section}{\numberline {13}Note about heap allocated memory in vectors}{33}{section.0.13}%
\contentsline {section}{\numberline {14}Function that takes a const reference can accept rvalues}{34}{section.0.14}%
\contentsline {section}{\numberline {15}Notes about c++ casts}{35}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}Static\_cast}{35}{subsection.0.15.1}%
\contentsline {subsection}{\numberline {15.2}Dynamic\_cast}{35}{subsection.0.15.2}%
\contentsline {subsubsection}{\numberline {15.2.1}When to Use Dynamic Casting}{36}{subsubsection.0.15.2.1}%
\contentsline {subsubsection}{\numberline {15.2.2}RTTI}{36}{subsubsection.0.15.2.2}%
\contentsline {subsection}{\numberline {15.3}const\_cast}{36}{subsection.0.15.3}%
\contentsline {subsubsection}{\numberline {15.3.1}Modifying a non-const object that was passed as const}{37}{subsubsection.0.15.3.1}%
\contentsline {subsubsection}{\numberline {15.3.2}Removing const to use overloaded functions}{37}{subsubsection.0.15.3.2}%
\contentsline {subsection}{\numberline {15.4}reinterpret\_cast}{38}{subsection.0.15.4}%
\contentsline {subsection}{\numberline {15.5}Why are c casts unsafe?}{38}{subsection.0.15.5}%
\contentsline {section}{\numberline {16}The compiler and functions}{39}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Important: compile time constant variables and memory (constant propagation/constant folding)}{41}{subsection.0.16.1}%
\contentsline {section}{\numberline {17}The introduction of the nullptr}{42}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Ambiguity in Overloaded Functions}{42}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Type safety}{42}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}The type of nullptr}{42}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}nullptr vs void*}{43}{subsection.0.17.4}%
\contentsline {subsection}{\numberline {17.5}Zero is a nullptr?}{43}{subsection.0.17.5}%
\contentsline {section}{\numberline {18}Brace initialization vs Parenthesized Initialization}{44}{section.0.18}%
\contentsline {section}{\numberline {19}Are chars unsigned?}{45}{section.0.19}%
\contentsline {section}{\numberline {20}Size of types}{46}{section.0.20}%
\contentsline {section}{\numberline {21}Trivially copyable}{47}{section.0.21}%
\contentsline {section}{\numberline {22}POD types (Plain old data)}{48}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}Trivial type}{48}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Standard layout}{48}{subsection.0.22.2}%
\contentsline {section}{\numberline {23}Notes about initialization}{49}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}How many names does brace initialization have?}{49}{subsection.0.23.1}%
\contentsline {subsubsection}{\numberline {23.1.1}Uniform Initialization (General Term)}{49}{subsubsection.0.23.1.1}%
\contentsline {subsubsection}{\numberline {23.1.2}List Initialization}{49}{subsubsection.0.23.1.2}%
\contentsline {subsubsection}{\numberline {23.1.3}Aggregate Initialization}{49}{subsubsection.0.23.1.3}%
\contentsline {subsubsection}{\numberline {23.1.4}Value Initialization}{49}{subsubsection.0.23.1.4}%
\contentsline {subsubsection}{\numberline {23.1.5}Direct List Initialization}{50}{subsubsection.0.23.1.5}%
\contentsline {subsubsection}{\numberline {23.1.6}Copy List Initialization}{50}{subsubsection.0.23.1.6}%
\contentsline {subsubsection}{\numberline {23.1.7}Narrowing Prevention Initialization}{50}{subsubsection.0.23.1.7}%
\contentsline {subsubsection}{\numberline {23.1.8} Default Member Initialization}{50}{subsubsection.0.23.1.8}%
\contentsline {subsubsection}{\numberline {23.1.9}Copy list initialization and direct list initialization in aggregate types}{50}{subsubsection.0.23.1.9}%
\contentsline {subsection}{\numberline {23.2}Other forms of initialization and their names}{51}{subsection.0.23.2}%
\contentsline {subsubsection}{\numberline {23.2.1} Direct Initialization}{52}{subsubsection.0.23.2.1}%
\contentsline {subsubsection}{\numberline {23.2.2}Copy Initialization }{52}{subsubsection.0.23.2.2}%
\contentsline {subsubsection}{\numberline {23.2.3} Default Initialization}{52}{subsubsection.0.23.2.3}%
\contentsline {subsection}{\numberline {23.3}Excess elements in scalar initialization}{52}{subsection.0.23.3}%
\contentsline {section}{\numberline {24}Notes about constructors and destructors}{54}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Value initialized vs default initialized}{54}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}What exactly is =default}{54}{subsection.0.24.2}%
\contentsline {subsubsection}{\numberline {24.2.1}Non-POD fields}{55}{subsubsection.0.24.2.1}%
\contentsline {subsubsection}{\numberline {24.2.2}With copy constructors}{55}{subsubsection.0.24.2.2}%
\contentsline {subsubsection}{\numberline {24.2.3}Copy Assignment}{56}{subsubsection.0.24.2.3}%
\contentsline {subsubsection}{\numberline {24.2.4}Move constructor}{56}{subsubsection.0.24.2.4}%
\contentsline {subsubsection}{\numberline {24.2.5} Move Assignment}{57}{subsubsection.0.24.2.5}%
\contentsline {subsubsection}{\numberline {24.2.6}Destructor}{57}{subsubsection.0.24.2.6}%
\contentsline {subsubsection}{\numberline {24.2.7}Do you need to write them?}{57}{subsubsection.0.24.2.7}%
\contentsline {subsection}{\numberline {24.3}=delete}{58}{subsection.0.24.3}%
\contentsline {subsection}{\numberline {24.4}Rule of five}{58}{subsection.0.24.4}%
\contentsline {subsection}{\numberline {24.5}A confused compiler}{58}{subsection.0.24.5}%
\contentsline {subsection}{\numberline {24.6}Which constructor will be called}{59}{subsection.0.24.6}%
\contentsline {subsection}{\numberline {24.7}Constructors are implicitly inline constexpr}{60}{subsection.0.24.7}%
\contentsline {subsection}{\numberline {24.8}Destructors are implicitly noexcept}{60}{subsection.0.24.8}%
\contentsline {subsection}{\numberline {24.9} When is an object "Fully constructed"}{61}{subsection.0.24.9}%
\contentsline {subsection}{\numberline {24.10}When is an object not fully constructed}{61}{subsection.0.24.10}%
\contentsline {subsection}{\numberline {24.11}Converting (cast) constructors}{62}{subsection.0.24.11}%
\contentsline {section}{\numberline {25}Dividing by zero}{64}{section.0.25}%
\contentsline {section}{\numberline {26}Notes about inheritance}{65}{section.0.26}%
\contentsline {subsection}{\numberline {26.1}Constructor chain}{65}{subsection.0.26.1}%
\contentsline {subsection}{\numberline {26.2}Destructor chain}{65}{subsection.0.26.2}%
\contentsline {subsection}{\numberline {26.3}So who needs a virtual destructor?}{65}{subsection.0.26.3}%
\contentsline {subsection}{\numberline {26.4}Default access modifier}{66}{subsection.0.26.4}%
\contentsline {subsection}{\numberline {26.5}Can a class inherit from a struct, or a struct inherit from a class?}{67}{subsection.0.26.5}%
\contentsline {section}{\numberline {27}Booleans under the hood: Adding two booleans}{68}{section.0.27}%
\contentsline {section}{\numberline {28}Type Promotion}{69}{section.0.28}%
\contentsline {subsection}{\numberline {28.1}Ranking}{69}{subsection.0.28.1}%
\contentsline {section}{\numberline {29}Notes about static}{71}{section.0.29}%
\contentsline {subsection}{\numberline {29.1}Static variables inside member functions}{71}{subsection.0.29.1}%
\contentsline {subsection}{\numberline {29.2}Using instances to call static methods}{71}{subsection.0.29.2}%
\contentsline {subsection}{\numberline {29.3}Can you make pure virtual methods static?}{71}{subsection.0.29.3}%
\contentsline {subsection}{\numberline {29.4}Inline Static methods?}{71}{subsection.0.29.4}%
\contentsline {subsection}{\numberline {29.5}Static and extern (linkage)}{72}{subsection.0.29.5}%
\contentsline {subsubsection}{\numberline {29.5.1}Using extern to declare a variable with the same name as a static variable from another translation unit}{72}{subsubsection.0.29.5.1}%
\contentsline {subsubsection}{\numberline {29.5.2}Forgetting to use extern}{73}{subsubsection.0.29.5.2}%
\contentsline {subsubsection}{\numberline {29.5.3}Forgetting to use keyword static}{73}{subsubsection.0.29.5.3}%
\contentsline {subsubsection}{\numberline {29.5.4}Constinit with extern}{73}{subsubsection.0.29.5.4}%
\contentsline {section}{\numberline {30}Trying to move const objects}{74}{section.0.30}%
\contentsline {section}{\numberline {31}Smart pointers in conjunction with raw ptrs}{75}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Shared\_ptr with raw ptrs}{75}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Unique\_ptr with raw ptrs}{75}{subsection.0.31.2}%
\contentsline {section}{\numberline {32}Calling delete on a nullptr}{76}{section.0.32}%
\contentsline {section}{\numberline {33}Notes about short circuits}{77}{section.0.33}%
\contentsline {subsection}{\numberline {33.1}With ands}{77}{subsection.0.33.1}%
\contentsline {subsection}{\numberline {33.2}With ors}{77}{subsection.0.33.2}%
\contentsline {section}{\numberline {34}Notes about types}{79}{section.0.34}%
\contentsline {section}{\numberline {35}Notes about inline functions}{80}{section.0.35}%
\contentsline {subsection}{\numberline {35.1}Inline functions in the context of multiple translation units}{80}{subsection.0.35.1}%
\contentsline {subsection}{\numberline {35.2}Class/Struct methods are implicitly inline}{81}{subsection.0.35.2}%
\contentsline {section}{\numberline {36}Notes about object creation}{82}{section.0.36}%
\contentsline {subsection}{\numberline {36.1}Default initialize const object (const default constructible)?}{82}{subsection.0.36.1}%
\contentsline {section}{\numberline {37}What is a "function signature"}{83}{section.0.37}%
\contentsline {subsection}{\numberline {37.1}Function Signature (Overriding Perspective)}{83}{subsection.0.37.1}%
\contentsline {subsection}{\numberline {37.2}What is NOT Part of a Function Signature? }{83}{subsection.0.37.2}%
\contentsline {subsection}{\numberline {37.3}noexcept?}{84}{subsection.0.37.3}%
\contentsline {section}{\numberline {38}Maximal munch principle}{85}{section.0.38}%
\contentsline {section}{\numberline {39}What happens if a noexcept function throws an exception?}{86}{section.0.39}%
\contentsline {section}{\numberline {40}Exception propogation}{87}{section.0.40}%
\contentsline {section}{\numberline {41}The catch all exception handler (...)}{88}{section.0.41}%
\contentsline {section}{\numberline {42}A typedef cannot be a template}{89}{section.0.42}%
\contentsline {section}{\numberline {43}Return value optimization}{90}{section.0.43}%
\contentsline {section}{\numberline {44}Using function templates in multiple files}{91}{section.0.44}%
\contentsline {section}{\numberline {45}Review of access modifiers in inheritance}{93}{section.0.45}%
\contentsline {section}{\numberline {46}Notes about the conditional operator}{94}{section.0.46}%
\contentsline {section}{\numberline {47}Notes about CTAD (Class template argument deduction)}{95}{section.0.47}%
\contentsline {section}{\numberline {48}Strong types}{96}{section.0.48}%
\contentsline {subsection}{\numberline {48.1}Why Use Strong Types?}{96}{subsection.0.48.1}%
\contentsline {subsection}{\numberline {48.2}Strong typing in regards to readability}{96}{subsection.0.48.2}%
\contentsline {section}{\numberline {49}Argument dependent name lookup (Koenig lookup)}{98}{section.0.49}%
\contentsline {section}{\numberline {50}C vs c++ external linkage}{99}{section.0.50}%
\contentsline {subsection}{\numberline {50.1}C++ external linkage}{99}{subsection.0.50.1}%
\contentsline {subsection}{\numberline {50.2}C external linkage}{99}{subsection.0.50.2}%
\contentsline {section}{\numberline {51}Who cleans up the call stack, the caller or the callee}{101}{section.0.51}%
\contentsline {section}{\numberline {52}Notes about sizeof}{102}{section.0.52}%
\contentsline {subsection}{\numberline {52.1}non types in sizeof?}{102}{subsection.0.52.1}%
\contentsline {subsection}{\numberline {52.2}No side effects?}{102}{subsection.0.52.2}%
\contentsline {subsection}{\numberline {52.3}What is the output?}{102}{subsection.0.52.3}%
\contentsline {section}{\numberline {53}Parenthesized declarators}{104}{section.0.53}%
\contentsline {section}{\numberline {54}Notes about classes and member variables}{105}{section.0.54}%
\contentsline {subsection}{\numberline {54.1}Const member variable assigned in constructor?}{105}{subsection.0.54.1}%
\contentsline {section}{\numberline {55}What is the type of a string literal?}{106}{section.0.55}%
\contentsline {section}{\numberline {56}Notes about const\_cast}{107}{section.0.56}%
\contentsline {subsubsection}{\numberline {56.0.1}Dangers of trying to modify string literals (const char*)}{107}{subsubsection.0.56.0.1}%
\contentsline {section}{\numberline {57}Notes about friend functions}{108}{section.0.57}%
\contentsline {subsection}{\numberline {57.1}Recall friend}{108}{subsection.0.57.1}%
\contentsline {subsubsection}{\numberline {57.1.1}Friend functions}{108}{subsubsection.0.57.1.1}%
\contentsline {subsubsection}{\numberline {57.1.2}Friend class}{108}{subsubsection.0.57.1.2}%
\contentsline {section}{\numberline {58}What is the value of argv[argc]?}{110}{section.0.58}%
