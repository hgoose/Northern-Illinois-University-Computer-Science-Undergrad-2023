\contentsline {section}{\numberline {1}Converting char to std::string}{6}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Constructor signature}{6}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Example}{6}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}std::string::npos}{7}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Example}{7}{subsection.0.2.1}%
\contentsline {section}{\numberline {3}Narrowing}{8}{section.0.3}%
\contentsline {section}{\numberline {4}Aggregate types}{9}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Aggregate initialization}{9}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Narrowing is not allowed in aggregate-initialization from an initializer list}{10}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}implicit conversion using a single-argument constructor}{10}{subsection.0.4.3}%
\contentsline {section}{\numberline {5}Floating point literals}{12}{section.0.5}%
\contentsline {section}{\numberline {6}Size of structs and classes}{13}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Padding}{14}{subsection.0.6.1}%
\contentsline {section}{\numberline {7}When is trailing return type useful}{15}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Decltype on template parameters}{15}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Nested structs}{15}{subsection.0.7.2}%
\contentsline {section}{\numberline {8}Most vexing parse}{16}{section.0.8}%
\contentsline {section}{\numberline {9}Notes about copy constructors}{17}{section.0.9}%
\contentsline {section}{\numberline {10}Exceptions during a call to new}{18}{section.0.10}%
\contentsline {subsection}{\numberline {10.1}Exceptions during constructors}{18}{subsection.0.10.1}%
\contentsline {section}{\numberline {11}Notes about polymorphism}{19}{section.0.11}%
\contentsline {subsection}{\numberline {11.1}Polymorphism with arrays and slicing}{20}{subsection.0.11.1}%
\contentsline {subsubsection}{\numberline {11.1.1}Object Slicing}{20}{subsubsection.0.11.1.1}%
\contentsline {subsubsection}{\numberline {11.1.2}Polymorphism with arrays}{21}{subsubsection.0.11.1.2}%
\contentsline {subsection}{\numberline {11.2}Runtime polymorphism, dynamic dispatch, dynamic binding, and the vtable}{22}{subsection.0.11.2}%
\contentsline {subsubsection}{\numberline {11.2.1}Dynamic dispatch and dynamic binding}{22}{subsubsection.0.11.2.1}%
\contentsline {subsubsection}{\numberline {11.2.2}The Vtable}{23}{subsubsection.0.11.2.2}%
\contentsline {subsection}{\numberline {11.3}Can you call pure virtual methods}{25}{subsection.0.11.3}%
\contentsline {subsection}{\numberline {11.4}Do the signatures need to exactly match on overridden functions}{25}{subsection.0.11.4}%
\contentsline {subsection}{\numberline {11.5}What happens if you forget the keyword virtual on base class methods}{25}{subsection.0.11.5}%
\contentsline {subsection}{\numberline {11.6}Do you need the keyword virtual on overridden methods?}{25}{subsection.0.11.6}%
\contentsline {subsection}{\numberline {11.7}What happens if you forget the override}{26}{subsection.0.11.7}%
\contentsline {subsection}{\numberline {11.8}Overrides with default args}{26}{subsection.0.11.8}%
\contentsline {subsection}{\numberline {11.9}Private and public with polymorphism}{27}{subsection.0.11.9}%
\contentsline {section}{\numberline {12}The existence of structs and classes}{29}{section.0.12}%
\contentsline {section}{\numberline {13}Note about heap allocated memory in vectors}{30}{section.0.13}%
\contentsline {section}{\numberline {14}Function that takes a const reference can accept rvalues}{31}{section.0.14}%
\contentsline {section}{\numberline {15}Notes about c++ casts}{32}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}Static\_cast}{32}{subsection.0.15.1}%
\contentsline {subsection}{\numberline {15.2}Dynamic\_cast}{32}{subsection.0.15.2}%
\contentsline {subsubsection}{\numberline {15.2.1}When to Use Dynamic Casting}{33}{subsubsection.0.15.2.1}%
\contentsline {subsubsection}{\numberline {15.2.2}RTTI}{33}{subsubsection.0.15.2.2}%
\contentsline {subsection}{\numberline {15.3}const\_cast}{33}{subsection.0.15.3}%
\contentsline {subsubsection}{\numberline {15.3.1}Modifying a non-const object that was passed as const}{34}{subsubsection.0.15.3.1}%
\contentsline {subsubsection}{\numberline {15.3.2}Removing const to use overloaded functions}{34}{subsubsection.0.15.3.2}%
\contentsline {subsection}{\numberline {15.4}reinterpret\_cast}{35}{subsection.0.15.4}%
\contentsline {subsection}{\numberline {15.5}Why are c casts unsafe?}{35}{subsection.0.15.5}%
\contentsline {section}{\numberline {16}The compiler and functions}{36}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Important: compile time constant variables and memory (constant propagation/constant folding)}{38}{subsection.0.16.1}%
\contentsline {section}{\numberline {17}The introduction of the nullptr}{39}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Ambiguity in Overloaded Functions}{39}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Type safety}{39}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}The type of nullptr}{39}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}nullptr vs void*}{40}{subsection.0.17.4}%
\contentsline {section}{\numberline {18}Brace initialization vs Parenthesized Initialization}{41}{section.0.18}%
\contentsline {section}{\numberline {19}Are chars unsigned?}{42}{section.0.19}%
\contentsline {section}{\numberline {20}Size of types}{43}{section.0.20}%
\contentsline {section}{\numberline {21}Trivially copyable}{44}{section.0.21}%
\contentsline {section}{\numberline {22}POD types (Plain old data)}{45}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}Trivial type}{45}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Standard layout}{45}{subsection.0.22.2}%
\contentsline {section}{\numberline {23}Notes about initialization}{46}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}How many names does brace initialization have?}{46}{subsection.0.23.1}%
\contentsline {subsubsection}{\numberline {23.1.1}Uniform Initialization (General Term)}{46}{subsubsection.0.23.1.1}%
\contentsline {subsubsection}{\numberline {23.1.2}List Initialization}{46}{subsubsection.0.23.1.2}%
\contentsline {subsubsection}{\numberline {23.1.3}Aggregate Initialization}{46}{subsubsection.0.23.1.3}%
\contentsline {subsubsection}{\numberline {23.1.4}Value Initialization}{46}{subsubsection.0.23.1.4}%
\contentsline {subsubsection}{\numberline {23.1.5}Direct List Initialization}{47}{subsubsection.0.23.1.5}%
\contentsline {subsubsection}{\numberline {23.1.6}Copy List Initialization}{47}{subsubsection.0.23.1.6}%
\contentsline {subsubsection}{\numberline {23.1.7}Narrowing Prevention Initialization}{47}{subsubsection.0.23.1.7}%
\contentsline {subsubsection}{\numberline {23.1.8} Default Member Initialization}{47}{subsubsection.0.23.1.8}%
\contentsline {subsubsection}{\numberline {23.1.9}Copy list initialization and direct list initialization in aggregate types}{47}{subsubsection.0.23.1.9}%
\contentsline {subsection}{\numberline {23.2}Other forms of initialization and their names}{48}{subsection.0.23.2}%
\contentsline {subsubsection}{\numberline {23.2.1} Direct Initialization}{49}{subsubsection.0.23.2.1}%
\contentsline {subsubsection}{\numberline {23.2.2}Copy Initialization }{49}{subsubsection.0.23.2.2}%
\contentsline {subsubsection}{\numberline {23.2.3} Default Initialization}{49}{subsubsection.0.23.2.3}%
\contentsline {subsection}{\numberline {23.3}Excess elements in scalar initialization}{49}{subsection.0.23.3}%
\contentsline {section}{\numberline {24}Notes about constructors}{51}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Value initialized vs default initialized}{51}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}What exactly is =default}{51}{subsection.0.24.2}%
\contentsline {subsubsection}{\numberline {24.2.1}Non-POD fields}{52}{subsubsection.0.24.2.1}%
\contentsline {subsubsection}{\numberline {24.2.2}With copy constructors}{52}{subsubsection.0.24.2.2}%
\contentsline {subsubsection}{\numberline {24.2.3}Copy Assignment}{53}{subsubsection.0.24.2.3}%
\contentsline {subsubsection}{\numberline {24.2.4}Move constructor}{53}{subsubsection.0.24.2.4}%
\contentsline {subsubsection}{\numberline {24.2.5} Move Assignment}{54}{subsubsection.0.24.2.5}%
\contentsline {subsubsection}{\numberline {24.2.6}Destructor}{54}{subsubsection.0.24.2.6}%
\contentsline {subsubsection}{\numberline {24.2.7}Do you need to write them?}{54}{subsubsection.0.24.2.7}%
\contentsline {subsection}{\numberline {24.3}=delete}{55}{subsection.0.24.3}%
\contentsline {subsection}{\numberline {24.4}Rule of five}{55}{subsection.0.24.4}%
\contentsline {subsection}{\numberline {24.5}A confused compiler}{55}{subsection.0.24.5}%
\contentsline {subsection}{\numberline {24.6}Which constructor will be called}{56}{subsection.0.24.6}%
\contentsline {section}{\numberline {25}Notes about inheritance}{58}{section.0.25}%
\contentsline {subsection}{\numberline {25.1}Constructor chain}{58}{subsection.0.25.1}%
\contentsline {subsection}{\numberline {25.2}Destructor chain}{58}{subsection.0.25.2}%
\contentsline {section}{\numberline {26}Booleans under the hood: Adding two booleans}{59}{section.0.26}%
\contentsline {section}{\numberline {27}Type Promotion}{60}{section.0.27}%
\contentsline {subsection}{\numberline {27.1}Ranking}{60}{subsection.0.27.1}%
\contentsline {section}{\numberline {28}Notes about static}{61}{section.0.28}%
\contentsline {subsection}{\numberline {28.1}Static variables inside member functions}{61}{subsection.0.28.1}%
\contentsline {subsection}{\numberline {28.2}Using instances to call static methods}{61}{subsection.0.28.2}%
\contentsline {subsection}{\numberline {28.3}Can you make pure virtual methods static?}{61}{subsection.0.28.3}%
\contentsline {subsection}{\numberline {28.4}Static and extern (linkage)}{61}{subsection.0.28.4}%
\contentsline {subsubsection}{\numberline {28.4.1}Using extern to declare a variable with the same name as a static variable from another translation unit}{62}{subsubsection.0.28.4.1}%
\contentsline {subsubsection}{\numberline {28.4.2}Forgetting to use extern}{62}{subsubsection.0.28.4.2}%
\contentsline {subsubsection}{\numberline {28.4.3}Forgetting to use keyword static}{62}{subsubsection.0.28.4.3}%
\contentsline {subsubsection}{\numberline {28.4.4}Constinit with extern}{63}{subsubsection.0.28.4.4}%
\contentsline {section}{\numberline {29}Trying to move const objects}{64}{section.0.29}%
\contentsline {section}{\numberline {30}Smart pointers in conjunction with raw ptrs}{65}{section.0.30}%
\contentsline {subsection}{\numberline {30.1}Shared\_ptr with raw ptrs}{65}{subsection.0.30.1}%
\contentsline {subsection}{\numberline {30.2}Unique\_ptr with raw ptrs}{65}{subsection.0.30.2}%
\contentsline {section}{\numberline {31}Calling delete on a nullptr}{66}{section.0.31}%
\contentsline {section}{\numberline {32}Notes about short circuits}{67}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}With ands}{67}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}With ors}{67}{subsection.0.32.2}%
\contentsline {section}{\numberline {33}Notes about types}{69}{section.0.33}%
\contentsline {section}{\numberline {34}Notes about inline functions}{70}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Inline functions in the context of multiple translation units}{70}{subsection.0.34.1}%
\contentsline {section}{\numberline {35}Notes about object creation}{71}{section.0.35}%
\contentsline {section}{\numberline {36}What is a "function signature"}{72}{section.0.36}%
\contentsline {subsection}{\numberline {36.1}Function Signature (Overriding Perspective)}{72}{subsection.0.36.1}%
\contentsline {subsection}{\numberline {36.2}What is NOT Part of a Function Signature? }{72}{subsection.0.36.2}%
\contentsline {subsection}{\numberline {36.3}noexcept?}{72}{subsection.0.36.3}%
\contentsline {section}{\numberline {37}Maximal munch principle}{73}{section.0.37}%
