\contentsline {section}{\numberline {1}Converting char to std::string}{3}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Constructor signature}{3}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Example}{3}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}std::string::npos}{4}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Example}{4}{subsection.0.2.1}%
\contentsline {section}{\numberline {3}Narrowing}{5}{section.0.3}%
\contentsline {section}{\numberline {4}Aggregate types}{6}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Aggregate initialization}{6}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Narrowing is not allowed in aggregate-initialization from an initializer list}{7}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}implicit conversion using a single-argument constructor}{7}{subsection.0.4.3}%
\contentsline {section}{\numberline {5}Floating point literals}{9}{section.0.5}%
\contentsline {section}{\numberline {6}Size of structs and classes}{10}{section.0.6}%
\contentsline {section}{\numberline {7}When is trailing return type useful}{11}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Decltype on template parameters}{11}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Nested structs}{11}{subsection.0.7.2}%
\contentsline {section}{\numberline {8}Most vexing parse}{12}{section.0.8}%
\contentsline {section}{\numberline {9}Notes about copy constructors}{13}{section.0.9}%
\contentsline {section}{\numberline {10}Exceptions during a call to new}{14}{section.0.10}%
\contentsline {subsection}{\numberline {10.1}Exceptions during constructors}{14}{subsection.0.10.1}%
\contentsline {section}{\numberline {11}Notes about polymorphism}{15}{section.0.11}%
\contentsline {subsection}{\numberline {11.1}Polymorphism with arrays and slicing}{16}{subsection.0.11.1}%
\contentsline {subsubsection}{\numberline {11.1.1}Object Slicing}{16}{subsubsection.0.11.1.1}%
\contentsline {subsubsection}{\numberline {11.1.2}Polymorphism with arrays}{17}{subsubsection.0.11.1.2}%
\contentsline {subsection}{\numberline {11.2}Runtime polymorphism, dynamic dispatch, dynamic binding, and the vtable}{18}{subsection.0.11.2}%
\contentsline {subsubsection}{\numberline {11.2.1}Dynamic dispatch and dynamic binding}{18}{subsubsection.0.11.2.1}%
\contentsline {subsubsection}{\numberline {11.2.2}The Vtable}{19}{subsubsection.0.11.2.2}%
\contentsline {section}{\numberline {12}The existence of structs and classes}{22}{section.0.12}%
\contentsline {section}{\numberline {13}Note about heap allocated memory in vectors}{23}{section.0.13}%
\contentsline {section}{\numberline {14}Function that takes a const reference can accept rvalues}{24}{section.0.14}%
\contentsline {section}{\numberline {15}Notes about c++ casts}{25}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}Static\_cast}{25}{subsection.0.15.1}%
\contentsline {subsection}{\numberline {15.2}Dynamic\_cast}{25}{subsection.0.15.2}%
\contentsline {subsubsection}{\numberline {15.2.1}When to Use Dynamic Casting}{26}{subsubsection.0.15.2.1}%
\contentsline {subsubsection}{\numberline {15.2.2}RTTI}{26}{subsubsection.0.15.2.2}%
\contentsline {subsection}{\numberline {15.3}const\_cast}{26}{subsection.0.15.3}%
\contentsline {subsubsection}{\numberline {15.3.1}Modifying a non-const object that was passed as const}{27}{subsubsection.0.15.3.1}%
\contentsline {subsubsection}{\numberline {15.3.2}Removing const to use overloaded functions}{27}{subsubsection.0.15.3.2}%
\contentsline {subsection}{\numberline {15.4}reinterpret\_cast}{28}{subsection.0.15.4}%
\contentsline {subsection}{\numberline {15.5}Why are c casts unsafe?}{28}{subsection.0.15.5}%
