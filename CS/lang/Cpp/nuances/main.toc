\contentsline {section}{\numberline {1}Converting char to std::string}{5}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Constructor signature}{5}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Example}{5}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}std::string::npos}{6}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Example}{6}{subsection.0.2.1}%
\contentsline {section}{\numberline {3}Narrowing}{7}{section.0.3}%
\contentsline {section}{\numberline {4}Aggregate types}{8}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Aggregate initialization}{8}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Narrowing is not allowed in aggregate-initialization from an initializer list}{9}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}implicit conversion using a single-argument constructor}{9}{subsection.0.4.3}%
\contentsline {section}{\numberline {5}Floating point literals}{11}{section.0.5}%
\contentsline {section}{\numberline {6}Size of structs and classes}{12}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Padding}{13}{subsection.0.6.1}%
\contentsline {section}{\numberline {7}When is trailing return type useful}{14}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Decltype on template parameters}{14}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Nested structs}{14}{subsection.0.7.2}%
\contentsline {section}{\numberline {8}Most vexing parse}{15}{section.0.8}%
\contentsline {section}{\numberline {9}Notes about copy constructors}{16}{section.0.9}%
\contentsline {section}{\numberline {10}Exceptions during a call to new}{17}{section.0.10}%
\contentsline {subsection}{\numberline {10.1}Exceptions during constructors}{17}{subsection.0.10.1}%
\contentsline {section}{\numberline {11}Notes about polymorphism}{18}{section.0.11}%
\contentsline {subsection}{\numberline {11.1}Polymorphism with arrays and slicing}{19}{subsection.0.11.1}%
\contentsline {subsubsection}{\numberline {11.1.1}Object Slicing}{19}{subsubsection.0.11.1.1}%
\contentsline {subsubsection}{\numberline {11.1.2}Polymorphism with arrays}{20}{subsubsection.0.11.1.2}%
\contentsline {subsection}{\numberline {11.2}Runtime polymorphism, dynamic dispatch, dynamic binding, and the vtable}{21}{subsection.0.11.2}%
\contentsline {subsubsection}{\numberline {11.2.1}Dynamic dispatch and dynamic binding}{21}{subsubsection.0.11.2.1}%
\contentsline {subsubsection}{\numberline {11.2.2}The Vtable}{22}{subsubsection.0.11.2.2}%
\contentsline {subsection}{\numberline {11.3}Can you call pure virtual methods}{24}{subsection.0.11.3}%
\contentsline {section}{\numberline {12}The existence of structs and classes}{25}{section.0.12}%
\contentsline {section}{\numberline {13}Note about heap allocated memory in vectors}{26}{section.0.13}%
\contentsline {section}{\numberline {14}Function that takes a const reference can accept rvalues}{27}{section.0.14}%
\contentsline {section}{\numberline {15}Notes about c++ casts}{28}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}Static\_cast}{28}{subsection.0.15.1}%
\contentsline {subsection}{\numberline {15.2}Dynamic\_cast}{28}{subsection.0.15.2}%
\contentsline {subsubsection}{\numberline {15.2.1}When to Use Dynamic Casting}{29}{subsubsection.0.15.2.1}%
\contentsline {subsubsection}{\numberline {15.2.2}RTTI}{29}{subsubsection.0.15.2.2}%
\contentsline {subsection}{\numberline {15.3}const\_cast}{29}{subsection.0.15.3}%
\contentsline {subsubsection}{\numberline {15.3.1}Modifying a non-const object that was passed as const}{30}{subsubsection.0.15.3.1}%
\contentsline {subsubsection}{\numberline {15.3.2}Removing const to use overloaded functions}{30}{subsubsection.0.15.3.2}%
\contentsline {subsection}{\numberline {15.4}reinterpret\_cast}{31}{subsection.0.15.4}%
\contentsline {subsection}{\numberline {15.5}Why are c casts unsafe?}{31}{subsection.0.15.5}%
\contentsline {section}{\numberline {16}The compiler and functions}{32}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}Important: compile time constant variables and memory (constant propagation/constant folding)}{34}{subsection.0.16.1}%
\contentsline {section}{\numberline {17}The introduction of the nullptr}{35}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Ambiguity in Overloaded Functions}{35}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Type safety}{35}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}The type of nullptr}{35}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}nullptr vs void*}{36}{subsection.0.17.4}%
\contentsline {section}{\numberline {18}Brace initialization vs Parenthesized Initialization}{37}{section.0.18}%
\contentsline {section}{\numberline {19}Are chars unsigned?}{38}{section.0.19}%
\contentsline {section}{\numberline {20}Size of types}{39}{section.0.20}%
\contentsline {section}{\numberline {21}Trivially copyable}{40}{section.0.21}%
\contentsline {section}{\numberline {22}POD types (Plain old data)}{41}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}Trivial type}{41}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}Standard layout}{41}{subsection.0.22.2}%
\contentsline {section}{\numberline {23}Notes about constructors}{42}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}Value initialized vs default initialized}{42}{subsection.0.23.1}%
\contentsline {subsection}{\numberline {23.2}What exactly is =default}{42}{subsection.0.23.2}%
\contentsline {subsubsection}{\numberline {23.2.1}Non-POD fields}{43}{subsubsection.0.23.2.1}%
\contentsline {subsubsection}{\numberline {23.2.2}With copy constructors}{43}{subsubsection.0.23.2.2}%
\contentsline {subsubsection}{\numberline {23.2.3}Copy Assignment}{44}{subsubsection.0.23.2.3}%
\contentsline {subsubsection}{\numberline {23.2.4}Move constructor}{44}{subsubsection.0.23.2.4}%
\contentsline {subsubsection}{\numberline {23.2.5} Move Assignment}{45}{subsubsection.0.23.2.5}%
\contentsline {subsubsection}{\numberline {23.2.6}Destructor}{45}{subsubsection.0.23.2.6}%
\contentsline {subsubsection}{\numberline {23.2.7}Do you need to write them?}{45}{subsubsection.0.23.2.7}%
\contentsline {subsection}{\numberline {23.3}=delete}{46}{subsection.0.23.3}%
\contentsline {subsection}{\numberline {23.4}Rule of five}{46}{subsection.0.23.4}%
\contentsline {section}{\numberline {24}Notes about inheritance}{47}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Constructor chain}{47}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Destructor chain}{47}{subsection.0.24.2}%
\contentsline {section}{\numberline {25}Booleans under the hood: Adding two booleans}{48}{section.0.25}%
\contentsline {section}{\numberline {26}Type Promotion}{49}{section.0.26}%
\contentsline {subsection}{\numberline {26.1}Ranking}{49}{subsection.0.26.1}%
\contentsline {section}{\numberline {27}Notes about static}{50}{section.0.27}%
\contentsline {subsection}{\numberline {27.1}Static variables inside member functions}{50}{subsection.0.27.1}%
\contentsline {subsection}{\numberline {27.2}Using instances to call static methods}{50}{subsection.0.27.2}%
\contentsline {subsection}{\numberline {27.3}Can you make pure virtual methods static?}{50}{subsection.0.27.3}%
\contentsline {section}{\numberline {28}Trying to move const objects}{51}{section.0.28}%
\contentsline {section}{\numberline {29}Smart pointers in conjunction with raw ptrs}{52}{section.0.29}%
\contentsline {subsection}{\numberline {29.1}Shared\_ptr with raw ptrs}{52}{subsection.0.29.1}%
\contentsline {subsection}{\numberline {29.2}Unique\_ptr with raw ptrs}{52}{subsection.0.29.2}%
