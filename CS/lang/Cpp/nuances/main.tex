\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Cpp Nuances}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Cpp Nuances}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Converting char to std::string}
    \bigbreak \noindent 
    Suppose we have a char variable, and we need to "convert" it to a string. To do this we use the string class constructor, which has two parameters, the size of the string to create, and the character to use as the fill.
    \bigbreak \noindent 
    \subsection{Constructor signature}
    \bigbreak \noindent 
    \begin{cppcode}
    string(size_t n, char x) 
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    char c = 'a';
    string s(1,c);
    \end{cppcode}

    \pagebreak 
    \unsect{std::string::npos}
    \bigbreak \noindent 
    \begin{concept}
        In C++, std::string::npos is a static member constant value with the greatest possible value for an element of type size\_t. This value, when used as the length in string operations, typically represents "until the end of the string." It is often used in string manipulation functions to specify that the operation should proceed from the starting position to the end of the string, or until no more characters are found.
    \end{concept}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    string infix = buffer.substr(index + 2, string::npos);
    \end{cppcode}
    \bigbreak \noindent 
    std::string::npos is defined as the maximum value representable by the type size\_t. This value is typically used to signify an error condition or a not-found condition when working with strings and other sequence types. However, when used as a length argument in methods like std::string::substr, it effectively becomes a directive to process characters until the end of the string. This is because any attempt to access beyond the end of the string would exceed the string's length, and the methods are designed to stop processing at that point.

    \pagebreak 
    \unsect{Narrowing}
    \bigbreak \noindent 
    Narrowing happens when:
    \begin{itemize}
        \item A value of a larger or more precise type is converted to a smaller or less precise type (e.g., double to int, int to char).
        \item A floating-point value is converted to an integer type.
        \item An integer value is converted to a smaller integer type (e.g., int to short) and does not fit within the destination type's range.
    \end{itemize}

    \pagebreak 
    \unsect{Aggregate types}
    \bigbreak \noindent 
    Aggregate types in C++ are simple data structures that hold collections of values and have minimal additional behavior. They are essentially "plain old data" structures that are easy to initialize and manipulate. The term "aggregate" is formally defined by the C++ standard.
    \bigbreak \noindent 
    A class, struct, or union is considered an aggregate if it satisfies all of the following conditions:
    \begin{enumerate}
        \item No User-Defined Constructors: It must not have any explicitly declared constructors (including default, copy, or move constructors).
        \item No Private or Protected Non-Static Data Members: All non-static data members must be public.
        \item No Virtual Functions: It must not have any virtual functions.
        \item No Base Classes: It must not inherit from another class or struct.
        \item No Virtual Base Classes: It must not use virtual inheritance.
    \end{enumerate}
    \bigbreak \noindent 
    For example
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;
        };
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Aggregate initialization}
    \bigbreak \noindent 
    Aggregate initialization in C++ refers to a special form of initialization for aggregate types using an initializer list enclosed in \{\} braces. This allows you to directly specify values for the members of an aggregate type in the order they are declared.
    \bigbreak \noindent 
    Each member of the aggregate is initialized with the corresponding value provided in the initializer list. The order of values in the initializer list must match the declaration order of members in the aggregate.
    \bigbreak \noindent 
    If fewer values are provided in the initializer list than there are members in the aggregate, the remaining members are value-initialized (e.g., zero-initialized for fundamental types).
    \bigbreak \noindent 
    If the type is not an aggregate (e.g., has a user-defined constructor, private members, or virtual functions), aggregate initialization cannot be used.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;
        };

        S s = {1,2};
    \end{cppcode}
    \bigbreak \noindent 
    Consider the next example,
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;

            S(int x, int y) : x(x), y(y) {}
        };
         
        S s = {1,2}; // Works fine
    \end{cppcode}
    \bigbreak \noindent 
    Since the class $S$ has a user-defined constructor, it is no longer an aggregate type.
    \bigbreak \noindent 
    Aggregate initialization is not applicable here. Instead, C++ checks for constructors that match the initializer list \{1, 2\}.
    \bigbreak \noindent 
    Since it found one, the compiler interprets it as calling the constructor S(int x, int y) with the arguments 1 and 2.
    \bigbreak \noindent 
    In modern C++ (C++11 and later), brace-enclosed initialization is often used for uniform initialization.
    \bigbreak \noindent 
    If a constructor is available that matches the initializer list, it is called.

    \bigbreak \noindent 
    \subsection{Narrowing is not allowed in aggregate-initialization from an initializer list}
    \bigbreak \noindent 
    The error "narrowing is not allowed in aggregate-initialization from an initializer list" occurs in C++ when you try to initialize an aggregate type (e.g., structs, arrays, or classes with no user-defined constructors) using values in an initializer list, but the values undergo an implicit narrowing conversion that could lose information or precision.
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            int x;
            float y;
        };

        A a = {1, 3.14}; // OK, no narrowing
        A b = {1, 3.14f}; // OK, no narrowing (3.14f is a float literal)

        A c = {1, 3.14}; // ERROR: narrowing from `double` to `float`
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{implicit conversion using a single-argument constructor}
    \bigbreak \noindent 
     A constructor that takes one argument can be used for implicit conversion of that argument type to the class type.
     \bigbreak \noindent 
     \begin{cppcode}
     struct s {
         int x;
         s(int value) : x(value) {} // Single-argument constructor
     };
     s s1 = 1;
 \end{cppcode}
 \bigbreak \noindent 
 The integer 1 is implicitly converted to an object of type s using the s(int value) constructor.
 \bigbreak \noindent 
 By default, a single-argument constructor allows implicit conversions. If you want to prevent implicit conversions and require explicit construction, you can use the explicit keyword
 \bigbreak \noindent 
 \begin{cppcode}
     struct s {
         int x;
         explicit s(int value) : x(value) {}
     };

     int main() {
         s s1 = 1; // ERROR: Explicit constructor prevents implicit conversion
         s s2(1);  // OK: Direct initialization
     }
 \end{cppcode}





    \pagebreak 
    \unsect{Floating point literals}
    \bigbreak \noindent 
    Floating point literals in c++ will be of type double. For example,
    \bigbreak \noindent 
    \begin{cppcode}
    cout << typeid(4.09).name(); // d
    \end{cppcode}
    \bigbreak \noindent 
    Append $f$ to the literal to make it a float
    \bigbreak \noindent 
    \begin{cppcode}
        cout << typeid(4.09f).name(); // d
    \end{cppcode}

    \pagebreak 
    \unsect{Size of structs and classes}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { }
        cout << sizeof(s) << endl; // 1

        s s1;
        cout << sizeof(s1) << endl; // 1
    \end{cppcode}
    \bigbreak \noindent 
    Notice that empty structs do not have a size of zero. Empty structs have a size of one byte. 
    \bigbreak \noindent 
    A size of zero for a struct would mean that it occupies no memory. If multiple instances of such a struct are created, they would have no unique memory location to occupy. As a result, the compiler would assign the same memory address to all instances, which would violate fundamental rules of object-oriented programming in C++.
    \bigbreak \noindent 
    Furthermore, giving fields to the struct or class increases the size of that struct or class by size of the type. 
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { int x; }
        cout << sizeof(s); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Notice that the size is \textbf{not} 5. Creating functions and creating variables in those functions does not add to the size
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            void f()  {
                int  x;
            }
        }
        cout << sizeof(s); // 1
    \end{cppcode}
    \bigbreak \noindent 
    Creating structs inside structs and even adding fields to the inner structs does not increase the size
    \bigbreak \noindent 
    \begin{cppcode}
    struct s {
        struct k { int x; };
    };

    cout << sizeof(s); // 1
    cout << sizeof(s::k); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Lastly, constructors and destructors do not increase the size.
    \bigbreak \noindent 
    It seems only fields increase the size.

    \bigbreak \noindent 
    \subsection{Padding}
    \bigbreak \noindent 
    Consider the following struct
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            char c; // 1 byte
            int x; // 4 bytes
        };
        cout << sizeof(s) << endl; // 8
    \end{cppcode}
    \bigbreak \noindent 
    Notice that we do not get a size of 5. In C++, padding is introduced by the compiler to ensure proper memory alignment of data members. This improves performance on most hardware architectures. The first member, char $c$, occupies 1 byte. The next member, int $x$, requires 4 bytes and should be aligned to a 4-byte boundary (on most systems). To achieve this alignment, 3 bytes of padding are added after c before x starts.

    \pagebreak 
    \unsect{When is trailing return type useful}
    \bigbreak \noindent 
    \subsection{Decltype on template parameters}
    \bigbreak \noindent 
    Suppose we had two template types $T,U$, and a function that accepts $T a, U b$. Suppose we wanted the return type to be the type of $T + U$, we could of course just write
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        decltype(T{} + U{}) f(T a, U b) {
            return a + b; 
        }
    \end{cppcode}
    \bigbreak \noindent 
    Or, we could utilize a trailing return
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T, typename U>
    auto f(T a, U b) -> decltype(a+b) {
        return a + b; 
    }
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Nested structs}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            struct B {};

            B f() const;
        };

        A::B A::f() const { }
    \end{cppcode}
    \bigbreak \noindent 
    Instead of having to use the scope resolution operator, we could use a trailing return type.
    \bigbreak \noindent 
    \begin{cppcode}
        auto A::f() const -> B {

        }
    \end{cppcode}
    \bigbreak \noindent 
    By using a trailing return type, we are essentially inside the scope of $A$ by the time we specify the return type.

    \pagebreak 
    \unsect{Most vexing parse}
    \bigbreak \noindent 
    The most vexing parse is a phenomenon in C++ where a line of code that looks like a variable declaration is instead interpreted by the compiler as a function declaration. This often happens because of C++'s ambiguous grammar for declarations.
    \bigbreak \noindent 
    \begin{cppcode}
    std::string s(); // Treated as a function declaration
    \end{cppcode}
    \bigbreak \noindent 
    This will not be treated as a default constructed string by the C++ compiler, but instead as a function declaration. To fix this issue, we instead use brace initialization
    \bigbreak \noindent 
    \begin{cppcode}
        std::string s{} // A default string variable
    \end{cppcode}

    \pagebreak 
    \unsect{Notes about copy constructors}
    \bigbreak \noindent 
    The copy constructor in C++ typically takes a const reference (const T\&) to ensure correctness and efficiency. If the copy constructor took its parameter by value, this would require making a copy of other before calling the constructor itself. But that copy itself would require calling the copy constructor, leading to infinite recursion until a stack overflow.
    \bigbreak \noindent 
    If the copy constructor took a non-const reference, this would not allow copying from const objects.
    \bigbreak \noindent 
    Since a copy operation should not modify the original object, using const ensures the copy constructor can be called for const objects.
    \bigbreak \noindent 
    Recall that functions (and methods) that take a const reference insure that the function can be called on both const objects and non-const objects. Functions that take non-const references can only accept non-const objects.
    \bigbreak \noindent 
    As a quick side note, since we are on the topic of const correctness, recall that constant member functions cannot call non-const member functions.

    \pagebreak 
    \unsect{Exceptions during a call to new}
    \bigbreak \noindent 
    When using raw pointers, an exception occurring after a new allocation leads to a resource leak if the allocated memory is not properly managed. This happens because new dynamically allocates memory on the heap, but if an exception interrupts execution before delete is called, the allocated memory remains unreachable and never freed.
    \bigbreak \noindent 
    To prevent this, use smart pointers (std::unique\_ptr or std::shared\_ptr), which automatically manage memory and clean up even if an exception occurs.
    \bigbreak \noindent 
    However, it is true that using std::unique\_ptr and std::shared\_ptr does not guarantee that there will be no resource leaks if they are not used properly. Specifically, passing new directly to their constructors can still lead to resource leaks in certain cases. This is why std::make\_unique and std::make\_shared are preferred
    \bigbreak \noindent 
    make\_shared performs a single allocation that stores both the object and the control block together. If an exception occurs, no memory leak happens because allocation and ownership setup happen in one step.
    \bigbreak \noindent 
    Same is true for make\_unique
    \bigbreak \noindent 
    \subsection{Exceptions during constructors}
    \bigbreak \noindent 
    If a call to new results in an exception, the object is never allocated.
    When you use new, the operator first tries to allocate memory by calling operator new(size), which is similar to malloc.
    \bigbreak \noindent 
    If memory allocation is successful, the constructor of the object is called.
    \bigbreak \noindent 
    If there isn't enough memory, operator new will throw a std::bad\_alloc exception (unless you use nothrow new, which returns nullptr)
    \bigbreak \noindent 
    If memory allocation succeeds but the constructor of the object throws an exception, the allocated memory is automatically freed, so there is no memory leak. If an exception is thrown in the constructor after memory has been allocated but before construction is complete, the C++ runtime ensures that the allocated memory is automatically freed. This is done by:
    \begin{itemize}
        \item Catching the exception inside the new operator.
        \item Calling operator delete(ptr) to deallocate the memory.
    \end{itemize}

    \pagebreak 
    \unsect{Notes about polymorphism}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };
        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base* o) {
            o->print();
        }

        void f(const base& o) {
            o.print();
        }

        derived d1;
        base& b1 = d1;

        f(b1);

        base* d = new derived();
        f(d);

        delete d;
    \end{cppcode}
    \bigbreak \noindent 
    We get the output
    \bigbreak \noindent 
    \begin{cppcode}
        Derived
        Cleaned up derived
        Cleaned up base
    \end{cppcode}
    \bigbreak \noindent 
    The reason both destructor messages ("Cleaned up derived" and "Cleaned up base") are printed when you call delete d; is due to polymorphic destruction.
    \bigbreak \noindent 
    The base class has a virtual destructor (virtual $\sim$base()). This ensures that when an object is deleted through a pointer to base, the destructor of the derived class will also be invoked before the base destructor.
    \bigbreak \noindent 
    $d$ is deleted, and because base has a virtual destructor, the destructor call correctly cascades down the inheritance chain:
    \begin{itemize}
        \item First, $\sim$derived() runs and prints "Cleaned up derived".
        \item Then, $\sim$base() runs and prints "Cleaned up base".
    \end{itemize}
    \bigbreak \noindent 
    If the destructor in base wasn't virtual, deleting a derived object through a base* pointer would cause undefined behavior (likely only $\sim$base() would be called, leading to memory leaks).
    \bigbreak \noindent 
    If base has fields (member variables), whether directly inherited by derived or not, the base destructor must be called to clean up those fields properly when a derived object is deleted.

    \bigbreak \noindent 
    \subsection{Polymorphism with arrays and slicing}
    \bigbreak \noindent 
    \subsubsection{Object Slicing}
    \bigbreak \noindent 
    Object slicing occurs when an object of a derived class is assigned to a variable of a base class type, causing the derived part of the object to be "sliced off", leaving only the base class portion.
    \bigbreak \noindent 
    Slicing occurs when 
    \begin{itemize}
        \item A derived object is assigned to a base class object (not a pointer or reference).
        \item A derived object is stored in a container of base class objects (e.g., an array of base objects).
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            int x{1};

        };
        struct derived : base {
            int y{5};
        };

        base b = derived{};
        // Error, no member named y in base
        cout << b.x << endl << b.y;
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Polymorphism with arrays}
    \bigbreak \noindent 
    Consider the following code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };

        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base& o) {
            o.print();
        }

        auto main(int argc, const char* argv[]) -> int {
            base* barr = new derived[5];

            delete[] barr;

            return EXIT_SUCCESS;
        }
    \end{cppcode}
    \bigbreak \noindent 
    barr is declared as base*, but the memory actually holds derived objects. When delete[] barr; is called, C++ treats barr as an array of base objects, not derived objects. This breaks proper destructor calls, leading to undefined behavior.
    \bigbreak \noindent 
    Even though base has a virtual ~base(), the problem is not about virtual dispatch. Instead, it's about how C++ tracks array allocations.
    \bigbreak \noindent 
    The array of derived objects was allocated using new derived[5], but delete[] barr; doesn’t have enough information to correctly call derived destructors.
    \bigbreak \noindent 
    When delete[] barr; is called, C++ sees a base* pointer and assumes it points to an array of base objects.
    \bigbreak \noindent 
    Instead we either,
    \begin{cppcode}
        derived* darr = new derived[n]
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        vector<unique_ptr<base>> v(5);
        for (auto& item : v) {
            item = make_unique<derived>();
        }

        // Or the standard approach
        vector<base*> v2(5);
        for (auto& item : v2) {
            item = new derived();
        }

        for (auto& item : v2) {
            delete item;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Runtime polymorphism, dynamic dispatch, dynamic binding,  and the vtable}
    \bigbreak \noindent 
    Runtime polymorphism in C++ is achieved through function overriding and is implemented using virtual functions in an inheritance hierarchy. It allows a derived class to provide a specific implementation of a function that is already defined in its base class.
    \bigbreak \noindent 
    \subsubsection{Dynamic dispatch and dynamic binding}
    \bigbreak \noindent 
    Dynamic dispatch is a mechanism where the function to be executed is determined at runtime, rather than at compile-time. This is a key feature of runtime polymorphism and is enabled by virtual functions in C++
    \bigbreak \noindent 
    When a virtual function is declared in a base class and overridden in a derived class, C++ does not resolve function calls at compile-time.
    \bigbreak \noindent 
    Instead, when a function is called using a base class pointer/reference, C++ performs a runtime lookup to determine which function to execute.
    \bigbreak \noindent 
    This lookup is performed using the VTable (Virtual Table) and VPtr (Virtual Pointer) mechanism.
    \bigbreak \noindent 
    As a side note, the following will not work
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            consteval virtual int print() const {
                return 12;
            }

            virtual ~foo() {}
        };

        struct bar : foo {
            consteval int print() const override {
                return 0;
            }
        };

        foo* f = new bar{};
        constexpr int x = f.print();
    \end{cppcode}
    \bigbreak \noindent 
    The issue is that since the print functions are determined and called at runtime, it cannot be a compile time constant expression. We get the error "The value of $f$ is not usable in a constant expression"
    \bigbreak \noindent 
    Dynamic binding (also called late binding) is the underlying mechanism that allows dynamic dispatch to work. It refers to the process of determining which function implementation should be executed at runtime, rather than at compile time.
    \bigbreak \noindent 
    Binding refers to associating a function call with a function definition. Dynamic binding means this association happens at runtime, based on the actual type of the object.
    \bigbreak \noindent 
    Dynamic binding ensures that when a function is called on a base class pointer/reference, the correct overridden function from the derived class is invoked at runtime. Dynamic dispatch is the result of dynamic binding


    \bigbreak \noindent 
    \subsubsection{The Vtable}
    \bigbreak \noindent 
    C++ implements runtime polymorphism using a VTable (Virtual Table) and a VPointer (VPtr)
    \bigbreak \noindent 
    A VTable is a table of function pointers maintained per class. It stores pointers to the virtual functions defined in a class. Each class with virtual functions has a single VTable.
    \bigbreak \noindent 
    Each object of a class that has virtual functions contains a hidden pointer, called VPtr (Virtual Pointer). VPtr points to the VTable of that particular class.
    \bigbreak \noindent 
    During runtime, when a virtual function is called via a base class pointer, the VPtr is used to look up the correct function implementation in the VTable.
    \bigbreak \noindent
    When the program starts, the compiler creates a VTable for every class that has virtual functions. Every object of such a class gets a hidden VPtr, which points to the corresponding VTable.
    \bigbreak \noindent 
    When a virtual function is called using a base class pointer, the call is resolved dynamically by checking the VTable.
    \bigbreak \noindent 
    The VTable (Virtual Table) is created at compile time, but the VPtr (Virtual Pointer) is assigned and used at runtime.
    \bigbreak \noindent 
    The VTable itself is constructed at compile time, meaning the compiler generates and lays out the function pointers in the table before the program runs.
    \bigbreak \noindent 
    The VPtr is assigned at runtime, when an object of the class is created.
    \bigbreak \noindent 
    Because having virtual functions in our struct / class requires this VPtr to be created, having virtual functions therefore will increase the size of the struct and the objects created by the size of a pointer (8 bytes on 64-bit systems or 4 bytes on 32-bit systems).

    \bigbreak \noindent 
    each class in the inheritance hierarchy that has at least one virtual function has its own vtable.
    \begin{itemize}
        \item A base class with virtual functions has a vtable that stores pointers to its virtual functions.
        \item A derived class that overrides any virtual functions gets its own vtable, which replaces the base class’s function pointers with the derived class’s implementations.
        \item The vtable is associated with a class, not individual objects.
        \item Each object of a class with virtual functions has a vptr (virtual table pointer) that points to the vtable of its actual type.
    \end{itemize}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            virtual void print() const {
                cout << "Foo" << endl;
            }

            virtual ~foo() {}
        };

        struct bar : foo {
            void print() const override {
                cout << "Bar" << endl;
            }
        };
    \end{cppcode}
    \bigbreak \noindent 
    Since foo has virtual functions (print and the destructor), it will have a vtable.
    \begin{center}
        \begin{tabular}{p{4cm}|p{4cm}} 
            Index	&Function Pointer \\
            \hline
            0	&foo::print() \\
            1	&foo::$\sim$foo() (destructor) 
        \end{tabular}
    \end{center}
    \bigbreak \noindent 
    Every instance of foo has a vptr (virtual table pointer) pointing to this table.
    \bigbreak \noindent 
    Since bar overrides print(), but still inherits the virtual destructor from foo, its vtable will have the overridden version of print().
    \begin{center}
        \begin{tabular}{p{4cm}|p{4cm}}
            Index	&Function Pointer \\
            0	&bar::print() \\
            1	&foo::$\sim$foo() (inherited destructor) 
        \end{tabular}
    \end{center}
    \bigbreak \noindent 
    Each instance of bar will have its vptr pointing to vtable for bar.
    \bigbreak \noindent 
    \begin{cppcode}
        int main() {
            foo* obj = new bar();
            obj->print();  // Calls bar::print() because vptr points to bar's vtable
            delete obj;    // Calls foo::~foo() due to virtual destructor
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Can you call pure virtual methods}
    \bigbreak \noindent 
    You cannot instantiate abstract classes. Thus, you cannot call pure virtual methods

    \bigbreak \noindent 
    \subsection{Do the signatures need to exactly match on overridden functions}
    \bigbreak \noindent 
    Yes, the function signature must exactly match the base class function (including return type, parameters, and const qualifiers). If the signature differs in any way, the function in the derived class will be considered a new, independent function rather than an override.


    \bigbreak \noindent 
    \subsection{Do you need the keyword virtual on overridden methods?}
    \bigbreak \noindent 
    In the derived class, you do not need to explicitly write virtual again when overriding, though you can include it for clarity.

    \bigbreak \noindent 
    \subsection{What happens if you forget the override}
    \bigbreak \noindent 
    forgetting to put the override keyword when overriding a base class member function has the following consequences
    \bigbreak \noindent 
    The code will still compile, but if the function signature does not exactly match the base class function, you might accidentally create a new function in the derived class instead of overriding the base function.
    \bigbreak \noindent 
    If the function signature is incorrect (e.g., different return type, wrong parameters, or missing const qualifier), the base class function is hidden instead of being overridden. This means
    \begin{itemize}
        \item Calls to the function through a base class pointer/reference will not invoke the derived class function as intended.
        \item Instead, the base class implementation will be called, leading to unexpected behavior.
        \item If the function in the derived class has a different parameter list, the base class function can only be accessed using Base::functionName(...).
    \end{itemize}
    \bigbreak \noindent 
    The override keyword forces the compiler to check whether the function actually overrides a virtual function from the base class. Without it, if the base class function signature changes, the derived class function may silently stop overriding it, leading to subtle runtime errors.
    \bigbreak \noindent 
    \begin{cppcode}
    struct A {
        virtual void print() const {cout <<  "A"; }
    };

    struct B : A {
        virtual void print() {cout << "B";}
    };

    A* b = new B;
    b->print(); // A

    delete b;
    \end{cppcode}
    \bigbreak \noindent 
    We forgot the override keyword, which  would be fine as long as the function signatures still matched exactly, but notice that we also forgot the mark B's print const. Thus, B's print method does not override A's, and it is an independent function. Therefore, B's VTable remains
    \bigbreak \noindent 
    \begin{center}
        \begin{tabular}{c|c}
            Index & fn \\
            \hline 
            0 & A::print()
        \end{tabular}
    \end{center}
    Ie it does not get overridden. If we marked B's print with override, it would give a compiler error since the signatures don't match

    \bigbreak \noindent 
    \subsection{Overrides with default args}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            virtual void print(int x=5) const {cout <<  "A" << x; }
        };

        struct B : A {
            virtual void print(int x=10) const override {cout << "B" << x;}
        };

        A* b = new B;
        b->print(); // B5

        delete b;
        \end{cppcode}
        \bigbreak \noindent 
        So B's print gets called, but we get the default arg from A?
        \bigbreak \noindent 
        Since print() is virtual, dynamic dispatch occurs. The runtime determines that B::print() should be executed, not A::print().
        \bigbreak \noindent 
        However, default arguments are resolved at compile time, based on the static type of the pointer.
        \bigbreak \noindent 
        The call b->print(); is interpreted at compile time as
        \bigbreak \noindent 
        \begin{cppcode}
        b->print(5); // Because `b` is an `A*`, it uses A's default argument
        \end{cppcode}






    \pagebreak 
    \unsect{The existence of structs and classes}
    \bigbreak \noindent 
    Does a Struct Exist in Memory Before an Object is Created? Yes and No. It depends on what part of the struct you're referring to:
    \begin{itemize}
        \item \textbf{Struct Definition (Type Information) – Exists at Compile Time}: The struct itself is just a blueprint (like a class). It does not occupy memory on its own.
            \bigbreak \noindent 
            Only when you create an object of the struct does memory get allocated for its members.
        \item \textbf{VTable (for Virtual Functions) – Exists in Memory, Even Without Objects}: If the struct contains virtual functions, the compiler generates a VTable at compile time. The VTable itself is stored in static memory (not per object). Even if no object is created, the struct’s VTable exists somewhere in memory.
        \item \textbf{Object Instances – Exist in Memory When Created}: When you instantiate an object of the struct, memory is allocated for that object’s data members. If the struct has virtual functions, each object has a hidden VPtr (Virtual Pointer), which increases its size.
    \end{itemize}
    \bigbreak \noindent 
    If $A$ is a struct, why does sizeof(A) have a size even if no object is created? When you define a struct in C++, the compiler determines the size of its layout at compile time. This means that even if you don’t create an object of the struct, sizeof(A) can still return a valid size.
    \bigbreak \noindent 
    The compiler does not assign fixed memory addresses to struct members. Instead, it determines the memory layout (size, alignment, and padding) at compile time. Actual memory addresses are assigned at runtime when an object is created.







    \pagebreak 
    \unsect{Note about heap allocated memory in vectors}
    \bigbreak \noindent 
    If your std::vector contains raw pointers (e.g., std::vector<int*>), the vector will only destroy the pointers themselves but not the dynamically allocated memory they point to. This will cause a memory leak if you don’t manually delete each allocated object before the vector goes out of scope.
    \bigbreak \noindent 
    To avoid leaks, manually delete the elements before clearing the vector

    \pagebreak 
    \unsect{Function that takes a const reference can accept rvalues}
    \bigbreak \noindent 
    In C++, a function that takes a const reference can accept rvalues because const references extend the lifetime of temporary (rvalue) objects.
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        void f(const T& x) {}
    \end{cppcode}
    \bigbreak \noindent 
    A const T\& (a reference to a const object of type T) can bind to both lvalues and rvalues, because:
    \begin{enumerate}
        \item Lvalues are naturally bindable to references.
        \item Rvalues (temporaries) can bind to const T\& because:
            \begin{itemize}
                \item The const qualifier guarantees that the temporary will not be modified.
                \item C++ extends the lifetime of the temporary to match the lifetime of the reference.
            \end{itemize}
    \end{enumerate}
    \bigbreak \noindent 
    \begin{cppcode}
        const int& ref = 100; // OK: binds to temporary, lifetime extended
        std::cout << ref << std::endl; // Prints 100

        int& ref = 100; // ERROR: Cannot bind non-const lvalue reference to an rvalue
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item If an lvalue is passed $\to$ T deduces to int\&, making T\&\& collapse to int\&.
        \item If an rvalue is passed $\to$ T deduces to int, making T\&\& remain int\&\&.
    \end{itemize}



    
    \pagebreak 
    \unsect{Notes about c++ casts}
    \bigbreak \noindent 
    First, recall
    \begin{itemize}
        \item static\_cast is used for safe and well-defined type conversions that are checked at compile-time.
        \item dynamic\_cast is used only with polymorphic types (i.e., classes with at least one virtual function). It performs runtime type checking and is mainly used for safe downcasting.
        \item const\_cast is used to add or remove const or volatile qualifiers from a variable. It is the only cast that can remove const, allowing modifications to otherwise constant data.
        \item reinterpret\_cast is the most dangerous cast—it converts between completely unrelated types. It does not perform type checking and is used for low-level pointer manipulation.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Static\_cast}
    \bigbreak \noindent 
    \textbf{When to Use static\_cast}:
    \bigbreak \noindent 
    \begin{itemize}
        \item Converting between numeric types (e.g., int to double).
        \item Converting between pointers of related classes (e.g., upcasting in inheritance).
        \item Converting between explicitly defined conversion operators.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{What It CANNOT Do}:
    \begin{itemize}
        \item It does not check for validity at runtime.
        \item It cannot cast between unrelated types (use reinterpret\_cast for that).
        \item It cannot remove const or volatile qualifiers (use const\_cast for that).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Dynamic\_cast}
    \bigbreak \noindent 
    Dynamic casting in C++ is a feature provided by the language to safely convert pointers or references of base class types to pointers or references of derived class types at runtime. This is particularly useful in scenarios involving polymorphism, where you have a base class pointer or reference pointing to an object of a derived class, and you need to access derived class-specific members or methods.
    \bigbreak \noindent 
    Dynamic casting is used with pointers or references in class hierarchies that involve polymorphism (i.e., classes with at least one virtual function).
    \bigbreak \noindent 
    \begin{cppcode}
    dynamic_cast<new_type>(expression)
    \end{cppcode}
    \bigbreak \noindent 
    Dynamic casting performs a runtime check to ensure the cast is valid. If the cast is not possible, it returns nullptr for pointers or throws a std::bad\_cast exception for references.
    \bigbreak \noindent 
    Dynamic casting relies on Run-Time Type Information (RTTI), which must be enabled in your compiler.
    \bigbreak \noindent 
    \subsubsection{When to Use Dynamic Casting}
    \bigbreak \noindent 
    \begin{itemize}
        \item When you need to safely downcast in a polymorphic hierarchy.
        \item When you are unsure of the actual type of the object at runtime and need to check it.
    \end{itemize}
    \bigbreak \noindent 
    Dynamic casting incurs a runtime overhead due to the type checking. It only works with polymorphic types (classes with at least one virtual function).
    \bigbreak \noindent 
    Overuse of dynamic casting can indicate a design flaw; prefer virtual functions and polymorphism where possible.

    \bigbreak \noindent 
    \subsubsection{RTTI}
    \bigbreak \noindent 
    RTTI stands for Run-Time Type Information. It is a feature in C++ that provides mechanisms to determine the type of an object at runtime. RTTI is particularly useful in scenarios involving polymorphism, where you need to identify the actual type of an object pointed to by a base class pointer or reference.
    \bigbreak \noindent 
    RTTI relies on metadata stored by the compiler for polymorphic types (classes with at least one virtual function). This metadata includes:
    \begin{itemize}
        \item A vtable (virtual table) for each polymorphic class, which contains pointers to its virtual functions.
        \item A type\_info object for each class, which stores information about the class's type.
    \end{itemize}
    \bigbreak \noindent 
    When you use typeid or dynamic\_cast, the compiler generates code to access this metadata at runtime to determine the object's type.

    \bigbreak \noindent 
    \subsection{const\_cast}
    \bigbreak \noindent 
    const\_cast is only used to remove const or volatile qualifiers from a variable. It cannot be used to add const.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        void modify(int* ptr) {
            *ptr = 42;
        }

        int main() {
            const int x = 10;

            // Removing const
            int* ptr = const_cast<int*>(&x);

            modify(ptr); // Undefined behavior if `x` was originally a `const` object

            std::cout << "x: " << x << std::endl; // This may not reflect the change due to UB
        }
    \end{cppcode}
    \bigbreak \noindent 
    This is unsafe if x was originally declared as const int x = 10;, because modifying x leads to undefined behavior. However, if x was originally non-const and then cast to const, modifying it later using const\_cast is safe.
    \bigbreak \noindent 
    If you want to add const, you should use
    \begin{itemize}
        \item Implicit conversion
        \item static\_cast
        \item Declaring a const reference or pointer to a non-const object
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        int a = 5;
        const int* ptr = &a; // Adding const implicitly
        const int& ref = a;  // Adding const implicitly
    \end{cppcode}
    \bigbreak \noindent 
    const\_cast is useful in a few specific cases where you need to work around const qualifiers safely. 
    \bigbreak \noindent 
    \subsubsection{Modifying a non-const object that was passed as const}
    \bigbreak \noindent 
    If a function receives a const parameter but you know that the actual object is non-const, you can safely cast away const and modify it.
    \bigbreak \noindent 
    \subsubsection{Removing const to use overloaded functions}
    \bigbreak \noindent 
    Sometimes you have an overloaded function where one version accepts const and another modifies the object. const\_cast allows selecting the modifying version when needed.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Example {
            public:
            void print() {
                std::cout << "Non-const print" << std::endl;
            }

            void print() const {
                std::cout << "Const print" << std::endl;
            }
        };

        void forceModify(const Example& obj) {
            const_cast<Example&>(obj).print();  // Calls non-const version
        }

        int main() {
            Example e;
            forceModify(e);  // Calls non-const print()
        }
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{Note:} Const cast is a runtime operation and does not perform any checks

    \bigbreak \noindent 
    \subsection{reinterpret\_cast}
    \bigbreak \noindent 
    reinterpret\_cast is a type of casting operator in C++ that is used to convert one pointer type to another, even if the types are entirely unrelated. It performs a low-level reinterpretation of the underlying binary representation of the data.
    \bigbreak \noindent 
    \textbf{Note:} reinterpret\_cast is a runtime operation and does not perform any checks

    \bigbreak \noindent 
    \subsection{Why are c casts unsafe?}
    \bigbreak \noindent 
    C-style casting is unsafe and ambiguous because:
    \begin{itemize}
        \item It can perform multiple types of conversions at once, including:
            \begin{itemize}
                \item static\_cast
                \item reinterpret\_cast
                \item const\_cast
                \item Even dynamic\_cast (if a class has virtual functions)
            \end{itemize}
        \item It lacks compile-time safety—you might unintentionally use an invalid cast.
        \item It is hard to search and debug since (Type) doesn’t indicate what kind of conversion is being performed.
    \end{itemize}

    \pagebreak 
    \unsect{The compiler and functions}
    \bigbreak \noindent 
     The compiler handles functions through several stages, from parsing the source code to generating machine code. Here's an overview of how the compiler deals with functions
     \begin{enumerate}
         \item \textbf{Parsing and Syntax Analysis:} The compiler reads the source code and identifies function declarations and definitions.
             \bigbreak \noindent 
                It checks the syntax of the function, such as the return type, function name, parameter list, and body.
         \item \textbf{Semantic Analysis:} The compiler checks the meaning of the function, such as
             \begin{itemize}
                 \item Whether the function is declared before use (or has a prototype).
                 \item Whether the function parameters and return type match the function calls.
                 \item Whether the function body adheres to type rules (e.g., no invalid operations on types).
             \end{itemize}
         \item \textbf{Function Overloading Resolution:} If multiple functions with the same name exist (function overloading), the compiler determines which function to call based on the arguments provided.
         \item \textbf{Code Generation:} The compiler generates intermediate or machine code for the function body.
             \bigbreak \noindent 
            It allocates memory for local variables and parameters.
            \bigbreak \noindent 
            It generates instructions for the function's logic, such as arithmetic operations, loops, and conditionals.
         \item \textbf{Function Calls:} When a function is called, the compiler generates code to:
             \begin{itemize}
                 \item Push the arguments onto the stack (or pass them via registers, depending on the calling convention).
                 \item Transfer control to the function's code.
                 \item Save the return address so the program knows where to continue after the function finishes.
             \end{itemize}
         \item \textbf{Inlining (Optional):} If a function is marked with the inline keyword or the compiler determines it is beneficial, the compiler may replace the function call with the actual function body to avoid the overhead of a function call.
         \item \textbf{Linkage:}
             If a function is declared in one translation unit (source file) and defined in another, the compiler ensures the function is properly linked.
             \bigbreak \noindent 
            The compiler generates symbols for functions, which the linker resolves during the linking phase.
         \item \textbf{Optimization:}
             The compiler may optimize functions to improve performance, such as:
             \begin{itemize}
                 \item Removing unused code (dead code elimination).
                 \item Unrolling loops.
                 \item Inlining small functions.
                 \item Optimizing tail-recursive functions.
             \end{itemize}
     \end{enumerate}
     \bigbreak \noindent 
     When a function is called, the compiler (and the runtime environment) manages memory for local variables in a specific way
     \bigbreak \noindent 
     Local variables in a function are typically stored in the stack, a region of memory that is managed automatically by the compiler and runtime environment.
     \bigbreak \noindent 
     When a function is called, the compiler allocates memory on the stack for all of its local variables.
     \bigbreak \noindent 
     This memory is only valid for the duration of the function call. Once the function returns, the memory is deallocated (freed).
     \bigbreak \noindent 
     Each function call creates a stack frame (also called an activation record), which contains:
     \begin{itemize}
         \item The function's local variables.
         \item The return address (where the program should continue after the function finishes).
         \item The function's parameters (if any).
     \end{itemize}
    The stack grows downward in memory, and each new function call adds a new stack frame on top of the previous one.
    \bigbreak \noindent 
    When a function returns, its stack frame is deallocated, and the memory becomes available for reuse.
    \bigbreak \noindent 
    If the same function is called again, a new stack frame is created, and the local variables are allocated in the same memory region (which may have been overwritten by other function calls in the meantime).
    \bigbreak \noindent 
    Local variables have automatic storage duration, meaning they are created when the function is called and destroyed when the function returns.
    \bigbreak \noindent 
    This means that the values of local variables are not preserved between function calls.
    \bigbreak \noindent 
    constexpr variables are treated differently because they are compile-time constants.
    \bigbreak \noindent 
    The compiler evaluates constexpr variables at compile time and replaces their uses with their computed values.
    \bigbreak \noindent 
    No memory is allocated for constexpr variables at runtime—they are essentially "baked into" the code.
    \bigbreak \noindent 
    If a local variable is declared static, it has static storage duration, meaning it is allocated memory once and persists across function calls.
    \bigbreak \noindent 
    Static local variables are not stored on the stack but in a separate region of memory (typically the data segment).

    \bigbreak \noindent 
    \subsection{Important: compile time constant variables and memory (constant propagation/constant folding)}
    \bigbreak \noindent 
    When the compiler encounters a compile-time constant (e.g., a constexpr variable), it evaluates the constant expression at compile time and replaces all uses of the variable with the computed value. This means:
    \begin{itemize}
        \item \textbf{No Memory Allocation for the Variable:} Since the value of the compile-time constant is known at compile time, the compiler does not allocate memory for the variable at runtime.
            \bigbreak \noindent 
            Instead, the variable is treated like a literal value (e.g., 10, 3.14, etc.), and its value is "baked into" the generated code wherever it is used.
        \item \textbf{Replacement of Uses:} The compiler replaces every occurrence of the compile-time constant variable with its computed value.
        This process is called constant propagation or constant folding.
    \end{itemize}


    \pagebreak 
    \unsect{The introduction of the nullptr}
    \bigbreak \noindent 
    nullptr was introduced in C++11 to address several issues and improve type safety when dealing with null pointers. Prior to C++11, the standard way to represent a null pointer was to use the macro NULL, which is typically defined as 0 or ((void*)0) in C++. However, this approach had several drawbacks:
    \bigbreak \noindent 
    \subsection{Ambiguity in Overloaded Functions}
    \bigbreak \noindent 
    In C++, NULL is typically defined as 0, which is an integer. This can lead to ambiguity when overloading functions that take both integer and pointer arguments. For example
    \bigbreak \noindent 
    \begin{cppcode}
        void foo(int);
        void foo(char*);

        foo(NULL); // Which foo is called? Ambiguous, as NULL is an integer.
    \end{cppcode}
    \bigbreak \noindent 
    nullptr resolves this ambiguity because it has its own type, std::nullptr\_t, which is implicitly convertible to any pointer type but not to integral types. Thus:
    \bigbreak \noindent 
    \begin{cppcode}
        foo(nullptr); // Unambiguously calls foo(char*)
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Type safety}
    \bigbreak \noindent 
    Using 0 or NULL for null pointers can lead to type safety issues because 0 is an integer literal, and it can be implicitly converted to other types, such as bool or int. This can result in unintended behavior or bugs.
    \bigbreak \noindent 
    nullptr is a keyword that explicitly represents a null pointer, and it cannot be implicitly converted to an integer. This makes the code more type-safe and less prone to errors.
    \bigbreak \noindent 
    \subsection{The type of nullptr}
    \bigbreak \noindent 
    nullptr is of type nullptr\_t
    \bigbreak \noindent 
    \begin{cppcode}
    auto ptr = nullptr // has type nullptr\_t
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{nullptr vs void*}
    \bigbreak \noindent 
    nullptr is used to explicitly indicate that a pointer does not point to any valid memory location.
    \bigbreak \noindent 
    It has its own type, std::nullptr\_t, which is implicitly convertible to any pointer type (e.g., int*, char*, etc.) but not to other types like integers.
    \bigbreak \noindent 
    void* is a generic pointer type that can point to any data type.


    \pagebreak 
    \unsect{Brace initialization vs Parenthesized Initialization}
    \bigbreak \noindent 
    Brace initialization (also called uniform initialization or list initialization) was introduced in C++11 and has stricter rules compared to parenthesized initialization. Specifically, consider a uniform initialization of the form \texttt{type\{expr\}}
    \begin{itemize}
        \item \textbf{Prohibits narrowing conversions:} Brace initialization does not allow implicit narrowing conversions. If expr cannot be converted to Type without losing information (e.g., converting a double to an int), the compiler will emit an error.
        \item \textbf{Prevents most vexing parse:} Brace initialization avoids ambiguity with function declarations, which can occur with parenthesized initialization.
        \item \textbf{Calls constructors explicitly:} If Type has a constructor that takes an std::initializer\_list, brace initialization will prefer that constructor.
    \end{itemize}
    \bigbreak \noindent 
    If an std::initializer\_list constructor exists, it will be chosen over other constructors, even if another constructor is a better match.
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            s(int x) {cout << "1" << endl;}
            s(initializer_list<int> x) {cout << "2" << endl;}
        };
        s s1{2}; // 2
        s s2(2); // 1
    \end{cppcode}




    \bigbreak \noindent 
    Parenthesized initialization (also called direct initialization) is more permissive and allows narrowing conversions. It behaves like a function call, where the compiler attempts to convert expr to Type using implicit conversions, even if narrowing occurs.
    \bigbreak \noindent 
    Note that parenthesized initialization does call constructors
    \bigbreak \noindent 
    Since c++20, direct initialization will work for aggregate types
    \begin{align*}
        struct lattice {
            int x,y;
        };
        lattice p(10,20); // OK since c++20
    \end{align*}


    \pagebreak 
    \unsect{Are chars unsigned?}
    \bigbreak \noindent 
    In C++, the char type is neither inherently signed nor unsigned. It's implementation-defined behavior.
    \begin{itemize}
        \item char, signed char, and unsigned char are distinct types.
        \item The default behavior of char depends on the compiler. Some compilers treat char as signed char, while others treat it as unsigned char.
        \item To ensure consistent behavior, use signed char or unsigned char explicitly.
    \end{itemize}


    \pagebreak 
    \unsect{Size of types}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{bool}: 1 Byte
        \item \textbf{char}: 1 Byte
        \item \textbf{short}: 2 Bytes
        \item \textbf{int}: 4 Bytes
        \item \textbf{long}: 4 or 8 bytes
        \item \textbf{long long}: 8 bytes
        \item \textbf{float}: 4 bytes
        \item \textbf{double}: 8 bytes
        \item \textbf{long double}: 16 bytes
        \item \textbf{string}: 32 bytes
        \item \textbf{Pointers}: 8 bytes
    \end{itemize}
    \bigbreak \noindent 
    Note that the size of primitive types are usually implementation defined, and adding signed or unsigned does not change the size.
    \bigbreak \noindent 
    Also, references are the size of the type they refer to. 

    \pagebreak 
    \unsect{Trivially copyable}
    \bigbreak \noindent 
    A trivially copyable type in C++ is a type that can be copied efficiently using memcpy or similar low-level operations without breaking its correctness. This means it does not require custom copy/move constructors or destructors.
    \bigbreak \noindent 
    A class or struct is trivially copyable if:
    \begin{itemize}
        \item Can be copied with memcpy without breaking program semantics.
        \item Has no user-defined copy/move constructors, assignment operators, or destructors.
        \item Only contains trivially copyable members.
        \item Does not have virtual functions or virtual base classes.
    \end{itemize}


    \pagebreak 
    \unsect{POD types (Plain old data)}
    \bigbreak \noindent 
    POD (Plain Old Data) refers to a type in C++ that is simple, compatible with C structures, and has well-defined memory layouts. A POD type behaves like a C-style struct and lacks modern C++ features such as constructors, destructors, virtual functions, and non-trivial member functions.
    \bigbreak \noindent 
    A type is considered POD if:
    \begin{itemize}
        \item It is a trivial type (trivial constructor, destructor, copy/move operations).
        \item It is a standard-layout type (data layout matches C structs).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Trivial type}
    \bigbreak \noindent 
    A type is trivial if:
    \begin{itemize}
        \item It has a trivial default constructor (compiler-generated, does nothing).
        \item It has a trivial copy/move constructor and assignment (member-wise copying).
        \item It has a trivial destructor (compiler-generated, does nothing).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Standard layout}
    \bigbreak \noindent 
    A type is standard-layout if:
    \begin{itemize}
        \item It has no virtual functions or virtual base classes.
        \item It has only standard-layout base classes.
        \item All non-static data members have the same access control (public vs private matters).
        \item It does not inherit from multiple base classes with different access specifiers.
    \end{itemize}
    \bigbreak \noindent 
    For a C++ structure (struct or class) to match a C struct's layout, it must
    \begin{itemize}
        \item Store its members in the same order as declared.
        \item Not have hidden padding or unexpected compiler transformations.
        \item Not have virtual functions or virtual base classes.
        \item Not use complex features like multiple inheritance.
        \item Use only standard-layout types for its members.
    \end{itemize}
    \bigbreak \noindent 
    If a type is both trivial and standard-layout, it is POD.

    \pagebreak 
    \unsect{Notes about initialization}
    \bigbreak \noindent 
    \subsection{How many names does brace initialization have?}
    \bigbreak \noindent 
    \subsubsection{Uniform Initialization (General Term)}
    \bigbreak \noindent 
    Introduced in C++11, \{\} initialization is often referred to as uniform initialization because it provides a consistent syntax for initializing objects of any type.
    \bigbreak \noindent 
    Note that uniform initialization is an informal term


    \bigbreak \noindent 
    \subsubsection{List Initialization}
    \bigbreak \noindent 
    List initialization is the official term in the C++ standard for using \{\} to initialize objects.

    \bigbreak \noindent 
    \subsubsection{Aggregate Initialization}
    \bigbreak \noindent 
    When \{\} is used to initialize aggregates (structs, arrays, or classes with public members and no user-defined constructors), it's called aggregate initialization.
    \bigbreak \noindent 
    \begin{cppcode}
        struct Point {
            int x, y;
        };
        Point p = {1, 2}; // Aggregate initialization
    \end{cppcode}


    \bigbreak \noindent 
    \subsubsection{Value Initialization}
    \bigbreak \noindent 
    If \{\} is used without any elements, it results in value initialization.
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{},y{}; // Default value initialized
        };
    \end{cppcode}
    \bigbreak \noindent 
    Note that we can also do
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y
        };
        point p{}; // Construct p and default value initialize x,y
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Direct List Initialization}
    \bigbreak \noindent 
    When \{\} is used with a constructor that takes a list, it is called direct list initialization.
    \bigbreak \noindent 
    \begin{cppcode}
    std::vector<int> v{1, 2, 3}; // Direct list initialization
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Copy List Initialization}
    \bigbreak \noindent 
    When \{\} is used on the right-hand side of an assignment or in variable initialization without explicit construction, it's called copy list initialization.
    \bigbreak \noindent 
    \begin{cppcode}
    std::vector<int> v = {1, 2, 3}; // Copy list initialization
    \end{cppcode}
    
    \bigbreak \noindent 
    \subsubsection{Narrowing Prevention Initialization}
    \bigbreak \noindent 
    \{\} initialization prevents narrowing conversions, meaning it does not allow implicit type conversions that lose information.
    \bigbreak \noindent 
    \begin{cppcode}
        int x = 3.5;  // Allowed (implicit conversion)
        int y{3.5};   // Error (narrowing conversion)
    \end{cppcode}


    \bigbreak \noindent 
    \subsubsection{ Default Member Initialization}
    \bigbreak \noindent 
    \{\} can be used to initialize class members with default values.
    \bigbreak \noindent 
    \begin{cppcode}
        struct Example {
            int a = {};  // Value-initialized to 0
        };
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Copy list initialization and direct list initialization in aggregate types}
    \bigbreak \noindent 
    We note that for an aggregate type, copy list initialization and direct list initialization behave the same
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y
        };
        point p1 = {1,2};
        point p1{1,2};
    \end{cppcode}
    \bigbreak \noindent 
    For aggregates, both = (copy list initialization) and \{\} (direct list initialization) behave identically because C++ applies aggregate initialization in both cases.
    \bigbreak \noindent 
    However, if point had a user-defined constructor, then they could behave differently.
    \bigbreak \noindent 
    If we defined a constructor that takes an initializer\_list, both the above objects would call that constructor
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{},y{}; // Default value initialized

            point(std::initializer_list<int> l) {
                cout << "called init list " << endl;
            }
        };

        point p1 = {1,2}; // called init list
        point p2{1,2}; // called init list
    \end{cppcode}

    \bigbreak \noindent 
    Note that if we define a virtual method, our type becomes polymorphic and is no longer aggregate. Therefore, we cannot use either initialization above. Note however that c++ will still implicitly give us the default constructors, so the following will still work
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;

            virtual void f();
        };
        point p1{1,2} // Error
        point p2 = {1,2} // Error
        point p3{};
    \end{cppcode}
    \bigbreak \noindent 
    In this case, we need to explicitly define our constructor
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;

            point(int x, int y) : x(x), y(y) {}

            virtual void f();
        };
        point p1{1,2} 
        point p2 = {1,2} 
        point p3{};
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Other forms of initialization and their names}
    \bigbreak \noindent 
    \subsubsection{ Direct Initialization}
    \bigbreak \noindent 
    Uses the parenthesis () syntax
    \bigbreak \noindent 
    \begin{cppcode}
        int x(10);   // Direct initialization
        std::string s("hello");
    \end{cppcode}
    \bigbreak \noindent 
    Note that aggregate initialization logic  will not work with this syntax
    \bigbreak \noindent 
    \begin{cppcode}
        struct point{
            int x,y
        };
        point p(1,2) // Error! Must define the constructor.
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Copy Initialization }
    \bigbreak \noindent 
    Uses assignment =
    \bigbreak \noindent 
    \begin{cppcode}
    int x = 10;
    \end{cppcode}
    \bigbreak \noindent 
    Creates a temporary object and copies/moves it to initialize the variable. May involve implicit conversions. Calls copy constructor if the type has one.

    \bigbreak \noindent 
    \subsubsection{ Default Initialization}
    \bigbreak \noindent 
    No explicit initializer
    \bigbreak \noindent 
    \begin{cppcode}
        int x;      // Default initialization (uninitialized in local scope)
        std::string s; // Calls default constructor (empty string)
    \end{cppcode}



    % \pagebreak 
    % \unsect{Notes about destructors}
    % \bigbreak \noindent 
    % \subsection{Manual destructor calls}
    % \bigbreak \noindent 
    % Manually calling a destructor in C++ is dangerous because it can lead to undefined behavior, double destruction, and resource leaks.
    % \bigbreak \noindent 
    % If you manually call the destructor and then let the object go out of scope (or delete it via delete), the destructor will be called again, leading to a double free or use-after-free error.
    %

    \bigbreak \noindent 
    \subsection{Excess elements in scalar initialization}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        int x{1,2,3}
    \end{cppcode}
    \bigbreak \noindent 
    Results in a compilation error "excess elements in scalar initialization"
    \bigbreak \noindent 
    Further consider
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename ... Args>
    struct foo {
        int var;

        foo(Args... args) : var(args...) {}
    };
    X x(1); // fine
    X y(1,2,3); // Excess elements in scalar initialization
    \end{cppcode}



    \pagebreak 
    \unsect{Notes about constructors}
    \bigbreak \noindent 
    \subsection{Value initialized vs default initialized}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s1 {
            string s{};
            int x{};
        };

        struct s2 {
            string s;
            int x;
        };
    \end{cppcode}
    \bigbreak \noindent 
    Whats the difference? In s1, the members are explicitly initialized with \{\}
    \bigbreak \noindent 
    \begin{cppcode}
        struct s1 {
            std::string s{};  // Initializes to an empty string
            int x{};          // Initializes to 0
        };
    \end{cppcode}
    \bigbreak \noindent 
    This ensures that when an instance of s1 is created, s will be initialized to an empty string (""), and x will be initialized to 0.
    \bigbreak \noindent 
    In s2, the members are not explicitly initialized:
    \bigbreak \noindent 
    \begin{cppcode}
        struct s2 {
            std::string s;  // Default constructor of std::string initializes it to ""
            int x;          // Uninitialized, contains garbage value if not explicitly set
        };
    \end{cppcode}
    \bigbreak \noindent 
    s is fine because std::string has a default constructor that initializes it to "".
    \bigbreak \noindent 
    x, however, remains uninitialized when a default-constructed object of s2 is created, leading to an indeterminate value.







    \bigbreak \noindent 
    \subsection{What exactly is =default}
    \bigbreak \noindent 
    the = default specifier is used to explicitly declare that a special member function should be automatically generated by the compiler with its default behavior.
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            char c; 
            int x; 

            s() = default;
        };
    \end{cppcode}
    \bigbreak \noindent 
    This declares a default constructor (s()) explicitly, but it tells the compiler to generate it using the default implementation.
    \bigbreak \noindent 
    By default, the compiler-generated constructor does not initialize member variables. So, this:
    \bigbreak \noindent 
    \begin{cppcode}
    s() = default;
    \end{cppcode}
    \bigbreak \noindent 
    is equivalent to:
    \bigbreak \noindent 
    \begin{cppcode}
    s() {}  // Default constructor, does nothing
    \end{cppcode}
    \bigbreak \noindent 
    which means the members (char c; int x;) remain uninitialized when an object of s is created
    \bigbreak \noindent 
    \subsubsection{Non-POD fields}
    \bigbreak \noindent 
    =default construct (default constructor) calls default constructors of non-POD (plain-old-data) members.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str; // std::string has a default constructor
            int x;

            S() = default; // Compiler generates: S() {} (but calls std::string's constructor)
        };
    \end{cppcode}
    \bigbreak \noindent 
    The std::string member is properly initialized (since std::string has a default constructor). The int x is uninitialized.

    \bigbreak \noindent 
    \subsubsection{With copy constructors}
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S() = default;
            S(const S&) = default;  // Compiler generates: S(const S& other) : str(other.str), x(other.x) {}
        };
    \end{cppcode}
    \bigbreak \noindent 
    Generates a copy constructor that copies each member individually using their copy constructors.

    \bigbreak \noindent 
    \subsubsection{Copy Assignment}
    \bigbreak \noindent 
    Generates an assignment operator that copies each member individually.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S& operator=(const S&) = default;
        };
    \end{cppcode}
    \bigbreak \noindent 
    Equivalent to
    \bigbreak \noindent 
    \begin{cppcode}
        S& operator=(const S& other) {
            str = other.str; // Calls std::string's assignment operator
            x = other.x;     // Simply copies x
            return *this;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Move constructor}
    \bigbreak \noindent 
    Generates a move constructor that moves each member individually.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S(S&&) = default;  // Compiler generates: S(S&& other) : str(std::move(other.str)), x(other.x) {}
        };
    \end{cppcode}
    \bigbreak \noindent 
    This allows efficient moving:
    \bigbreak \noindent 
    \begin{cppcode}
        S obj1;
        S obj2 = std::move(obj1);  // Moves `str`, but leaves `x` as a copy
    \end{cppcode}
    \bigbreak \noindent 
    the move constructor does not "move" the int x. Instead, it simply copies x from the source. This is because int is a trivially copyable type, and moving it is no different from copying.

    \bigbreak \noindent 
    \subsubsection{ Move Assignment}
    \bigbreak \noindent 
    Generates a move assignment operator that moves each member individually.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S& operator=(S&&) = default;
        };
    \end{cppcode}
    \bigbreak \noindent 
    Equivalent to:
    \bigbreak \noindent 
    \begin{cppcode}
        S& operator=(S&& other) {
            str = std::move(other.str);  // Moves the string instead of copying
            x = other.x;  // Simply copies x (since int doesn't benefit from move)
            return *this;
        }
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{Destructor}
    \bigbreak \noindent 
    Generates a destructor that:
    \begin{itemize}
        \item Does nothing for fundamental types.
        \item Calls the destructors of member objects.
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            ~S() = default;  // Compiler generates: ~S() {} (but calls std::string's destructor)
        };
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Do you need to write them?}
    \bigbreak \noindent 
    In C++, the compiler will automatically generate default implementations for special member functions only if they are needed and not explicitly declared.
    \bigbreak \noindent 
    However, if you declare any of them (without defining them), the compiler will not automatically generate them. This is where = default comes in—it explicitly tells the compiler to generate the default implementation.


    \bigbreak \noindent 
    \subsection{=delete}
    \bigbreak \noindent 
    =delete does the opposite of =default... It deletes the default implementation

    \bigbreak \noindent 
    \subsection{Rule of five}
    \bigbreak \noindent 
    In C++, the Rule of Five states that if you define or explicitly delete any of the following five special member functions, you should likely define or delete all five
    \begin{itemize}
        \item Destructor
        \item copy constructor
        \item copy assignment operator
        \item move constructor 
        \item move assignment operator
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            string str{};

            s(const s& other) {
                cout << "Copy constructor called" << endl;
                str = other.str;
            }
        };
        s s1;
    \end{cppcode}
    \bigbreak \noindent 
    In this case, we get an error. When you explicitly define a copy constructor in C++, the compiler does not automatically generate the default constructor for you. This is due to the Rule of Five
    \bigbreak \noindent 
    The C++ standard states that if you declare any of the above special member functions, the compiler will not generate a default constructor for you:
    \bigbreak \noindent 
    Once you define any of these functions, the compiler assumes you want full control over object creation and copying, so it does not provide the default constructor.

    \bigbreak \noindent 
    \subsection{A confused compiler}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{};

            point (int x) : x(x) {}

            point(int&& other) {
                cout << "called second" << endl;
                x = other;
            }
        };
        point p = 20; // Error
    \end{cppcode}
    \bigbreak \noindent 
    We get "error: conversion from ‘int’ to ‘point’ is ambiguous".
    \bigbreak \noindent 
    happens because there are multiple constructors that can accept an int, and the compiler doesn't know which one to pick.
    \bigbreak \noindent 
    \begin{itemize}
        \item point(int) is a direct match for int.
        \item point(int\&\&) can accept an int as an rvalue reference.
    \end{itemize}
    The compiler does not know which one to pick, so it gives an error.
    \bigbreak \noindent 
    If we mark the first constructor explicit, we then prevent implicit conversion from int to point, and the second constructor will be the one called.
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{};

            explicit point (int x) : x(x) {}

            point(int&& other) {
                cout << "called second" << endl;
                x = other;
            }
        };
        point p = 20;
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Which constructor will be called}
    \bigbreak \noindent 
    Suppose we have
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{};

            point(const int& other) {
                cout << "called first" << endl;
                x = other;
            }

            point(int&& other) {
                cout << "called second" << endl;
                x = other;
            }
        };
        point p = 20;
    \end{cppcode}
    \bigbreak \noindent 
    Which constructor gets called? The second constructor (point(int\&\& other)) is called in this case because the literal 20 is an rvalue.
    \bigbreak \noindent 
    We have two suitable constructors, and the compiler must determine which constructor to call.
    \bigbreak \noindent 
    The compiler  deems the second as a better match than the first, because 20 is a pure rvalue. Note that if we removed the second constructor, the first would work. A constructor that takes a const reference can bind to both rvalues and lvalues.
    



    \pagebreak 
    \unsect{Notes about inheritance}
    \bigbreak \noindent 
    \subsection{Constructor chain}
    \bigbreak \noindent 
    In C++ inheritance, the constructor chain (or constructor delegation) refers to the sequence in which constructors of base and derived classes are called when an object of the derived class is created.
    \bigbreak \noindent 
    When an object of a derived class is created, the constructor of the base class runs before the constructor of the derived class.
    \bigbreak \noindent 
    If the base class has multiple levels, constructors are called in top-to-bottom order (from base to most derived).
    \bigbreak \noindent 
    If the base class does not have a user-defined constructor, the compiler provides a default constructor that is automatically invoked.
    \bigbreak \noindent 
    If the base class has a parameterized constructor, you must explicitly call it in the initializer list of the derived class.
    \bigbreak \noindent 
    \subsection{Destructor chain}
    \bigbreak \noindent 
    Destructors execute in reverse order of constructors (i.e., derived class destructor runs first, then base class destructor).

    \pagebreak 
    \unsect{Booleans under the hood: Adding two booleans}
    \bigbreak \noindent 
    In C++, bool is typically represented under the hood as an integral type, often stored as a single byte (char-sized) in memory. However, when used in expressions, bool values implicitly promote to int.
    \bigbreak \noindent 
    In C++, bool is effectively an integer type but only holds 0 (false) or 1 (true).
    \bigbreak \noindent 
    When used in an arithmetic expression, a bool value is promoted to an int.
    \bigbreak \noindent 
    This is part of the integral promotion rules in C++.
    \bigbreak \noindent 
    \begin{cppcode}
        bool b1 = 1, b2 = 1;
        cout << typeid(b1 + b2).name();
    \end{cppcode}

    \pagebreak 
    \unsect{Type Promotion}
    \bigbreak \noindent 
    Type promotion in C++ refers to the implicit conversion of smaller or lower-ranked types to larger or higher-ranked types in expressions. This ensures consistent operations without data loss.
    \begin{itemize}
        \item \textbf{Boolean Promotion:} bool converts to int (false → 0, true → 1) when used in arithmetic or bitwise operations.
        \item \textbf{Integral Promotion:} Types smaller than int (char, short, bool) promote to int if int can represent all values; otherwise, they promote to unsigned int.
    \end{itemize}
    If operands have different types, the one with the lower rank is converted to the higher-ranked type.
    \bigbreak \noindent 
    \subsection{Ranking}
    \bigbreak \noindent 
    \begin{center}
        bool $\to$ char/short $\to$ int $\to$ long $\to$ long long $\to$ float $\to$ double $\to$ long double
    \end{center}

    \pagebreak 
    \unsect{Notes about static}
    \bigbreak \noindent 
    \subsection{Static variables inside member functions}
    \bigbreak \noindent 
    Static variables inside member functions behave the same as static variables in regular functions
    \bigbreak \noindent 
    \subsection{Using instances to call static methods}
    \bigbreak \noindent 
    We note that we can use instances to call static methods using the dot notation
    \bigbreak \noindent 
    \begin{cppcode}
        struct s{
            int x = 20;
            static void f() {
                cout << "static method" << endl;
            }
        };
        s::f();

        s S;
        S.f();
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Can you make pure virtual methods static?}
    \bigbreak \noindent 
    No, you cannot

    \bigbreak \noindent 
    \subsection{Static and extern (linkage)}
    \bigbreak \noindent 
    Global variables without the use of the keyword static have external linkage. In other translation units that are compiled  with the file that has the global variable, we use the keyword \texttt{extern} to access it
    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    int x = 20;

    // File2.cpp
    extern int x; // Refers to x from file1.cpp
    \end{cppcode}
    \bigbreak \noindent 
    Declaring a global variable as static restricts its visibility to the current translation unit
    \bigbreak \noindent 
    If we declare a global variable static in on unit, we can get a separate copy in a different unit by declaring the same variable (with the same signature) and also using the keyword static
    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    static int x = 20;

    // File2.cpp
    static int x = 20; // File2 gets its own copy of x
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Using extern to declare a variable with the same name as a static variable from another translation unit}
    \bigbreak \noindent 
    If you use extern to declare a variable with the same name as a static variable from another translation unit, the linker will not find the definition of that variable, leading to a linker error (undefined reference). This is because static variables have internal linkage, meaning they are restricted to their translation unit and cannot be accessed from another file.
    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    static int x = 20;

    // File2.cpp
    extern int x; // Linker error
    \end{cppcode}
    
    \bigbreak \noindent 
    \subsubsection{Forgetting to use extern}
    \bigbreak \noindent 
    If you forget to put extern when declaring a global variable in another translation unit, the compiler will treat it as a new, separate definition rather than referring to an existing one. This can lead to multiple definition errors at the linking stage
    \bigbreak \noindent 
    \begin{cppcode}
    //  File1.cpp
    int x = 20;

    // File2.cpp
    int x; // Liner error: Multiple definition
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Forgetting to use keyword static}
    \bigbreak \noindent 
    \begin{cppcode}
        //  File1.cpp
        static int x = 20;

        // File2.cpp
        int x = 20; 
    \end{cppcode}
    \bigbreak \noindent 
    No errors for two units, file2 will simply make its own version of x with external linkage. If you add a third unit and forget to put static on that x as well, we would then get multiple definition errors.

    \bigbreak \noindent 
    \subsubsection{Constinit with extern}
    \bigbreak \noindent 
    constinit is only required in the definition (where the variable is actually allocated memory).
    \bigbreak \noindent 
    When using extern to refer to that variable in another translation unit, constinit is not necessary because extern simply tells the compiler that the variable is defined elsewhere.

    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    constinit int x = 50;

    // File2.cpp
    extern int x;
    \end{cppcode}

    \pagebreak 
    \unsect{Trying to move const objects}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            string str{};

            s() = default;

            s(const string& other) {
                cout << "Copy constructor called" << endl;
                str = other;
            }

            s(string&& other) {
                cout << "Move constructor called " << endl;

            }
        };
        const string str = "Hello";
        s s1(std::move(str));
    \end{cppcode}
    \bigbreak \noindent 
    Something interesting happens, we get \textit{"Copy constructor called"}. A constant object cannot be moved because moving modifies the source object.
    \bigbreak \noindent 
    The move constructor requires an argument of type std::string\&\& (a temporary, non-const string).
    \bigbreak \noindent 
    However, std::move(str) produces a const std::string\&\& (rvalue reference to const), which cannot be passed to the move constructor because the move constructor expects a non-const rvalue reference (string\&\&).
    \bigbreak \noindent 
    \begin{cppcode}
        s(const string& other) {   // (1) Copy constructor
            cout << "Copy constructor called" << endl;
            str = other;
        }

        s(string&& other) {        // (2) Move constructor
            cout << "Move constructor called" << endl;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Since std::move(str) produces const std::string\&\&, it cannot bind to (2) s(string\&\&), because the move constructor does not accept const.
    \bigbreak \noindent 
    Instead, s(const string\&) (the copy constructor) is selected, because it can accept a const std::string\&.
    \bigbreak \noindent 
    This is one reason why we have const in the copy constructor, if the copy constructors argument was not const, we would get an error trying to move the const object.

    \pagebreak 
    \unsect{Smart pointers in conjunction with raw ptrs}
    \subsection{Shared\_ptr with raw ptrs}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
    int x = 50;
    std::shared_ptr<int> ptr = std::make_shared<int>(50);
    \end{cppcode}
    \bigbreak \noindent 
    What happens if we do
    \bigbreak \noindent 
    \begin{cppcode}
        int* ptr2 = &(*ptr);
    \end{cppcode}
    \bigbreak \noindent 
    Will it increase the reference count? No it does not
    \bigbreak \noindent 
    \begin{cppcode}
        cout << ptr.use_count() << endl; // 1
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Unique\_ptr with raw ptrs}
    \bigbreak \noindent 
    What if we do
    \bigbreak \noindent 
    \begin{cppcode}
        std::unique_ptr<int> ptr = std::make_unique<int>(50);
        int* ptr2 = &(*ptr);
    \end{cppcode}
    \bigbreak \noindent 
    Does this even work? Yes, this works perfectly fine. *ptr dereferences the std::unique\_ptr<int>, retrieving the integer it owns. \&(*ptr) takes the address of that integer, effectively obtaining a raw pointer to the managed object.
    \bigbreak \noindent 
    If ptr2 is used only within the scope where ptr exists and is valid, it's generally fine
    \bigbreak \noindent 
    If ptr is reset or goes out of scope, ptr2 becomes a dangling pointer, leading to undefined behavior

    \pagebreak 
    \unsect{Calling delete on a nullptr}
    \bigbreak \noindent 
     Calling delete on a nullptr is perfectly safe and has no effect.
     \bigbreak \noindent 
     The delete operator first checks whether the pointer is nullptr. If the pointer is nullptr, delete does nothing and returns immediately.
     \bigbreak \noindent 
    This behavior ensures that you don’t have to explicitly check for nullptr before calling delete.

    \pagebreak 
    \unsect{Notes about short circuits}
    \bigbreak \noindent 
    Short-circuiting in C++ refers to the behavior of logical operators (&& and ||) where the second operand is not evaluated if the result of the entire expression can be determined from the first operand alone.
    \bigbreak \noindent 
    \subsection{With ands}
    \bigbreak \noindent 
    Consider the following code
    \bigbreak \noindent 
    \begin{cppcode}
        bool foo() {
            cout << "Foo" << endl;
            return false;
        }

        bool bar() {
            cout << "bar" << endl;
            return true;
        }

        if (foo() && bar()) // "Foo"
    \end{cppcode}
    \bigbreak \noindent 
    The bar function never gets called because when the foo function returns, the if statement "short-circuits" and exits. If we want to prevent short circuiting, we use a bitwise and $(\&)$
    \bigbreak \noindent 
    \begin{cppcode}
    if (foo() & bar()) // Foo\n bar
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{With ors}
    \bigbreak \noindent 
    Similarly, 
    \bigbreak \noindent 
    \begin{cppcode}
        bool foo() {
            cout << "Foo" << endl;
            return true;
        }

        bool bar() {
            cout << "bar" << endl;
            return true;
        }

        if (foo() || bar()) // Foo
    \end{cppcode}
    \bigbreak \noindent 
    We again just get "Foo". When the foo function returns true, the if statement is automatically true and again we get a short circuit, which leads to bar never getting called.  If we want to prevent short circuiting with ors, we use bitwise or (|)
    \bigbreak \noindent 
    \begin{cppcode}
    if (foo() | bar()) // Foo\n bar
    \end{cppcode}

    \pagebreak 
    \unsect{Notes about types}
    \bigbreak \noindent 
    \begin{itemize}
        \item bool
        \item char (unsigned and signed)
        \item short (unsigned and signed)
        \item int (unsigned and signed)
        \item long (unsigned and signed)
        \item long long (unsigned and signed)
    \end{itemize}

    \pagebreak 
    \unsect{Notes about inline functions}
    \bigbreak \noindent 
    Recall that an inline function in C++ is a function that is expanded in place where it is called, rather than executing a traditional function call. This is a compiler directive that can reduce function call overhead and potentially improve performance.
    \bigbreak \noindent 
    When a function is declared as inline, the compiler replaces the function call with the actual function definition (code) at compile time. This eliminates the overhead of a function call, such as:
    \begin{itemize}
        \item Pushing arguments onto the stack.
        \item Jumping to the function's memory location.
        \item Returning to the caller.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Advantages:}
    \begin{itemize}
        \item \textbf{Eliminates Function Call Overhead}: Since the function code is directly inserted at the call site, there is no function call overhead.
        \item \textbf{Faster Execution}: If the function is small, inlining can make the program faster.
        \item \textbf{Useful for Small, Repeated Functions}: It is particularly useful for small functions that are frequently called (e.g., getter functions in classes).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Disadvantages}:
    \begin{itemize}
        \item \textbf{Increased Binary Size (Code Bloat)}: If a function is large and used in multiple places, its repeated expansion increases the binary size.
        \item \textbf{Decreased Cache Efficiency}: More inline code means a larger executable, which may lead to poor instruction cache performance.
    \end{itemize}
    \bigbreak \noindent 
    Note that inlining is a suggestion, not a command, The compiler may ignore the inline keyword if the function is too complex.

    \bigbreak \noindent 
    \subsection{Inline functions in the context of multiple translation units}
    \bigbreak \noindent 
    In C++, a program can consist of multiple translation units, where each source file (.cpp) and its included headers form a separate unit compiled independently before linking. Using inline functions across multiple translation units can help avoid multiple definition errors.
    \bigbreak \noindent 
    When defining a function in a header file (.h), multiple source files (.cpp) including the header may result in multiple definitions of the function
    \bigbreak \noindent 
    When compiled separately and linked together, the linker will complain about multiple definitions of square(int) because each translation unit includes its own separate copy.
    \bigbreak \noindent 
    The inline keyword tells the compiler that multiple identical definitions of the function are allowed across translation units, and they should be merged.
    \bigbreak \noindent 
    Normally, functions with external linkage (int square(int)) violate the One Definition Rule (ODR) when included in multiple translation units.
    \bigbreak \noindent 
    Marking the function inline allows the linker to consolidate multiple instances into one.
    \bigbreak \noindent 

    \pagebreak 
    \unsect{Notes about object creation}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A{
            A() { cout << 'a'}
            ~A() { cout << 'A'}
        };

        struct B {
            B() {cout << 'b'}
            ~B() {cout << 'B'}
            A a;
        };

        int main() {B b;} // abBA
    \end{cppcode}
    \bigbreak \noindent 
    Member variables are initialized before the constructor is called. The destructor is called before member variables are destroyed.


    \pagebreak 
    \unsect{What is a "function signature"}
    \bigbreak \noindent 
    a function signature refers to the combination of components that uniquely identify a function within a given scope. However, different contexts use "function signature" to mean slightly different things.
    \bigbreak \noindent 
    When the compiler determines whether two functions are overloaded (i.e., different functions in the same scope), it considers:
    \bigbreak \noindent 
    \begin{itemize}
        \item Function name
        \item Parameter types (including order and const qualifiers on parameters)
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Function Signature (Overriding Perspective)}
    \bigbreak \noindent 
    When dealing with function overriding in a derived class, the function signature must exactly match the base class function's:
    \begin{itemize}
        \item Function name
        \item Parameter types (including order and const/reference qualifiers)
        \item const qualifier (for member functions)
        \item Volatile qualifier (volatile if present)
        \item Ref-qualifier (\& or \&\&)
    \end{itemize}

    \bigbreak \noindent 
    \subsection{What is NOT Part of a Function Signature? }
    \bigbreak \noindent 
    The following do not contribute to a function’s signature:
    \begin{itemize}
        \item \textbf{Return type}: Functions cannot be overloaded solely by differing return types.
        \item \textbf{Default arguments}: Default arguments are resolved at compile time, so they are not part of the function signature.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Note:} Even if parameter types are aliased, they resolve to the same type and do not create a different signature.

    \bigbreak \noindent 
    \subsection{noexcept?}
    \bigbreak \noindent 
    The noexcept specifier is part of the function signature for function overloading but not for overriding.








    





    
\end{document}
