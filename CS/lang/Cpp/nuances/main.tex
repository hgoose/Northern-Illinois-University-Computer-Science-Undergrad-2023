\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Cpp Nuances}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Cpp Nuances}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Converting char to std::string}
    \bigbreak \noindent 
    Suppose we have a char variable, and we need to "convert" it to a string. To do this we use the string class constructor, which has two parameters, the size of the string to create, and the character to use as the fill.
    \bigbreak \noindent 
    \subsection{Constructor signature}
    \bigbreak \noindent 
    \begin{cppcode}
    string(size_t n, char x) 
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    char c = 'a';
    string s(1,c);
    \end{cppcode}

    \pagebreak 
    \unsect{std::string::npos}
    \bigbreak \noindent 
    \begin{concept}
        In C++, std::string::npos is a static member constant value with the greatest possible value for an element of type size\_t. This value, when used as the length in string operations, typically represents "until the end of the string." It is often used in string manipulation functions to specify that the operation should proceed from the starting position to the end of the string, or until no more characters are found.
    \end{concept}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    string infix = buffer.substr(index + 2, string::npos);
    \end{cppcode}
    \bigbreak \noindent 
    std::string::npos is defined as the maximum value representable by the type size\_t. This value is typically used to signify an error condition or a not-found condition when working with strings and other sequence types. However, when used as a length argument in methods like std::string::substr, it effectively becomes a directive to process characters until the end of the string. This is because any attempt to access beyond the end of the string would exceed the string's length, and the methods are designed to stop processing at that point.

    \pagebreak 
    \unsect{Narrowing}
    \bigbreak \noindent 
    Narrowing happens when:
    \begin{itemize}
        \item A value of a larger or more precise type is converted to a smaller or less precise type (e.g., double to int, int to char).
        \item A floating-point value is converted to an integer type.
        \item An integer value is converted to a smaller integer type (e.g., int to short) and does not fit within the destination type's range.
    \end{itemize}

    \pagebreak 
    \unsect{Aggregate types}
    \bigbreak \noindent 
    Aggregate types in C++ are simple data structures that hold collections of values and have minimal additional behavior. They are essentially "plain old data" structures that are easy to initialize and manipulate. The term "aggregate" is formally defined by the C++ standard.
    \bigbreak \noindent 
    A class, struct, or union is considered an aggregate if it satisfies all of the following conditions:
    \begin{enumerate}
        \item No User-Defined Constructors: It must not have any explicitly declared constructors (including default, copy, or move constructors).
        \item No Private or Protected Non-Static Data Members: All non-static data members must be public.
        \item No Virtual Functions: It must not have any virtual functions.
        \item No Base Classes: It must not inherit from another class or struct.
        \item No Virtual Base Classes: It must not use virtual inheritance.
    \end{enumerate}
    \bigbreak \noindent 
    For example
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;
        };
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Aggregate initialization}
    \bigbreak \noindent 
    Aggregate initialization in C++ refers to a special form of initialization for aggregate types using an initializer list enclosed in \{\} braces. This allows you to directly specify values for the members of an aggregate type in the order they are declared.
    \bigbreak \noindent 
    Each member of the aggregate is initialized with the corresponding value provided in the initializer list. The order of values in the initializer list must match the declaration order of members in the aggregate.
    \bigbreak \noindent 
    If fewer values are provided in the initializer list than there are members in the aggregate, the remaining members are value-initialized (e.g., zero-initialized for fundamental types).
    \bigbreak \noindent 
    If the type is not an aggregate (e.g., has a user-defined constructor, private members, or virtual functions), aggregate initialization cannot be used.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;
        };

        S s = {1,2};
    \end{cppcode}
    \bigbreak \noindent 
    Consider the next example,
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;

            S(int x, int y) : x(x), y(y) {}
        };
         
        S s = {1,2}; // Works fine
    \end{cppcode}
    \bigbreak \noindent 
    Since the class $S$ has a user-defined constructor, it is no longer an aggregate type.
    \bigbreak \noindent 
    Aggregate initialization is not applicable here. Instead, C++ checks for constructors that match the initializer list \{1, 2\}.
    \bigbreak \noindent 
    Since it found one, the compiler interprets it as calling the constructor S(int x, int y) with the arguments 1 and 2.
    \bigbreak \noindent 
    In modern C++ (C++11 and later), brace-enclosed initialization is often used for uniform initialization.
    \bigbreak \noindent 
    If a constructor is available that matches the initializer list, it is called.

    \bigbreak \noindent 
    \subsection{Narrowing is not allowed in aggregate-initialization from an initializer list}
    \bigbreak \noindent 
    The error "narrowing is not allowed in aggregate-initialization from an initializer list" occurs in C++ when you try to initialize an aggregate type (e.g., structs, arrays, or classes with no user-defined constructors) using values in an initializer list, but the values undergo an implicit narrowing conversion that could lose information or precision.
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            int x;
            float y;
        };

        A a = {1, 3.14}; // OK, no narrowing
        A b = {1, 3.14f}; // OK, no narrowing (3.14f is a float literal)

        A c = {1, 3.14}; // ERROR: narrowing from `double` to `float`
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{implicit conversion using a single-argument constructor}
    \bigbreak \noindent 
     A constructor that takes one argument can be used for implicit conversion of that argument type to the class type.
     \bigbreak \noindent 
     \begin{cppcode}
     struct s {
         int x;
         s(int value) : x(value) {} // Single-argument constructor
     };
     s s1 = 1;
 \end{cppcode}
 \bigbreak \noindent 
 The integer 1 is implicitly converted to an object of type s using the s(int value) constructor.
 \bigbreak \noindent 
 By default, a single-argument constructor allows implicit conversions. If you want to prevent implicit conversions and require explicit construction, you can use the explicit keyword
 \bigbreak \noindent 
 \begin{cppcode}
     struct s {
         int x;
         explicit s(int value) : x(value) {}
     };

     int main() {
         s s1 = 1; // ERROR: Explicit constructor prevents implicit conversion
         s s2(1);  // OK: Direct initialization
     }
 \end{cppcode}





    \pagebreak 
    \unsect{Floating point literals}
    \bigbreak \noindent 
    Floating point literals in c++ will be of type double. For example,
    \bigbreak \noindent 
    \begin{cppcode}
    cout << typeid(4.09).name(); // d
    \end{cppcode}
    \bigbreak \noindent 
    Append $f$ to the literal to make it a float
    \bigbreak \noindent 
    \begin{cppcode}
        cout << typeid(4.09f).name(); // d
    \end{cppcode}

    \pagebreak 
    \unsect{Size of structs and classes}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { }
        cout << sizeof(s) << endl; // 1

        s s1;
        cout << sizeof(s1) << endl; // 1
    \end{cppcode}
    \bigbreak \noindent 
    Notice that empty structs do not have a size of zero. Empty structs have a size of one byte. 
    \bigbreak \noindent 
    A size of zero for a struct would mean that it occupies no memory. If multiple instances of such a struct are created, they would have no unique memory location to occupy. As a result, the compiler would assign the same memory address to all instances, which would violate fundamental rules of object-oriented programming in C++.
    \bigbreak \noindent 
    Furthermore, giving fields to the struct or class increases the size of that struct or class by size of the type. 
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { int x; }
        cout << sizeof(s); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Notice that the size is \textbf{not} 5. Creating functions and creating variables in those functions does not add to the size
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            void f()  {
                int  x;
            }
        }
        cout << sizeof(s); // 1
    \end{cppcode}
    \bigbreak \noindent 
    Creating structs inside structs and even adding fields to the inner structs does not increase the size
    \bigbreak \noindent 
    \begin{cppcode}
    struct s {
        struct k { int x; };
    };

    cout << sizeof(s); // 1
    cout << sizeof(s::k); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Lastly, constructors and destructors do not increase the size.
    \bigbreak \noindent 
    It seems only fields increase the size.

    \bigbreak \noindent 
    \subsection{Padding}
    \bigbreak \noindent 
    Consider the following struct
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            char c; // 1 byte
            int x; // 4 bytes
        };
        cout << sizeof(s) << endl; // 8
    \end{cppcode}
    \bigbreak \noindent 
    Notice that we do not get a size of 5. In C++, padding is introduced by the compiler to ensure proper memory alignment of data members. This improves performance on most hardware architectures. The first member, char $c$, occupies 1 byte. The next member, int $x$, requires 4 bytes and should be aligned to a 4-byte boundary (on most systems). To achieve this alignment, 3 bytes of padding are added after c before x starts.

    \pagebreak 
    \unsect{When is trailing return type useful}
    \bigbreak \noindent 
    \subsection{Decltype on template parameters}
    \bigbreak \noindent 
    Suppose we had two template types $T,U$, and a function that accepts $T a, U b$. Suppose we wanted the return type to be the type of $T + U$, we could of course just write
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        decltype(T{} + U{}) f(T a, U b) {
            return a + b; 
        }
    \end{cppcode}
    \bigbreak \noindent 
    Or, we could utilize a trailing return
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T, typename U>
    auto f(T a, U b) -> decltype(a+b) {
        return a + b; 
    }
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Nested structs}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            struct B {};

            B f() const;
        };

        A::B A::f() const { }
    \end{cppcode}
    \bigbreak \noindent 
    Instead of having to use the scope resolution operator, we could use a trailing return type.
    \bigbreak \noindent 
    \begin{cppcode}
        auto A::f() const -> B {

        }
    \end{cppcode}
    \bigbreak \noindent 
    By using a trailing return type, we are essentially inside the scope of $A$ by the time we specify the return type.

    \pagebreak 
    \unsect{Most vexing parse}
    \bigbreak \noindent 
    The most vexing parse is a phenomenon in C++ where a line of code that looks like a variable declaration is instead interpreted by the compiler as a function declaration. This often happens because of C++'s ambiguous grammar for declarations.
    \bigbreak \noindent 
    \begin{cppcode}
    std::string s(); // Treated as a function declaration
    \end{cppcode}
    \bigbreak \noindent 
    This will not be treated as a default constructed string by the C++ compiler, but instead as a function declaration. To fix this issue, we instead use brace initialization
    \bigbreak \noindent 
    \begin{cppcode}
        std::string s{} // A default string variable
    \end{cppcode}

    \pagebreak 
    \unsect{Notes about copy constructors}
    \bigbreak \noindent 
    The copy constructor in C++ typically takes a const reference (const T\&) to ensure correctness and efficiency. If the copy constructor took its parameter by value, this would require making a copy of other before calling the constructor itself. But that copy itself would require calling the copy constructor, leading to infinite recursion until a stack overflow.
    \bigbreak \noindent 
    If the copy constructor took a non-const reference, this would not allow copying from const objects.
    \bigbreak \noindent 
    Since a copy operation should not modify the original object, using const ensures the copy constructor can be called for const objects.
    \bigbreak \noindent 
    Recall that functions (and methods) that take a const reference insure that the function can be called on both const objects and non-const objects. Functions that take non-const references can only accept non-const objects.
    \bigbreak \noindent 
    As a quick side note, since we are on the topic of const correctness, recall that constant member functions cannot call non-const member functions.

    \bigbreak \noindent 
    \subsection{Copy constructors in inheritance}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            A() { cout << "default" << endl; }
            A(const A& other) { cout << "other" << endl; }
        };

        struct B : A {
            B() { cout << "default" << endl; }
            B(const B& other) { cout << "other" << endl; }
        };
        B b;
        B b2(b);
        // Default
        // Default
        // Default
        // Other
    \end{cppcode}
    \bigbreak \noindent 
    So why isn't \texttt{B b2(b)} calling A's copy constructor?
    \bigbreak \noindent 
    When you write the copy constructor for class B without an initializer list for the base class A, the base class part of B is default-constructed by default
    \bigbreak \noindent 
    Since there is no initializer list here, A is constructed using its default constructor (which prints "default") rather than its copy constructor. To have A's copy constructor called when copying a B object, you need to explicitly initialize the A subobject using A(other) in B’s copy constructor, like so:
    \bigbreak \noindent 
    \begin{cppcode}
    B(const B& other) : A(other) { cout << "other" << endl; }
    \end{cppcode}
    \bigbreak \noindent 
    This change ensures that when you copy a B object, the A part is also copied (using A's copy constructor), and the output would reflect that.
    \bigbreak \noindent 
    As it turns out, an implicitly-defined copy constructor would have called the copy constructor of its bases "The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move of its bases and members"). But when you provide a user-defined copy constructor, this is something you have to do explicitly


    \pagebreak 
    \unsect{Exceptions during a call to new}
    \bigbreak \noindent 
    When using raw pointers, an exception occurring after a new allocation leads to a resource leak if the allocated memory is not properly managed. This happens because new dynamically allocates memory on the heap, but if an exception interrupts execution before delete is called, the allocated memory remains unreachable and never freed.
    \bigbreak \noindent 
    To prevent this, use smart pointers (std::unique\_ptr or std::shared\_ptr), which automatically manage memory and clean up even if an exception occurs.
    \bigbreak \noindent 
    However, it is true that using std::unique\_ptr and std::shared\_ptr does not guarantee that there will be no resource leaks if they are not used properly. Specifically, passing new directly to their constructors can still lead to resource leaks in certain cases. This is why std::make\_unique and std::make\_shared are preferred
    \bigbreak \noindent 
    make\_shared performs a single allocation that stores both the object and the control block together. If an exception occurs, no memory leak happens because allocation and ownership setup happen in one step.
    \bigbreak \noindent 
    Same is true for make\_unique
    \bigbreak \noindent 
    \subsection{Exceptions during constructors}
    \bigbreak \noindent 
    If a call to new results in an exception, the object is never allocated.
    When you use new, the operator first tries to allocate memory by calling operator new(size), which is similar to malloc.
    \bigbreak \noindent 
    If memory allocation is successful, the constructor of the object is called.
    \bigbreak \noindent 
    If there isn't enough memory, operator new will throw a std::bad\_alloc exception (unless you use nothrow new, which returns nullptr)
    \bigbreak \noindent 
    If memory allocation succeeds but the constructor of the object throws an exception, the allocated memory is automatically freed, so there is no memory leak. If an exception is thrown in the constructor after memory has been allocated but before construction is complete, the C++ runtime ensures that the allocated memory is automatically freed. This is done by:
    \begin{itemize}
        \item Catching the exception inside the new operator.
        \item Calling operator delete(ptr) to deallocate the memory.
    \end{itemize}

    \pagebreak 
    \unsect{Notes about polymorphism}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };
        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base* o) {
            o->print();
        }

        void f(const base& o) {
            o.print();
        }

        derived d1;
        base& b1 = d1;

        f(b1);

        base* d = new derived();
        f(d);

        delete d;
    \end{cppcode}
    \bigbreak \noindent 
    We get the output
    \bigbreak \noindent 
    \begin{cppcode}
        Derived
        Cleaned up derived
        Cleaned up base
    \end{cppcode}
    \bigbreak \noindent 
    The reason both destructor messages ("Cleaned up derived" and "Cleaned up base") are printed when you call delete d; is due to polymorphic destruction.
    \bigbreak \noindent 
    The base class has a virtual destructor (virtual $\sim$base()). This ensures that when an object is deleted through a pointer to base, the destructor of the derived class will also be invoked before the base destructor.
    \bigbreak \noindent 
    $d$ is deleted, and because base has a virtual destructor, the destructor call correctly cascades down the inheritance chain:
    \begin{itemize}
        \item First, $\sim$derived() runs and prints "Cleaned up derived".
        \item Then, $\sim$base() runs and prints "Cleaned up base".
    \end{itemize}
    \bigbreak \noindent 
    If the destructor in base wasn't virtual, deleting a derived object through a base* pointer would cause undefined behavior (likely only $\sim$base() would be called, leading to memory leaks).
    \bigbreak \noindent 
    If base has fields (member variables), whether directly inherited by derived or not, the base destructor must be called to clean up those fields properly when a derived object is deleted.

    \bigbreak \noindent 
    \subsection{Polymorphism with arrays and slicing}
    \bigbreak \noindent 
    \subsubsection{Object Slicing}
    \bigbreak \noindent 
    Object slicing occurs when an object of a derived class is assigned to a variable of a base class type, causing the derived part of the object to be "sliced off", leaving only the base class portion.
    \bigbreak \noindent 
    Slicing occurs when 
    \begin{itemize}
        \item A derived object is assigned to a base class object (not a pointer or reference).
        \item A derived object is stored in a container of base class objects (e.g., an array of base objects).
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            int x{1};

        };
        struct derived : base {
            int y{5};
        };

        base b = derived{};
        // Error, no member named y in base
        cout << b.x << endl << b.y;
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Polymorphism with arrays}
    \bigbreak \noindent 
    Consider the following code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };

        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base& o) {
            o.print();
        }

        auto main(int argc, const char* argv[]) -> int {
            base* barr = new derived[5];

            delete[] barr;

            return EXIT_SUCCESS;
        }
    \end{cppcode}
    \bigbreak \noindent 
    barr is declared as base*, but the memory actually holds derived objects. When delete[] barr; is called, C++ treats barr as an array of base objects, not derived objects. This breaks proper destructor calls, leading to undefined behavior.
    \bigbreak \noindent 
    Even though base has a virtual ~base(), the problem is not about virtual dispatch. Instead, it's about how C++ tracks array allocations.
    \bigbreak \noindent 
    The array of derived objects was allocated using new derived[5], but delete[] barr; doesn’t have enough information to correctly call derived destructors.
    \bigbreak \noindent 
    When delete[] barr; is called, C++ sees a base* pointer and assumes it points to an array of base objects.
    \bigbreak \noindent 
    Instead we either,
    \begin{cppcode}
        derived* darr = new derived[n]
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        vector<unique_ptr<base>> v(5);
        for (auto& item : v) {
            item = make_unique<derived>();
        }

        // Or the standard approach
        vector<base*> v2(5);
        for (auto& item : v2) {
            item = new derived();
        }

        for (auto& item : v2) {
            delete item;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Runtime polymorphism, dynamic dispatch, dynamic binding,  and the vtable}
    \bigbreak \noindent 
    Runtime polymorphism in C++ is achieved through function overriding and is implemented using virtual functions in an inheritance hierarchy. It allows a derived class to provide a specific implementation of a function that is already defined in its base class.
    \bigbreak \noindent 
    \subsubsection{Dynamic dispatch and dynamic binding}
    \bigbreak \noindent 
    Dynamic dispatch is a mechanism where the function to be executed is determined at runtime, rather than at compile-time. This is a key feature of runtime polymorphism and is enabled by virtual functions in C++
    \bigbreak \noindent 
    When a virtual function is declared in a base class and overridden in a derived class, C++ does not resolve function calls at compile-time.
    \bigbreak \noindent 
    Instead, when a function is called using a base class pointer/reference, C++ performs a runtime lookup to determine which function to execute.
    \bigbreak \noindent 
    This lookup is performed using the VTable (Virtual Table) and VPtr (Virtual Pointer) mechanism.
    \bigbreak \noindent 
    As a side note, the following will not work
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            consteval virtual int print() const {
                return 12;
            }

            virtual ~foo() {}
        };

        struct bar : foo {
            consteval int print() const override {
                return 0;
            }
        };

        foo* f = new bar{};
        constexpr int x = f.print();
    \end{cppcode}
    \bigbreak \noindent 
    The issue is that since the print functions are determined and called at runtime, it cannot be a compile time constant expression. We get the error "The value of $f$ is not usable in a constant expression"
    \bigbreak \noindent 
    Dynamic binding (also called late binding) is the underlying mechanism that allows dynamic dispatch to work. It refers to the process of determining which function implementation should be executed at runtime, rather than at compile time.
    \bigbreak \noindent 
    Binding refers to associating a function call with a function definition. Dynamic binding means this association happens at runtime, based on the actual type of the object.
    \bigbreak \noindent 
    Dynamic binding ensures that when a function is called on a base class pointer/reference, the correct overridden function from the derived class is invoked at runtime. Dynamic dispatch is the result of dynamic binding


    \bigbreak \noindent 
    \subsubsection{The Vtable}
    \bigbreak \noindent 
    C++ implements runtime polymorphism using a VTable (Virtual Table) and a VPointer (VPtr)
    \bigbreak \noindent 
    A VTable is a table of function pointers maintained per class. It stores pointers to the virtual functions defined in a class. Each class with virtual functions has a single VTable.
    \bigbreak \noindent 
    Each object of a class that has virtual functions contains a hidden pointer, called VPtr (Virtual Pointer). VPtr points to the VTable of that particular class.
    \bigbreak \noindent 
    During runtime, when a virtual function is called via a base class pointer, the VPtr is used to look up the correct function implementation in the VTable.
    \bigbreak \noindent
    When the program starts, the compiler creates a VTable for every class that has virtual functions. Every object of such a class gets a hidden VPtr, which points to the corresponding VTable.
    \bigbreak \noindent 
    When a virtual function is called using a base class pointer, the call is resolved dynamically by checking the VTable.
    \bigbreak \noindent 
    The VTable (Virtual Table) is created at compile time, but the VPtr (Virtual Pointer) is assigned and used at runtime.
    \bigbreak \noindent 
    The VTable itself is constructed at compile time, meaning the compiler generates and lays out the function pointers in the table before the program runs.
    \bigbreak \noindent 
    The VPtr is assigned at runtime, when an object of the class is created.
    \bigbreak \noindent 
    Because having virtual functions in our struct / class requires this VPtr to be created, having virtual functions therefore will increase the size of the struct and the objects created by the size of a pointer (8 bytes on 64-bit systems or 4 bytes on 32-bit systems).

    \bigbreak \noindent 
    each class in the inheritance hierarchy that has at least one virtual function has its own vtable.
    \begin{itemize}
        \item A base class with virtual functions has a vtable that stores pointers to its virtual functions.
        \item A derived class that overrides any virtual functions gets its own vtable, which replaces the base class’s function pointers with the derived class’s implementations.
        \item The vtable is associated with a class, not individual objects.
        \item Each object of a class with virtual functions has a vptr (virtual table pointer) that points to the vtable of its actual type.
    \end{itemize}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            virtual void print() const {
                cout << "Foo" << endl;
            }

            virtual ~foo() {}
        };

        struct bar : foo {
            void print() const override {
                cout << "Bar" << endl;
            }
        };
    \end{cppcode}
    \bigbreak \noindent 
    Since foo has virtual functions (print and the destructor), it will have a vtable.
    \begin{center}
        \begin{tabular}{p{4cm}|p{4cm}} 
            Index	&Function Pointer \\
            \hline
            0	&foo::print() \\
            1	&foo::$\sim$foo() (destructor) 
        \end{tabular}
    \end{center}
    \bigbreak \noindent 
    Every instance of foo has a vptr (virtual table pointer) pointing to this table.
    \bigbreak \noindent 
    Since bar overrides print(), but still inherits the virtual destructor from foo, its vtable will have the overridden version of print().
    \begin{center}
        \begin{tabular}{p{4cm}|p{4cm}}
            Index	&Function Pointer \\
            0	&bar::print() \\
            1	&foo::$\sim$foo() (inherited destructor) 
        \end{tabular}
    \end{center}
    \bigbreak \noindent 
    Each instance of bar will have its vptr pointing to vtable for bar.
    \bigbreak \noindent 
    \begin{cppcode}
        int main() {
            foo* obj = new bar();
            obj->print();  // Calls bar::print() because vptr points to bar's vtable
            delete obj;    // Calls foo::~foo() due to virtual destructor
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Can you call pure virtual methods}
    \bigbreak \noindent 
    You cannot instantiate abstract classes. Thus, you cannot call pure virtual methods

    \bigbreak \noindent 
    \subsection{Do the signatures need to exactly match on overridden functions}
    \bigbreak \noindent 
    Yes, the function signature must exactly match the base class function (including return type, parameters, and const qualifiers). If the signature differs in any way, the function in the derived class will be considered a new, independent function rather than an override.

    \bigbreak \noindent 
    \subsection{What happens if you forget the keyword virtual on base class methods}
    \bigbreak \noindent 
    Consider
    \bigbreak \noindent 
    \begin{cppcode}
        struct s{
            void print() const & {cout << "Base" << endl;}
        };

        struct k : s{
            virtual void print() const & override {cout << "Derived" << endl;}
        };
    \end{cppcode}
    \bigbreak \noindent 
    We get a compiler error \textit{print marked override but does not override any member functions}

    \bigbreak \noindent 
    \subsection{Do you need the keyword virtual on overridden methods?}
    \bigbreak \noindent 
    In the derived class, you do not need to explicitly write virtual again when overriding, though you can include it for clarity.

    \bigbreak \noindent 
    \subsection{What happens if you forget the override}
    \bigbreak \noindent 
    forgetting to put the override keyword when overriding a base class member function has the following consequences
    \bigbreak \noindent 
    The code will still compile, but if the function signature does not exactly match the base class function, you might accidentally create a new function in the derived class instead of overriding the base function.
    \bigbreak \noindent 
    If the function signature is incorrect (e.g., different return type, wrong parameters, or missing const qualifier), the base class function is hidden instead of being overridden. This means
    \begin{itemize}
        \item Calls to the function through a base class pointer/reference will not invoke the derived class function as intended.
        \item Instead, the base class implementation will be called, leading to unexpected behavior.
        \item If the function in the derived class has a different parameter list, the base class function can only be accessed using Base::functionName(...).
    \end{itemize}
    \bigbreak \noindent 
    The override keyword forces the compiler to check whether the function actually overrides a virtual function from the base class. Without it, if the base class function signature changes, the derived class function may silently stop overriding it, leading to subtle runtime errors.
    \bigbreak \noindent 
    \begin{cppcode}
    struct A {
        virtual void print() const {cout <<  "A"; }
    };

    struct B : A {
        virtual void print() {cout << "B";}
    };

    A* b = new B;
    b->print(); // A

    delete b;
    \end{cppcode}
    \bigbreak \noindent 
    We forgot the override keyword, which  would be fine as long as the function signatures still matched exactly, but notice that we also forgot the mark B's print const. Thus, B's print method does not override A's, and it is an independent function. Therefore, B's VTable remains
    \bigbreak \noindent 
    \begin{center}
        \begin{tabular}{c|c}
            Index & fn \\
            \hline 
            0 & A::print()
        \end{tabular}
    \end{center}
    Ie it does not get overridden. If we marked B's print with override, it would give a compiler error since the signatures don't match

    \bigbreak \noindent 
    \subsection{Overrides with default args}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            virtual void print(int x=5) const {cout <<  "A" << x; }
        };

        struct B : A {
            virtual void print(int x=10) const override {cout << "B" << x;}
        };

        A* b = new B;
        b->print(); // B5

        delete b;
        \end{cppcode}
        \bigbreak \noindent 
        So B's print gets called, but we get the default arg from A?
        \bigbreak \noindent 
        Since print() is virtual, dynamic dispatch occurs. The runtime determines that B::print() should be executed, not A::print().
        \bigbreak \noindent 
        However, default arguments are resolved at compile time, based on the static type of the pointer.
        \bigbreak \noindent 
        The call b->print(); is interpreted at compile time as
        \bigbreak \noindent 
        \begin{cppcode}
        b->print(5); // Because `b` is an `A*`, it uses A's default argument
        \end{cppcode}

    \bigbreak \noindent 
    \subsection{Private and public with polymorphism}
    \bigbreak \noindent 
    Recall that for a struct $S$
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
        private: 
            void print() {}
        };

        S s;
        s.print() // Error: Print is private
    \end{cppcode}
    \bigbreak \noindent 
    We cannot call private methods through an object. However, consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {cout << "Base" << endl;}
        };

        struct derived : base{
            private:
            void print() const override {cout << "Derived" << endl;}
        };
        base* b = new derived{};
        b->print(); // "Derived"
    \end{cppcode}
    \bigbreak \noindent 
    So why does this work? Why are we able to call this private method?
    \bigbreak \noindent 
    In C++, access control (private, protected, public) is enforced at compile time and is based on the class from which the call is made. However, when using dynamic dispatch (i.e., calling a virtual function through a base class pointer), the actual function that gets invoked is determined at runtime via the vtable mechanism, which is independent of access control.

    \bigbreak \noindent 
    \subsection{Virtual methods are implicitly inline}
    \bigbreak \noindent 
    In C++, virtual methods are implicitly considered inline by the compiler, but this doesn't mean they are always inlined at runtime.
    \bigbreak \noindent 
    The inline keyword in C++ does not necessarily mean "replace the function call with its body" (though that is one possible effect). Instead, it has two key meanings:
    \begin{itemize}
        \item \textbf{Allows multiple definitions across translation units}:
        \begin{itemize}
            \item Normally, a function or method definition must appear in only one .cpp file (ODR - One Definition Rule).
            \item An inline function can be defined in multiple translation units as long as all definitions are identical.
        \end{itemize}
        \item \textbf{Hints for compiler optimization}: The compiler may replace calls to an inline function with its body (but this is not guaranteed).
    \end{itemize}
    \bigbreak \noindent 
    Virtual Methods Are Typically Defined in Header Files
    \bigbreak \noindent 
    \begin{itemize}
        \item Virtual methods must be known at compile-time to construct the vtable (virtual table) correctly.
        \item Because virtual methods are often declared in a class definition (inside a header file), they must be allowed in multiple translation units.
        \item Making them implicitly inline prevents ODR violations when the class is included in multiple .cpp files.
    \end{itemize}
    \bigbreak \noindent 
    The primary reason for marking functions inline to avoid ODR (One Definition Rule) violations applies to functions defined in header files that are included in multiple translation units.
    \bigbreak \noindent 
    Normally, if you define a function in a header file, and that header is included in multiple .cpp files, you would get multiple definitions of the same function when linking.
    \bigbreak \noindent 
    Marking the function inline tells the compiler that all definitions of the function in different translation units are identical and should be treated as a single definition.
    \bigbreak \noindent 
     If a function is defined only in a .cpp file, it will not be included in multiple translation units, so inline is unnecessary.

     \bigbreak \noindent 
     \subsection{Base class pointer if the base class is abstract}
     \bigbreak \noindent 
     Consider the code
     \bigbreak \noindent 
     \begin{cppcode}
     struct A {
         virtual void print() const = 0;
         ~A() = default;
     };
     struct B : A { };
     A* b = new B{};
     \end{cppcode}
     \bigbreak \noindent 
     print is declared as a pure virtual function. This means that any concrete (non-abstract) subclass of A must provide an override for print(). However, struct B does not implement print(), so B remains abstract, and you cannot instantiate an object of an abstract class.
     \bigbreak \noindent 
     Thus, the fix is to simply override print in B
     \bigbreak \noindent 
     \begin{cppcode}
         struct A {
             virtual void print() const = 0;
             ~A() = default;
         };

         struct B : A {
             void print() const override;
         };
         A* b = new B{}; // OK
     \end{cppcode}

     \bigbreak \noindent 
     \subsection{Does the destructor need to be pure in an abstract class?}
     \bigbreak \noindent 
     it's not necessary to make the destructor pure just because the class is abstract. Here's why:
     \begin{itemize}
         \item The class A is abstract due to the pure virtual function print(). You don't need a pure virtual destructor to make a class abstract; a single pure virtual function is enough.
            \item The destructor in an abstract class should be virtual to ensure proper cleanup of derived objects. Marking the destructor as virtual (even if defaulted) is sufficient. A pure virtual destructor requires an out-of-class definition, which can be unnecessary overhead if you already have other pure virtual functions enforcing abstraction.
            \item In many cases, a defaulted virtual destructor (i.e., $\sim$A() = default;) is the simplest and most effective choice, allowing for correct object destruction without extra boilerplate.
     \end{itemize}


    \pagebreak 
    \unsect{The existence of structs and classes}
    \bigbreak \noindent 
    Does a Struct Exist in Memory Before an Object is Created? Yes and No. It depends on what part of the struct you're referring to:
    \begin{itemize}
        \item \textbf{Struct Definition (Type Information) – Exists at Compile Time}: The struct itself is just a blueprint (like a class). It does not occupy memory on its own.
            \bigbreak \noindent 
            Only when you create an object of the struct does memory get allocated for its members.
        \item \textbf{VTable (for Virtual Functions) – Exists in Memory, Even Without Objects}: If the struct contains virtual functions, the compiler generates a VTable at compile time. The VTable itself is stored in static memory (not per object). Even if no object is created, the struct’s VTable exists somewhere in memory.
        \item \textbf{Object Instances – Exist in Memory When Created}: When you instantiate an object of the struct, memory is allocated for that object’s data members. If the struct has virtual functions, each object has a hidden VPtr (Virtual Pointer), which increases its size.
    \end{itemize}
    \bigbreak \noindent 
    If $A$ is a struct, why does sizeof(A) have a size even if no object is created? When you define a struct in C++, the compiler determines the size of its layout at compile time. This means that even if you don’t create an object of the struct, sizeof(A) can still return a valid size.
    \bigbreak \noindent 
    The compiler does not assign fixed memory addresses to struct members. Instead, it determines the memory layout (size, alignment, and padding) at compile time. Actual memory addresses are assigned at runtime when an object is created.







    \pagebreak 
    \unsect{Note about heap allocated memory in vectors}
    \bigbreak \noindent 
    If your std::vector contains raw pointers (e.g., std::vector<int*>), the vector will only destroy the pointers themselves but not the dynamically allocated memory they point to. This will cause a memory leak if you don’t manually delete each allocated object before the vector goes out of scope.
    \bigbreak \noindent 
    To avoid leaks, manually delete the elements before clearing the vector

    \pagebreak 
    \unsect{Function that takes a const reference can accept rvalues}
    \bigbreak \noindent 
    In C++, a function that takes a const reference can accept rvalues because const references extend the lifetime of temporary (rvalue) objects.
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        void f(const T& x) {}
    \end{cppcode}
    \bigbreak \noindent 
    A const T\& (a reference to a const object of type T) can bind to both lvalues and rvalues, because:
    \begin{enumerate}
        \item Lvalues are naturally bindable to references.
        \item Rvalues (temporaries) can bind to const T\& because:
            \begin{itemize}
                \item The const qualifier guarantees that the temporary will not be modified.
                \item C++ extends the lifetime of the temporary to match the lifetime of the reference.
            \end{itemize}
    \end{enumerate}
    \bigbreak \noindent 
    \begin{cppcode}
        const int& ref = 100; // OK: binds to temporary, lifetime extended
        std::cout << ref << std::endl; // Prints 100

        int& ref = 100; // ERROR: Cannot bind non-const lvalue reference to an rvalue
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item If an lvalue is passed $\to$ T deduces to int\&, making T\&\& collapse to int\&.
        \item If an rvalue is passed $\to$ T deduces to int, making T\&\& remain int\&\&.
    \end{itemize}



    
    \pagebreak 
    \unsect{Notes about c++ casts}
    \bigbreak \noindent 
    First, recall
    \begin{itemize}
        \item static\_cast is used for safe and well-defined type conversions that are checked at compile-time.
        \item dynamic\_cast is used only with polymorphic types (i.e., classes with at least one virtual function). It performs runtime type checking and is mainly used for safe downcasting.
        \item const\_cast is used to add or remove const or volatile qualifiers from a variable. It is the only cast that can remove const, allowing modifications to otherwise constant data.
        \item reinterpret\_cast is the most dangerous cast—it converts between completely unrelated types. It does not perform type checking and is used for low-level pointer manipulation.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Static\_cast}
    \bigbreak \noindent 
    \textbf{When to Use static\_cast}:
    \bigbreak \noindent 
    \begin{itemize}
        \item Converting between numeric types (e.g., int to double).
        \item Converting between pointers of related classes (e.g., upcasting in inheritance).
        \item Converting between explicitly defined conversion operators.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{What It CANNOT Do}:
    \begin{itemize}
        \item It does not check for validity at runtime.
        \item It cannot cast between unrelated types (use reinterpret\_cast for that).
        \item It cannot remove const or volatile qualifiers (use const\_cast for that).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Dynamic\_cast}
    \bigbreak \noindent 
    Dynamic casting in C++ is a feature provided by the language to safely convert pointers or references of base class types to pointers or references of derived class types at runtime. This is particularly useful in scenarios involving polymorphism, where you have a base class pointer or reference pointing to an object of a derived class, and you need to access derived class-specific members or methods.
    \bigbreak \noindent 
    Dynamic casting is used with pointers or references in class hierarchies that involve polymorphism (i.e., classes with at least one virtual function).
    \bigbreak \noindent 
    \begin{cppcode}
    dynamic_cast<new_type>(expression)
    \end{cppcode}
    \bigbreak \noindent 
    Dynamic casting performs a runtime check to ensure the cast is valid. If the cast is not possible, it returns nullptr for pointers or throws a std::bad\_cast exception for references.
    \bigbreak \noindent 
    Dynamic casting relies on Run-Time Type Information (RTTI), which must be enabled in your compiler.
    \bigbreak \noindent 
    \subsubsection{When to Use Dynamic Casting}
    \bigbreak \noindent 
    \begin{itemize}
        \item When you need to safely downcast in a polymorphic hierarchy.
        \item When you are unsure of the actual type of the object at runtime and need to check it.
    \end{itemize}
    \bigbreak \noindent 
    Dynamic casting incurs a runtime overhead due to the type checking. It only works with polymorphic types (classes with at least one virtual function).
    \bigbreak \noindent 
    Overuse of dynamic casting can indicate a design flaw; prefer virtual functions and polymorphism where possible.

    \bigbreak \noindent 
    \subsubsection{RTTI}
    \bigbreak \noindent 
    RTTI stands for Run-Time Type Information. It is a feature in C++ that provides mechanisms to determine the type of an object at runtime. RTTI is particularly useful in scenarios involving polymorphism, where you need to identify the actual type of an object pointed to by a base class pointer or reference.
    \bigbreak \noindent 
    RTTI relies on metadata stored by the compiler for polymorphic types (classes with at least one virtual function). This metadata includes:
    \begin{itemize}
        \item A vtable (virtual table) for each polymorphic class, which contains pointers to its virtual functions.
        \item A type\_info object for each class, which stores information about the class's type.
    \end{itemize}
    \bigbreak \noindent 
    When you use typeid or dynamic\_cast, the compiler generates code to access this metadata at runtime to determine the object's type.

    \bigbreak \noindent 
    \subsection{const\_cast}
    \bigbreak \noindent 
    const\_cast is only used to remove const or volatile qualifiers from a variable. It cannot be used to add const.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        void modify(int* ptr) {
            *ptr = 42;
        }

        int main() {
            const int x = 10;

            // Removing const
            int* ptr = const_cast<int*>(&x);

            modify(ptr); // Undefined behavior if `x` was originally a `const` object

            std::cout << "x: " << x << std::endl; // This may not reflect the change due to UB
        }
    \end{cppcode}
    \bigbreak \noindent 
    This is unsafe if x was originally declared as const int x = 10;, because modifying x leads to undefined behavior. However, if x was originally non-const and then cast to const, modifying it later using const\_cast is safe.
    \bigbreak \noindent 
    If you want to add const, you should use
    \begin{itemize}
        \item Implicit conversion
        \item static\_cast
        \item Declaring a const reference or pointer to a non-const object
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        int a = 5;
        const int* ptr = &a; // Adding const implicitly
        const int& ref = a;  // Adding const implicitly
    \end{cppcode}
    \bigbreak \noindent 
    const\_cast is useful in a few specific cases where you need to work around const qualifiers safely. 
    \bigbreak \noindent 
    \subsubsection{Modifying a non-const object that was passed as const}
    \bigbreak \noindent 
    If a function receives a const parameter but you know that the actual object is non-const, you can safely cast away const and modify it.
    \bigbreak \noindent 
    \subsubsection{Removing const to use overloaded functions}
    \bigbreak \noindent 
    Sometimes you have an overloaded function where one version accepts const and another modifies the object. const\_cast allows selecting the modifying version when needed.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Example {
            public:
            void print() {
                std::cout << "Non-const print" << std::endl;
            }

            void print() const {
                std::cout << "Const print" << std::endl;
            }
        };

        void forceModify(const Example& obj) {
            const_cast<Example&>(obj).print();  // Calls non-const version
        }

        int main() {
            Example e;
            forceModify(e);  // Calls non-const print()
        }
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{Note:} Const cast is a runtime operation and does not perform any checks

    \bigbreak \noindent 
    \subsection{reinterpret\_cast}
    \bigbreak \noindent 
    reinterpret\_cast is a type of casting operator in C++ that is used to convert one pointer type to another, even if the types are entirely unrelated. It performs a low-level reinterpretation of the underlying binary representation of the data.
    \bigbreak \noindent 
    \textbf{Note:} reinterpret\_cast is a runtime operation and does not perform any checks

    \bigbreak \noindent 
    \subsection{Why are c casts unsafe?}
    \bigbreak \noindent 
    C-style casting is unsafe and ambiguous because:
    \begin{itemize}
        \item It can perform multiple types of conversions at once, including:
            \begin{itemize}
                \item static\_cast
                \item reinterpret\_cast
                \item const\_cast
                \item Even dynamic\_cast (if a class has virtual functions)
            \end{itemize}
        \item It lacks compile-time safety—you might unintentionally use an invalid cast.
        \item It is hard to search and debug since (Type) doesn’t indicate what kind of conversion is being performed.
    \end{itemize}

    \pagebreak 
    \unsect{The compiler and functions}
    \bigbreak \noindent 
     The compiler handles functions through several stages, from parsing the source code to generating machine code. Here's an overview of how the compiler deals with functions
     \begin{enumerate}
         \item \textbf{Parsing and Syntax Analysis:} The compiler reads the source code and identifies function declarations and definitions.
             \bigbreak \noindent 
                It checks the syntax of the function, such as the return type, function name, parameter list, and body.
         \item \textbf{Semantic Analysis:} The compiler checks the meaning of the function, such as
             \begin{itemize}
                 \item Whether the function is declared before use (or has a prototype).
                 \item Whether the function parameters and return type match the function calls.
                 \item Whether the function body adheres to type rules (e.g., no invalid operations on types).
             \end{itemize}
         \item \textbf{Function Overloading Resolution:} If multiple functions with the same name exist (function overloading), the compiler determines which function to call based on the arguments provided.
         \item \textbf{Code Generation:} The compiler generates intermediate or machine code for the function body.
             \bigbreak \noindent 
            It allocates memory for local variables and parameters.
            \bigbreak \noindent 
            It generates instructions for the function's logic, such as arithmetic operations, loops, and conditionals.
         \item \textbf{Function Calls:} When a function is called, the compiler generates code to:
             \begin{itemize}
                 \item Push the arguments onto the stack (or pass them via registers, depending on the calling convention).
                 \item Transfer control to the function's code.
                 \item Save the return address so the program knows where to continue after the function finishes.
             \end{itemize}
         \item \textbf{Inlining (Optional):} If a function is marked with the inline keyword or the compiler determines it is beneficial, the compiler may replace the function call with the actual function body to avoid the overhead of a function call.
         \item \textbf{Linkage:}
             If a function is declared in one translation unit (source file) and defined in another, the compiler ensures the function is properly linked.
             \bigbreak \noindent 
            The compiler generates symbols for functions, which the linker resolves during the linking phase.
         \item \textbf{Optimization:}
             The compiler may optimize functions to improve performance, such as:
             \begin{itemize}
                 \item Removing unused code (dead code elimination).
                 \item Unrolling loops.
                 \item Inlining small functions.
                 \item Optimizing tail-recursive functions.
             \end{itemize}
     \end{enumerate}
     \bigbreak \noindent 
     When a function is called, the compiler (and the runtime environment) manages memory for local variables in a specific way
     \bigbreak \noindent 
     Local variables in a function are typically stored in the stack, a region of memory that is managed automatically by the compiler and runtime environment.
     \bigbreak \noindent 
     When a function is called, the compiler allocates memory on the stack for all of its local variables.
     \bigbreak \noindent 
     This memory is only valid for the duration of the function call. Once the function returns, the memory is deallocated (freed).
     \bigbreak \noindent 
     Each function call creates a stack frame (also called an activation record), which contains:
     \begin{itemize}
         \item The function's local variables.
         \item The return address (where the program should continue after the function finishes).
         \item The function's parameters (if any).
     \end{itemize}
    The stack grows downward in memory, and each new function call adds a new stack frame on top of the previous one.
    \bigbreak \noindent 
    When a function returns, its stack frame is deallocated, and the memory becomes available for reuse.
    \bigbreak \noindent 
    If the same function is called again, a new stack frame is created, and the local variables are allocated in the same memory region (which may have been overwritten by other function calls in the meantime).
    \bigbreak \noindent 
    Local variables have automatic storage duration, meaning they are created when the function is called and destroyed when the function returns.
    \bigbreak \noindent 
    This means that the values of local variables are not preserved between function calls.
    \bigbreak \noindent 
    constexpr variables are treated differently because they are compile-time constants.
    \bigbreak \noindent 
    The compiler evaluates constexpr variables at compile time and replaces their uses with their computed values.
    \bigbreak \noindent 
    No memory is allocated for constexpr variables at runtime—they are essentially "baked into" the code.
    \bigbreak \noindent 
    If a local variable is declared static, it has static storage duration, meaning it is allocated memory once and persists across function calls.
    \bigbreak \noindent 
    Static local variables are not stored on the stack but in a separate region of memory (typically the data segment).

    \bigbreak \noindent 
    \subsection{Important: compile time constant variables and memory (constant propagation/constant folding)}
    \bigbreak \noindent 
    When the compiler encounters a compile-time constant (e.g., a constexpr variable), it evaluates the constant expression at compile time and replaces all uses of the variable with the computed value. This means:
    \begin{itemize}
        \item \textbf{No Memory Allocation for the Variable:} Since the value of the compile-time constant is known at compile time, the compiler does not allocate memory for the variable at runtime.
            \bigbreak \noindent 
            Instead, the variable is treated like a literal value (e.g., 10, 3.14, etc.), and its value is "baked into" the generated code wherever it is used.
        \item \textbf{Replacement of Uses:} The compiler replaces every occurrence of the compile-time constant variable with its computed value.
        This process is called constant propagation or constant folding.
    \end{itemize}




    \pagebreak 
    \unsect{Brace initialization vs Parenthesized Initialization}
    \bigbreak \noindent 
    Brace initialization (also called uniform initialization or list initialization) was introduced in C++11 and has stricter rules compared to parenthesized initialization. Specifically, consider a uniform initialization of the form \texttt{type\{expr\}}
    \begin{itemize}
        \item \textbf{Prohibits narrowing conversions:} Brace initialization does not allow implicit narrowing conversions. If expr cannot be converted to Type without losing information (e.g., converting a double to an int), the compiler will emit an error.
        \item \textbf{Prevents most vexing parse:} Brace initialization avoids ambiguity with function declarations, which can occur with parenthesized initialization.
        \item \textbf{Calls constructors explicitly:} If Type has a constructor that takes an std::initializer\_list, brace initialization will prefer that constructor.
    \end{itemize}
    \bigbreak \noindent 
    If an std::initializer\_list constructor exists, it will be chosen over other constructors, even if another constructor is a better match.
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            s(int x) {cout << "1" << endl;}
            s(initializer_list<int> x) {cout << "2" << endl;}
        };
        s s1{2}; // 2
        s s2(2); // 1
    \end{cppcode}




    \bigbreak \noindent 
    Parenthesized initialization (also called direct initialization) is more permissive and allows narrowing conversions. It behaves like a function call, where the compiler attempts to convert expr to Type using implicit conversions, even if narrowing occurs.
    \bigbreak \noindent 
    Note that parenthesized initialization does call constructors
    \bigbreak \noindent 
    Since c++20, direct initialization will work for aggregate types
    \begin{align*}
        struct lattice {
            int x,y;
        };
        lattice p(10,20); // OK since c++20
    \end{align*}


    \pagebreak 
    \unsect{Are chars unsigned?}
    \bigbreak \noindent 
    In C++, the char type is neither inherently signed nor unsigned. It's implementation-defined behavior.
    \begin{itemize}
        \item char, signed char, and unsigned char are distinct types.
        \item The default behavior of char depends on the compiler. Some compilers treat char as signed char, while others treat it as unsigned char.
        \item To ensure consistent behavior, use signed char or unsigned char explicitly.
    \end{itemize}


    \pagebreak 
    \unsect{Size of types}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{bool}: 1 Byte
        \item \textbf{char}: 1 Byte
        \item \textbf{short}: 2 Bytes
        \item \textbf{int}: 4 Bytes
        \item \textbf{long}: 4 or 8 bytes
        \item \textbf{long long}: 8 bytes
        \item \textbf{float}: 4 bytes
        \item \textbf{double}: 8 bytes
        \item \textbf{long double}: 16 bytes
        \item \textbf{string}: 32 bytes
        \item \textbf{Pointers}: 8 bytes
    \end{itemize}
    \bigbreak \noindent 
    Note that the size of primitive types are usually implementation defined, and adding signed or unsigned does not change the size.
    \bigbreak \noindent 
    Also, references are the size of the type they refer to. 

    \pagebreak 
    \unsect{Trivially copyable}
    \bigbreak \noindent 
    A trivially copyable type in C++ is a type that can be copied efficiently using memcpy or similar low-level operations without breaking its correctness. This means it does not require custom copy/move constructors or destructors.
    \bigbreak \noindent 
    A class or struct is trivially copyable if:
    \begin{itemize}
        \item Can be copied with memcpy without breaking program semantics.
        \item Has no user-defined copy/move constructors, assignment operators, or destructors.
        \item Only contains trivially copyable members.
        \item Does not have virtual functions or virtual base classes.
    \end{itemize}


    \pagebreak 
    \unsect{POD types (Plain old data)}
    \bigbreak \noindent 
    POD (Plain Old Data) refers to a type in C++ that is simple, compatible with C structures, and has well-defined memory layouts. A POD type behaves like a C-style struct and lacks modern C++ features such as constructors, destructors, virtual functions, and non-trivial member functions.
    \bigbreak \noindent 
    A type is considered POD if:
    \begin{itemize}
        \item It is a trivial type (trivial constructor, destructor, copy/move operations).
        \item It is a standard-layout type (data layout matches C structs).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Trivial type}
    \bigbreak \noindent 
    A type is trivial if:
    \begin{itemize}
        \item It has a trivial default constructor (compiler-generated, does nothing).
        \item It has a trivial copy/move constructor and assignment (member-wise copying).
        \item It has a trivial destructor (compiler-generated, does nothing).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Standard layout}
    \bigbreak \noindent 
    A type is standard-layout if:
    \begin{itemize}
        \item It has no virtual functions or virtual base classes.
        \item It has only standard-layout base classes.
        \item All non-static data members have the same access control (public vs private matters).
        \item It does not inherit from multiple base classes with different access specifiers.
    \end{itemize}
    \bigbreak \noindent 
    For a C++ structure (struct or class) to match a C struct's layout, it must
    \begin{itemize}
        \item Store its members in the same order as declared.
        \item Not have hidden padding or unexpected compiler transformations.
        \item Not have virtual functions or virtual base classes.
        \item Not use complex features like multiple inheritance.
        \item Use only standard-layout types for its members.
    \end{itemize}
    \bigbreak \noindent 
    If a type is both trivial and standard-layout, it is POD.

    \pagebreak 
    \unsect{Notes about initialization}
    \bigbreak \noindent 
    \subsection{How many names does brace initialization have?}
    \bigbreak \noindent 
    \subsubsection{Uniform Initialization (General Term)}
    \bigbreak \noindent 
    Introduced in C++11, \{\} initialization is often referred to as uniform initialization because it provides a consistent syntax for initializing objects of any type.
    \bigbreak \noindent 
    Note that uniform initialization is an informal term


    \bigbreak \noindent 
    \subsubsection{List Initialization}
    \bigbreak \noindent 
    List initialization is the official term in the C++ standard for using \{\} to initialize objects.

    \bigbreak \noindent 
    \subsubsection{Aggregate Initialization}
    \bigbreak \noindent 
    When \{\} is used to initialize aggregates (structs, arrays, or classes with public members and no user-defined constructors), it's called aggregate initialization.
    \bigbreak \noindent 
    \begin{cppcode}
        struct Point {
            int x, y;
        };
        Point p = {1, 2}; // Aggregate initialization
    \end{cppcode}


    \bigbreak \noindent 
    \subsubsection{Value Initialization}
    \bigbreak \noindent 
    If \{\} is used without any elements, it results in value initialization.
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{},y{}; // Default value initialized
        };
    \end{cppcode}
    \bigbreak \noindent 
    Note that we can also do
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y
        };
        point p{}; // Construct p and default value initialize x,y
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Direct List Initialization}
    \bigbreak \noindent 
    When \{\} is used with a constructor that takes a list, it is called direct list initialization.
    \bigbreak \noindent 
    \begin{cppcode}
    std::vector<int> v{1, 2, 3}; // Direct list initialization
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Copy List Initialization}
    \bigbreak \noindent 
    When \{\} is used on the right-hand side of an assignment or in variable initialization without explicit construction, it's called copy list initialization.
    \bigbreak \noindent 
    \begin{cppcode}
    std::vector<int> v = {1, 2, 3}; // Copy list initialization
    \end{cppcode}
    
    \bigbreak \noindent 
    \subsubsection{Narrowing Prevention Initialization}
    \bigbreak \noindent 
    \{\} initialization prevents narrowing conversions, meaning it does not allow implicit type conversions that lose information.
    \bigbreak \noindent 
    \begin{cppcode}
        int x = 3.5;  // Allowed (implicit conversion)
        int y{3.5};   // Error (narrowing conversion)
    \end{cppcode}


    \bigbreak \noindent 
    \subsubsection{ Default Member Initialization}
    \bigbreak \noindent 
    \{\} can be used to initialize class members with default values.
    \bigbreak \noindent 
    \begin{cppcode}
        struct Example {
            int a = {};  // Value-initialized to 0
        };
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Copy list initialization and direct list initialization in aggregate types}
    \bigbreak \noindent 
    We note that for an aggregate type, copy list initialization and direct list initialization behave the same
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y
        };
        point p1 = {1,2};
        point p1{1,2};
    \end{cppcode}
    \bigbreak \noindent 
    For aggregates, both = (copy list initialization) and \{\} (direct list initialization) behave identically because C++ applies aggregate initialization in both cases.
    \bigbreak \noindent 
    However, if point had a user-defined constructor, then they could behave differently.
    \bigbreak \noindent 
    If we defined a constructor that takes an initializer\_list, both the above objects would call that constructor
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{},y{}; // Default value initialized

            point(std::initializer_list<int> l) {
                cout << "called init list " << endl;
            }
        };

        point p1 = {1,2}; // called init list
        point p2{1,2}; // called init list
    \end{cppcode}

    \bigbreak \noindent 
    Note that if we define a virtual method, our type becomes polymorphic and is no longer aggregate. Therefore, we cannot use either initialization above. Note however that c++ will still implicitly give us the default constructors, so the following will still work
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;

            virtual void f();
        };
        point p1{1,2} // Error
        point p2 = {1,2} // Error
        point p3{};
    \end{cppcode}
    \bigbreak \noindent 
    In this case, we need to explicitly define our constructor
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;

            point(int x, int y) : x(x), y(y) {}

            virtual void f();
        };
        point p1{1,2} 
        point p2 = {1,2} 
        point p3{};
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Other forms of initialization and their names}
    \bigbreak \noindent 
    \subsubsection{ Direct Initialization}
    \bigbreak \noindent 
    Uses the parenthesis () syntax
    \bigbreak \noindent 
    \begin{cppcode}
        int x(10);   // Direct initialization
        std::string s("hello");
    \end{cppcode}
    \bigbreak \noindent 
    Note that aggregate initialization logic  will not work with this syntax
    \bigbreak \noindent 
    \begin{cppcode}
        struct point{
            int x,y
        };
        point p(1,2) // Error! Must define the constructor.
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Copy Initialization }
    \bigbreak \noindent 
    Uses assignment =
    \bigbreak \noindent 
    \begin{cppcode}
    int x = 10;
    \end{cppcode}
    \bigbreak \noindent 
    Creates a temporary object and copies/moves it to initialize the variable. May involve implicit conversions. Calls copy constructor if the type has one.

    \bigbreak \noindent 
    \subsubsection{ Default Initialization}
    \bigbreak \noindent 
    No explicit initializer
    \bigbreak \noindent 
    \begin{cppcode}
        int x;      // Default initialization (uninitialized in local scope)
        std::string s; // Calls default constructor (empty string)
    \end{cppcode}



    % \pagebreak 
    % \unsect{Notes about destructors}
    % \bigbreak \noindent 
    % \subsection{Manual destructor calls}
    % \bigbreak \noindent 
    % Manually calling a destructor in C++ is dangerous because it can lead to undefined behavior, double destruction, and resource leaks.
    % \bigbreak \noindent 
    % If you manually call the destructor and then let the object go out of scope (or delete it via delete), the destructor will be called again, leading to a double free or use-after-free error.
    %

    \bigbreak \noindent 
    \subsection{Excess elements in scalar initialization}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        int x{1,2,3}
    \end{cppcode}
    \bigbreak \noindent 
    Results in a compilation error "excess elements in scalar initialization"
    \bigbreak \noindent 
    Further consider
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename ... Args>
    struct foo {
        int var;

        foo(Args... args) : var(args...) {}
    };
    X x(1); // fine
    X y(1,2,3); // Excess elements in scalar initialization
    \end{cppcode}



    \pagebreak 
    \unsect{Notes about constructors and destructors}
    \bigbreak \noindent 
    \subsection{Value initialized vs default initialized}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s1 {
            string s{};
            int x{};
        };

        struct s2 {
            string s;
            int x;
        };
    \end{cppcode}
    \bigbreak \noindent 
    Whats the difference? In s1, the members are explicitly initialized with \{\}
    \bigbreak \noindent 
    \begin{cppcode}
        struct s1 {
            std::string s{};  // Initializes to an empty string
            int x{};          // Initializes to 0
        };
    \end{cppcode}
    \bigbreak \noindent 
    This ensures that when an instance of s1 is created, s will be initialized to an empty string (""), and x will be initialized to 0.
    \bigbreak \noindent 
    In s2, the members are not explicitly initialized:
    \bigbreak \noindent 
    \begin{cppcode}
        struct s2 {
            std::string s;  // Default constructor of std::string initializes it to ""
            int x;          // Uninitialized, contains garbage value if not explicitly set
        };
    \end{cppcode}
    \bigbreak \noindent 
    s is fine because std::string has a default constructor that initializes it to "".
    \bigbreak \noindent 
    x, however, remains uninitialized when a default-constructed object of s2 is created, leading to an indeterminate value.



    \bigbreak \noindent 
    \subsection{What exactly is =default}
    \bigbreak \noindent 
    the = default specifier is used to explicitly declare that a special member function should be automatically generated by the compiler with its default behavior.
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            char c; 
            int x; 

            s() = default;
        };
    \end{cppcode}
    \bigbreak \noindent 
    This declares a default constructor (s()) explicitly, but it tells the compiler to generate it using the default implementation.
    \bigbreak \noindent 
    By default, the compiler-generated constructor does not initialize member variables. So, this:
    \bigbreak \noindent 
    \begin{cppcode}
    s() = default;
    \end{cppcode}
    \bigbreak \noindent 
    is equivalent to:
    \bigbreak \noindent 
    \begin{cppcode}
    s() {}  // Default constructor, does nothing
    \end{cppcode}
    \bigbreak \noindent 
    which means the members (char c; int x;) remain uninitialized when an object of s is created
    \bigbreak \noindent 
    \subsubsection{Non-POD fields}
    \bigbreak \noindent 
    =default construct (default constructor) calls default constructors of non-POD (plain-old-data) members.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str; // std::string has a default constructor
            int x;

            S() = default; // Compiler generates: S() {} (but calls std::string's constructor)
        };
    \end{cppcode}
    \bigbreak \noindent 
    The std::string member is properly initialized (since std::string has a default constructor). The int x is uninitialized.

    \bigbreak \noindent 
    \subsubsection{With copy constructors}
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S() = default;
            S(const S&) = default;  // Compiler generates: S(const S& other) : str(other.str), x(other.x) {}
        };
    \end{cppcode}
    \bigbreak \noindent 
    Generates a copy constructor that copies each member individually using their copy constructors.

    \bigbreak \noindent 
    \subsubsection{Copy Assignment}
    \bigbreak \noindent 
    Generates an assignment operator that copies each member individually.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S& operator=(const S&) = default;
        };
    \end{cppcode}
    \bigbreak \noindent 
    Equivalent to
    \bigbreak \noindent 
    \begin{cppcode}
        S& operator=(const S& other) {
            str = other.str; // Calls std::string's assignment operator
            x = other.x;     // Simply copies x
            return *this;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Move constructor}
    \bigbreak \noindent 
    Generates a move constructor that moves each member individually.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S(S&&) = default;  // Compiler generates: S(S&& other) : str(std::move(other.str)), x(other.x) {}
        };
    \end{cppcode}
    \bigbreak \noindent 
    This allows efficient moving:
    \bigbreak \noindent 
    \begin{cppcode}
        S obj1;
        S obj2 = std::move(obj1);  // Moves `str`, but leaves `x` as a copy
    \end{cppcode}
    \bigbreak \noindent 
    the move constructor does not "move" the int x. Instead, it simply copies x from the source. This is because int is a trivially copyable type, and moving it is no different from copying.

    \bigbreak \noindent 
    \subsubsection{ Move Assignment}
    \bigbreak \noindent 
    Generates a move assignment operator that moves each member individually.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            S& operator=(S&&) = default;
        };
    \end{cppcode}
    \bigbreak \noindent 
    Equivalent to:
    \bigbreak \noindent 
    \begin{cppcode}
        S& operator=(S&& other) {
            str = std::move(other.str);  // Moves the string instead of copying
            x = other.x;  // Simply copies x (since int doesn't benefit from move)
            return *this;
        }
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{Destructor}
    \bigbreak \noindent 
    Generates a destructor that:
    \begin{itemize}
        \item Does nothing for fundamental types.
        \item Calls the destructors of member objects.
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            std::string str;
            int x;

            ~S() = default;  // Compiler generates: ~S() {} (but calls std::string's destructor)
        };
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Do you need to write them?}
    \bigbreak \noindent 
    In C++, the compiler will automatically generate default implementations for special member functions only if they are needed and not explicitly declared.
    \bigbreak \noindent 
    However, if you declare any of them (without defining them), the compiler will not automatically generate them. This is where = default comes in—it explicitly tells the compiler to generate the default implementation.


    \bigbreak \noindent 
    \subsection{=delete}
    \bigbreak \noindent 
    =delete does the opposite of =default... It deletes the default implementation

    \bigbreak \noindent 
    \subsection{Rule of five}
    \bigbreak \noindent 
    In C++, the Rule of Five states that if you define or explicitly delete any of the following five special member functions, you should likely define or delete all five
    \begin{itemize}
        \item Destructor
        \item copy constructor
        \item copy assignment operator
        \item move constructor 
        \item move assignment operator
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            string str{};

            s(const s& other) {
                cout << "Copy constructor called" << endl;
                str = other.str;
            }
        };
        s s1;
    \end{cppcode}
    \bigbreak \noindent 
    In this case, we get an error. When you explicitly define a copy constructor in C++, the compiler does not automatically generate the default constructor for you. This is due to the Rule of Five
    \bigbreak \noindent 
    The C++ standard states that if you declare any of the above special member functions, the compiler will not generate a default constructor for you:
    \bigbreak \noindent 
    Once you define any of these functions, the compiler assumes you want full control over object creation and copying, so it does not provide the default constructor.

    \bigbreak \noindent 
    \subsection{A confused compiler}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{};

            point (int x) : x(x) {}

            point(int&& other) {
                cout << "called second" << endl;
                x = other;
            }
        };
        point p = 20; // Error
    \end{cppcode}
    \bigbreak \noindent 
    We get "error: conversion from ‘int’ to ‘point’ is ambiguous".
    \bigbreak \noindent 
    happens because there are multiple constructors that can accept an int, and the compiler doesn't know which one to pick.
    \bigbreak \noindent 
    \begin{itemize}
        \item point(int) is a direct match for int.
        \item point(int\&\&) can accept an int as an rvalue reference.
    \end{itemize}
    The compiler does not know which one to pick, so it gives an error.
    \bigbreak \noindent 
    If we mark the first constructor explicit, we then prevent implicit conversion from int to point, and the second constructor will be the one called.
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{};

            explicit point (int x) : x(x) {}

            point(int&& other) {
                cout << "called second" << endl;
                x = other;
            }
        };
        point p = 20;
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Which constructor will be called}
    \bigbreak \noindent 
    Suppose we have
    \bigbreak \noindent 
    \begin{cppcode}
        struct  point {
            int x{};

            point(const int& other) {
                cout << "called first" << endl;
                x = other;
            }

            point(int&& other) {
                cout << "called second" << endl;
                x = other;
            }
        };
        point p = 20;
    \end{cppcode}
    \bigbreak \noindent 
    Which constructor gets called? The second constructor (point(int\&\& other)) is called in this case because the literal 20 is an rvalue.
    \bigbreak \noindent 
    We have two suitable constructors, and the compiler must determine which constructor to call.
    \bigbreak \noindent 
    The compiler  deems the second as a better match than the first, because 20 is a pure rvalue. Note that if we removed the second constructor, the first would work. A constructor that takes a const reference can bind to both rvalues and lvalues.

    \bigbreak \noindent 
    \subsection{Constructors are implicitly inline constexpr}
    \bigbreak \noindent 
    constructors are implicitly constexpr under certain conditions. This means they can be evaluated at compile time if all their operations are constexpr. The main reason for this behavior is to make objects usable in constant expressions without requiring explicit constexpr annotations.

    \bigbreak \noindent 
    \subsection{Destructors are implicitly noexcept}
    \bigbreak \noindent 
    In C++, destructors are implicitly declared as noexcept unless a potentially throwing operation is explicitly present in the destructor's definition. This behavior exists to improve performance, exception safety, and compatibility with standard library features.
    \bigbreak \noindent 
    When a function is marked as noexcept, the compiler can generate more efficient code:
    \bigbreak \noindent 
    If destructors could throw by default, objects in RAII (Resource Acquisition Is Initialization) and smart pointers (std::unique_ptr, std::shared_ptr) would lead to undefined behavior or terminate the program when a destructor is called during stack unwinding.
    \bigbreak \noindent 
    \begin{cppcode}
        struct B {
            ~B() { throw std::runtime_error("Error!"); } // Dangerous!
        };

        void func() {
            try {
                B b;
                throw std::runtime_error("Oops");
            } catch (...) {
                // Stack unwinding will terminate the program if ~B() throws
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    To prevent such issues, destructors are noexcept by default, meaning they do not propagate exceptions. If an exception occurs in a noexcept destructor, std::terminate() is called.
    \bigbreak \noindent 

    \bigbreak \noindent 
    \subsection{ When is an object "Fully constructed"}
    \bigbreak \noindent 
    In C++, an object is considered fully constructed when its constructor has finished executing successfully. Specifically:
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{For a non-inherited class (without base classes)}: The object is fully constructed after its constructor runs to completion.
        \item \textbf{For a class with base classes}: The object is fully constructed after all base class subobjects and non-static data members have been successfully initialized.
        \item \textbf{For a class with member variables}: Each member is constructed in the order they are declared in the class definition, before the body of the constructor executes. If a member's constructor throws an exception, the object is not fully constructed.
        \item \textbf{For a derived class}: A derived class object is fully constructed only after
            \begin{itemize}
                \item The base class constructor(s) finish execution.
                \item All member variables of the derived class are constructed.
                \item The body of the derived class constructor executes successfully.
            \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    \subsection{When is an object not fully constructed}
    \bigbreak \noindent 
    If a base class constructor throws, the derived class never completes construction.
    \bigbreak \noindent 
    If a member variable's constructor throws, the object never becomes fully constructed.
    \bigbreak \noindent 
    If a constructor exits via an exception, the destructor never runs, because the object was never fully formed.
    \bigbreak \noindent 
    Consider the code
    \begin{cppcode}
        struct B {
            B() { throw std::runtime_error("Error"); }
            ~B() { cout << "Destructor called" << endl; }
        };

        try {
            B b;
        } catch (...) {

        }
    \end{cppcode}
    \bigbreak \noindent 
    Here we get no output, the constructor never finished, which means the object was not fully constructed, which means the destructor will not get called.
    \bigbreak \noindent 
    Further consider 
    \bigbreak \noindent 
    \begin{cppcode}
        struct B {
            B() {}
            B(int n) : B() { throw std::runtime_error("Error"); }
            ~B() { cout << "Destructor called" << endl; }
        };

        try {
            B b;
        } catch (...) {

        }
    \end{cppcode}
    \bigbreak \noindent 
    In this example, we do get "destructor called". The destructor is called because the default constructor B() successfully constructs an object, even though the other constructor (B(int)) throws an exception.

    \bigbreak \noindent 
    \subsection{Converting constructors (cast constructors)}
    \bigbreak \noindent 
    A converting constructor is a constructor that allows you to create an object of a class from a value of another type, often implicitly. For example, if a class B has a constructor that takes an A as a parameter (and it's not marked explicit), then an object of type A can be automatically converted to a B when needed
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            A() { std::cout << "a"; }
        };

        struct B {
            B() { std::cout << "b"; }
            B(const A&) { std::cout << "B"; }
        };
        B b = A{};
    \end{cppcode}
    \bigbreak \noindent 
    Consider the example
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            int value;   
            A(int value) : value(value) {}
            operator int() { // Notice no return type
                return value;
            }
        };
        A a(5);
        int x = int(a) // OK, since we defined operator int()  
        int x = a; // Allow enables implicit conversions since operator int() is not marked explicit
    \end{cppcode}
    \bigbreak \noindent 
    This is an example of a conversion constructor. These operator overloads  do not have return types in their signature. a conversion operator like operator int() doesn’t explicitly state a return type because its return type is implicit—it’s defined by the type you're converting to, the function automatically returns an int. 
    \bigbreak \noindent 
    The C++ language grammar specifies that conversion operators are declared without a return type; the type following the operator keyword is the type to which the class is converted

    \bigbreak \noindent 
    \subsection{operator void() overload}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            operator void() {
                std::cout << "F";
            }
        };
        (void)s;
        static_cast<void>(s);
        s.operator void();
    \end{cppcode}
    \bigbreak \noindent 
    The only one that actually calls our overload is the third (manual call). According to the C++ standard, conversion functions will never be used to convert an object to void. So the conversion function is only called once, when we manually call it on the line s.operator void()

    \pagebreak 
    \unsect{Dividing by zero}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
    int a = 5, b = 0;
    int c = a/b;
    \end{cppcode}
    \bigbreak \noindent 
    Here we get \textit{terminated by signal SIGFPE (Floating point exception)}



    \pagebreak 
    \unsect{Notes about inheritance}
    \bigbreak \noindent 
    \subsection{Constructor chain}
    \bigbreak \noindent 
    In C++ inheritance, the constructor chain (or constructor delegation) refers to the sequence in which constructors of base and derived classes are called when an object of the derived class is created.
    \bigbreak \noindent 
    When an object of a derived class is created, the constructor of the base class runs before the constructor of the derived class.
    \bigbreak \noindent 
    If the base class has multiple levels, constructors are called in top-to-bottom order (from base to most derived).
    \bigbreak \noindent 
    If the base class does not have a user-defined constructor, the compiler provides a default constructor that is automatically invoked.
    \bigbreak \noindent 
    If the base class has a parameterized constructor, you must explicitly call it in the initializer list of the derived class.
    \bigbreak \noindent 
    \subsection{Destructor chain}
    \bigbreak \noindent 
    When a class has a virtual destructor, the vtable includes a pointer to the most derived destructor. However, destructors are special because they are split into two parts in the vtable:
    \begin{itemize}
        \item \textbf{Complete Object Destructor:} Calls all destructors in the chain (Child → Dad → Grandfather).
        \item \textbf{Base Object Destructor:} Only relevant when the object is part of another object (not directly deleted).
    \end{itemize}
    \bigbreak \noindent 
    When Child overrides Dad (which overrides Grandfather), the vtable for Child includes a pointer to the most derived destructor ($\sim$Child), but that destructor is responsible for calling the entire chain.
    \bigbreak \noindent 
    If Grandfather's destructor is not virtual, the vtable will not be consulted during delete obj. Instead, the compiler resolves delete obj at compile-time and calls Grandfather::$\sim$Grandfather() directly, ignoring the destructors of Dad and Child
    \bigbreak \noindent 
    Destructors execute in reverse order of constructors (i.e., derived class destructor runs first, then base class destructor).

    \bigbreak \noindent 
    \subsection{So who needs a virtual destructor?}
    \bigbreak \noindent 
    Consider the situation
    \bigbreak \noindent 
    \begin{cppcode}
        struct grandfather {
            virtual ~grandfather() = default;
        };


        struct dad : grandfather {
        };

        struct child : dad {
        };
    \end{cppcode}
    \bigbreak \noindent 
    When a destructor is declared virtual in a base class (grandfather), all derived classes (dad and child) automatically have virtual destructors, even if they don’t explicitly declare them
    \bigbreak \noindent 
    Since dad and child inherit from grandfather, they do not need to explicitly mark their destructors as virtual—they already are.
    \bigbreak \noindent 
    \begin{cppcode}
        struct grandfather {
            virtual ~grandfather() { std::cout << "grandfather destroyed\n"; }
        };

        struct mom : public virtual grandfather {
            ~mom() { std::cout << "mom destroyed\n"; } // Implicitly virtual
        };

        struct dad : public virtual grandfather {
            ~dad() { std::cout << "dad destroyed\n"; } // Implicitly virtual
        };

        struct child : public mom, public dad {
            ~child() { std::cout << "child destroyed\n"; } // Implicitly virtual
        };
        grandfather* g = new child();
        delete g;
        /* 
        child destroyed
        dad destroyed
        mom destroyed
        grandfather destroyed
        */
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Default access modifier} 
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
    class A {};
    class B : A {};
    \end{cppcode}
    \bigbreak \noindent 
    The default access modifier  is private for class inheritance, and public for structs.

    \bigbreak \noindent 
    \subsection{Can a class inherit from a struct, or a struct inherit from a class?}
    \bigbreak \noindent 
    Yes, perfectly acceptable. Recall though the default access specifiers for class vs struct inheritance



    \pagebreak 
    \unsect{Booleans under the hood: Adding two booleans}
    \bigbreak \noindent 
    In C++, bool is typically represented under the hood as an integral type, often stored as a single byte (char-sized) in memory. However, when used in expressions, bool values implicitly promote to int.
    \bigbreak \noindent 
    In C++, bool is effectively an integer type but only holds 0 (false) or 1 (true).
    \bigbreak \noindent 
    When used in an arithmetic expression, a bool value is promoted to an int.
    \bigbreak \noindent 
    This is part of the integral promotion rules in C++.
    \bigbreak \noindent 
    \begin{cppcode}
        bool b1 = 1, b2 = 1;
        cout << typeid(b1 + b2).name();
    \end{cppcode}

    \pagebreak 
    \unsect{Type Promotion}
    \bigbreak \noindent 
    Type promotion in C++ refers to the implicit conversion of smaller or lower-ranked types to larger or higher-ranked types in expressions. This ensures consistent operations without data loss.
    \begin{itemize}
        \item \textbf{Boolean Promotion:} bool converts to int (false → 0, true → 1) when used in arithmetic or bitwise operations.
        \item \textbf{Integral Promotion:} Types smaller than int (char, short, bool) promote to int if int can represent all values; otherwise, they promote to unsigned int.
    \end{itemize}
    If operands have different types, the one with the lower rank is converted to the higher-ranked type.
    \bigbreak \noindent 
    \subsection{Ranking}
    \bigbreak \noindent 
    % \begin{center}
    %     bool $\to$ char/short $\to$ int $\to$ long $\to$ long long $\to$ float $\to$ double $\to$ long double
    % \end{center}
    Standard conversion sequences are categorized in one of three ranks. The ranks are listed in order from best to worst:
    \begin{itemize}
        \item \textbf{Exact match:} This rank includes the following conversions:
            \begin{itemize}
                \item Identity conversions
                \item Lvalue-to-rvalue conversions
                \item Array-to-pointer conversions
                \item Qualification conversions
            \end{itemize}
        \item \textbf{Promotion:} This rank includes integral and floating point promotions.
        \item \textbf{Conversion:} This rank includes the following conversions:
            \begin{itemize}
                \item Integral and floating-point conversions
                \item Floating-integral conversions
                \item Pointer conversions
                \item Pointer-to-member conversions
                \item Boolean conversions
            \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    Consider
    \bigbreak \noindent 
    \begin{cppcode}
        void f(double x) { }
        void f(unsigned x) { }
        f(1.0); // Error, call to f is ambiguous
    \end{cppcode}
    \bigbreak \noindent 
    This situation is ambiguous because the integer literal 1.0 can be converted to either int or unsigned int, and both conversions have the same rank in the standard conversion sequence (Floating-integral conversions)
    \bigbreak \noindent 
    Further, consider
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int x) { cout << "1"; }
        void f(unsigned x) { cout << "2"; } 
        f((short)5); // 1
    \end{cppcode}
    \bigbreak \noindent 
    Although both conversions have rank \textit{promotion}, the compiler  chooses the first
    \bigbreak \noindent 
    The compiler looks for the best function match among the available overloads
    \bigbreak \noindent 
    \begin{itemize}
        \item short $\to$ int is an integral promotion.
        \item short $\to$ unsigned int is also a promotion, but only considered if int is not available.
    \end{itemize}
    Since integral promotions have higher precedence than standard conversions, f(int) is chosen because it's a direct promotion, whereas f(unsigned) is a conversion if int is available.
    \bigbreak \noindent 
    Consider
    \bigbreak \noindent 
    \begin{cppcode}
        void f(char x) { cout << "1"; }
        void f(short x) { cout << "2"; }
        f((bool)5); // Error: call to f is ambiguous
    \end{cppcode}
    \bigbreak \noindent 
    The function call f((bool)5); is ambiguous because both void f(char) and void f(short) are equally valid candidates based on integral promotions, and neither is strictly better than the other
    \bigbreak \noindent 
    This situation falls under conversion rank because bool is promoted to int first, and then int must be converted to either char or short, both of which have equal ranking in standard conversions.
    \bigbreak \noindent 
    promotions are a subset of standard conversions that always take precedence over regular conversions in overload resolution. A promotion only occurs when converting a smaller type to a larger type of the same category (integral or floating-point), without changing its fundamental nature.
    \bigbreak \noindent 
    Integral promotions occur when a smaller integer type is promoted to at least int or unsigned int. These promotions are preferred over standard conversions and are commonly used in arithmetic expressions, function calls, and overload resolution.








    \pagebreak 
    \unsect{Notes about static}
    \bigbreak \noindent 
    \subsection{Static variables inside member functions}
    \bigbreak \noindent 
    Static variables inside member functions behave the same as static variables in regular functions
    \bigbreak \noindent 
    \subsection{Using instances to call static methods}
    \bigbreak \noindent 
    We note that we can use instances to call static methods using the dot notation
    \bigbreak \noindent 
    \begin{cppcode}
        struct s{
            int x = 20;
            static void f() {
                cout << "static method" << endl;
            }
        };
        s::f();

        s S;
        S.f();
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Can you make pure virtual methods static?}
    \bigbreak \noindent 
    No, you cannot

    \bigbreak \noindent 
    \subsection{Inline Static methods?}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s{
            static void print() {} // Implicitly inline... Means
            static inline void print() {} // Exact same
        };
    \end{cppcode}
    \bigbreak \noindent 
    However, defining static methods outside the class does not make it implicitly inline
    \bigbreak \noindent 
    \begin{cppcode}
        struct s  {
            static void print();
        };
        void s::print() {} // Not inline
    \end{cppcode}
    \bigbreak \noindent 
    The inline keyword suggests that the function can be defined inside the header file (or within the struct/class definition) without violating the one-definition rule (ODR).
    \bigbreak \noindent 
    It is a hint to the compiler that function calls may be replaced with the actual function body to reduce function call overhead (though modern compilers decide this automatically).
    \bigbreak \noindent 
    More importantly, in this case, inline ensures that if the function is defined in a header file and included in multiple translation units, it does not cause multiple definition errors.
    \bigbreak \noindent 
    We can of course  still explicitly make the second version inline..
    \bigbreak \noindent 
    \begin{cppcode}
        struct s  {
            static void print();
        };
        inline void s::print() {} // Not inline
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Static and extern (linkage)}
    \bigbreak \noindent 
    Global variables without the use of the keyword static have external linkage. In other translation units that are compiled  with the file that has the global variable, we use the keyword \texttt{extern} to access it
    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    int x = 20;

    // File2.cpp
    extern int x; // Refers to x from file1.cpp
    \end{cppcode}
    \bigbreak \noindent 
    Declaring a global variable as static restricts its visibility to the current translation unit
    \bigbreak \noindent 
    If we declare a global variable static in on unit, we can get a separate copy in a different unit by declaring the same variable (with the same signature) and also using the keyword static
    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    static int x = 20;

    // File2.cpp
    static int x = 20; // File2 gets its own copy of x
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Using extern to declare a variable with the same name as a static variable from another translation unit}
    \bigbreak \noindent 
    If you use extern to declare a variable with the same name as a static variable from another translation unit, the linker will not find the definition of that variable, leading to a linker error (undefined reference). This is because static variables have internal linkage, meaning they are restricted to their translation unit and cannot be accessed from another file.
    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    static int x = 20;

    // File2.cpp
    extern int x; // Linker error
    \end{cppcode}
    
    \bigbreak \noindent 
    \subsubsection{Forgetting to use extern}
    \bigbreak \noindent 
    If you forget to put extern when declaring a global variable in another translation unit, the compiler will treat it as a new, separate definition rather than referring to an existing one. This can lead to multiple definition errors at the linking stage
    \bigbreak \noindent 
    \begin{cppcode}
    //  File1.cpp
    int x = 20;

    // File2.cpp
    int x; // Liner error: Multiple definition
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Forgetting to use keyword static}
    \bigbreak \noindent 
    \begin{cppcode}
        //  File1.cpp
        static int x = 20;

        // File2.cpp
        int x = 20; 
    \end{cppcode}
    \bigbreak \noindent 
    No errors for two units, file2 will simply make its own version of x with external linkage. If you add a third unit and forget to put static on that x as well, we would then get multiple definition errors.

    \bigbreak \noindent 
    \subsubsection{Constinit with extern}
    \bigbreak \noindent 
    constinit is only required in the definition (where the variable is actually allocated memory).
    \bigbreak \noindent 
    When using extern to refer to that variable in another translation unit, constinit is not necessary because extern simply tells the compiler that the variable is defined elsewhere.

    \bigbreak \noindent 
    \begin{cppcode}
    // File1.cpp
    constinit int x = 50;

    // File2.cpp
    extern int x;
    \end{cppcode}

    \pagebreak 
    \unsect{Trying to move const objects}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            string str{};

            s() = default;

            s(const string& other) {
                cout << "Copy constructor called" << endl;
                str = other;
            }

            s(string&& other) {
                cout << "Move constructor called " << endl;

            }
        };
        const string str = "Hello";
        s s1(std::move(str));
    \end{cppcode}
    \bigbreak \noindent 
    Something interesting happens, we get \textit{"Copy constructor called"}. A constant object cannot be moved because moving modifies the source object.
    \bigbreak \noindent 
    The move constructor requires an argument of type std::string\&\& (a temporary, non-const string).
    \bigbreak \noindent 
    However, std::move(str) produces a const std::string\&\& (rvalue reference to const), which cannot be passed to the move constructor because the move constructor expects a non-const rvalue reference (string\&\&).
    \bigbreak \noindent 
    \begin{cppcode}
        s(const string& other) {   // (1) Copy constructor
            cout << "Copy constructor called" << endl;
            str = other;
        }

        s(string&& other) {        // (2) Move constructor
            cout << "Move constructor called" << endl;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Since std::move(str) produces const std::string\&\&, it cannot bind to (2) s(string\&\&), because the move constructor does not accept const.
    \bigbreak \noindent 
    Instead, s(const string\&) (the copy constructor) is selected, because it can accept a const std::string\&.
    \bigbreak \noindent 
    This is one reason why we have const in the copy constructor, if the copy constructors argument was not const, we would get an error trying to move the const object.

    \pagebreak 
    \unsect{Smart pointers in conjunction with raw ptrs}
    \subsection{Shared\_ptr with raw ptrs}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
    int x = 50;
    std::shared_ptr<int> ptr = std::make_shared<int>(50);
    \end{cppcode}
    \bigbreak \noindent 
    What happens if we do
    \bigbreak \noindent 
    \begin{cppcode}
        int* ptr2 = &(*ptr);
    \end{cppcode}
    \bigbreak \noindent 
    Will it increase the reference count? No it does not
    \bigbreak \noindent 
    \begin{cppcode}
        cout << ptr.use_count() << endl; // 1
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Unique\_ptr with raw ptrs}
    \bigbreak \noindent 
    What if we do
    \bigbreak \noindent 
    \begin{cppcode}
        std::unique_ptr<int> ptr = std::make_unique<int>(50);
        int* ptr2 = &(*ptr);
    \end{cppcode}
    \bigbreak \noindent 
    Does this even work? Yes, this works perfectly fine. *ptr dereferences the std::unique\_ptr<int>, retrieving the integer it owns. \&(*ptr) takes the address of that integer, effectively obtaining a raw pointer to the managed object.
    \bigbreak \noindent 
    If ptr2 is used only within the scope where ptr exists and is valid, it's generally fine
    \bigbreak \noindent 
    If ptr is reset or goes out of scope, ptr2 becomes a dangling pointer, leading to undefined behavior

    \pagebreak 
    \unsect{Calling delete on a nullptr}
    \bigbreak \noindent 
     Calling delete on a nullptr is perfectly safe and has no effect.
     \bigbreak \noindent 
     The delete operator first checks whether the pointer is nullptr. If the pointer is nullptr, delete does nothing and returns immediately.
     \bigbreak \noindent 
    This behavior ensures that you don’t have to explicitly check for nullptr before calling delete.

    \pagebreak 
    \unsect{Notes about short circuits}
    \bigbreak \noindent 
    Short-circuiting in C++ refers to the behavior of logical operators (&& and ||) where the second operand is not evaluated if the result of the entire expression can be determined from the first operand alone.
    \bigbreak \noindent 
    \subsection{With ands}
    \bigbreak \noindent 
    Consider the following code
    \bigbreak \noindent 
    \begin{cppcode}
        bool foo() {
            cout << "Foo" << endl;
            return false;
        }

        bool bar() {
            cout << "bar" << endl;
            return true;
        }

        if (foo() && bar()) // "Foo"
    \end{cppcode}
    \bigbreak \noindent 
    The bar function never gets called because when the foo function returns, the if statement "short-circuits" and exits. If we want to prevent short circuiting, we use a bitwise and $(\&)$
    \bigbreak \noindent 
    \begin{cppcode}
    if (foo() & bar()) // Foo\n bar
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{With ors}
    \bigbreak \noindent 
    Similarly, 
    \bigbreak \noindent 
    \begin{cppcode}
        bool foo() {
            cout << "Foo" << endl;
            return true;
        }

        bool bar() {
            cout << "bar" << endl;
            return true;
        }

        if (foo() || bar()) // Foo
    \end{cppcode}
    \bigbreak \noindent 
    We again just get "Foo". When the foo function returns true, the if statement is automatically true and again we get a short circuit, which leads to bar never getting called.  If we want to prevent short circuiting with ors, we use bitwise or (|)
    \bigbreak \noindent 
    \begin{cppcode}
    if (foo() | bar()) // Foo\n bar
    \end{cppcode}

    \pagebreak 
    \unsect{Notes about types}
    \bigbreak \noindent 
    \begin{itemize}
        \item bool
        \item char (unsigned and signed)
        \item short (unsigned and signed)
        \item int (unsigned and signed)
        \item long (unsigned and signed)
        \item long long (unsigned and signed)
    \end{itemize}

    \pagebreak 
    \unsect{Notes about inline functions}
    \bigbreak \noindent 
    Recall that an inline function in C++ is a function that is expanded in place where it is called, rather than executing a traditional function call. This is a compiler directive that can reduce function call overhead and potentially improve performance.
    \bigbreak \noindent 
    When a function is declared as inline, the compiler replaces the function call with the actual function definition (code) at compile time. This eliminates the overhead of a function call, such as:
    \begin{itemize}
        \item Pushing arguments onto the stack.
        \item Jumping to the function's memory location.
        \item Returning to the caller.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Advantages:}
    \begin{itemize}
        \item \textbf{Eliminates Function Call Overhead}: Since the function code is directly inserted at the call site, there is no function call overhead.
        \item \textbf{Faster Execution}: If the function is small, inlining can make the program faster.
        \item \textbf{Useful for Small, Repeated Functions}: It is particularly useful for small functions that are frequently called (e.g., getter functions in classes).
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Disadvantages}:
    \begin{itemize}
        \item \textbf{Increased Binary Size (Code Bloat)}: If a function is large and used in multiple places, its repeated expansion increases the binary size.
        \item \textbf{Decreased Cache Efficiency}: More inline code means a larger executable, which may lead to poor instruction cache performance.
    \end{itemize}
    \bigbreak \noindent 
    Note that inlining is a suggestion, not a command, The compiler may ignore the inline keyword if the function is too complex.

    \bigbreak \noindent 
    \subsection{Inline functions in the context of multiple translation units}
    \bigbreak \noindent 
    In C++, a program can consist of multiple translation units, where each source file (.cpp) and its included headers form a separate unit compiled independently before linking. Using inline functions across multiple translation units can help avoid multiple definition errors.
    \bigbreak \noindent 
    When defining a function in a header file (.h), multiple source files (.cpp) including the header may result in multiple definitions of the function
    \bigbreak \noindent 
    When compiled separately and linked together, the linker will complain about multiple definitions of square(int) because each translation unit includes its own separate copy.
    \bigbreak \noindent 
    The inline keyword tells the compiler that multiple identical definitions of the function are allowed across translation units, and they should be merged.
    \bigbreak \noindent 
    Normally, functions with external linkage (int square(int)) violate the One Definition Rule (ODR) when included in multiple translation units.
    \bigbreak \noindent 
    Marking the function inline allows the linker to consolidate multiple instances into one.
    \bigbreak \noindent 

    \bigbreak \noindent 
    \subsection{Class/Struct methods are implicitly inline}
    \bigbreak \noindent 
    Since it is common to define classes or structs in header files, the c++ compiler makes all methods inline to avoid violation of the one definition rule (ODR)

    \pagebreak 
    \unsect{Notes about object creation}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A{
            A() { cout << 'a'}
            ~A() { cout << 'A'}
        };

        struct B {
            B() {cout << 'b'}
            ~B() {cout << 'B'}
            A a;
        };

        int main() {B b;} // abBA
    \end{cppcode}
    \bigbreak \noindent 
    Member variables are initialized before the constructor is called. The destructor is called before member variables are destroyed.

    \bigbreak \noindent 
    \subsection{Default initialize const object (const default constructible)?}
    \bigbreak \noindent 
    Consider
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            A() = default;
            int i;
        } ;
        const A a;
    \end{cppcode}
    \bigbreak \noindent 
    We actually get an error here: Default initialization of an object of const type 'const A' without a user provided default constructor
    \bigbreak \noindent 
    A class type T is const-default-constructible if default-initialization of T would invoke a user-provided constructor of T (not inherited from a base class)


    \pagebreak 
    \unsect{What is a "function signature"}
    \bigbreak \noindent 
    a function signature refers to the combination of components that uniquely identify a function within a given scope. However, different contexts use "function signature" to mean slightly different things.
    \bigbreak \noindent 
    When the compiler determines whether two functions are overloaded (i.e., different functions in the same scope), it considers:
    \bigbreak \noindent 
    \begin{itemize}
        \item Function name
        \item Parameter types (including order and const qualifiers on parameters)
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Function Signature (Overriding Perspective)}
    \bigbreak \noindent 
    When dealing with function overriding in a derived class, the function signature must exactly match the base class function's:
    \begin{itemize}
        \item return types
        \item Function name
        \item Parameter types (including order and const/reference qualifiers)
        \item const qualifier (for member functions)
        \item Volatile qualifier (volatile if present)
        \item Ref-qualifier (\& or \&\&)
    \end{itemize}
    \bigbreak \noindent 
    While return types are not part of the function signature in the overloading perspective, they are in the overriding perspective
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            virtual void print() const {}
        };
        struct k : s {
            int print() const override {} // Error: Return type must match the overridden function
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{What is NOT Part of a Function Signature? }
    \bigbreak \noindent 
    The following do not contribute to a function’s signature:
    \begin{itemize}
        \item \textbf{Return type}: Functions cannot be overloaded solely by differing return types.
        \item \textbf{Default arguments}: Default arguments are resolved at compile time, so they are not part of the function signature.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Note:} Even if parameter types are aliased, they resolve to the same type and do not create a different signature.

    \bigbreak \noindent 
    \subsection{noexcept?}
    \bigbreak \noindent 
    The noexcept specifier is part of the function signature for function overloading but not for overriding.

    \pagebreak 
    \unsect{Maximal munch principle}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
    int a=5, b=2; 
    cout << a+++++b; // ERROR
    \end{cppcode}
    \bigbreak \noindent 
    Why is this an error? Why is it not simply \texttt{a++ + ++b} = 8? The Maximal Munch Principle is a rule used in lexical analysis (tokenization) to determine how to group characters into tokens. It states: \textit{Always consume the longest possible sequence of characters that form a valid token.}
    \bigbreak \noindent 
    When scanning input text, the lexer tries to form the longest valid token at each step before moving on. This avoids ambiguity in tokenization. So after parsing a++, it is not allowed to just parse +, it has to parse ++. The sequence is thus parsed as:
    \bigbreak \noindent 
    \begin{cppcode}
    a ++ ++ + b
    \end{cppcode}
    which is ill-formed since post-increment requires a modifiable lvalue but the first post-increment will produce a prvalue

    \pagebreak 
    \unsect{What happens if a noexcept function throws an exception?}
    \bigbreak \noindent 
    If a function is declared noexcept but still throws an exception, the program immediately terminates by calling std::terminate(). This behavior exists to enforce the contract that noexcept functions are not supposed to throw.
    \bigbreak \noindent 
    noexcept functions promise not to throw. The compiler and standard library rely on this assumption. If a noexcept function throws, continuing execution would violate the contract and lead to undefined behavior. Instead of allowing UB, C++ forces a hard fail by calling std::terminate().
    \bigbreak \noindent 
    If a noexcept function must perform an operation that might throw, you need to catch exceptions inside the function and handle them before returning.



    \pagebreak 
    \unsect{Exception propogation}
    \bigbreak \noindent 
    When an exception propagates, it means that the exception is not handled in the current function and is instead passed up the call stack until it reaches a function that can handle it (i.e., a function with a try-catch block). If no function catches the exception, the program terminates.
    \bigbreak \noindent 
    When an exception is thrown using throw, control is immediately transferred to the nearest matching catch block in the call stack.
    \bigbreak \noindent 
    \begin{cppcode}
    void foo() {
        throw std::runtime_error("Error in foo");
    }

    void bar() {
        foo();  // No try-catch here, so the exception propagates
    }

    int main() {
        try {
            bar();  // Calls bar(), which calls foo()
        } catch (const std::runtime_error& e) {
            std::cout << "Caught exception: " << e.what() << '\n';
        }
    }
\end{cppcode}

\pagebreak 
\unsect{The catch all exception handler (...)}
\bigbreak \noindent 
In C++, catch (...) is a catch-all exception handler, meaning it catches any exception, regardless of its type. It is useful when you want to handle or log exceptions without knowing their exact type.
\bigbreak \noindent 
\begin{cppcode}
    try {
        someFunction();
    } catch (...) {
        std::cerr << "An unknown exception occurred!\n";
    }
\end{cppcode}


\pagebreak 
\unsect{A typedef cannot be a template}
\bigbreak \noindent 
We must use a \textit{using} directive instead


\pagebreak 
\unsect{Return value optimization}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    struct E
    {
        E() { std::cout << "1"; }
        E(const E&) { std::cout << "2"; }
        ~E() { std::cout << "3"; }
    };

    E f()
    {
        return E();
    }

    int main()
    {
        f(); // 13 (no copy constructor called)
    }
\end{cppcode}
\bigbreak \noindent 
The copy constructor isn't called because of a compiler optimization known as copy elision (specifically, Return Value Optimization or RVO). In this case, the temporary E() object is constructed directly in the location where the return value of the function f() resides, so no copy (or move) constructor call is needed. This optimization is allowed (and in some cases mandated in C++17 and later) by the C++ standard.
\bigbreak \noindent 

\pagebreak 
\unsect{Using function templates in multiple files}
\bigbreak \noindent 
Consider the following program, which doesn’t work correctly:
\bigbreak \noindent 
\begin{cppcode}
    // main.cpp:
    #include <iostream>

    template <typename T>
    T addOne(T x); // function template forward declaration

    int main() {
        std::cout << addOne(1) << '\n';
        std::cout << addOne(2.3) << '\n';

        return 0;
    }

    // add.cpp
    template <typename T>
    T addOne(T x) // function template definition
    {
        return x + 1;
    }
\end{cppcode}
\bigbreak \noindent 
If addOne were a non-template function, this program would work fine: In main.cpp, the compiler would be satisfied with the forward declaration of addOne, and the linker would connect the call to addOne() in main.cpp to the function definition in add.cpp.
\bigbreak \noindent 
But because addOne is a template, this program doesn’t work, and we get a linker error:
\bigbreak \noindent 
In main.cpp, we call addOne<int> and addOne<double>. However, since the compiler can’t see the definition for function template addOne, it can’t instantiate those functions inside main.cpp. It does see the forward declaration for addOne though, and will assume those functions exist elsewhere and will be linked in later.
\bigbreak \noindent 
When the compiler goes to compile add.cpp, it will see the definition for function template addOne. However, there are no uses of this template in add.cpp, so the compiler will not instantiate anything. The end result is that the linker is unable to connect the calls to addOne<int> and addOne<double> in main.cpp to the actual functions, because those functions were never instantiated.
\bigbreak \noindent 
If add.cpp had instantiated those functions, the program would have compiled and linked just fine. But such solutions are fragile and should be avoided:
\bigbreak \noindent 
The most conventional way to address this issue is to put all your template code in a header (.h) file instead of a source (.cpp) file
\bigbreak \noindent 
\begin{cppcode}
// add.h
#ifndef ADD_H
#define ADD_H

template <typename T>
T addOne(T x) // function template definition
{
    return x + 1;
}

#endif
// main.cpp
#include "add.h" // import the function template definition
#include <iostream>

int main()
{
    std::cout << addOne(1) << '\n';
    std::cout << addOne(2.3) << '\n';

    return 0;
}
\end{cppcode}
\bigbreak \noindent 
That way, any files that need access to the template can #include the relevant header, and the template definition will be copied by the preprocessor into the source file. The compiler will then be able to instantiate any functions that are needed.
\bigbreak \noindent 
You may be wondering why this doesn’t cause a violation of the one-definition rule (ODR). The ODR says that types, templates, inline functions, and inline variables are allowed to have identical definitions in different files. So there is no problem if the template definition is copied into multiple files (as long as each definition is identical).
\bigbreak \noindent 
But what about the instantiated functions themselves? If a function is instantiated in multiple files, how does that not cause a violation of the ODR? The answer is that functions implicitly instantiated from templates are implicitly inline. And as you know, inline functions can be defined in multiple files, so long as the definition is identical in each.

\pagebreak 
\unsect{Review of access modifiers in inheritance}
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{Public:} Public members of the base class remain public in the derived class.
        \bigbreak \noindent 
        Protected members remain protected.
        \bigbreak \noindent 
        Private members are not accessible directly by the derived class (though they are still part of the object).
    \item \textbf{Protected:}
        Both public and protected members of the base class become protected in the derived class.
        \bigbreak \noindent 
        Private members remain inaccessible.
    \item \textbf{Private:}
        Both public and protected members of the base class become private in the derived class.
        \bigbreak \noindent 
        Private members remain inaccessible.
\end{itemize}
\bigbreak \noindent 
Recall what it means to be protected
\begin{itemize}
    \item \textbf{Within the class:} The protected member is accessible just like a private member.
    \item \textbf{Outside the class hierarchy:} The protected member is not accessible from code that is not part of the class or its descendants.
    \item \textbf{In derived classes:} The protected member is accessible to any class that inherits from the base class.
\end{itemize}

\pagebreak 
\unsect{Notes about the conditional operator}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        A() { std::cout << "a"; }

        void foo() { std::cout << "1"; }
    };

    struct B {
        B() { std::cout << "b"; }
        B(const A&) { std::cout << "B"; }

        void foo() { std::cout << "2"; }
    };

    auto L(auto flag) {
        return flag ? A{} : B{};
    }
    L(true).foo();
    L(false).foo();
\end{cppcode}
\bigbreak \noindent 
We get the output \texttt{aB2b2}. The conditional operator in \texttt{L} has two branches that return different types: one returns an A and the other a B. However, the conditional operator requires both branches to have a common type. Since B has a converting constructor B(const A\&), the A{} in the true branch is converted to a B.
\bigbreak \noindent 
Thus, L always returns a B object. When the function is called with the argument flag set to true, a temporary $A$ is constructed, converted to $B$, then $B.foo()$ is called. When the function is called with flag set to false, B is constructed and B.foo() is called. Thus, the output is $aB2b2$
\bigbreak \noindent 
So what happens if we remove the converting constructor in $B$?
\bigbreak \noindent 
\begin{cppcode}
auto L(auto flag) {
    return flag ? A{} : B{};
}
L(true);
\end{cppcode}
\bigbreak \noindent 
We get an error: incompatible operand types

\pagebreak 
\unsect{Notes about CTAD (Class template argument deduction)}
\bigbreak \noindent 
CTAD does not consider user-defined conversions (Conversions provided by conversion constructors or conversion operators defined by a user) during deduction
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
void call_with(std::function<void(T)> f, T val) {
    f(val);
}
auto print = [] (int x) { std::cout << x; };
call_with(print, 42)
\end{cppcode}
\bigbreak \noindent 
the lambda print has a unique, unnamed type—not std::function<void(int)>. Even though it can be converted to std::function<void(int)> (since it has a matching operator()), that conversion is a user‐defined conversion, and such conversions are not considered during template argument deduction.
\bigbreak \noindent 
One way to resolve this would be 
\begin{cppcode}
    call_with<int>(print, 42);
\end{cppcode}
\bigbreak \noindent 
When you write call\_with<int>(print, 42);, you're explicitly specifying that T is int.
\bigbreak \noindent 
At this point, the compiler already knows that it needs a std::function<void(int)> for the first parameter. Now, when you pass the lambda print, the compiler sees that print is convertible to std::function<void(int)> via a user-defined conversion (using the converting constructor of std::function). Since the template argument is already fixed as int, the conversion is allowed during the normal overload resolution and conversion process.
\bigbreak \noindent 
In summary, explicitly specifying T bypasses the template argument deduction phase. Therefore, the compiler doesn't have to deduce T by matching the lambda to std::function<void(T)> (which would fail because user-defined conversions aren't considered during deduction). Instead, it only needs to check that the lambda can be converted to the already specified type std::function<void(int)>, and that conversion works as expected.

\bigbreak \noindent 
\subsection{const vs non-const template parameters}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
void foo(T& x)
{
    std::cout << std::is_same_v<const int, T>;
}

template <typename T>
void bar(const T& x)
{
    std::cout << std::is_same_v<const int, T>;
}
const int i{};
int j{};

foo(i);
foo(j);
bar(i);
bar(j);
\end{cppcode}
\bigbreak \noindent 
We get 1000.
\bigbreak \noindent 
In a function like:
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
void foo(T& x)
{
    // ...
}
\end{cppcode}
\bigbreak \noindent 
the type T is deduced to match the argument exactly.
\begin{itemize}
    \item If you pass a const int, T becomes const int.
    \item If you pass an int, T becomes int.
\end{itemize}
\bigbreak \noindent 
In a function like
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
void bar(const T& x)
{
    // ...
}
\end{cppcode}
\bigbreak \noindent 
the const in the parameter (const T\&) applies to the entire parameter but is not used in deducing T. This means:
\begin{itemize}
    \item Whether you pass a const int or an int, T is deduced as int.
\end{itemize}
\bigbreak \noindent 
During template argument deduction, the compiler examines the argument type and tries to determine what T must be. With a parameter of type const T\&, the compiler looks at the underlying type of the argument without taking the const in the parameter into account.

\pagebreak 
\unsect{Strong types}
\bigbreak \noindent 
A strong type is a type that enforces strict type safety by not allowing implicit conversions to or from its underlying type. This means that even if a strong type wraps a primitive type (like an int or double), it won't automatically convert to that primitive type or another type without an explicit conversion. This helps prevent accidental mixing of types that represent different concepts.
\bigbreak \noindent 
\begin{cppcode}
    struct Meter {
        explicit Meter(int v) : value(v) {}  // Explicit constructor
        int value;
    };
    Meter m(10); // Ok
    Meter k=5; // Int cannot be implicitly converted to Meter, must be explicit
    Meter r=static_cast<Meter>(5);  // Ok
\end{cppcode}
\bigbreak \noindent 
C++11 introduced enum classes, which are also an example of strong types. Unlike traditional enums, enum classes do not implicitly convert to integers:
\bigbreak \noindent 
\begin{cppcode}
    enum E {x,y,z};
    E e = x; // Works fine
    int x = e; // Works fine
\end{cppcode}

\bigbreak \noindent 
\begin{cppcode}
    enum class E {x,y,z};
    E e = E::x; // Works fine
    int x = e; // No implicit conversion, must be explicit
    int y = static_cast<int>(e); 
\end{cppcode}

\bigbreak \noindent 
\subsection{Why Use Strong Types?}
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{Type Safety:} They prevent mixing up logically different values (like meters vs. seconds) that might have the same underlying type.
    \item \textbf{Code Clarity:} They make the programmer’s intent explicit, reducing the chance of bugs.
    \item \textbf{Maintenance:} They help document the domain model of your application, making the code easier to understand and maintain.
\end{itemize}


\bigbreak \noindent 
\subsection{Strong typing in regards to readability}
\bigbreak \noindent 
Consider the following example
\bigbreak \noindent 
\begin{cppcode}
struct Car {
    Car(int horsepower, int nDoors, bool isAutomatic, bool isElectric)  : horsepower(horsepower), nDoors(nDoors), isAutomatic(isAutomatic), isElectric(isElectric) {}
    int horsepower, nDoors;
    bool isAutomatic, isElectric;
};
Car c1(400,4,true, false);
\end{cppcode}
\bigbreak \noindent 
So whats the problem? If the class definition were far away, we would need to take the time to look at it to figure out what the argument list in the instantiation means. Instead, we can enforce strong typing.
\bigbreak \noindent 
A strong type in this context is a type that carries extra information, a specific meaning through its name
\bigbreak \noindent 
Regarding the example above, we could instead enforce strong typing
\begin{cppcode}
struct HorsePower {
    int horsePower{};
    HorsePower(int horsepower) : horsePower(horsepower) {}
};

struct Car {
    Car(HorsePower horsepower)  : horsepower(horsepower) {}
    HorsePower horsepower;
};
Car c1(HorsePower(400));
\end{cppcode}


\pagebreak 
\unsect{Argument dependent name lookup (Koenig lookup)}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
namespace x {
  class C {};
  void f(const C& i) {
    std::cout << "1";
  }
}

namespace y {
  void f(const x::C& i) {
    std::cout << "2";
  }
}
int main() {
    f(x::C());
}
\end{cppcode}
\bigbreak \noindent 
This outputs 1
\bigbreak \noindent 
Since the functions f are declared inside namespaces, and the call f(x::C()) is unqualified (not preceded by x:: or y::), this would normally not compile.
\bigbreak \noindent 
However, due to argument-dependent name lookup a.k.a. "Koenig lookup", the behavior is well-defined.
\bigbreak \noindent 
With argument-dependent name lookup, the namespaces of the arguments to a function is added to the set of namespaces to be searched for that function. Since we're passing an x::C to f, the namespace x is also searched, and the function x::f is found
\bigbreak \noindent 
If instead we have
\begin{cppcode}
    int main() {
        y::f(x::C());
    }
\end{cppcode}
\bigbreak \noindent 
We would get 2 as output.

\pagebreak 
\unsect{C vs c++ external linkage}
\bigbreak \noindent 
\subsection{C++ external linkage}
\bigbreak \noindent 
This is the default when we use the extern keyword
\bigbreak \noindent 
\begin{cppcode}
extern int x;
\end{cppcode}
\bigbreak \noindent 
Which means
\begin{itemize}
    \item \textbf{Name mangling:} The symbol for b might be mangled to include additional type and scope information.
    \item \textbf{C++ specific features:} This mangling supports function overloading and other C++ features.
\end{itemize}
\bigbreak \noindent 
Name mangling is the process by which C++ compilers encode extra information into the names of functions and variables. This extra information typically includes details like:
\begin{itemize}
    \item \textbf{Function parameters:} To distinguish between overloaded functions.
    \item \textbf{Namespaces or class membership:} So that functions or variables in different scopes (like classes or namespaces) have unique names.
    \item \textbf{Other attributes:} Such as constness, etc.
\end{itemize}
\bigbreak \noindent 
when you define overloaded functions
\bigbreak \noindent 
\begin{cppcode}
int add(int a, int b);
double add(double a, double b);
\end{cppcode}
\bigbreak \noindent 
the compiler transforms (or "mangles") these names into unique symbols internally (e.g., something like \_Z3addii for the first function and \_Z3adddd for the second) so that the linker can differentiate between them. This process is essential for supporting C++ features that are not present in C, which does not allow function overloading and thus doesn't need name mangling.

\bigbreak \noindent 
\subsection{C external linkage}
\bigbreak \noindent 
We could also do
\bigbreak \noindent 
\begin{cppcode}
extern "C" int x;
\end{cppcode}
\bigbreak \noindent 
Which tells the compiler that the variable a should use C linkage. This means
\begin{itemize}
    \item \textbf{No name mangling:} The symbol for a will have the plain C name.
        \bigbreak \noindent 
        The compiler is instructed to leave the name unmangled. The symbol in the object file for a remains simply a and for add it remains exactly add
        \bigbreak \noindent 
        This is crucial when linking C++ code with C code. C does not support name mangling (since it doesn’t have function overloading), so the symbols need to match exactly between the C library and your C++ code.
    \item \textbf{C calling convention:} When used with functions (though here it’s a variable), it would use the C calling convention.
        \bigbreak \noindent 
        The calling convention defines how functions receive parameters, return values, and how the call stack is managed. It covers aspects like:
        \begin{itemize}
            \item \textbf{Order of parameter passing:} Right-to-left vs. left-to-right.
            \item \textbf{Who cleans up the stack:} The caller or the callee.
            \item \textbf{Register usage:} Which registers are used for passing parameters.
        \end{itemize}
    \item \textbf{Interoperability:} It can be linked with C code that expects a symbol named exactly a.
        \bigbreak \noindent 
        By using extern "C", your C++ code can directly link to and use C libraries. This interoperability is essential when integrating legacy C code with newer C++ codebases or when using system libraries written in C.
\end{itemize}
\bigbreak \noindent 
Consider the following example
\bigbreak \noindent 
\begin{cppcode}
    namespace A{
        extern "C" int x;
    };

    namespace B{
        extern "C" int x;
    };

    int A::x = 0;

    int main(){
        std::cout << B::x;
        A::x=1;
        std::cout << B::x;
    }
\end{cppcode}
\bigbreak \noindent 
Due to the extern "C" specifications, A::x and B::x actually refer to the same variable.
\bigbreak \noindent 
x is first initialized to 0, then main() starts, 0 is printed, x is incremented to 1, and finally 1 is printed.

\pagebreak 
\unsect{Who cleans up the call stack, the caller or the callee}
\bigbreak \noindent 
It depends on the calling convention. With the most common cdecl calling convention used in many C++ environments, the caller is responsible for cleaning up the call stack after the function call. However, if a function uses a calling convention like stdcall, then the callee cleans up the stack before returning.
\bigbreak \noindent 
So, in standard C++ using cdecl, the caller cleans up the stack, but this can vary with different calling conventions.


\pagebreak 
\unsect{Notes about sizeof}
\bigbreak \noindent 
\subsection{non types in sizeof?}
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
cout << sizeof(1); //4
cout << sizeof(1.0); // 8
short x = 5;
cout << sizeof(x); // 2
\end{cppcode}
\bigbreak \noindent 
In C++, the sizeof operator is evaluated at compile time and it inspects the type of its operand rather than evaluating the operand itself. This means that it doesn’t matter whether you pass an lvalue or an rvalue.

\bigbreak \noindent 
\subsection{No side effects?}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    int x = 5;
    cout << sizeof(++x) << endl;
    cout << x; // 5
\end{cppcode}
\bigbreak \noindent 
Why is $x$ not changed?  sizeof is computed during compilation. No code is executed to determine its value, which means even if the operand has side effects, those side effects will not occur.

\bigbreak \noindent 
\subsection{What is the output?}
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
    int n = sizeof(0)["abcdefghij"];
    std::cout << n; // 1
\end{cppcode}
\bigbreak \noindent 
First, recall the sizeof is an operator, not a function. Sizeof(0) = sizeof  0. Since the subscript operator has higher precedence over the sizeof operator, what we get is
\bigbreak \noindent 
\begin{cppcode}
    sizeof 0["abcdefghi"]
\end{cppcode}
\bigbreak \noindent 
Which is
\bigbreak \noindent 
\begin{cppcode}
    sizeof(0["abcdefghi"])
\end{cppcode}
\bigbreak \noindent 
Which is
\bigbreak \noindent 
\begin{cppcode}
sizeof(a) // Char is 1 byte
\end{cppcode}

\pagebreak 
\unsect{Parenthesized declarators}
\bigbreak \noindent 
Consider the following code
\bigbreak \noindent 
\begin{cppcode}
    int main() {
        int(myint) = 10; 
        // Equivalent to
        int myint = 10;
    }
\end{cppcode}
\bigbreak \noindent 
This syntax is perfectly legal to create an int named \texttt{myint}, although some warnings will show up about redundant parenthesis. This syntax is just
\bigbreak \noindent 
\begin{cppcode}
int (myint) = 10;
\end{cppcode}
\bigbreak \noindent 
Without the space after \texttt{int}. With this concept in mind, examine the following code
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        A() {cout << "1";}
        A(const A& other) { cout << "2"; }
    } object;

    int main() {
        A(object);
    }
\end{cppcode}
\bigbreak \noindent 
We get output: 11, the copy constructor is not called, because in main we are creating a new A object named object, which will shadow the global one
\bigbreak \noindent 
Note that if we had a constructor that took a value, the compiler will try to use that constructor
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        int x{};   
        A(int x) : x(x) {}
    };
    A(object); // Error: No matching constructor
\end{cppcode}

\pagebreak 
\unsect{Notes about classes and member variables}
\bigbreak \noindent 
\subsection{Const member variable assigned in constructor?}
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
    struct A{
        const int x;
        A(int x) : x(x) {}
    };
\end{cppcode}
\bigbreak \noindent 
This works just fine. Although in a function that is not a constructor, it will not.
\bigbreak \noindent 
\begin{cppcode}
    void setX(int y) {
        x = y; // Error x is const-qualified
    }
\end{cppcode}
\bigbreak \noindent 
In C++, const member variables must be initialized at the time of object creation rather than being assigned to later. The constructor’s initializer list (the part after the colon in the constructor) is specifically designed for this purpose. When you write:
\bigbreak \noindent 
\begin{cppcode}
A(int x) : x(x) { 
    cout << "Constructed A object with x = " << x << endl; 
}
\end{cppcode}
\bigbreak \noindent 
you aren’t performing an assignment inside the constructor body; instead, you’re initializing the const member x directly with the value provided as an argument. This initialization is allowed even though x is const, because once it’s set during construction, its value cannot be changed thereafter
\bigbreak \noindent 
\textbf{Note:} Trying to assign x inside the body of the constructor will fail
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        const int x = 12;
        A(int y) { 
            x = y; // Error: x is const-qualified
            cout << "Constructed A object with x = " << x << endl; 
        } 
    };
\end{cppcode}

\pagebreak 
\unsect{What is the type of a string literal?}
\bigbreak \noindent 
Of type const char*

\pagebreak 
\unsect{Notes about const\_cast}
\bigbreak \noindent 
\subsubsection{Dangers of trying to modify string literals (const char*)}
\bigbreak \noindent 
Consider the following code
\bigbreak \noindent 
\begin{cppcode}
    char* a = const_cast<char*>("Hello");
    a[4] = '\0';
    std::cout << a;
\end{cppcode}
\bigbreak \noindent 
So we have this const char* string literal "Hello", and we store it in a char* by const casting the constness away. Then, we try to modify it. 
\bigbreak \noindent 
Modifying the contents pointed to by a would result in undefined behavior because string literals are usually stored in read-only memory.

\bigbreak \noindent 
\subsection{const\_cast is UB example}
\bigbreak \noindent 
Consider the code

\pagebreak 
\unsect{Notes about friend functions}
\bigbreak \noindent 
\subsection{Recall friend}
\bigbreak \noindent 
In C++, the friend keyword is used within a class to grant non-member functions or other classes access to its private and protected members. This can be particularly useful when you want a function or another class to have access to the internals of your class without making those members public.
\begin{itemize}
    \item \textbf{Friend Function:} A non-member function can be declared as a friend inside a class. This function, although not a member of the class, can access the class's private and protected members.
    \item \textbf{Friend Class:} You can declare an entire class as a friend. Every member of that friend class will have access to the private and protected members of the class that declares the friendship.
    \item \textbf{Encapsulation Consideration:} Using the friend keyword is a deliberate break of encapsulation. It should be used sparingly and only when necessary to allow closely related classes or functions to interact efficiently.
    \item \textbf{Not Inherited:} Friendship is not inherited. If Class A declares Class B as a friend, and Class C inherits from A, Class B is not automatically a friend of Class C.
\end{itemize}


\bigbreak \noindent 
\subsubsection{Friend functions}
\bigbreak \noindent 
\begin{cppcode}
    class A {
        public:
        A(int x) : x(x) {}
        private:
        int x{};
        friend void print(const A& obj); 
    };

    void print(const A& obj) {
        cout << obj.x << endl;
    }
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Friend class}
\bigbreak \noindent 
\begin{cppcode}
    class B;

    class A {
        public:
        A(int x) : x(x) {}
        private:
        int x{};
        friend B;
    };

    class B {
        public: 
        void print(const A& a) {
            cout << a.x << endl;
        }
    };
    A a(10);
    B aObserver{};
    aObserver.print(a);
\end{cppcode}
\bigbreak \noindent 
Note that we can also remove the forward declare and just do \texttt{friend class B}
\bigbreak \noindent 
\begin{cppcode}
    class A; // Forward declaration for A (needed for B)

    class B {
        public:
        void print(const A& a); // Declare print here.
    };

    class A {
        public:
        A(int x) : x(x) {}
        private:
        int x{};
        friend void B::print(const A& a);  // Now the compiler knows B::print exists.
    };

    void B::print(const A& a) {
        cout << a.x << endl;
    }
\end{cppcode}

\pagebreak 
\unsect{What is the value of argv[argc]?}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    int main(int argc, char** argv) {
        cout << boolalpha << (argv[argc] == nullptr);
    }
\end{cppcode}
\bigbreak \noindent 
We get true... The standard states that the value of argv[argc] shall be 0.

\pagebreak 
\unsect{Notes about const}
\bigbreak \noindent 
\subsection{Returning const?}
\bigbreak \noindent 
Consider the function
\bigbreak \noindent 
\begin{cppcode}
    const int f() {
        const int x = 10;
        return x;
    }
\end{cppcode}
\bigbreak \noindent 
When you call the function, you receive a temporary object of type const int. This means you can’t directly modify the temporary (e.g., writing f() = 30; would be illegal).
\bigbreak \noindent 
If you assign the result of the function to a non-const variable, the const qualifier is not carried over. For example:
\bigbreak \noindent 
Since the function returns a copy, marking it as const doesn’t protect any underlying data. It only prevents modifications on the temporary object itself before it’s used to initialize another variable.
\bigbreak \noindent 
Imagine that you buy a house but you cannot modify it? While
there can be special cases, in general, you want your house to be
your castle. Similarly, you want your copy to really be your object
and you want to be able to do with it just whatever as an owner of
it.
\bigbreak \noindent 
It doesn’t make sense and it’s misleading to return by value a const object
\bigbreak \noindent 
Also, returning by value a const object will not allow the compiler to perform the RVO where the temporary is moved instead of copied, since a move would modify the temporary
\bigbreak \noindent 
Using const in the return type by value is generally discouraged because it can interfere with move semantics and does not provide additional safety benefits. It’s more common and useful to use const when returning by reference, where you want to prevent the caller from modifying the original object
\bigbreak \noindent 
\begin{cppcode}
    const int& f(const int& x) {
        return x;
    }
    int x = 20;
    int& y = f(x); // Error: cannot drop const qualifier
\end{cppcode}

\bigbreak \noindent 
\subsection{is\_const\_v}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
std::cout << std::is_const_v<const int *>
              << std::is_const_v<const int [1]>
              << std::is_const_v<const int **>
              << std::is_const_v<const int (*)[1]>
              << std::is_const_v<const int *[1]>
              << std::is_const_v<const int [1][1]>;
\end{cppcode}
We get 010001. The output is determined by how std::is\_const checks for a top‑level const qualification. In C++, a type’s const qualification is considered "top‑level" if it applies directly to the type rather than to something the type points to or contains
\bigbreak \noindent 
"An array type whose elements are cv-qualified is also considered to have the same cv-qualifications as its elements." Since the array's element type is const, the array type itself is also const


\pagebreak 
\unsect{Mixed type references}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    int a = '0';
    char const &b = a;
    std::cout << b;
    a++;
    std::cout << b;
\end{cppcode}
\bigbreak \noindent 
We get output 00. In C++, binding a const reference of a different type (in this case, a char const & to an int) does not bind the reference directly to the original variable. Instead, it creates a temporary object
\bigbreak \noindent 
Since a is an int and b is a char const \&, C++ performs an implicit conversion from int to char by creating a temporary char object holding the value '0'. The const reference b is then bound to this temporary object, not directly to a. The lifetime of this temporary is extended to match that of b.
\bigbreak \noindent 
Even after incrementing a, the temporary object (which b refers to) remains unchanged. Therefore, printing b twice results in "00".

\pagebreak 
\unsect{The types of literals and builtin suffixes}
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{Integer Literals:} The type of integral literals depend on the size of the literal. Small integral literals will be of type int, where as large values will be of type long or even unsigned long.
    \item \textbf{Floating-Point Literals}: A literal like 3.14 is of type double by default
    \item \textbf{Character literals}: A literal like 'a' is of type char, 
    \item \textbf{String Literals}: Are of type const char[] by default
    \item \textbf{Boolean literals}: (true/false) Of type bool, note that 1 and 0 are of type int
    \item \textbf{Nullptr literal}: of type std::nullptr\_t
\end{itemize}
\subsection{Suffixes}
\bigbreak \noindent 
For integrals,
\begin{cppcode}
42 // no suffix: int if it fits
42u // unsigned
42U // unsigned
42l // long
42L // long
42ll // long long
42LL // long long
\end{cppcode}
\bigbreak \noindent 
For floating point literals,
\bigbreak \noindent 
\begin{cppcode}
3.14 // No suffix: double
3.14f // float
3.14F // float
3.14l // long double
3.14L // long double
\end{cppcode}
\bigbreak \noindent 
For chars,
\bigbreak \noindent 
\begin{cppcode}
'a' // No suffix: char
L'a' // wchar_t
u'a' // utf-16 (char16_t)
U'a' // utf-32 (char32_t)
\end{cppcode}
\bigbreak \noindent 
For strings,
\bigbreak \noindent 
\begin{cppcode}
L"Hello" // Array of wchar_t
u8"hello" // UTF-8 encoded string (array of const char8_t)
u"hello" // UTF-16 (array of const char16_t)
U"hello" // UTF-32 (array of const char32_t)
\end{cppcode}

\pagebreak 
\unsect{Notes about perfect forwarding}
\bigbreak \noindent 
Consider the code with the unexpected results 
\bigbreak \noindent 
\begin{cppcode}
    void f(float &&) { std::cout << "f"; }
    void f(int &&) { std::cout << "i"; }

    template <typename... T>
    void g(T&&... v)
    {
        (f(v), ...);
    }
    g(1.0f, 1); // if
    g(1.0f, 1.2f); // ii
    g(1,1); // ff
\end{cppcode}
\bigbreak \noindent 
even though each parameter is declared as a forwarding (universal) reference (T\&\&), when you refer to a named parameter (here, “v”), it is an lvalue. That means that even if you pass an rvalue (like 1.0f or 1), inside g the variables v are lvalues.
\bigbreak \noindent 
The functions $f$ only accept rvalue arguments. Since the named parameters in g are lvalues, neither f(float\&\&) nor f(int\&\&) can bind directly. However, implicit conversion is available. For an lvalue of type float (coming from 1.0f):
\begin{itemize}
    \item It cannot bind to f(float\&\&) (because it’s an lvalue).
    \item It can convert to an long, which then binds to f(int\&\&) and prints "i".
\end{itemize}
\bigbreak \noindent 
Similarly, for an lvalue of type int (coming from 1):
\begin{itemize}
    \item It cannot bind to f(int\&\&).
    \item It converts to a float, binding to f(float\&\&) and printing "f".
\end{itemize}
\bigbreak \noindent 
To preserve the original value category and get the expected overload, you should forward the arguments:
\bigbreak \noindent 
\begin{cppcode}
    template <typename... T>
    void g(T&&... v) {
        (f(std::forward<decltype(v)>(v)), ...);
    }
\end{cppcode}
\bigbreak \noindent 
Since a named int (an lvalue) cannot bind directly to an rvalue reference like int\&\&, the f(int\&\&) overload is rejected. However, the compiler can perform an implicit conversion: it converts the int lvalue to a float, producing a prvalue (an rvalue) that can bind to f(float\&\&). That’s why an int ends up calling f(float\&\&) (printing "f").
\bigbreak \noindent 
Similarly, if you pass a float, it ends up converting to int for the other overload, because the float lvalue cannot bind to float\&\& directly, so it converts to an int prvalue to bind to f(int\&\&).

\pagebreak 
\unsect{lazy instantiation in templates}
\bigbreak \noindent 
Lazy instantiation means that the compiler defers generating the full definition of a template until it’s actually needed. 
\bigbreak \noindent 
When you write a template (like a class template), you're providing a blueprint. The compiler doesn’t generate code for that blueprint until you use it with a specific type in a context that requires the complete definition. For example, merely declaring a pointer to a template instantiation doesn’t force the compiler to instantiate its members.
\bigbreak \noindent 
This approach improves compile times by only generating code for the parts of the template that are actually used. It also allows you to write templates that can work with a broader range of types—even if some types would cause errors in unused parts of the template, they won’t be instantiated unless needed.
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
template<typename T>
struct A {
    static_assert(false);
};

A<int>* a; // does not cause static_assert to execute, since a is a pointer
\end{cppcode}

\pagebreak 
\unsect{Notes about initializer\_list}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        A () = default;
        A(const A& other) { cout << "Copied" << endl; }
    };
    void f(std::initializer_list<A> i) {}

    A a;
    std::initializer_list<A> i{a};
    f(i);
    f(i);
\end{cppcode}
\bigbreak \noindent 
So when we construct the initializer list i, we can imagine a temporary array of one C being created, where the element is copy-initialized. Since c is an lvalue, a copy is made (not for instance a move), and 1 is printed.
\bigbreak \noindent 
Then, f is called twice, taking the freshly created initializer\_list by value. So a copy of the initializer\_list is made for each call. Does that make a copy of the elements in the initializer list, as it would when taking for instance a vector or a list by value? No...
\bigbreak \noindent 
\begin{quote}
    Copying an initializer list does not copy the underlying elements.
\end{quote}
\bigbreak \noindent 
If you write an initializer list constructor for your class, never move the elements out of the initializer list. Even if you took it by value, you were not passed an exclusive copy of the elements, which might still be used by others.

\pagebreak 
\unsect{Notes about operator precedence}
\bigbreak \noindent 
\subsection{Logical operators}
\bigbreak \noindent 
consider the code
\bigbreak \noindent 
\begin{cppcode}
int i=1,j=1,k=1;
if (++i || ++j && ++ k);
cout << i << j << k;
\end{cppcode}
\bigbreak \noindent 
Here, we get $1211$, only $i$ is incremented. \&\& (logical-and-expression) has higher precedence than || (logical-or-expression
\bigbreak \noindent 
Logical precedence from lowest to highest
\begin{enumerate}
    \item logical-or-expression:
    \item logical-and-expression
    \item logical-or-expression || logical-and-expression
\end{enumerate}
\bigbreak \noindent 
So (++I || ++J \&\& ++K) will be equal to (++I || (++J \&\& ++K)). Since $++i$ is true, the short circuiting principle guarantees that the right side will be skipped.


\pagebreak 
\unsect{Alternative tokens}
\bigbreak \noindent 
Alternative token representations are provided for some operators and punctuators. In all respects of the language, each alternative token behaves the same, respectively, as its primary token, except for its spelling. The set of alternative tokens is
\begin{center}
    \begin{tabular}{|c|c||c|c||c|c|}
        \hline
        \textbf{Alternative} & \textbf{Primary} & \textbf{Alternative} & \textbf{Primary} & \textbf{Alternative} & \textbf{Primary} \\
        \hline
        \texttt{<\%} & \texttt{\{} & \texttt{and} & \texttt{\&\&} & \texttt{and\_eq} & \texttt{\&=} \\
            \hline
        \texttt{\%>} & \texttt{\}} & \texttt{bitor} & \texttt{|} & \texttt{or\_eq} & \texttt{|=} \\
        \hline
        \texttt{<:} & \texttt{[} & \texttt{or} & \texttt{||} & \texttt{xor\_eq} & \texttt{$^{\land}$=} \\
        \hline
        \texttt{:>} & \texttt{]} & \texttt{xor} & \texttt{\^} & \texttt{not} & \texttt{!} \\
        \hline
        \texttt{\%:} & \texttt{\#} & \texttt{compl} & \texttt{\~} & \texttt{not\_eq} & \texttt{!=} \\
        \hline
        \texttt{\%:\%:} & \texttt{\#\#} & \texttt{bitand} & \texttt{\&} &  &  \\
        \hline
    \end{tabular}
\end{center}


\pagebreak 
\unsect{Notes about C arrays}
\bigbreak \noindent 
Consider the following
\bigbreak \noindent 
\begin{cppcode}
    void f(int* arr) {
        cout << sizeof(arr) << endl // 8: decays to int pointer
    }

    void f(int arr[]) {
        cout << sizeof(arr) << endl // 8: decays to int pointer
    }

    void f(int (&arr)[10]) {
        cout << sizeof(arr) << endl; // 40: the result is the size of the referenced type.
        // arr is a reference to an array of 10 ints
    }

    int main() {
        int arr[10];

        cout << sizeof(arr) << endl; // 40 (bytes): ten four byte integers 
    }
\end{cppcode}

\pagebreak 
\unsect{Notes about operator overloads}
\bigbreak \noindent 
\subsection{Manually calling operator overloads}
\bigbreak \noindent 
We can manual call our operator overloads. Observe
\bigbreak \noindent 
\begin{cppcode}
    struct S {
        int x{};
        S(int x) : x(x) {}
        bool operator<(const S& other) {
            return x < other.x;
        }
    };
    S s1(5);
    S s2(10);
    cout << s1.operator <(s2) << endl;
\end{cppcode}

\pagebreak 
\unsect{Notes about pointers}
    \pagebreak 
    \subsection{The introduction of the nullptr}
    \bigbreak \noindent 
    nullptr was introduced in C++11 to address several issues and improve type safety when dealing with null pointers. Prior to C++11, the standard way to represent a null pointer was to use the macro NULL, which is typically defined as 0 or ((void*)0) in C++. However, this approach had several drawbacks:
    \bigbreak \noindent 
    \subsubsection{Ambiguity in Overloaded Functions}
    \bigbreak \noindent 
    In C++, NULL is typically defined as 0, which is an integer. This can lead to ambiguity when overloading functions that take both integer and pointer arguments. For example
    \bigbreak \noindent 
    \begin{cppcode}
        void foo(int);
        void foo(char*);

        foo(NULL); // Which foo is called? Ambiguous, as NULL is an integer.
    \end{cppcode}
    \bigbreak \noindent 
    nullptr resolves this ambiguity because it has its own type, std::nullptr\_t, which is implicitly convertible to any pointer type but not to integral types. Thus:
    \bigbreak \noindent 
    \begin{cppcode}
        foo(nullptr); // Unambiguously calls foo(char*)
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Type safety}
    \bigbreak \noindent 
    Using 0 or NULL for null pointers can lead to type safety issues because 0 is an integer literal, and it can be implicitly converted to other types, such as bool or int. This can result in unintended behavior or bugs.
    \bigbreak \noindent 
    nullptr is a keyword that explicitly represents a null pointer, and it cannot be implicitly converted to an integer. This makes the code more type-safe and less prone to errors.
    \bigbreak \noindent 
    \subsubsection{The type of nullptr}
    \bigbreak \noindent 
    nullptr is of type nullptr\_t
    \bigbreak \noindent 
    \begin{cppcode}
    auto ptr = nullptr // has type nullptr\_t
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{nullptr vs void*}
    \bigbreak \noindent 
    nullptr is used to explicitly indicate that a pointer does not point to any valid memory location.
    \bigbreak \noindent 
    It has its own type, std::nullptr\_t, which is implicitly convertible to any pointer type (e.g., int*, char*, etc.) but not to other types like integers.
    \bigbreak \noindent 
    void* is a generic pointer type that can point to any data type.

    \bigbreak \noindent 
    \subsubsection{Zero is a nullptr?}
    \bigbreak \noindent 
    The literal 0 is special in C++—it’s a null pointer constant. This means that when 0 is used in a pointer context, it is implicitly converted to a null pointer.
    \bigbreak \noindent 
    \begin{cppcode}
    cout << (nullptr == 0); // True
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{What does an uninitialized pointer point to?}
    \bigbreak \noindent 
    In C++, if you declare a pointer like int* ptr; without initializing it, the pointer's value is indeterminate. This means it doesn't point to a specific, valid memory location—it essentially contains a "garbage" value. Dereferencing such a pointer leads to undefined behavior. It's best practice to initialize pointers to at least nullptr. This way, you can safely check if the pointer is valid before using it.
    \bigbreak \noindent 
    An uninitialized pointer contains whatever "garbage" value happens to be in that memory location, so it might point to some



    \pagebreak 
    \unsect{Notes about gotos}
    \bigbreak \noindent 
    \subsection{Scope}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        class A {
            public:
            A() { std::cout << "a"; }
            ~A() { std::cout << "A"; }
        };
        int i = 1;

        int main(int argc, const char *argv[]) {
        label:
            A a;
            if (i--)
            goto label;
            return EXIT_SUCCESS;
        }
    \end{cppcode}
    \bigbreak \noindent 
    We get output aAaA. In C++, the lifetime of an automatic (local) object is tied to the scope in which it’s defined. Even though the label is textually within the same function block, when the program executes the goto label; statement, it leaves the scope of the current instance of a, triggering its destructor before jumping back to the label.
    \bigbreak \noindent 
    The goto label; statement causes the program to exit the region where that instance of a is alive. According to C++ rules, exiting the scope of an object (even via goto) must trigger its destructor.

    \pagebreak 
    \unsect{Notes about lambdas}
    \bigbreak \noindent 
    \subsection{Global variables}
    \bigbreak \noindent 
    \begin{cppcode}
    int a =5;

    int main() {
        cout << [](int x){return a + x;}(5); // 10
    }
    \end{cppcode}
    \bigbreak \noindent 
    You may think that the global $a$ needs to be captured. However, only local variables may be captured by a lambda. a is a global variable with static storage duration and may not be captured





























    





    
\end{document}
