\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Cpp Nuances}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Cpp Nuances}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Converting char to std::string}
    \bigbreak \noindent 
    Suppose we have a char variable, and we need to "convert" it to a string. To do this we use the string class constructor, which has two parameters, the size of the string to create, and the character to use as the fill.
    \bigbreak \noindent 
    \subsection{Constructor signature}
    \bigbreak \noindent 
    \begin{cppcode}
    string(size_t n, char x) 
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    char c = 'a';
    string s(1,c);
    \end{cppcode}

    \pagebreak 
    \unsect{std::string::npos}
    \bigbreak \noindent 
    \begin{concept}
        In C++, std::string::npos is a static member constant value with the greatest possible value for an element of type size\_t. This value, when used as the length in string operations, typically represents "until the end of the string." It is often used in string manipulation functions to specify that the operation should proceed from the starting position to the end of the string, or until no more characters are found.
    \end{concept}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    string infix = buffer.substr(index + 2, string::npos);
    \end{cppcode}
    \bigbreak \noindent 
    std::string::npos is defined as the maximum value representable by the type size\_t. This value is typically used to signify an error condition or a not-found condition when working with strings and other sequence types. However, when used as a length argument in methods like std::string::substr, it effectively becomes a directive to process characters until the end of the string. This is because any attempt to access beyond the end of the string would exceed the string's length, and the methods are designed to stop processing at that point.

    \pagebreak 
    \unsect{Narrowing}
    \bigbreak \noindent 
    Narrowing happens when:
    \begin{itemize}
        \item A value of a larger or more precise type is converted to a smaller or less precise type (e.g., double to int, int to char).
        \item A floating-point value is converted to an integer type.
        \item An integer value is converted to a smaller integer type (e.g., int to short) and does not fit within the destination type's range.
    \end{itemize}

    \pagebreak 
    \unsect{Aggregate types}
    \bigbreak \noindent 
    Aggregate types in C++ are simple data structures that hold collections of values and have minimal additional behavior. They are essentially "plain old data" structures that are easy to initialize and manipulate. The term "aggregate" is formally defined by the C++ standard.
    \bigbreak \noindent 
    A class, struct, or union is considered an aggregate if it satisfies all of the following conditions:
    \begin{enumerate}
        \item No User-Defined Constructors: It must not have any explicitly declared constructors (including default, copy, or move constructors).
        \item No Private or Protected Non-Static Data Members: All non-static data members must be public.
        \item No Virtual Functions: It must not have any virtual functions.
        \item No Base Classes: It must not inherit from another class or struct.
        \item No Virtual Base Classes: It must not use virtual inheritance.
    \end{enumerate}
    \bigbreak \noindent 
    For example
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;
        };
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Aggregate initialization}
    \bigbreak \noindent 
    Aggregate initialization in C++ refers to a special form of initialization for aggregate types using an initializer list enclosed in \{\} braces. This allows you to directly specify values for the members of an aggregate type in the order they are declared.
    \bigbreak \noindent 
    Each member of the aggregate is initialized with the corresponding value provided in the initializer list. The order of values in the initializer list must match the declaration order of members in the aggregate.
    \bigbreak \noindent 
    If fewer values are provided in the initializer list than there are members in the aggregate, the remaining members are value-initialized (e.g., zero-initialized for fundamental types).
    \bigbreak \noindent 
    If the type is not an aggregate (e.g., has a user-defined constructor, private members, or virtual functions), aggregate initialization cannot be used.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;
        };

        S s = {1,2};
    \end{cppcode}
    \bigbreak \noindent 
    Consider the next example,
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;

            S(int x, int y) : x(x), y(y) {}
        };
         
        S s = {1,2}; // Works fine
    \end{cppcode}
    \bigbreak \noindent 
    Since the class $S$ has a user-defined constructor, it is no longer an aggregate type.
    \bigbreak \noindent 
    Aggregate initialization is not applicable here. Instead, C++ checks for constructors that match the initializer list \{1, 2\}.
    \bigbreak \noindent 
    Since it found one, the compiler interprets it as calling the constructor S(int x, int y) with the arguments 1 and 2.
    \bigbreak \noindent 
    In modern C++ (C++11 and later), brace-enclosed initialization is often used for uniform initialization.
    \bigbreak \noindent 
    If a constructor is available that matches the initializer list, it is called.

    \bigbreak \noindent 
    \subsection{Narrowing is not allowed in aggregate-initialization from an initializer list}
    \bigbreak \noindent 
    The error "narrowing is not allowed in aggregate-initialization from an initializer list" occurs in C++ when you try to initialize an aggregate type (e.g., structs, arrays, or classes with no user-defined constructors) using values in an initializer list, but the values undergo an implicit narrowing conversion that could lose information or precision.
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            int x;
            float y;
        };

        A a = {1, 3.14}; // OK, no narrowing
        A b = {1, 3.14f}; // OK, no narrowing (3.14f is a float literal)

        A c = {1, 3.14}; // ERROR: narrowing from `double` to `float`
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{implicit conversion using a single-argument constructor}
    \bigbreak \noindent 
     A constructor that takes one argument can be used for implicit conversion of that argument type to the class type.
     \bigbreak \noindent 
     \begin{cppcode}
     struct s {
         int x;
         s(int value) : x(value) {} // Single-argument constructor
     };
     s s1 = 1;
 \end{cppcode}
 \bigbreak \noindent 
 The integer 1 is implicitly converted to an object of type s using the s(int value) constructor.
 \bigbreak \noindent 
 By default, a single-argument constructor allows implicit conversions. If you want to prevent implicit conversions and require explicit construction, you can use the explicit keyword
 \bigbreak \noindent 
 \begin{cppcode}
     struct s {
         int x;
         explicit s(int value) : x(value) {}
     };

     int main() {
         s s1 = 1; // ERROR: Explicit constructor prevents implicit conversion
         s s2(1);  // OK: Direct initialization
     }
 \end{cppcode}





    \pagebreak 
    \unsect{Floating point literals}
    \bigbreak \noindent 
    Floating point literals in c++ will be of type double. For example,
    \bigbreak \noindent 
    \begin{cppcode}
    cout << typeid(4.09).name(); // d
    \end{cppcode}
    \bigbreak \noindent 
    Append $f$ to the literal to make it a float
    \bigbreak \noindent 
    \begin{cppcode}
        cout << typeid(4.09f).name(); // d
    \end{cppcode}

    \pagebreak 
    \unsect{Size of structs and classes}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { }
        cout << sizeof(s) << endl; // 1

        s s1;
        cout << sizeof(s1) << endl; // 1
    \end{cppcode}
    Notice that empty structs do not have a size of zero. Empty structs have a size of one byte. 
    \bigbreak \noindent 
    A size of zero for a struct would mean that it occupies no memory. If multiple instances of such a struct are created, they would have no unique memory location to occupy. As a result, the compiler would assign the same memory address to all instances, which would violate fundamental rules of object-oriented programming in C++.
    \bigbreak \noindent 
    Furthermore, giving fields to the struct or class increases the size of that struct or class by size of the type. 
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { int x; }
        cout << sizeof(s); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Notice that the size is \textbf{not} 5. Creating functions and creating variables in those functions does not add to the size
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            void f()  {
                int  x;
            }
        }
        cout << sizeof(s); // 1
    \end{cppcode}
    \bigbreak \noindent 
    Creating structs inside structs and even adding fields to the inner structs does not increase the size
    \bigbreak \noindent 
    \begin{cppcode}
    struct s {
        struct k { int x; };
    };

    cout << sizeof(s); // 1
    cout << sizeof(s::k); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Lastly, constructors and destructors do not increase the size.
    \bigbreak \noindent 
    It seems only fields increase the size.

    \pagebreak 
    \unsect{When is trailing return type useful}
    \bigbreak \noindent 
    \subsection{Decltype on template parameters}
    \bigbreak \noindent 
    Suppose we had two template types $T,U$, and a function that accepts $T a, U b$. Suppose we wanted the return type to be the type of $T + U$, we could of course just write
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        decltype(T{} + U{}) f(T a, U b) {
            return a + b; 
        }
    \end{cppcode}
    \bigbreak \noindent 
    Or, we could utilize a trailing return
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T, typename U>
    auto f(T a, U b) -> decltype(a+b) {
        return a + b; 
    }
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Nested structs}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            struct B {};

            B f() const;
        };

        A::B A::f() const { }
    \end{cppcode}
    \bigbreak \noindent 
    Instead of having to use the scope resolution operator, we could use a trailing return type.
    \bigbreak \noindent 
    \begin{cppcode}
        auto A::f() const -> B {

        }
    \end{cppcode}
    \bigbreak \noindent 
    By using a trailing return type, we are essentially inside the scope of $A$ by the time we specify the return type.

    \pagebreak 
    \unsect{Most vexing parse}
    \bigbreak \noindent 
    The most vexing parse is a phenomenon in C++ where a line of code that looks like a variable declaration is instead interpreted by the compiler as a function declaration. This often happens because of C++'s ambiguous grammar for declarations.
    \bigbreak \noindent 
    \begin{cppcode}
    std::string s(); // Treated as a function declaration
    \end{cppcode}
    \bigbreak \noindent 
    This will not be treated as a default constructed string by the C++ compiler, but instead as a function declaration. To fix this issue, we instead use brace initialization
    \bigbreak \noindent 
    \begin{cppcode}
        std::string s{} // A default string variable
    \end{cppcode}

    \pagebreak 
    \unsect{Notes about copy constructors}
    \bigbreak \noindent 
    The copy constructor in C++ typically takes a const reference (const T\&) to ensure correctness and efficiency. If the copy constructor took its parameter by value, this would require making a copy of other before calling the constructor itself. But that copy itself would require calling the copy constructor, leading to infinite recursion until a stack overflow.
    \bigbreak \noindent 
    If the copy constructor took a non-const reference, this would not allow copying from const objects.
    \bigbreak \noindent 
    Since a copy operation should not modify the original object, using const ensures the copy constructor can be called for const objects.
    \bigbreak \noindent 
    Recall that functions (and methods) that take a const reference insure that the function can be called on both const objects and non-const objects. Functions that take non-const references can only accept non-const objects.
    \bigbreak \noindent 
    As a quick side note, since we are on the topic of const correctness, recall that constant member functions cannot call non-const member functions.

    \pagebreak 
    \unsect{Exceptions during a call to new}
    \bigbreak \noindent 
    When using raw pointers, an exception occurring after a new allocation leads to a resource leak if the allocated memory is not properly managed. This happens because new dynamically allocates memory on the heap, but if an exception interrupts execution before delete is called, the allocated memory remains unreachable and never freed.
    \bigbreak \noindent 
    To prevent this, use smart pointers (std::unique\_ptr or std::shared\_ptr), which automatically manage memory and clean up even if an exception occurs.
    \bigbreak \noindent 
    However, it is true that using std::unique\_ptr and std::shared\_ptr does not guarantee that there will be no resource leaks if they are not used properly. Specifically, passing new directly to their constructors can still lead to resource leaks in certain cases. This is why std::make\_unique and std::make\_shared are preferred
    \bigbreak \noindent 
    make\_shared performs a single allocation that stores both the object and the control block together. If an exception occurs, no memory leak happens because allocation and ownership setup happen in one step.
    \bigbreak \noindent 
    Same is true for make\_unique
    \bigbreak \noindent 
    \subsection{Exceptions during constructors}
    \bigbreak \noindent 
    If a call to new results in an exception, the object is never allocated.
    When you use new, the operator first tries to allocate memory by calling operator new(size), which is similar to malloc.
    \bigbreak \noindent 
    If memory allocation is successful, the constructor of the object is called.
    \bigbreak \noindent 
    If there isn't enough memory, operator new will throw a std::bad\_alloc exception (unless you use nothrow new, which returns nullptr)
    \bigbreak \noindent 
    If memory allocation succeeds but the constructor of the object throws an exception, the allocated memory is automatically freed, so there is no memory leak. If an exception is thrown in the constructor after memory has been allocated but before construction is complete, the C++ runtime ensures that the allocated memory is automatically freed. This is done by:
    \begin{itemize}
        \item Catching the exception inside the new operator.
        \item Calling operator delete(ptr) to deallocate the memory.
    \end{itemize}

    \pagebreak 
    \unsect{Notes about polymorphism}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };
        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base* o) {
            o->print();
        }

        void f(const base& o) {
            o.print();
        }

        derived d1;
        base& b1 = d1;

        f(b1);

        base* d = new derived();
        f(d);

        delete d;
    \end{cppcode}
    \bigbreak \noindent 
    We get the output
    \bigbreak \noindent 
    \begin{cppcode}
        Derived
        Cleaned up derived
        Cleaned up base
    \end{cppcode}
    \bigbreak \noindent 
    The reason both destructor messages ("Cleaned up derived" and "Cleaned up base") are printed when you call delete d; is due to polymorphic destruction.
    \bigbreak \noindent 
    The base class has a virtual destructor (virtual $\sim$base()). This ensures that when an object is deleted through a pointer to base, the destructor of the derived class will also be invoked before the base destructor.
    \bigbreak \noindent 
    $d$ is deleted, and because base has a virtual destructor, the destructor call correctly cascades down the inheritance chain:
    \begin{itemize}
        \item First, $\sim$derived() runs and prints "Cleaned up derived".
        \item Then, $\sim$base() runs and prints "Cleaned up base".
    \end{itemize}
    \bigbreak \noindent 
    If the destructor in base wasn't virtual, deleting a derived object through a base* pointer would cause undefined behavior (likely only $\sim$base() would be called, leading to memory leaks).
    \bigbreak \noindent 
    If base has fields (member variables), whether directly inherited by derived or not, the base destructor must be called to clean up those fields properly when a derived object is deleted.

    \bigbreak \noindent 
    \subsection{Polymorphism with arrays and slicing}
    \bigbreak \noindent 
    \subsubsection{Object Slicing}
    \bigbreak \noindent 
    Object slicing occurs when an object of a derived class is assigned to a variable of a base class type, causing the derived part of the object to be "sliced off", leaving only the base class portion.
    \bigbreak \noindent 
    Slicing occurs when 
    \begin{itemize}
        \item A derived object is assigned to a base class object (not a pointer or reference).
        \item A derived object is stored in a container of base class objects (e.g., an array of base objects).
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            int x{1};

        };
        struct derived : base {
            int y{5};
        };

        base b = derived{};
        // Error, no member named y in base
        cout << b.x << endl << b.y;
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Polymorphism with arrays}
    \bigbreak \noindent 
    Consider the following code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };

        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base& o) {
            o.print();
        }

        auto main(int argc, const char* argv[]) -> int {
            base* barr = new derived[5];

            delete[] barr;

            return EXIT_SUCCESS;
        }
    \end{cppcode}
    \bigbreak \noindent 
    barr is declared as base*, but the memory actually holds derived objects. When delete[] barr; is called, C++ treats barr as an array of base objects, not derived objects. This breaks proper destructor calls, leading to undefined behavior.
    \bigbreak \noindent 
    Even though base has a virtual ~base(), the problem is not about virtual dispatch. Instead, it's about how C++ tracks array allocations.
    \bigbreak \noindent 
    The array of derived objects was allocated using new derived[5], but delete[] barr; doesn’t have enough information to correctly call derived destructors.
    \bigbreak \noindent 
    When delete[] barr; is called, C++ sees a base* pointer and assumes it points to an array of base objects.
    \bigbreak \noindent 
    Instead we either,
    \begin{cppcode}
        derived* darr = new derived[n]
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        vector<unique_ptr<base>> v(5);
        for (auto& item : v) {
            item = make_unique<derived>();
        }

        // Or the standard approach
        vector<base*> v2(5);
        for (auto& item : v2) {
            item = new derived();
        }

        for (auto& item : v2) {
            delete item;
        }
    \end{cppcode}

    \pagebreak 
    \unsect{Note about heap allocated memory in vectors}
    \bigbreak \noindent 
    If your std::vector contains raw pointers (e.g., std::vector<int*>), the vector will only destroy the pointers themselves but not the dynamically allocated memory they point to. This will cause a memory leak if you don’t manually delete each allocated object before the vector goes out of scope.
    \bigbreak \noindent 
    To avoid leaks, manually delete the elements before clearing the vector

    \pagebreak 
    \unsect{Function that takes a const reference can accept rvalues}
    \bigbreak \noindent 
    In C++, a function that takes a const reference can accept rvalues because const references extend the lifetime of temporary (rvalue) objects.
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        void f(const T& x) {}
    \end{cppcode}
    \bigbreak \noindent 
    A const T\& (a reference to a const object of type T) can bind to both lvalues and rvalues, because:
    \begin{enumerate}
        \item Lvalues are naturally bindable to references.
        \item Rvalues (temporaries) can bind to const T\& because:
            \begin{itemize}
                \item The const qualifier guarantees that the temporary will not be modified.
                \item C++ extends the lifetime of the temporary to match the lifetime of the reference.
            \end{itemize}
    \end{enumerate}
    \bigbreak \noindent 
    \begin{cppcode}
        const int& ref = 100; // OK: binds to temporary, lifetime extended
        std::cout << ref << std::endl; // Prints 100

        int& ref = 100; // ERROR: Cannot bind non-const lvalue reference to an rvalue
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item If an lvalue is passed $\to$ T deduces to int\&, making T\&\& collapse to int\&.
        \item If an rvalue is passed $\to$ T deduces to int, making T\&\& remain int\&\&.
    \end{itemize}



    








    

    
\end{document}
