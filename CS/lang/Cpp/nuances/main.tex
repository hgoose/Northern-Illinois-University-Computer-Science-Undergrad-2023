\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Cpp Nuances}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Cpp Nuances}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Converting char to std::string}
    \bigbreak \noindent 
    Suppose we have a char variable, and we need to "convert" it to a string. To do this we use the string class constructor, which has two parameters, the size of the string to create, and the character to use as the fill.
    \bigbreak \noindent 
    \subsection{Constructor signature}
    \bigbreak \noindent 
    \begin{cppcode}
    string(size_t n, char x) 
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    char c = 'a';
    string s(1,c);
    \end{cppcode}

    \pagebreak 
    \unsect{std::string::npos}
    \bigbreak \noindent 
    \begin{concept}
        In C++, std::string::npos is a static member constant value with the greatest possible value for an element of type size\_t. This value, when used as the length in string operations, typically represents "until the end of the string." It is often used in string manipulation functions to specify that the operation should proceed from the starting position to the end of the string, or until no more characters are found.
    \end{concept}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    string infix = buffer.substr(index + 2, string::npos);
    \end{cppcode}
    \bigbreak \noindent 
    std::string::npos is defined as the maximum value representable by the type size\_t. This value is typically used to signify an error condition or a not-found condition when working with strings and other sequence types. However, when used as a length argument in methods like std::string::substr, it effectively becomes a directive to process characters until the end of the string. This is because any attempt to access beyond the end of the string would exceed the string's length, and the methods are designed to stop processing at that point.

    \pagebreak 
    \unsect{Narrowing}
    \bigbreak \noindent 
    Narrowing happens when:
    \begin{itemize}
        \item A value of a larger or more precise type is converted to a smaller or less precise type (e.g., double to int, int to char).
        \item A floating-point value is converted to an integer type.
        \item An integer value is converted to a smaller integer type (e.g., int to short) and does not fit within the destination type's range.
    \end{itemize}

    \pagebreak 
    \unsect{Aggregate types}
    \bigbreak \noindent 
    Aggregate types in C++ are simple data structures that hold collections of values and have minimal additional behavior. They are essentially "plain old data" structures that are easy to initialize and manipulate. The term "aggregate" is formally defined by the C++ standard.
    \bigbreak \noindent 
    A class, struct, or union is considered an aggregate if it satisfies all of the following conditions:
    \begin{enumerate}
        \item No User-Defined Constructors: It must not have any explicitly declared constructors (including default, copy, or move constructors).
        \item No Private or Protected Non-Static Data Members: All non-static data members must be public.
        \item No Virtual Functions: It must not have any virtual functions.
        \item No Base Classes: It must not inherit from another class or struct.
        \item No Virtual Base Classes: It must not use virtual inheritance.
    \end{enumerate}
    \bigbreak \noindent 
    For example
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x,y;
        };
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Aggregate initialization}
    \bigbreak \noindent 
    Aggregate initialization in C++ refers to a special form of initialization for aggregate types using an initializer list enclosed in \{\} braces. This allows you to directly specify values for the members of an aggregate type in the order they are declared.
    \bigbreak \noindent 
    Each member of the aggregate is initialized with the corresponding value provided in the initializer list. The order of values in the initializer list must match the declaration order of members in the aggregate.
    \bigbreak \noindent 
    If fewer values are provided in the initializer list than there are members in the aggregate, the remaining members are value-initialized (e.g., zero-initialized for fundamental types).
    \bigbreak \noindent 
    If the type is not an aggregate (e.g., has a user-defined constructor, private members, or virtual functions), aggregate initialization cannot be used.
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;
        };

        S s = {1,2};
    \end{cppcode}
    \bigbreak \noindent 
    Consider the next example,
    \bigbreak \noindent 
    \begin{cppcode}
        struct S {
            int x,y;

            S(int x, int y) : x(x), y(y) {}
        };
         
        S s = {1,2}; // Works fine
    \end{cppcode}
    \bigbreak \noindent 
    Since the class $S$ has a user-defined constructor, it is no longer an aggregate type.
    \bigbreak \noindent 
    Aggregate initialization is not applicable here. Instead, C++ checks for constructors that match the initializer list \{1, 2\}.
    \bigbreak \noindent 
    Since it found one, the compiler interprets it as calling the constructor S(int x, int y) with the arguments 1 and 2.
    \bigbreak \noindent 
    In modern C++ (C++11 and later), brace-enclosed initialization is often used for uniform initialization.
    \bigbreak \noindent 
    If a constructor is available that matches the initializer list, it is called.

    \bigbreak \noindent 
    \subsection{Narrowing is not allowed in aggregate-initialization from an initializer list}
    \bigbreak \noindent 
    The error "narrowing is not allowed in aggregate-initialization from an initializer list" occurs in C++ when you try to initialize an aggregate type (e.g., structs, arrays, or classes with no user-defined constructors) using values in an initializer list, but the values undergo an implicit narrowing conversion that could lose information or precision.
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            int x;
            float y;
        };

        A a = {1, 3.14}; // OK, no narrowing
        A b = {1, 3.14f}; // OK, no narrowing (3.14f is a float literal)

        A c = {1, 3.14}; // ERROR: narrowing from `double` to `float`
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{implicit conversion using a single-argument constructor}
    \bigbreak \noindent 
     A constructor that takes one argument can be used for implicit conversion of that argument type to the class type.
     \bigbreak \noindent 
     \begin{cppcode}
     struct s {
         int x;
         s(int value) : x(value) {} // Single-argument constructor
     };
     s s1 = 1;
 \end{cppcode}
 \bigbreak \noindent 
 The integer 1 is implicitly converted to an object of type s using the s(int value) constructor.
 \bigbreak \noindent 
 By default, a single-argument constructor allows implicit conversions. If you want to prevent implicit conversions and require explicit construction, you can use the explicit keyword
 \bigbreak \noindent 
 \begin{cppcode}
     struct s {
         int x;
         explicit s(int value) : x(value) {}
     };

     int main() {
         s s1 = 1; // ERROR: Explicit constructor prevents implicit conversion
         s s2(1);  // OK: Direct initialization
     }
 \end{cppcode}





    \pagebreak 
    \unsect{Floating point literals}
    \bigbreak \noindent 
    Floating point literals in c++ will be of type double. For example,
    \bigbreak \noindent 
    \begin{cppcode}
    cout << typeid(4.09).name(); // d
    \end{cppcode}
    \bigbreak \noindent 
    Append $f$ to the literal to make it a float
    \bigbreak \noindent 
    \begin{cppcode}
        cout << typeid(4.09f).name(); // d
    \end{cppcode}

    \pagebreak 
    \unsect{Size of structs and classes}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { }
        cout << sizeof(s) << endl; // 1

        s s1;
        cout << sizeof(s1) << endl; // 1
    \end{cppcode}
    Notice that empty structs do not have a size of zero. Empty structs have a size of one byte. 
    \bigbreak \noindent 
    A size of zero for a struct would mean that it occupies no memory. If multiple instances of such a struct are created, they would have no unique memory location to occupy. As a result, the compiler would assign the same memory address to all instances, which would violate fundamental rules of object-oriented programming in C++.
    \bigbreak \noindent 
    Furthermore, giving fields to the struct or class increases the size of that struct or class by size of the type. 
    \bigbreak \noindent 
    \begin{cppcode}
        struct s { int x; }
        cout << sizeof(s); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Notice that the size is \textbf{not} 5. Creating functions and creating variables in those functions does not add to the size
    \bigbreak \noindent 
    \begin{cppcode}
        struct s {
            void f()  {
                int  x;
            }
        }
        cout << sizeof(s); // 1
    \end{cppcode}
    \bigbreak \noindent 
    Creating structs inside structs and even adding fields to the inner structs does not increase the size
    \bigbreak \noindent 
    \begin{cppcode}
    struct s {
        struct k { int x; };
    };

    cout << sizeof(s); // 1
    cout << sizeof(s::k); // 4
    \end{cppcode}
    \bigbreak \noindent 
    Lastly, constructors and destructors do not increase the size.
    \bigbreak \noindent 
    It seems only fields increase the size.

    \pagebreak 
    \unsect{When is trailing return type useful}
    \bigbreak \noindent 
    \subsection{Decltype on template parameters}
    \bigbreak \noindent 
    Suppose we had two template types $T,U$, and a function that accepts $T a, U b$. Suppose we wanted the return type to be the type of $T + U$, we could of course just write
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        decltype(T{} + U{}) f(T a, U b) {
            return a + b; 
        }
    \end{cppcode}
    \bigbreak \noindent 
    Or, we could utilize a trailing return
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T, typename U>
    auto f(T a, U b) -> decltype(a+b) {
        return a + b; 
    }
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Nested structs}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct A {
            struct B {};

            B f() const;
        };

        A::B A::f() const { }
    \end{cppcode}
    \bigbreak \noindent 
    Instead of having to use the scope resolution operator, we could use a trailing return type.
    \bigbreak \noindent 
    \begin{cppcode}
        auto A::f() const -> B {

        }
    \end{cppcode}
    \bigbreak \noindent 
    By using a trailing return type, we are essentially inside the scope of $A$ by the time we specify the return type.

    \pagebreak 
    \unsect{Most vexing parse}
    \bigbreak \noindent 
    The most vexing parse is a phenomenon in C++ where a line of code that looks like a variable declaration is instead interpreted by the compiler as a function declaration. This often happens because of C++'s ambiguous grammar for declarations.
    \bigbreak \noindent 
    \begin{cppcode}
    std::string s(); // Treated as a function declaration
    \end{cppcode}
    \bigbreak \noindent 
    This will not be treated as a default constructed string by the C++ compiler, but instead as a function declaration. To fix this issue, we instead use brace initialization
    \bigbreak \noindent 
    \begin{cppcode}
        std::string s{} // A default string variable
    \end{cppcode}

    \pagebreak 
    \unsect{Notes about copy constructors}
    \bigbreak \noindent 
    The copy constructor in C++ typically takes a const reference (const T\&) to ensure correctness and efficiency. If the copy constructor took its parameter by value, this would require making a copy of other before calling the constructor itself. But that copy itself would require calling the copy constructor, leading to infinite recursion until a stack overflow.
    \bigbreak \noindent 
    If the copy constructor took a non-const reference, this would not allow copying from const objects.
    \bigbreak \noindent 
    Since a copy operation should not modify the original object, using const ensures the copy constructor can be called for const objects.
    \bigbreak \noindent 
    Recall that functions (and methods) that take a const reference insure that the function can be called on both const objects and non-const objects. Functions that take non-const references can only accept non-const objects.
    \bigbreak \noindent 
    As a quick side note, since we are on the topic of const correctness, recall that constant member functions cannot call non-const member functions.

    \pagebreak 
    \unsect{Exceptions during a call to new}
    \bigbreak \noindent 
    When using raw pointers, an exception occurring after a new allocation leads to a resource leak if the allocated memory is not properly managed. This happens because new dynamically allocates memory on the heap, but if an exception interrupts execution before delete is called, the allocated memory remains unreachable and never freed.
    \bigbreak \noindent 
    To prevent this, use smart pointers (std::unique\_ptr or std::shared\_ptr), which automatically manage memory and clean up even if an exception occurs.
    \bigbreak \noindent 
    However, it is true that using std::unique\_ptr and std::shared\_ptr does not guarantee that there will be no resource leaks if they are not used properly. Specifically, passing new directly to their constructors can still lead to resource leaks in certain cases. This is why std::make\_unique and std::make\_shared are preferred
    \bigbreak \noindent 
    make\_shared performs a single allocation that stores both the object and the control block together. If an exception occurs, no memory leak happens because allocation and ownership setup happen in one step.
    \bigbreak \noindent 
    Same is true for make\_unique
    \bigbreak \noindent 
    \subsection{Exceptions during constructors}
    \bigbreak \noindent 
    If a call to new results in an exception, the object is never allocated.
    When you use new, the operator first tries to allocate memory by calling operator new(size), which is similar to malloc.
    \bigbreak \noindent 
    If memory allocation is successful, the constructor of the object is called.
    \bigbreak \noindent 
    If there isn't enough memory, operator new will throw a std::bad\_alloc exception (unless you use nothrow new, which returns nullptr)
    \bigbreak \noindent 
    If memory allocation succeeds but the constructor of the object throws an exception, the allocated memory is automatically freed, so there is no memory leak. If an exception is thrown in the constructor after memory has been allocated but before construction is complete, the C++ runtime ensures that the allocated memory is automatically freed. This is done by:
    \begin{itemize}
        \item Catching the exception inside the new operator.
        \item Calling operator delete(ptr) to deallocate the memory.
    \end{itemize}

    \pagebreak 
    \unsect{Notes about polymorphism}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };
        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base* o) {
            o->print();
        }

        void f(const base& o) {
            o.print();
        }

        derived d1;
        base& b1 = d1;

        f(b1);

        base* d = new derived();
        f(d);

        delete d;
    \end{cppcode}
    \bigbreak \noindent 
    We get the output
    \bigbreak \noindent 
    \begin{cppcode}
        Derived
        Cleaned up derived
        Cleaned up base
    \end{cppcode}
    \bigbreak \noindent 
    The reason both destructor messages ("Cleaned up derived" and "Cleaned up base") are printed when you call delete d; is due to polymorphic destruction.
    \bigbreak \noindent 
    The base class has a virtual destructor (virtual $\sim$base()). This ensures that when an object is deleted through a pointer to base, the destructor of the derived class will also be invoked before the base destructor.
    \bigbreak \noindent 
    $d$ is deleted, and because base has a virtual destructor, the destructor call correctly cascades down the inheritance chain:
    \begin{itemize}
        \item First, $\sim$derived() runs and prints "Cleaned up derived".
        \item Then, $\sim$base() runs and prints "Cleaned up base".
    \end{itemize}
    \bigbreak \noindent 
    If the destructor in base wasn't virtual, deleting a derived object through a base* pointer would cause undefined behavior (likely only $\sim$base() would be called, leading to memory leaks).
    \bigbreak \noindent 
    If base has fields (member variables), whether directly inherited by derived or not, the base destructor must be called to clean up those fields properly when a derived object is deleted.

    \bigbreak \noindent 
    \subsection{Polymorphism with arrays and slicing}
    \bigbreak \noindent 
    \subsubsection{Object Slicing}
    \bigbreak \noindent 
    Object slicing occurs when an object of a derived class is assigned to a variable of a base class type, causing the derived part of the object to be "sliced off", leaving only the base class portion.
    \bigbreak \noindent 
    Slicing occurs when 
    \begin{itemize}
        \item A derived object is assigned to a base class object (not a pointer or reference).
        \item A derived object is stored in a container of base class objects (e.g., an array of base objects).
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            int x{1};

        };
        struct derived : base {
            int y{5};
        };

        base b = derived{};
        // Error, no member named y in base
        cout << b.x << endl << b.y;
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Polymorphism with arrays}
    \bigbreak \noindent 
    Consider the following code
    \bigbreak \noindent 
    \begin{cppcode}
        struct base {
            virtual void print() const {
                cout << "Base" << endl;
            }

            virtual ~base() {
                cout << "Cleaned up base" << endl;
            }
        };

        struct derived : base {
            void print() const override {
                cout << "Derived" << endl;
            }

            ~derived() {
                cout << "Cleaned up derived" << endl;
            }
        };

        void f(const base& o) {
            o.print();
        }

        auto main(int argc, const char* argv[]) -> int {
            base* barr = new derived[5];

            delete[] barr;

            return EXIT_SUCCESS;
        }
    \end{cppcode}
    \bigbreak \noindent 
    barr is declared as base*, but the memory actually holds derived objects. When delete[] barr; is called, C++ treats barr as an array of base objects, not derived objects. This breaks proper destructor calls, leading to undefined behavior.
    \bigbreak \noindent 
    Even though base has a virtual ~base(), the problem is not about virtual dispatch. Instead, it's about how C++ tracks array allocations.
    \bigbreak \noindent 
    The array of derived objects was allocated using new derived[5], but delete[] barr; doesn’t have enough information to correctly call derived destructors.
    \bigbreak \noindent 
    When delete[] barr; is called, C++ sees a base* pointer and assumes it points to an array of base objects.
    \bigbreak \noindent 
    Instead we either,
    \begin{cppcode}
        derived* darr = new derived[n]
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        vector<unique_ptr<base>> v(5);
        for (auto& item : v) {
            item = make_unique<derived>();
        }

        // Or the standard approach
        vector<base*> v2(5);
        for (auto& item : v2) {
            item = new derived();
        }

        for (auto& item : v2) {
            delete item;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Runtime polymorphism, dynamic dispatch, dynamic binding,  and the vtable}
    \bigbreak \noindent 
    Runtime polymorphism in C++ is achieved through function overriding and is implemented using virtual functions in an inheritance hierarchy. It allows a derived class to provide a specific implementation of a function that is already defined in its base class.
    \bigbreak \noindent 
    \subsubsection{Dynamic dispatch and dynamic binding}
    \bigbreak \noindent 
    Dynamic dispatch is a mechanism where the function to be executed is determined at runtime, rather than at compile-time. This is a key feature of runtime polymorphism and is enabled by virtual functions in C++
    \bigbreak \noindent 
    When a virtual function is declared in a base class and overridden in a derived class, C++ does not resolve function calls at compile-time.
    \bigbreak \noindent 
    Instead, when a function is called using a base class pointer/reference, C++ performs a runtime lookup to determine which function to execute.
    \bigbreak \noindent 
    This lookup is performed using the VTable (Virtual Table) and VPtr (Virtual Pointer) mechanism.
    \bigbreak \noindent 
    As a side note, the following will not work
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            consteval virtual int print() const {
                return 12;
            }

            virtual ~foo() {}
        };

        struct bar : foo {
            consteval int print() const override {
                return 0;
            }
        };

        foo* f = new bar{};
        constexpr int x = f.print();
    \end{cppcode}
    \bigbreak \noindent 
    The issue is that since the print functions are determined and called at runtime, it cannot be a compile time constant expression. We get the error "The value of $f$ is not usable in a constant expression"
    \bigbreak \noindent 
    Dynamic binding (also called late binding) is the underlying mechanism that allows dynamic dispatch to work. It refers to the process of determining which function implementation should be executed at runtime, rather than at compile time.
    \bigbreak \noindent 
    Binding refers to associating a function call with a function definition. Dynamic binding means this association happens at runtime, based on the actual type of the object.
    \bigbreak \noindent 
    Dynamic binding ensures that when a function is called on a base class pointer/reference, the correct overridden function from the derived class is invoked at runtime. Dynamic dispatch is the result of dynamic binding


    \bigbreak \noindent 
    \subsubsection{The Vtable}
    \bigbreak \noindent 
    C++ implements runtime polymorphism using a VTable (Virtual Table) and a VPointer (VPtr)
    \bigbreak \noindent 
    A VTable is a table of function pointers maintained per class. It stores pointers to the virtual functions defined in a class. Each class with virtual functions has a single VTable.
    \bigbreak \noindent 
    Each object of a class that has virtual functions contains a hidden pointer, called VPtr (Virtual Pointer). VPtr points to the VTable of that particular class.
    \bigbreak \noindent 
    During runtime, when a virtual function is called via a base class pointer, the VPtr is used to look up the correct function implementation in the VTable.
    \bigbreak \noindent
    When the program starts, the compiler creates a VTable for every class that has virtual functions. Every object of such a class gets a hidden VPtr, which points to the corresponding VTable.
    \bigbreak \noindent 
    When a virtual function is called using a base class pointer, the call is resolved dynamically by checking the VTable.
    \bigbreak \noindent 
    The VTable (Virtual Table) is created at compile time, but the VPtr (Virtual Pointer) is assigned and used at runtime.
    \bigbreak \noindent 
    The VTable itself is constructed at compile time, meaning the compiler generates and lays out the function pointers in the table before the program runs.
    \bigbreak \noindent 
    The VPtr is assigned at runtime, when an object of the class is created.
    \bigbreak \noindent 
    Because having virtual functions in our struct / class requires this VPtr to be created, having virtual functions therefore will increase the size of the struct and the objects created by the size of a pointer (8 bytes on 64-bit systems or 4 bytes on 32-bit systems).

    \bigbreak \noindent 
    each class in the inheritance hierarchy that has at least one virtual function has its own vtable.
    \begin{itemize}
        \item A base class with virtual functions has a vtable that stores pointers to its virtual functions.
        \item A derived class that overrides any virtual functions gets its own vtable, which replaces the base class’s function pointers with the derived class’s implementations.
        \item The vtable is associated with a class, not individual objects.
        \item Each object of a class with virtual functions has a vptr (virtual table pointer) that points to the vtable of its actual type.
    \end{itemize}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            virtual void print() const {
                cout << "Foo" << endl;
            }

            virtual ~foo() {}
        };

        struct bar : foo {
            void print() const override {
                cout << "Bar" << endl;
            }
        };
    \end{cppcode}
    \bigbreak \noindent 
    Since foo has virtual functions (print and the destructor), it will have a vtable.
    \begin{center}
        \begin{tabular}{p{4cm}|p{4cm}} 
            Index	&Function Pointer \\
            \hline
            0	&foo::print() \\
            1	&foo::$\sim$foo() (destructor) 
        \end{tabular}
    \end{center}
    \bigbreak \noindent 
    Every instance of foo has a vptr (virtual table pointer) pointing to this table.
    \bigbreak \noindent 
    Since bar overrides print(), but still inherits the virtual destructor from foo, its vtable will have the overridden version of print().
    \begin{center}
        \begin{tabular}{p{4cm}|p{4cm}}
            Index	&Function Pointer \\
            0	&bar::print() \\
            1	&foo::$\sim$foo() (inherited destructor) 
        \end{tabular}
    \end{center}
    \bigbreak \noindent 
    Each instance of bar will have its vptr pointing to vtable for bar.
    \bigbreak \noindent 
    \begin{cppcode}
        int main() {
            foo* obj = new bar();
            obj->print();  // Calls bar::print() because vptr points to bar's vtable
            delete obj;    // Calls foo::~foo() due to virtual destructor
        }
    \end{cppcode}






    \pagebreak 
    \unsect{The existence of structs and classes}
    \bigbreak \noindent 
    Does a Struct Exist in Memory Before an Object is Created? Yes and No. It depends on what part of the struct you're referring to:
    \begin{itemize}
        \item \textbf{Struct Definition (Type Information) – Exists at Compile Time}: The struct itself is just a blueprint (like a class). It does not occupy memory on its own.
            \bigbreak \noindent 
            Only when you create an object of the struct does memory get allocated for its members.
        \item \textbf{VTable (for Virtual Functions) – Exists in Memory, Even Without Objects}: If the struct contains virtual functions, the compiler generates a VTable at compile time. The VTable itself is stored in static memory (not per object). Even if no object is created, the struct’s VTable exists somewhere in memory.
        \item \textbf{Object Instances – Exist in Memory When Created}: When you instantiate an object of the struct, memory is allocated for that object’s data members. If the struct has virtual functions, each object has a hidden VPtr (Virtual Pointer), which increases its size.
    \end{itemize}
    \bigbreak \noindent 
    If $A$ is a struct, why does sizeof(A) have a size even if no object is created? When you define a struct in C++, the compiler determines the size of its layout at compile time. This means that even if you don’t create an object of the struct, sizeof(A) can still return a valid size.
    \bigbreak \noindent 
    The compiler does not assign fixed memory addresses to struct members. Instead, it determines the memory layout (size, alignment, and padding) at compile time. Actual memory addresses are assigned at runtime when an object is created.







    \pagebreak 
    \unsect{Note about heap allocated memory in vectors}
    \bigbreak \noindent 
    If your std::vector contains raw pointers (e.g., std::vector<int*>), the vector will only destroy the pointers themselves but not the dynamically allocated memory they point to. This will cause a memory leak if you don’t manually delete each allocated object before the vector goes out of scope.
    \bigbreak \noindent 
    To avoid leaks, manually delete the elements before clearing the vector

    \pagebreak 
    \unsect{Function that takes a const reference can accept rvalues}
    \bigbreak \noindent 
    In C++, a function that takes a const reference can accept rvalues because const references extend the lifetime of temporary (rvalue) objects.
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        void f(const T& x) {}
    \end{cppcode}
    \bigbreak \noindent 
    A const T\& (a reference to a const object of type T) can bind to both lvalues and rvalues, because:
    \begin{enumerate}
        \item Lvalues are naturally bindable to references.
        \item Rvalues (temporaries) can bind to const T\& because:
            \begin{itemize}
                \item The const qualifier guarantees that the temporary will not be modified.
                \item C++ extends the lifetime of the temporary to match the lifetime of the reference.
            \end{itemize}
    \end{enumerate}
    \bigbreak \noindent 
    \begin{cppcode}
        const int& ref = 100; // OK: binds to temporary, lifetime extended
        std::cout << ref << std::endl; // Prints 100

        int& ref = 100; // ERROR: Cannot bind non-const lvalue reference to an rvalue
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item If an lvalue is passed $\to$ T deduces to int\&, making T\&\& collapse to int\&.
        \item If an rvalue is passed $\to$ T deduces to int, making T\&\& remain int\&\&.
    \end{itemize}



    
    \pagebreak 
    \unsect{Notes about c++ casts}
    \bigbreak \noindent 
    First, recall
    \begin{itemize}
        \item static\_cast is used for safe and well-defined type conversions that are checked at compile-time.
        \item dynamic\_cast is used only with polymorphic types (i.e., classes with at least one virtual function). It performs runtime type checking and is mainly used for safe downcasting.
        \item const\_cast is used to add or remove const or volatile qualifiers from a variable. It is the only cast that can remove const, allowing modifications to otherwise constant data.
        \item reinterpret\_cast is the most dangerous cast—it converts between completely unrelated types. It does not perform type checking and is used for low-level pointer manipulation.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Static\_cast}
    \bigbreak \noindent 
    \textbf{When to Use static\_cast}:
    \bigbreak \noindent 
    \begin{itemize}
        \item Converting between numeric types (e.g., int to double).
        \item Converting between pointers of related classes (e.g., upcasting in inheritance).
        \item Converting between explicitly defined conversion operators.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{What It CANNOT Do}:
    \begin{itemize}
        \item It does not check for validity at runtime.
        \item It cannot cast between unrelated types (use reinterpret\_cast for that).
        \item It cannot remove const or volatile qualifiers (use const\_cast for that).
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Dynamic\_cast}
    \bigbreak \noindent 
    Dynamic casting in C++ is a feature provided by the language to safely convert pointers or references of base class types to pointers or references of derived class types at runtime. This is particularly useful in scenarios involving polymorphism, where you have a base class pointer or reference pointing to an object of a derived class, and you need to access derived class-specific members or methods.
    \bigbreak \noindent 
    Dynamic casting is used with pointers or references in class hierarchies that involve polymorphism (i.e., classes with at least one virtual function).
    \bigbreak \noindent 
    \begin{cppcode}
    dynamic_cast<new_type>(expression)
    \end{cppcode}
    \bigbreak \noindent 
    Dynamic casting performs a runtime check to ensure the cast is valid. If the cast is not possible, it returns nullptr for pointers or throws a std::bad\_cast exception for references.
    \bigbreak \noindent 
    Dynamic casting relies on Run-Time Type Information (RTTI), which must be enabled in your compiler.
    \bigbreak \noindent 
    \subsubsection{When to Use Dynamic Casting}
    \bigbreak \noindent 
    \begin{itemize}
        \item When you need to safely downcast in a polymorphic hierarchy.
        \item When you are unsure of the actual type of the object at runtime and need to check it.
    \end{itemize}
    \bigbreak \noindent 
    Dynamic casting incurs a runtime overhead due to the type checking. It only works with polymorphic types (classes with at least one virtual function).
    \bigbreak \noindent 
    Overuse of dynamic casting can indicate a design flaw; prefer virtual functions and polymorphism where possible.

    \bigbreak \noindent 
    \subsubsection{RTTI}
    \bigbreak \noindent 
    RTTI stands for Run-Time Type Information. It is a feature in C++ that provides mechanisms to determine the type of an object at runtime. RTTI is particularly useful in scenarios involving polymorphism, where you need to identify the actual type of an object pointed to by a base class pointer or reference.
    \bigbreak \noindent 
    RTTI relies on metadata stored by the compiler for polymorphic types (classes with at least one virtual function). This metadata includes:
    \begin{itemize}
        \item A vtable (virtual table) for each polymorphic class, which contains pointers to its virtual functions.
        \item A type\_info object for each class, which stores information about the class's type.
    \end{itemize}
    \bigbreak \noindent 
    When you use typeid or dynamic\_cast, the compiler generates code to access this metadata at runtime to determine the object's type.

    \bigbreak \noindent 
    \subsection{const\_cast}
    \bigbreak \noindent 
    const\_cast is only used to remove const or volatile qualifiers from a variable. It cannot be used to add const.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        void modify(int* ptr) {
            *ptr = 42;
        }

        int main() {
            const int x = 10;

            // Removing const
            int* ptr = const_cast<int*>(&x);

            modify(ptr); // Undefined behavior if `x` was originally a `const` object

            std::cout << "x: " << x << std::endl; // This may not reflect the change due to UB
        }
    \end{cppcode}
    \bigbreak \noindent 
    This is unsafe if x was originally declared as const int x = 10;, because modifying x leads to undefined behavior. However, if x was originally non-const and then cast to const, modifying it later using const\_cast is safe.
    \bigbreak \noindent 
    If you want to add const, you should use
    \begin{itemize}
        \item Implicit conversion
        \item static\_cast
        \item Declaring a const reference or pointer to a non-const object
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        int a = 5;
        const int* ptr = &a; // Adding const implicitly
        const int& ref = a;  // Adding const implicitly
    \end{cppcode}
    \bigbreak \noindent 
    const\_cast is useful in a few specific cases where you need to work around const qualifiers safely. 
    \bigbreak \noindent 
    \subsubsection{Modifying a non-const object that was passed as const}
    \bigbreak \noindent 
    If a function receives a const parameter but you know that the actual object is non-const, you can safely cast away const and modify it.
    \bigbreak \noindent 
    \subsubsection{Removing const to use overloaded functions}
    \bigbreak \noindent 
    Sometimes you have an overloaded function where one version accepts const and another modifies the object. const\_cast allows selecting the modifying version when needed.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Example {
            public:
            void print() {
                std::cout << "Non-const print" << std::endl;
            }

            void print() const {
                std::cout << "Const print" << std::endl;
            }
        };

        void forceModify(const Example& obj) {
            const_cast<Example&>(obj).print();  // Calls non-const version
        }

        int main() {
            Example e;
            forceModify(e);  // Calls non-const print()
        }
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{Note:} Const cast is a runtime operation and does not perform any checks

    \bigbreak \noindent 
    \subsection{reinterpret\_cast}
    \bigbreak \noindent 
    reinterpret\_cast is a type of casting operator in C++ that is used to convert one pointer type to another, even if the types are entirely unrelated. It performs a low-level reinterpretation of the underlying binary representation of the data.
    \bigbreak \noindent 
    \textbf{Note:} reinterpret\_cast is a runtime operation and does not perform any checks

    \bigbreak \noindent 
    \subsection{Why are c casts unsafe?}
    \bigbreak \noindent 
    C-style casting is unsafe and ambiguous because:
    \begin{itemize}
        \item It can perform multiple types of conversions at once, including:
            \begin{itemize}
                \item static\_cast
                \item reinterpret\_cast
                \item const\_cast
                \item Even dynamic\_cast (if a class has virtual functions)
            \end{itemize}
        \item It lacks compile-time safety—you might unintentionally use an invalid cast.
        \item It is hard to search and debug since (Type) doesn’t indicate what kind of conversion is being performed.
    \end{itemize}














    

    
\end{document}
