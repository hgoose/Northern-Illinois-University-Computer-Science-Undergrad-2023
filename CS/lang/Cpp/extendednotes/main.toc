\contentsline {section}{\numberline {1}STL Containers}{2}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}STL Vectors}{2}{subsection.0.1.1}%
\contentsline {subsubsection}{\numberline {1.1.1}Implementation}{2}{subsubsection.0.1.1.1}%
\contentsline {subsubsection}{\numberline {1.1.2}Performance in operations on the end}{2}{subsubsection.0.1.1.2}%
\contentsline {subsubsection}{\numberline {1.1.3}Size and capacity}{2}{subsubsection.0.1.1.3}%
\contentsline {subsubsection}{\numberline {1.1.4}Constructors}{3}{subsubsection.0.1.1.4}%
\contentsline {subsubsection}{\numberline {1.1.5}Note about at()}{4}{subsubsection.0.1.1.5}%
\contentsline {subsubsection}{\numberline {1.1.6}Iterator methods}{4}{subsubsection.0.1.1.6}%
\contentsline {subsubsection}{\numberline {1.1.7}Using vectors as 2d arrays}{4}{subsubsection.0.1.1.7}%
\contentsline {subsubsection}{\numberline {1.1.8}For those interested}{6}{subsubsection.0.1.1.8}%
\contentsline {paragraph}{\numberline {1.1.8.1}Manual Dynamic Memory Allocation (Using new)}{6}{paragraph.0.1.1.8.1}%
\contentsline {paragraph}{\numberline {1.1.8.2}Using unique pointer}{6}{paragraph.0.1.1.8.2}%
\contentsline {paragraph}{\numberline {1.1.8.3}Recall: Unique pointer for dynamic arry}{7}{paragraph.0.1.1.8.3}%
\contentsline {paragraph}{\numberline {1.1.8.4}If sizes are truly known at compile time}{8}{paragraph.0.1.1.8.4}%
\contentsline {subsection}{\numberline {1.2}STL Deque}{9}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Implementation}{9}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Abilities, performance, uses}{9}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}When to use deques}{9}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}Constructors}{10}{subsubsection.0.1.2.4}%
\contentsline {subsection}{\numberline {1.3}STL Lists}{11}{subsection.0.1.3}%
\contentsline {subsubsection}{\numberline {1.3.1}Implementation}{11}{subsubsection.0.1.3.1}%
\contentsline {subsubsection}{\numberline {1.3.2}Abilities}{11}{subsubsection.0.1.3.2}%
\contentsline {subsubsection}{\numberline {1.3.3}Differencs in the methods}{11}{subsubsection.0.1.3.3}%
\contentsline {subsubsection}{\numberline {1.3.4}Constructors}{12}{subsubsection.0.1.3.4}%
\contentsline {subsubsection}{\numberline {1.3.5}Element access}{12}{subsubsection.0.1.3.5}%
\contentsline {subsubsection}{\numberline {1.3.6}Iterator functions}{12}{subsubsection.0.1.3.6}%
\contentsline {subsubsection}{\numberline {1.3.7}Splice Functions and Functions to Change the Order of Elements}{13}{subsubsection.0.1.3.7}%
\contentsline {subsection}{\numberline {1.4}STL Forward lists}{14}{subsection.0.1.4}%
\contentsline {subsubsection}{\numberline {1.4.1}Implementation}{14}{subsubsection.0.1.4.1}%
\contentsline {subsubsection}{\numberline {1.4.2}Abilities, limitations}{14}{subsubsection.0.1.4.2}%
\contentsline {subsubsection}{\numberline {1.4.3}No size()?}{15}{subsubsection.0.1.4.3}%
\contentsline {subsubsection}{\numberline {1.4.4}Similarities to list}{15}{subsubsection.0.1.4.4}%
\contentsline {subsubsection}{\numberline {1.4.5}Constructors}{16}{subsubsection.0.1.4.5}%
\contentsline {subsection}{\numberline {1.5}STL Sets and multisets}{17}{subsection.0.1.5}%
\contentsline {subsubsection}{\numberline {1.5.1}Implementation}{17}{subsubsection.0.1.5.1}%
\contentsline {subsubsection}{\numberline {1.5.2}Strict weak ordering}{17}{subsubsection.0.1.5.2}%
\contentsline {subsubsection}{\numberline {1.5.3}Abilities}{18}{subsubsection.0.1.5.3}%
\contentsline {subsubsection}{\numberline {1.5.4}Changing elements directly, no direct element access}{18}{subsubsection.0.1.5.4}%
\contentsline {subsubsection}{\numberline {1.5.5}Constructors}{18}{subsubsection.0.1.5.5}%
\contentsline {subsubsection}{\numberline {1.5.6}Types}{19}{subsubsection.0.1.5.6}%
\contentsline {subsubsection}{\numberline {1.5.7}Constructors}{20}{subsubsection.0.1.5.7}%
\contentsline {subsection}{\numberline {1.6}STL Maps and multimaps}{21}{subsection.0.1.6}%
\contentsline {subsubsection}{\numberline {1.6.1}Implementation}{21}{subsubsection.0.1.6.1}%
\contentsline {subsubsection}{\numberline {1.6.2}Template parameters}{21}{subsubsection.0.1.6.2}%
\contentsline {subsubsection}{\numberline {1.6.3}Abilities}{21}{subsubsection.0.1.6.3}%
\contentsline {subsubsection}{\numberline {1.6.4}Constructors and types}{22}{subsubsection.0.1.6.4}%
\contentsline {subsubsection}{\numberline {1.6.5}Using maps as associative arrays}{23}{subsubsection.0.1.6.5}%
\contentsline {subsubsection}{\numberline {1.6.6}Constructors}{23}{subsubsection.0.1.6.6}%
\contentsline {subsection}{\numberline {1.7}Example of bounds and equal range}{25}{subsection.0.1.7}%
\contentsline {subsection}{\numberline {1.8}STL Unordered containers}{26}{subsection.0.1.8}%
\contentsline {subsubsection}{\numberline {1.8.1}Implementation}{26}{subsubsection.0.1.8.1}%
\contentsline {subsubsection}{\numberline {1.8.2}Abilities}{26}{subsubsection.0.1.8.2}%
\contentsline {subsubsection}{\numberline {1.8.3}Disadvantages}{27}{subsubsection.0.1.8.3}%
\contentsline {subsection}{\numberline {1.9}STL Containers: Implementations}{28}{subsection.0.1.9}%
\contentsline {subsection}{\numberline {1.10}STL Containers: Iterator Functions}{29}{subsection.0.1.10}%
\contentsline {subsection}{\numberline {1.11}STL containers: Main concepts, differences, uses}{30}{subsection.0.1.11}%
\contentsline {subsection}{\numberline {1.12}STL Containers: Iterator invalidation}{32}{subsection.0.1.12}%
\contentsline {subsection}{\numberline {1.13}STL Containers: Reallocation}{33}{subsection.0.1.13}%
\contentsline {subsection}{\numberline {1.14}STL Containers: Element access}{34}{subsection.0.1.14}%
\contentsline {subsection}{\numberline {1.15}STL Containers: Uses and advantages}{35}{subsection.0.1.15}%
\contentsline {subsection}{\numberline {1.16}STL Iterators}{36}{subsection.0.1.16}%
\contentsline {subsection}{\numberline {1.17}Complexity of container operations}{40}{subsection.0.1.17}%
\contentsline {section}{\numberline {2}STL Algorithms}{41}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}<algorithm>}{41}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}<numeric>}{42}{subsection.0.2.2}%
\contentsline {subsubsection}{\numberline {2.2.1}transform\_reduce}{42}{subsubsection.0.2.2.1}%
\contentsline {paragraph}{\numberline {2.2.1.1}Unary transform and reduce}{42}{paragraph.0.2.2.1.1}%
\contentsline {paragraph}{\numberline {2.2.1.2}Binary transform and reduce}{43}{paragraph.0.2.2.1.2}%
\contentsline {paragraph}{\numberline {2.2.1.3}std::plus<> and std::multiplies<>}{44}{paragraph.0.2.2.1.3}%
\contentsline {paragraph}{\numberline {2.2.1.4}Other key function objects}{44}{paragraph.0.2.2.1.4}%
\contentsline {section}{\numberline {3}Labels and goto}{46}{section.0.3}%
\contentsline {section}{\numberline {4}Type traits}{47}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Nonstandard type of types}{47}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}::value, ::type, and ::value\_type}{48}{subsection.0.4.2}%
\contentsline {section}{\numberline {5}Function Objects}{49}{section.0.5}%
\contentsline {paragraph}{\numberline {5.0.0.1}Why?}{49}{paragraph.0.5.0.0.1}%
\contentsline {paragraph}{\numberline {5.0.0.2}Predefined function objects}{50}{paragraph.0.5.0.0.2}%
\contentsline {section}{\numberline {6}Decltype}{50}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Syntax}{50}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Example}{51}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Things to pair with decltype}{51}{subsection.0.6.3}%
\contentsline {section}{\numberline {7}Constexpr}{52}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Variables}{52}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}Functions}{52}{subsection.0.7.2}%
\contentsline {subsection}{\numberline {7.3}Object Constructors}{53}{subsection.0.7.3}%
\contentsline {subsection}{\numberline {7.4}constexpr vs const}{53}{subsection.0.7.4}%
\contentsline {section}{\numberline {8}Function pointers and callable parametrs}{54}{section.0.8}%
\contentsline {subsection}{\numberline {8.1}Function pointers}{54}{subsection.0.8.1}%
\contentsline {subsubsection}{\numberline {8.1.1}As types}{54}{subsubsection.0.8.1.1}%
\contentsline {subsubsection}{\numberline {8.1.2}As function paramater}{54}{subsubsection.0.8.1.2}%
\contentsline {subsubsection}{\numberline {8.1.3}Function pointers to member functions}{55}{subsubsection.0.8.1.3}%
\contentsline {subsection}{\numberline {8.2}Using std::function}{56}{subsection.0.8.2}%
\contentsline {subsection}{\numberline {8.3}With forwarding references}{56}{subsection.0.8.3}%
\contentsline {section}{\numberline {9}Templates}{57}{section.0.9}%
\contentsline {subsection}{\numberline {9.1}Template Function}{57}{subsection.0.9.1}%
\contentsline {subsection}{\numberline {9.2}Template Class}{58}{subsection.0.9.2}%
\contentsline {subsection}{\numberline {9.3}Class vs typename keyword}{58}{subsection.0.9.3}%
\contentsline {subsection}{\numberline {9.4}Handle friend functions}{58}{subsection.0.9.4}%
\contentsline {subsubsection}{\numberline {9.4.1}Friendship to a Non-Template Function}{58}{subsubsection.0.9.4.1}%
\contentsline {subsubsection}{\numberline {9.4.2}Friendship to a Template Function}{59}{subsubsection.0.9.4.2}%
\contentsline {subsection}{\numberline {9.5}Function Template Specialization}{61}{subsection.0.9.5}%
\contentsline {subsection}{\numberline {9.6}Class/Struct Template Specialization}{61}{subsection.0.9.6}%
\contentsline {subsection}{\numberline {9.7}Template Parameters}{61}{subsection.0.9.7}%
\contentsline {subsection}{\numberline {9.8}Trailing return type}{61}{subsection.0.9.8}%
\contentsline {subsubsection}{\numberline {9.8.1}Syntax}{62}{subsubsection.0.9.8.1}%
\contentsline {subsubsection}{\numberline {9.8.2}Example}{62}{subsubsection.0.9.8.2}%
\contentsline {subsection}{\numberline {9.9}Template functions with mixed types (Trailing return type)}{62}{subsection.0.9.9}%
\contentsline {subsection}{\numberline {9.10}Template functions with mixed types (Deduced return type)}{63}{subsection.0.9.10}%
\contentsline {subsection}{\numberline {9.11}Dependent name resolution}{63}{subsection.0.9.11}%
\contentsline {subsubsection}{\numberline {9.11.1}Dependent names}{63}{subsubsection.0.9.11.1}%
\contentsline {subsubsection}{\numberline {9.11.2}Typename Keyword}{63}{subsubsection.0.9.11.2}%
\contentsline {subsubsection}{\numberline {9.11.3}Nested types}{64}{subsubsection.0.9.11.3}%
\contentsline {subsubsection}{\numberline {9.11.4}Prereq: Using aliases defined in classes}{64}{subsubsection.0.9.11.4}%
\contentsline {subsubsection}{\numberline {9.11.5}Type Aliases}{65}{subsubsection.0.9.11.5}%
\contentsline {subsubsection}{\numberline {9.11.6}Return Types in Template Functions}{66}{subsubsection.0.9.11.6}%
\contentsline {subsubsection}{\numberline {9.11.7}Base Class Members}{66}{subsubsection.0.9.11.7}%
\contentsline {subsubsection}{\numberline {9.11.8}Dependent Types in Expressions}{66}{subsubsection.0.9.11.8}%
\contentsline {subsection}{\numberline {9.12}Variadic templates with functions}{66}{subsection.0.9.12}%
\contentsline {subsection}{\numberline {9.13}Left vs right folds}{70}{subsection.0.9.13}%
\contentsline {subsection}{\numberline {9.14}Parentheses in fold expressions}{71}{subsection.0.9.14}%
\contentsline {subsection}{\numberline {9.15}Pack size}{71}{subsection.0.9.15}%
\contentsline {subsection}{\numberline {9.16}Function calls in fold expressions}{72}{subsection.0.9.16}%
\contentsline {subsection}{\numberline {9.17}Variadic templates with classes}{73}{subsection.0.9.17}%
\contentsline {subsection}{\numberline {9.18}std::forward}{75}{subsection.0.9.18}%
\contentsline {subsubsection}{\numberline {9.18.1}Key Differences Between std::forward and std::move}{75}{subsubsection.0.9.18.1}%
\contentsline {subsection}{\numberline {9.19}Universal reference (forwarding reference)}{77}{subsection.0.9.19}%
\contentsline {subsection}{\numberline {9.20}Concepts}{78}{subsection.0.9.20}%
\contentsline {section}{\numberline {10}More on the comma operator}{80}{section.0.10}%
\contentsline {section}{\numberline {11}More on Lambdas}{81}{section.0.11}%
\contentsline {subsection}{\numberline {11.1}Auto in lambda args}{81}{subsection.0.11.1}%
\contentsline {subsection}{\numberline {11.2}Template lambdas}{81}{subsection.0.11.2}%
\contentsline {subsection}{\numberline {11.3}Recursive lambdas}{82}{subsection.0.11.3}%
\contentsline {section}{\numberline {12}When initializer lists are required}{83}{section.0.12}%
\contentsline {section}{\numberline {13}Inheritence and Subtype Polymorphism}{84}{section.0.13}%
\contentsline {subsection}{\numberline {13.1}OOP Main Concepts}{84}{subsection.0.13.1}%
\contentsline {subsection}{\numberline {13.2}Object Relationships}{84}{subsection.0.13.2}%
\contentsline {subsection}{\numberline {13.3}Ineritance}{85}{subsection.0.13.3}%
\contentsline {subsection}{\numberline {13.4}Inheritance and Member Access}{85}{subsection.0.13.4}%
\contentsline {subsection}{\numberline {13.5}Inheritance Syntax}{86}{subsection.0.13.5}%
\contentsline {subsection}{\numberline {13.6}Upcasting and Downcasting}{87}{subsection.0.13.6}%
\contentsline {subsection}{\numberline {13.7}More on Downcasting}{88}{subsection.0.13.7}%
\contentsline {subsubsection}{\numberline {13.7.1}What Happens Without Virtual Functions}{89}{subsubsection.0.13.7.1}%
\contentsline {subsubsection}{\numberline {13.7.2}Downcasting example}{90}{subsubsection.0.13.7.2}%
\contentsline {subsubsection}{\numberline {13.7.3}Base class pointer example}{91}{subsubsection.0.13.7.3}%
\contentsline {subsection}{\numberline {13.8}Object Slicing}{91}{subsection.0.13.8}%
\contentsline {subsection}{\numberline {13.9}Multiple Inheritance}{93}{subsection.0.13.9}%
\contentsline {subsubsection}{\numberline {13.9.1}Why Use Multiple Inheritance?}{93}{subsubsection.0.13.9.1}%
\contentsline {subsubsection}{\numberline {13.9.2}Example}{93}{subsubsection.0.13.9.2}%
\contentsline {subsubsection}{\numberline {13.9.3}Issues with Multiple Inheritance}{94}{subsubsection.0.13.9.3}%
\contentsline {subsection}{\numberline {13.10}Virtual inheritance}{95}{subsection.0.13.10}%
\contentsline {subsubsection}{\numberline {13.10.1}The Diamond Problem}{95}{subsubsection.0.13.10.1}%
\contentsline {subsubsection}{\numberline {13.10.2}Solution with Virtual Inheritance}{96}{subsubsection.0.13.10.2}%
\contentsline {subsection}{\numberline {13.11}Subtype Polymorphism}{96}{subsection.0.13.11}%
\contentsline {subsection}{\numberline {13.12}Declaring Virtual Member Functions}{97}{subsection.0.13.12}%
\contentsline {subsubsection}{\numberline {13.12.1}The override keyword}{97}{subsubsection.0.13.12.1}%
\contentsline {subsection}{\numberline {13.13}Abstract or Pure virtual Member Functions}{98}{subsection.0.13.13}%
\contentsline {subsection}{\numberline {13.14}Abstract Classes}{98}{subsection.0.13.14}%
\contentsline {subsection}{\numberline {13.15}Interface Inheritance}{99}{subsection.0.13.15}%
\contentsline {section}{\numberline {14}<regex.h> Pattern Matching and String Validation}{100}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}regcomp}{100}{subsection.0.14.1}%
\contentsline {subsubsection}{\numberline {14.1.1}Signature}{100}{subsubsection.0.14.1.1}%
\contentsline {subsubsection}{\numberline {14.1.2}Return value}{100}{subsubsection.0.14.1.2}%
\contentsline {subsubsection}{\numberline {14.1.3}Return errors}{100}{subsubsection.0.14.1.3}%
\contentsline {subsubsection}{\numberline {14.1.4}Flags}{101}{subsubsection.0.14.1.4}%
\contentsline {subsection}{\numberline {14.2}Regexec}{101}{subsection.0.14.2}%
\contentsline {subsubsection}{\numberline {14.2.1}Signature}{102}{subsubsection.0.14.2.1}%
\contentsline {subsubsection}{\numberline {14.2.2}Return value}{102}{subsubsection.0.14.2.2}%
\contentsline {subsection}{\numberline {14.3}Regerror}{102}{subsection.0.14.3}%
\contentsline {subsubsection}{\numberline {14.3.1}Signature}{102}{subsubsection.0.14.3.1}%
\contentsline {subsubsection}{\numberline {14.3.2}Return value}{103}{subsubsection.0.14.3.2}%
\contentsline {subsection}{\numberline {14.4}Regfree}{103}{subsection.0.14.4}%
\contentsline {subsubsection}{\numberline {14.4.1}Signature}{103}{subsubsection.0.14.4.1}%
\contentsline {subsection}{\numberline {14.5}regmatch\_t and pmatch}{104}{subsection.0.14.5}%
\contentsline {subsubsection}{\numberline {14.5.1}regmatch\_t}{104}{subsubsection.0.14.5.1}%
\contentsline {subsubsection}{\numberline {14.5.2}pmatch array}{105}{subsubsection.0.14.5.2}%
\contentsline {subsection}{\numberline {14.6}Regex Example}{105}{subsection.0.14.6}%
\contentsline {section}{\numberline {15}Structured bindings}{108}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}As unpacks}{108}{subsection.0.15.1}%
\contentsline {subsection}{\numberline {15.2}With returning}{108}{subsection.0.15.2}%
\contentsline {subsection}{\numberline {15.3}With structs and classes}{109}{subsection.0.15.3}%
\contentsline {subsection}{\numberline {15.4}With maps}{109}{subsection.0.15.4}%
\contentsline {section}{\numberline {16}Attributes in c++}{110}{section.0.16}%
\contentsline {subsection}{\numberline {16.1}General Attributes}{110}{subsection.0.16.1}%
\contentsline {section}{\numberline {17}Inline functions}{113}{section.0.17}%
\contentsline {section}{\numberline {18}Advanced iterator usage}{114}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}base()}{114}{subsection.0.18.1}%
\contentsline {section}{\numberline {19}Regular expressions in c++}{115}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}Basic components}{115}{subsection.0.19.1}%
\contentsline {subsubsection}{\numberline {19.1.1}The regex object}{115}{subsubsection.0.19.1.1}%
\contentsline {subsubsection}{\numberline {19.1.2}The smatch array}{115}{subsubsection.0.19.1.2}%
\contentsline {subsubsection}{\numberline {19.1.3}regex\_match}{116}{subsubsection.0.19.1.3}%
\contentsline {subsubsection}{\numberline {19.1.4}regex\_search}{116}{subsubsection.0.19.1.4}%
\contentsline {subsubsection}{\numberline {19.1.5}regex\_replace}{118}{subsubsection.0.19.1.5}%
\contentsline {subsection}{\numberline {19.2}match\_results}{118}{subsection.0.19.2}%
\contentsline {subsubsection}{\numberline {19.2.1}Methods}{118}{subsubsection.0.19.2.1}%
\contentsline {subsection}{\numberline {19.3}sub\_match}{119}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}Passing string iterators}{120}{subsection.0.19.4}%
\contentsline {subsubsection}{\numberline {19.4.1}Getting all matches}{120}{subsubsection.0.19.4.1}%
\contentsline {subsection}{\numberline {19.5}smatch prefix and suffix}{121}{subsection.0.19.5}%
\contentsline {section}{\numberline {20}Standard namespace}{123}{section.0.20}%
\contentsline {subsection}{\numberline {20.1}std::bind}{123}{subsection.0.20.1}%
\contentsline {subsubsection}{\numberline {20.1.1}std::placeholders}{123}{subsubsection.0.20.1.1}%
\contentsline {subsubsection}{\numberline {20.1.2}Using std::ref with bind}{124}{subsubsection.0.20.1.2}%
\contentsline {subsection}{\numberline {20.2}std::invoke}{125}{subsection.0.20.2}%
\contentsline {subsubsection}{\numberline {20.2.1}Calling a regular function}{125}{subsubsection.0.20.2.1}%
\contentsline {subsubsection}{\numberline {20.2.2}Calling a member function}{125}{subsubsection.0.20.2.2}%
\contentsline {subsubsection}{\numberline {20.2.3}Accessing a member variable}{126}{subsubsection.0.20.2.3}%
\contentsline {subsubsection}{\numberline {20.2.4}Calling a lambda}{126}{subsubsection.0.20.2.4}%
\contentsline {subsection}{\numberline {20.3}std::exchange}{127}{subsection.0.20.3}%
\contentsline {subsection}{\numberline {20.4}std::swap}{128}{subsection.0.20.4}%
\contentsline {subsection}{\numberline {20.5}std::get}{129}{subsection.0.20.5}%
\contentsline {subsection}{\numberline {20.6}std::tuple}{130}{subsection.0.20.6}%
\contentsline {subsubsection}{\numberline {20.6.1}std::tuple and std::make\_tuple}{130}{subsubsection.0.20.6.1}%
\contentsline {subsubsection}{\numberline {20.6.2}Modifying elements}{130}{subsubsection.0.20.6.2}%
\contentsline {subsubsection}{\numberline {20.6.3}std::tuple\_size}{130}{subsubsection.0.20.6.3}%
\contentsline {subsubsection}{\numberline {20.6.4}Unpacking with std::tie}{131}{subsubsection.0.20.6.4}%
\contentsline {subsubsection}{\numberline {20.6.5}std::tie with std::ignore}{131}{subsubsection.0.20.6.5}%
\contentsline {subsubsection}{\numberline {20.6.6}std::optional <optional>}{131}{subsubsection.0.20.6.6}%
\contentsline {subsubsection}{\numberline {20.6.7}std::expected <expected>}{132}{subsubsection.0.20.6.7}%
\contentsline {subsubsection}{\numberline {20.6.8}std::format <format>}{132}{subsubsection.0.20.6.8}%
\contentsline {subsection}{\numberline {20.7}std::bitset <bitset>}{132}{subsection.0.20.7}%
\contentsline {subsubsection}{\numberline {20.7.1}Operations on bitset}{133}{subsubsection.0.20.7.1}%
\contentsline {section}{\numberline {21}Views and Ranges}{135}{section.0.21}%
\contentsline {subsection}{\numberline {21.1}Views}{135}{subsection.0.21.1}%
\contentsline {subsubsection}{\numberline {21.1.1}Filter and transform}{135}{subsubsection.0.21.1.1}%
\contentsline {subsubsection}{\numberline {21.1.2}Iota}{136}{subsubsection.0.21.1.2}%
\contentsline {subsubsection}{\numberline {21.1.3}Take and drop}{136}{subsubsection.0.21.1.3}%
\contentsline {subsection}{\numberline {21.2}The ranges library}{136}{subsection.0.21.2}%
\contentsline {subsection}{\numberline {21.3}std::span}{136}{subsection.0.21.3}%
\contentsline {subsubsection}{\numberline {21.3.1}What does it mean to be "non-owning"}{137}{subsubsection.0.21.3.1}%
\contentsline {subsubsection}{\numberline {21.3.2}subspans}{137}{subsubsection.0.21.3.2}%
\contentsline {subsubsection}{\numberline {21.3.3}Key member functions}{138}{subsubsection.0.21.3.3}%
\contentsline {section}{\numberline {22}constexpr, consteval, and constinit}{139}{section.0.22}%
\contentsline {subsection}{\numberline {22.1}constexpr Objects}{139}{subsection.0.22.1}%
\contentsline {subsection}{\numberline {22.2}More on constexpr variables}{140}{subsection.0.22.2}%
\contentsline {subsection}{\numberline {22.3}When const Can Make a Compile-Time Constant}{140}{subsection.0.22.3}%
\contentsline {subsection}{\numberline {22.4}if constexpr}{141}{subsection.0.22.4}%
\contentsline {subsection}{\numberline {22.5}Is constexpr const}{142}{subsection.0.22.5}%
\contentsline {subsection}{\numberline {22.6}consteval}{142}{subsection.0.22.6}%
\contentsline {subsection}{\numberline {22.7}constinit}{144}{subsection.0.22.7}%
\contentsline {subsection}{\numberline {22.8}constexpr and consteval functions are implicitly inline}{144}{subsection.0.22.8}%
\contentsline {section}{\numberline {23}Smart pointers}{145}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}Class shared\_ptr}{146}{subsection.0.23.1}%
\contentsline {subsubsection}{\numberline {23.1.1}Using Class shared\_ptr}{146}{subsubsection.0.23.1.1}%
\contentsline {subsubsection}{\numberline {23.1.2}Defining a Deleter}{148}{subsubsection.0.23.1.2}%
\contentsline {subsubsection}{\numberline {23.1.3}Dealing with Arrays}{149}{subsubsection.0.23.1.3}%
\contentsline {subsubsection}{\numberline {23.1.4}More on make\_shared}{150}{subsubsection.0.23.1.4}%
\contentsline {subsubsection}{\numberline {23.1.5}Understanding the reference count}{151}{subsubsection.0.23.1.5}%
\contentsline {subsubsection}{\numberline {23.1.6}Cyclic references}{152}{subsubsection.0.23.1.6}%
\contentsline {subsubsection}{\numberline {23.1.7}Practical use of owner\_before()}{153}{subsubsection.0.23.1.7}%
\contentsline {subsection}{\numberline {23.2}Class weak\_ptr}{154}{subsection.0.23.2}%
\contentsline {subsubsection}{\numberline {23.2.1}Using a weak\_ptr}{155}{subsubsection.0.23.2.1}%
\contentsline {subsection}{\numberline {23.3}Unique\_ptr}{156}{subsection.0.23.3}%
\contentsline {subsubsection}{\numberline {23.3.1}Using a unique\_ptr}{157}{subsubsection.0.23.3.1}%
\contentsline {subsubsection}{\numberline {23.3.2}Transfer of Ownership by unique\_ptr}{158}{subsubsection.0.23.3.2}%
\contentsline {subsubsection}{\numberline {23.3.3}Source and Sink}{159}{subsubsection.0.23.3.3}%
\contentsline {subsubsection}{\numberline {23.3.4}unique\_ptrs as Members}{160}{subsubsection.0.23.3.4}%
\contentsline {subsubsection}{\numberline {23.3.5}Dealing with arrays}{161}{subsubsection.0.23.3.5}%
\contentsline {subsubsection}{\numberline {23.3.6}Double ownership}{162}{subsubsection.0.23.3.6}%
\contentsline {subsection}{\numberline {23.4}Smart pointers to stack memory?}{163}{subsection.0.23.4}%
\contentsline {section}{\numberline {24}Three way comparisons (spaceship operator) <compare>}{164}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}Custom <=> logic}{164}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Return types}{164}{subsection.0.24.2}%
\contentsline {subsection}{\numberline {24.3}Spaceship on primitive types}{165}{subsection.0.24.3}%
\contentsline {section}{\numberline {25}Single Dispatch and Overload Resolution}{166}{section.0.25}%
\contentsline {subsection}{\numberline {25.1}Single dispatch}{166}{subsection.0.25.1}%
\contentsline {subsection}{\numberline {25.2}Overload resolution (compile time)}{166}{subsection.0.25.2}%
\contentsline {section}{\numberline {26}Bitfields}{167}{section.0.26}%
\contentsline {subsubsection}{\numberline {26.0.1}Address operator on a bitfield?}{168}{subsubsection.0.26.0.1}%
\contentsline {section}{\numberline {27}Ref qualifiers}{169}{section.0.27}%
\contentsline {section}{\numberline {28}Understanding function types}{170}{section.0.28}%
\contentsline {subsection}{\numberline {28.1}free functions}{170}{subsection.0.28.1}%
\contentsline {section}{\numberline {29}Covariant return types}{171}{section.0.29}%
\contentsline {subsection}{\numberline {29.1}Rules for Covariant Return Types}{171}{subsection.0.29.1}%
\contentsline {subsection}{\numberline {29.2}Why Use Covariant Return Types?}{171}{subsection.0.29.2}%
\contentsline {section}{\numberline {30}declval}{172}{section.0.30}%
\contentsline {section}{\numberline {31}Value Categories}{173}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Lvalue (Locator Value)}{173}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Rvalue (Right Value)}{173}{subsection.0.31.2}%
\contentsline {subsection}{\numberline {31.3}Xvalue (Expiring Value)}{173}{subsection.0.31.3}%
\contentsline {subsubsection}{\numberline {31.3.1}Why Does an Xvalue Have a Memory Address?}{174}{subsubsection.0.31.3.1}%
\contentsline {subsection}{\numberline {31.4}PRvalue (Pure Rvalue)}{174}{subsection.0.31.4}%
\contentsline {subsection}{\numberline {31.5}Glvalue (Generalized Lvalue)}{174}{subsection.0.31.5}%
\contentsline {subsection}{\numberline {31.6}Summary}{175}{subsection.0.31.6}%
\contentsline {section}{\numberline {32}Deleting functions}{176}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}Deleting all non-matching overloads }{176}{subsection.0.32.1}%
\contentsline {section}{\numberline {33}Copy elision}{177}{section.0.33}%
\contentsline {section}{\numberline {34}User defined literals}{178}{section.0.34}%
\contentsline {subsubsection}{\numberline {34.0.1}Why unsigned long long and long double?}{178}{subsubsection.0.34.0.1}%
\contentsline {section}{\numberline {35}C++ versions and their additions}{179}{section.0.35}%
