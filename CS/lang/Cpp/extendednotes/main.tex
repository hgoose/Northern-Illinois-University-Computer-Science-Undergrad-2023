\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Second Cpp Notes}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Extended CPP Notes}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           April 17, 2024 \\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
   \pagebreak 
   \unsect{STL Containers}
   \subsection{STL Vectors}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent 
   A vector models a dynamic array. Thus, a vector is an abstraction that manages its elements with a dynamic C-style arra
   \bigbreak \noindent 
   A vector copies its elements into its internal dynamic array. The elements always have a certain order. Thus, a vector is a kind of ordered collection. A vector provides random access. Thus, you can access every element directly in constant time, provided that you know its position. The iterators are random-access iterators, so you can use any algorithm of the STL.

   \bigbreak \noindent 
   \subsubsection{Performance in operations on the end}
   \bigbreak \noindent 
   Vectors provide good performance if you append or delete elements at the end. If you insert or
   delete in the middle or at the beginning, performance gets worse. This is because every element
   behind has to be moved to another position. In fact, the assignment operator would be called for
   every following element.

   \bigbreak \noindent 
   \subsubsection{Size and capacity}
   \bigbreak \noindent 
   Part of the way in which vectors give good performance is by allocating more memory than they
   need to contain all their elements. To use vectors effectively and correctly, you should understand
   how size and capacity cooperate in a vector.
   \bigbreak \noindent 
   Vectors provide the usual size operations size(), empty(), and max\_size(). An additional “size” operation is the capacity() function, which returns the number of
   elements a vector could contain in its actual memory. If you exceed the capacity(), the vector has
   to reallocate its internal memory.
   \bigbreak \noindent 
   The capacity of a vector is important for two reasons:
   \begin{enumerate}
       \item Reallocation invalidates all references, pointers, and iterators for elements of the vector
       \item Reallocation takes time.
   \end{enumerate}
   Thus, if a program manages pointers, references, or iterators into a vector, or if speed is a goal, it is
   important to take the capacity into account
   \bigbreak \noindent 
   To avoid reallocation, you can use reserve() to ensure a certain capacity before you really need
it. In this way, you can ensure that references remain valid as long as the capacity is not exceeded:
\bigbreak \noindent 
Another way to avoid reallocation is to initialize a vector with enough elements by passing additional
arguments to the constructor. For example, if you pass a numeric value as parameter, it is taken as
the starting size of the vector:
\bigbreak \noindent 
\begin{cppcode}
    std::vector<T> v(5);
\end{cppcode}
\bigbreak \noindent 
\textbf{Note:} If the only reason for initialization is to reserve memory, you should use reserve()
\bigbreak \noindent 
Unlike for strings, it is not possible to call reserve() for vectors to shrink the capacity. Calling reserve() with an argument that is less than the current capacity is a no-op
\bigbreak \noindent 
Because the capacity of vectors never shrinks, it is guaranteed that references, pointers, and
iterators remain valid even when elements are deleted, provided that they refer to a position before
the manipulated elements. However, insertions invalidate all references, pointers, and iterators when
the capacity gets exceeded

\bigbreak \noindent 
\subsubsection{Constructors}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{vector<Elem> c} \\
          Default constructor; creates an empty vector without any elements.
          
    \item \texttt{vector<Elem> c(c2)} \\
          Copy constructor; creates a new vector as a copy of \texttt{c2} (all elements are copied).
          
    \item \texttt{vector<Elem> c = c2} \\
          Copy constructor; creates a new vector as a copy of \texttt{c2} (all elements are copied).
          
    \item \texttt{vector<Elem> c(rv)} \\
          Move constructor; creates a new vector, taking the contents of the rvalue \texttt{rv} (since C++11).
          
    \item \texttt{vector<Elem> c = rv} \\
          Move constructor; creates a new vector, taking the contents of the rvalue \texttt{rv} (since C++11).
          
    \item \texttt{vector<Elem> c(n)} \\
          Creates a vector with \texttt{n} elements created by the default constructor.
          
    \item \texttt{vector<Elem> c(n, elem)} \\
          Creates a vector initialized with \texttt{n} copies of element \texttt{elem}.
          
    \item \texttt{vector<Elem> c(beg, end)} \\
          Creates a vector initialized with the elements of the range [\texttt{beg}, \texttt{end}].
          
    \item \texttt{vector<Elem> c\{initlist\}} \\
          Creates a vector initialized with the elements of the initializer list \texttt{initlist} (since C++11).
          
    \item \texttt{vector<Elem> c = \{initlist\}} \\
        Creates a vector initialized with the elements of the initializer list \texttt{initlist} (since C++11).

    \item \texttt{c.~vector()} \\
        Destroys all elements and frees the memory.
\end{itemize}

\subsubsection{Note about at()}
\bigbreak \noindent 
Out of all the element access operators and methods: [], at(), front(), back(), only at() performs range checking. If the index is out of range, at() throws an out\_of\_range
\bigbreak \noindent 
All other functions do not check. A range error results in
undefined behavior. Calling operator [ ], front(), and back() for an empty container always
results in undefined behavior:

\bigbreak \noindent 
\subsubsection{Iterator methods}
\bigbreak \noindent 
We have
\begin{itemize}
    \item begin()
    \item end()
    \item rbegin()
    \item cbegin()
    \item cend()
    \item crbegin()
    \item crend()
\end{itemize}

    \bigbreak \noindent 
    \subsubsection{Using vectors as 2d arrays}
    \bigbreak \noindent 
    There is an issue that comes up when trying to use 2D arrays, when the size of the matrix is not known at compile time.
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int nrows, int ncols) {
            int arr[nrows][ncols]
        }

        int main() {
            f(5,6);
            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    The problem with this code is that the array arr inside the function f is declared with dimensions nrows and ncols, which are non-constant variables. In C++, standard arrays require their sizes to be constant at compile time, but in your code, the array dimensions are determined by function parameters, which are only known at runtime.
    \bigbreak \noindent 
    This means int arr[nrows][ncols] is not valid because the array size is determined at runtime, not compile time.
    \pagebreak \bigbreak \noindent 
    The most common and modern way to handle dynamic arrays in C++ is by using std::vector.
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int r, int c) {
            vector<vector<int>> m;
            m.resize(r);

            for (int i=0; i<c; ++i) {
                m[i].resize(c);
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    Or simply
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int nrows, int ncols) {
            // Create a vector of vectors (2D array)
            std::vector<std::vector<int>> arr(nrows, std::vector<int>(ncols));

            // Access elements like arr[i][j]
            for (int i = 0; i < nrows; ++i) {
                for (int j = 0; j < ncols; ++j) {
                    arr[i][j] = i * ncols + j;  // Example of initializing elements
                }
            }
        }

        int main() {
            f(5, 6);
            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    the constructor of std::vector is designed to accept an element initializer. In this case, the std::vector<int>(ncols) argument is used to initialize each element of the outer std::vector<std::vector<int>>. The constructor in question is 
    \bigbreak \noindent 
    \begin{cppcode}
        vector(size_type count, const T& value);
    \end{cppcode}
    \bigbreak \noindent 
    Where size\_type in this context is a typedef for size\_t.

    \pagebreak 
    \subsubsection{For those interested}
    \bigbreak \noindent 
    There are some other ways to solve this issue.
    \bigbreak \noindent 
    \paragraph{Manual Dynamic Memory Allocation (Using new)}
    \bigbreak \noindent \bigbreak \noindent 
    If for some reason you cannot use std::vector and need to manually allocate dynamic memory, you can use new to create a 2D array. This approach gives you control over memory allocation, but you must manually free the memory to avoid memory leaks.
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int r, int c) {
            int** arr = new int*[r];

            for (int i=0; i<r; ++i) {
                arr[i] = new int[c];
            }

            // Access elements like arr[i][j]
            int count=0;
            for (int i = 0; i < r; ++i) {
                for (int j = 0; j < c; ++j) {
                    arr[i][j] = count++;
                    cout << arr[i][j] << endl;
                }
            }

            // Free the memory when done
            for (int i = 0; i < r; ++i) {
                delete[] arr[i];  // Free each row
            }
            delete[] arr;  // Free the array of pointers
        }
    \end{cppcode}
    \bigbreak \noindent 
    \nt{heap allocation using new in C++ happens at runtime.}

    \bigbreak \noindent 
    \paragraph{Using unique pointer}
    \bigbreak \noindent \bigbreak \noindent 
    If you need more control over memory allocation but want to avoid the risk of memory leaks, you can use std::unique\_ptr to automatically manage memory
    \bigbreak \noindent 
    \begin{cppcode}
        void f(int nrows, int ncols) {
            // Allocate memory for a 2D array using std::unique_ptr
            std::unique_ptr<std::unique_ptr<int[]>[]> arr = std::make_unique<std::unique_ptr<int[]>[]>(nrows);
            for (int i = 0; i < nrows; ++i) {
                arr[i] = std::make_unique<int[]>(ncols);  // Allocate each row
            }

            // Access elements like arr[i][j]
            for (int i = 0; i < nrows; ++i) {
                for (int j = 0; j < ncols; ++j) {
                    arr[i][j] = i * ncols + j;  // Example of initializing elements
                }
            }
            // No need to manually free memory; std::unique_ptr handles it automatically
        }
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{How it works:}
    \begin{enumerate}
        \item \textbf{std::unique\_ptr<std::unique\_ptr<int[]>[]>}: is a unique pointer to an array of unique pointers, where each unique pointer in the array manages a dynamically allocated array of integers.
        \item \textbf{std::make\_unique<std::unique\_ptr<int[]>[]>(r)}: allocates an array of r unique pointers, each of which will eventually point to a row of integers.
    \end{enumerate}

    \bigbreak \noindent 
    \paragraph{Recall: Unique pointer for dynamic arry}
    \bigbreak \noindent 
    \bigbreak \noindent 
    \bigbreak \noindent 
    \begin{cppcode}
    #include <memory>
    using std::unique_ptr;
    using std::make_unique;
    int main() {
        unique_ptr<int[]> arr = make_unique<int[]>(size) // Which is the same as int* arr = new int[size]

        return 0;
}
    \end{cppcode}

    \pagebreak \bigbreak \noindent 
    \paragraph{If sizes are truly known at compile time}
    \bigbreak \noindent \bigbreak \noindent 
    If the dimensions are truly known at compile time, you can pass them as template arguments:
    \bigbreak \noindent 
    \begin{cppcode}
        template <int r, int c>
        void f() {
            int arr[r][c];  // Valid because r and c are compile-time constants
            // Initialize and print the array (for demonstration)
            for (int i = 0; i < r; ++i) {
                for (int j = 0; j < c; ++j) {
                    arr[i][j] = i * c + j;
                    std::cout << arr[i][j] << " ";
                }
                std::cout << std::endl;
            }
        }

        int main() {
            constexpr int r = 5;
            constexpr int c = 6;
            f<r, c>();  // Call function with compile-time constant dimensions
            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    The reason this code works when using template parameters is that the template parameters r and c are compile-time constants. In C++, when you use template parameters like this, the values of r and c are determined at compile time, allowing the array sizes to be known by the compiler ahead of time









    \pagebreak 
    \subsection{STL Deque}
    \bigbreak \noindent 
    \subsubsection{Implementation}
    \bigbreak \noindent 
    A deque (pronounced “deck”) is very similar to a vector. It manages its elements with a dynamic
    array, provides random access, and has almost the same interface as a vector. The difference is
    that with a deque, the dynamic array is open at both ends. Thus, a deque is fast for insertions and
    deletions at both the end and the beginning
    \bigbreak \noindent 
    To provide this ability, the deque is typically implemented as a bunch of individual blocks, with the
    first block growing in one direction and the last block growing in the opposite direction

    \subsubsection{Abilities, performance, uses}
    \bigbreak \noindent 
    The abilities of deques differ from those of vectors as follows:
    \begin{itemize}
        \item Inserting and removing elements is fast at both the beginning and the end (for vectors, it is fast only at the end). These operations are done in amortized constant time.
        \item The internal structure has one more indirection to access the elements, so with deques, element access and iterator movement are usually a bit slower.
        \item Iterators must be smart pointers of a special type rather than ordinary pointers because they must jump between different blocks.
        \item In systems that have size limitations for blocks of memory (for example, some PC systems), a deque might contain more elements because it uses more than one block of memory. Thus, max\_size() might be larger for deques.
        \item Deques provide no support to control the capacity and the moment of reallocation. In particular, any insertion or deletion of elements other than at the beginning or end invalidates all pointers, references, and iterators that refer to elements of the deque. However, reallocation may perform better than for vectors because according to their typical internal structure, deques don’t have to copy all elements on reallocation.
        \item Blocks of memory might get freed when they are no longer used, so the memory size of a deque might shrink (however, whether and how this happens is implementation specific).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{When to use deques}
    \begin{itemize}
        \item You insert and remove elements at both ends (this is the classic case for a queue).
        \item You don’t refer to elements of the container.
        \item It is important that the container frees memory when it is no longer used (however, the standard does not guarantee that this happens).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Constructors}
    \begin{itemize}
    \item \texttt{deque<Elem> c} \\
        Default constructor; creates an empty deque without any elements.
    \item \texttt{deque<Elem> c(c2)} \\
        Copy constructor; creates a new deque as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{deque<Elem> c = c2} \\
        Copy assignment operator; creates a new deque as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{deque<Elem> c(rv)} \\
        Move constructor; creates a new deque, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{deque<Elem> c = rv} \\
        Move assignment operator; creates a new deque, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{deque<Elem> c(n)} \\
        Creates a deque with \texttt{n} elements created by the default constructor.
    \item \texttt{deque<Elem> c(n, elem)} \\
        Creates a deque initialized with \texttt{n} copies of element \texttt{elem}.
    \item \texttt{deque<Elem> c(beg, end)} \\
        Creates a deque initialized with the elements of the range \texttt{[beg, end]}.
    \item \texttt{deque<Elem> c \{inilist\}} \\
        Creates a deque initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{deque<Elem> c = \{inilist\}} \\
        Creates a deque initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{c.\textasciitilde deque()} \\
        Destroys all elements and frees the memory.
\end{itemize}
\bigbreak \noindent 
Deque operations differ from vector operations in only two ways:
\begin{enumerate}
    \item Deques do not provide the functions for capacity (capacity() and reserve()).
    \item Deques do provide direct functions to insert and to delete the first element (push\_front() and pop\_front()).
\end{enumerate}




   \pagebreak 
   \subsection{STL Lists}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent 
   Manages its elements as a doubly linked list. As usual, the C++ standard library does not specify the kind of the implementation, but it follows from the list’s name, constraints, and specifications.
   \bigbreak \noindent 
   \subsubsection{Abilities}
   \bigbreak \noindent 
   The internal structure of a list is totally different from that of an array, a vector, or a deque. The list
object itself provides two pointers, the so-called anchors, which refer to the first and last elements.
Each element has pointers to the previous and next elements (or back to the anchor). To insert a new
element, you just manipulate the corresponding pointers
\bigbreak \noindent 
Thus, a list differs in several major ways from arrays, vectors, and deques:
\begin{itemize}
    \item A list does not provide random access. For example, to access the fifth element, you must navigate the first four elements, following the chain of links. Thus, accessing an arbitrary element using a list is slow. However, you can navigate through the list from both end. So accessing both the first and the last elements is fast.
    \item Inserting and removing elements is fast at each position (provided you are there), and not only at one or both ends. You can always insert and delete an element in constant time, because no other elements have to be moved. Internally, only some pointer values are manipulated.
    \item Inserting and deleting elements does not invalidate pointers, references, and iterators to other elements.
    \item A list supports exception handling in such a way that almost every operation succeeds or is a no-op. Thus, you can’t get into an intermediate state in which only half of the operation is complete.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Differencs in the methods}
\bigbreak \noindent 
The member functions provided for lists reflect these differences from arrays, vectors, and deques as follows:
\begin{itemize}
    \item Lists provide front(), push\_front(), and pop\_front(), as well as back(), push\_back(), and pop\_back().
    \item Lists provide neither a subscript operator nor at(), because no random access is provided.
\item Lists don’t provide operations for capacity or reallocation, because neither is needed. Each element has its own memory that stays valid until the element is deleted.
\item Lists provide many special member functions for moving and removing elements. These member functions are faster versions of general algorithms that have the same names. They are faster because they only redirect pointers rather than copy and move the values.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Constructors}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{list<Elem> c} \\
        Default constructor; creates an empty list without any elements.
    \item \texttt{list<Elem> c(c2)} \\
        Copy constructor; creates a new list as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{list<Elem> c = c2} \\
        Copy assignment operator; creates a new list as a copy of \texttt{c2} (all elements are copied).
    \item \texttt{list<Elem> c(rv)} \\
        Move constructor; creates a new list, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{list<Elem> c = rv} \\
        Move assignment operator; creates a new list, taking the contents of the rvalue \texttt{rv} (since C++11).
    \item \texttt{list<Elem> c(n)} \\
        Creates a list with \texttt{n} elements created by the default constructor.
    \item \texttt{list<Elem> c(n, elem)} \\
        Creates a list initialized with \texttt{n} copies of element \texttt{elem}.
    \item \texttt{list<Elem> c(beg, end)} \\
        Creates a list initialized with the elements of the range \texttt{[beg, end]}.
    \item \texttt{list<Elem> c\{inilist\}} \\
        Creates a list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{list<Elem> c = \{inilist\}} \\
        Creates a list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    \item \texttt{c.\~list()} \\
        Destroys all elements and frees the memory.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Element access}
\bigbreak \noindent 
With lists, we only have front and back methods. However, these methods do not check for existence. Calling these methods on empty containers results in undefined behavior
\bigbreak \noindent 
Thus, the caller must ensure that the container contains at least one element

\bigbreak \noindent 
\subsubsection{Iterator functions}
\bigbreak \noindent 
To access all elements of a list, you must use iterators. Lists provide the usual iterator functions. However, because a list has no random access, these iterators are only bidirectional.
Thus, you can’t call algorithms that require random-access iterators. All algorithms that manipulate
the order of elements a lot, especially sorting algorithms, are in this category. However, for sorting
the elements, lists provide the special member function sort()

\bigbreak \noindent 
\subsubsection{Splice Functions and Functions to Change the Order of Elements}
\bigbreak \noindent 
Linked lists have the advantage that you can remove and insert elements at any position in constant
time. If you move elements from one container to another, this advantage doubles in that you need
only redirect some internal pointers
\bigbreak \noindent 
To support this ability, lists provide not only remove() but also additional modifying member
functions to change the order of and relink elements and ranges.




   \pagebreak 
   \subsection{STL Forward lists}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent 
   \bigbreak \noindent 
   A forward list (an instance of the container class forward\_list<>), which was introduced with C++11, manages its elements as a singly linked list
   \bigbreak \noindent 
   Conceptionally, a forward list is a list (object of class list<>) restricted such that it is not able to iterate backward. It provides no functionality that is not also provided by lists. As benefits, it uses less memory and provides slightly better runtime behavior. The standard states: “It is intended that forward\_list have zero space or time overhead relative to a hand-written C-style singly linked list. Features that would conflict with that goal have been omitted.

   \bigbreak \noindent 
   \subsubsection{Abilities, limitations}
   \bigbreak \noindent \bigbreak \noindent 
   Forward lists have the following limitations compared to lists:
   \begin{itemize}
       \item A forward list provides only forward iterators, not bidirectional iterators. As a consequence, no reverse iterator support is provided, which means that types, such as reverse\_iterator, and member functions, such as rbegin(), rend(), crbegin(), and crend(), are not provided.
       \item A forward list does not provide a size() member function. This is a consequence of omitting features that create time or space overhead relative to a handwritten singly linked list.
       \item The anchor of a forward list has no pointer to the last element. For this reason, a forward list does not provide the special member functions to deal with the last element, back(), push\_back(), and pop\_back().
       \item For all member functions that modify forward lists in a way that elements are inserted or deleted at a specific position, special versions for forward lists are provided. The reason is that you have to pass the position of the element before the first element that gets manipulated, because there you have to assign a new successor element. Because you can’t navigate backwards (at least not in constant time), for all these member functions you have to pass the position of the preceding element. Because of this difference, these member functions have a \_after suffix in their name. For example, instead of insert(), insert\_after() is provided, which inserts new elements after the element passed as first argument; that is, it appends an element at that position.
       \item For this reason, forward lists provide before\_begin() and cbefore\_begin(), which yield the position of a virtual element before the first element (technically speaking, the anchor of the linked list), which can be used to let built-in algorithms ending with \_after exchange even the first element.
   \end{itemize}

   \bigbreak \noindent 
   \subsubsection{No size()?}
   \bigbreak \noindent \bigbreak \noindent 
   The decision not to provide size() might be especially surprising because size() is one of the operations required for all STL containers. Here, you can see the consequences of the design goal to have “zero space or time overhead relative to a hand-written Cstyle singly linked list.” The alternative would have been either to compute the size each time size() is called, which would have linear complexity, or to provide an additional field in the forward\_list object for the size, which is updated with each and every operation that changes the number of elements. As the design paper for the forward list, “It’s a cost that all users would have to pay for, whether they need this feature or not.” So, if you need the size, either track it outside the forward\_list or use a list instead.
   \bigbreak \noindent 
   If you have to compute the number of elements, you can use distance()
   \bigbreak \noindent 
   \begin{cppcode}
   #include <forward_list>
   #include <iterator>

   std::forward_list<int> l;
   std::cout << "Size: " << std::distance(l.begin(), l.end()) << std::endl;
   \end{cppcode}

   \bigbreak \noindent 
   \subsubsection{Similarities to list}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{itemize}
       \item A forward list does not provide random access. For example, to access the fifth element, you
       \item must navigate the first four elements, following the chain of links. Thus, using a forward list to access an arbitrary element is slow.
       \item Inserting and removing elements is fast at each position, if you are there. You can always insert and delete an element in constant time, because no other elements have to be moved. Internally, only some pointer values are manipulated.
       \item Inserting and deleting elements does not invalidate iterators, references, and pointers to other elements.
       \item A forward list supports exception handling in such a way that almost every operation succeeds or is a no-op. Thus, you can’t get into an intermediate state in which only half of the operation is complete.
       \item Forward lists provide many special member functions for moving and removing elements. These member functions are faster versions of general algorithms, because they only redirect pointers rather than copy and move the values. However, when element positions are involved, you have to pass the preceding position, and the member function has the suffix \_after in its name.
   \end{itemize}

   \bigbreak \noindent 
   \subsubsection{Constructors}
   \bigbreak \noindent 
   \bigbreak \noindent 
   \begin{itemize}
    \item \texttt{forward\_list<Elem> c} \\
    Default constructor; creates an empty forward list without any elements.
    
    \item \texttt{forward\_list<Elem> c(c2)} \\
    Copy constructor; creates a new forward list as a copy of \texttt{c2} (all elements are copied).
    
    \item \texttt{forward\_list<Elem> c = c2} \\
    Copy assignment operator; creates a new forward list as a copy of \texttt{c2} (all elements are copied).
    
    \item \texttt{forward\_list<Elem> c(rv)} \\
    Move constructor; creates a new forward list, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{forward\_list<Elem> c = rv} \\
    Move assignment operator; creates a new forward list, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{forward\_list<Elem> c(n)} \\
    Creates a forward list with \texttt{n} elements created by the default constructor.
    
    \item \texttt{forward\_list<Elem> c(n, elem)} \\
    Creates a forward list initialized with \texttt{n} copies of element \texttt{elem}.
    
    \item \texttt{forward\_list<Elem> c(beg, end)} \\
    Creates a forward list initialized with the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{forward\_list<Elem> c\{inilist\}} \\
    Creates a forward list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{forward\_list<Elem> c = \{inilist\}} \\
    Creates a forward list initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{c.\~forward\_list()} \\
    Destroys all elements and frees the memory.
\end{itemize}




   \pagebreak 
   \subsection{STL Sets and multisets}
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent \bigbreak \noindent 
   Sets and multisets are implemented as height balanced binary search trees. (red-black trees)
   \bigbreak \noindent 
   Set and multiset containers sort their elements automatically according to a certain sorting criterion. The difference between the two types of containers is that multisets allow duplicates, whereas sets do not
   \bigbreak \noindent 
   The elements of a set or a multiset may have any type T that is comparable according to the sorting criterion. The optional second template argument defines the sorting criterion. If a special sorting criterion is not passed, the default criterion less is used. The function object less sorts the elements by comparing them with operator $<$
   \bigbreak \noindent 
   The optional third template parameter defines the memory model. The default memory model is the model allocator, which is provided by the C++ standard library.
   \bigbreak \noindent 
   \subsubsection{Strict weak ordering}
   \bigbreak \noindent \bigbreak \noindent 
   The sorting criterion must define strict weak ordering, which is defined by the following four properties:
   \begin{enumerate}
       \item It has to be \textbf{antisymmetric}.
           \begin{itemize}
               \item This means that for operator \texttt{<}: If $x < y$ is true, then $y < x$ is false.
               \item This means that for a predicate \texttt{op()}: If \texttt{op(x, y)} is true, then \texttt{op(y, x)} is false.
           \end{itemize}

       \item It has to be \textbf{transitive}.
           \begin{itemize}
               \item This means that for operator \texttt{<}: If $x < y$ is true and $y < z$ is true, then $x < z$ is true.
               \item This means that for a predicate \texttt{op()}: If \texttt{op(x, y)} is true and \texttt{op(y, z)} is true, then \texttt{op(x, z)} is true.
           \end{itemize}

       \item It has to be \textbf{irreflexive}.
           \begin{itemize}
               \item This means that for operator \texttt{<}: $x < x$ is always false.
               \item This means that for a predicate \texttt{op()}: \texttt{op(x, x)} is always false.
           \end{itemize}

       \item It has to have \textbf{transitivity of equivalence}, which means roughly: If $a$ is equivalent to $b$ and $b$ is equivalent to $c$, then $a$ is equivalent to $c$.
           \begin{itemize}
               \item This means that for operator \texttt{<}: If !$(a < b)$ \&\& !$(b < a)$ is true and !$(b < c)$ \&\& !$(c < b)$ is true, then !$(a < c)$ \&\& !$(c < a)$ is true.
               \item This means that for a predicate \texttt{op()}: If \texttt{op(a, b)}, \texttt{op(b, a)}, \texttt{op(b, c)}, and \texttt{op(c, b)} all yield false, then \texttt{op(a, c)} and \texttt{op(c, a)} yield false.
           \end{itemize}
   \end{enumerate}
   \bigbreak \noindent 
   \textbf{Note}: Note that this means that you have to distinguish between less and equal. A criterion such as operator \texttt{<=} does not fulfill this requirement.
   \bigbreak \noindent 
   Based on these properties, the sorting criterion is also used to check equivalence. That is, two elements are considered to be duplicates if neither is less than the other (or if both \texttt{op(x, y)} and \texttt{op(y, x)} are false).
   \bigbreak \noindent 
   For multisets, the order of equivalent elements is random but stable. Thus, insertions and erasures preserve the relative ordering of equivalent elements (guaranteed since C++11).
   \bigbreak \noindent 
   \subsubsection{Abilities}
   \bigbreak \noindent \bigbreak \noindent 
   Like all standardized associative container classes, sets and multisets are usually implemented as balanced binary trees
   \bigbreak \noindent 
   The major advantage of automatic sorting is that a binary tree performs well when elements with
a certain value are searched. In fact, search functions have logarithmic complexity. For example, to
search for an element in a set or a multiset of 1,000 elements, a tree search performed by a member
function needs, on average, one-fiftieth of the comparisons of a linear search

\bigbreak \noindent 
\subsubsection{Changing elements directly, no direct element access}
\bigbreak \noindent 
Automatic sorting also imposes an important constraint on sets and multisets: You may
not change the value of an element directly
\bigbreak \noindent 
Therefore, to modify the value of an element, you must remove the element having the old value and
insert a new element that has the new value. The interface reflects this behavior:
\begin{itemize}
    \item Sets and multisets don’t provide operations for direct element access.
    \item Indirect access via iterators has the constraint that, from the iterator’s point of view, the element value is constant.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Constructors}
\bigbreak \noindent \bigbreak \noindent 
\begin{itemize}
    \item \texttt{set c} \\
    Default constructor; creates an empty set/multiset without any elements.
    
    \item \texttt{set c(op)} \\
    Creates an empty set/multiset that uses \texttt{op} as the sorting criterion.
    
    \item \texttt{set c(c2)} \\
    Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied).
    
    \item \texttt{set c = c2} \\
    Copy assignment operator; creates a copy of another set/multiset of the same type (all elements are copied).
    
    \item \texttt{set c(rv)} \\
    Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{set c = rv} \\
    Move assignment operator; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{set c(beg, end)} \\
    Creates a set/multiset initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{set c(beg, end, op)} \\
    Creates a set/multiset with the sorting criterion \texttt{op} initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{set c\{inilist\}} \\
    Creates a set/multiset initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{set c = \{inilist\}} \\
    Creates a set/multiset initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{c.\~set()} \\
    Destroys all elements and frees the memory.
\end{itemize}


\bigbreak \noindent 
\subsubsection{Types}
\bigbreak \noindent \bigbreak \noindent 
\begin{itemize}
    \item \texttt{set<Elem>} \\
    A set that by default sorts with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{set<Elem, Op>} \\
    A set that by default sorts with \texttt{Op}.
    
    \item \texttt{multiset<Elem>} \\
    A multiset that by default sorts with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{multiset<Elem, Op>} \\
    A multiset that by default sorts with \texttt{Op}.
\end{itemize}
\pagebreak 
\subsubsection{Constructors}
\begin{itemize}
    \item \texttt{set c} Default constructor; creates an empty set/multiset without any elements
    \item \texttt{set c(op)} Creates an empty set/multiset that uses \texttt{op} as the sorting criterion
    \item \texttt{set c(c2)} Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied)
    \item \texttt{set c = c2} Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied)
    \item \texttt{set c(rv)} Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{set c = rv} Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{set c(beg,end)} Creates a set/multiset initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{set c(beg,end,op)} Creates a set/multiset with the sorting criterion \texttt{op}, initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{set c(initlist)} Creates a set/multiset initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{set c = initlist} Creates a set/multiset initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{c.\~{}set()} Destroys all elements and frees the memory
\end{itemize}
\bigbreak \noindent 
\begin{itemize}
    \item \texttt{set<Elem>} A set that by default sorts with \texttt{less<>} (\texttt{operator <})
    \item \texttt{set<Elem,Op>} A set that by default sorts with \texttt{Op}
    \item \texttt{multiset<Elem>} A multiset that by default sorts with \texttt{less<>} (\texttt{operator <})
    \item \texttt{multiset<Elem,Op>} A multiset that by default sorts with \texttt{Op}
\end{itemize}









   \pagebreak 
   \subsection{STL Maps and multimaps}
   \bigbreak \noindent 
   Maps and multimaps are containers that manage key/value pairs as elements. These containers sort
   their elements automatically, according to a certain sorting criterion that is used for the key. The
   difference between the two is that multimaps allow duplicates, whereas maps do not
   \bigbreak \noindent 
   \subsubsection{Implementation}
   \bigbreak \noindent \bigbreak \noindent 
   Maps and multimaps are implemented the same as sets and multisets, height balanced binary search trees (red-black trees).

   \bigbreak \noindent 
   \subsubsection{Template parameters}
   \bigbreak \noindent \bigbreak \noindent 
   The first template parameter is the type of the element’s key, and the second template parameter is
the type of the element’s associated value. The elements of a map or a multimap may have any types
Key and T that meet the following two requirements:
\begin{enumerate}
    \item Both key and value must be copyable or movable.
    \item The key must be comparable with the sorting criterion.
\end{enumerate}
\bigbreak \noindent 
The optional third template parameter defines the sorting criterion. As for sets, this sorting criterion must define a “strict weak ordering” The elements are sorted according to their keys, so the value doesn’t matter for the order of the elements. The sorting criterion is also used to check for equivalence; that is, two elements are equal if neither key is less than the other.
\bigbreak \noindent 
If a special sorting criterion is not passed, the default criterion less<> is used. The function object
less<> sorts the elements by comparing them with operator <
\bigbreak \noindent 
\subsubsection{Abilities}
\bigbreak \noindent \bigbreak \noindent 
Sets, multisets, maps, and multimaps
typically use the same internal data type. So, you could consider sets and multisets as special maps
and multimaps, respectively, for which the value and the key of the elements are the same objects.
Thus, maps and multimaps have all the abilities and operations of sets and multisets. Some minor
differences exist, however. First, their elements are key/value pairs. In addition, maps can be used
as associative arrays.
\bigbreak \noindent 
Maps and multimaps sort their elements automatically, according to the element’s keys, and so have
good performance when searching for elements that have a certain key. Searching for elements that
have a certain value promotes bad performance. Automatic sorting imposes an important constraint
on maps and multimaps: You may not change the key of an element directly, because doing so might
compromise the correct order. To modify the key of an element, you must remove the element that
has the old key and insert a new element that has the new key and the old value. As a consequence, from the iterator’s point of view, the element’s key is
constant. However, a direct modification of the value of the element is still possible, provided that
the type of the value is not constant.

\bigbreak \noindent 
\subsubsection{Constructors and types}
\bigbreak \noindent \bigbreak \noindent 
\begin{itemize}
    \item \texttt{map c} \\
    Default constructor; creates an empty map/multimap without any elements.
    
    \item \texttt{map c(op)} \\
    Creates an empty map/multimap that uses \texttt{op} as the sorting criterion.
    
    \item \texttt{map c(c2)} \\
    Copy constructor; creates a copy of another map/multimap of the same type (all elements are copied).
    
    \item \texttt{map c = c2} \\
    Copy assignment operator; creates a copy of another map/multimap of the same type (all elements are copied).
    
    \item \texttt{map c(rv)} \\
    Move constructor; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{map c = rv} \\
    Move assignment operator; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11).
    
    \item \texttt{map c(beg, end)} \\
    Creates a map/multimap initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{map c(beg, end, op)} \\
    Creates a map/multimap with the sorting criterion \texttt{op} initialized by the elements of the range \texttt{[beg, end]}.
    
    \item \texttt{map c\{inilist\}} \\
    Creates a map/multimap initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{map c = \{inilist\}} \\
    Creates a map/multimap initialized with the elements of initializer list \texttt{inilist} (since C++11).
    
    \item \texttt{c.\~map()} \\
    Destroys all elements and frees the memory.
\end{itemize}
\textbf{Here, map may be one of the following types:}
\begin{itemize}
    \item \texttt{map<Key, Val>} \\
    A map that by default sorts keys with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{map<Key, Val, Op>} \\
    A map that by default sorts keys with \texttt{Op}.
    
    \item \texttt{multimap<Key, Val>} \\
    A multimap that by default sorts keys with \texttt{less<>} (operator \texttt{<}).
    
    \item \texttt{multimap<Key, Val, Op>} \\
    A multimap that by default sorts keys with \texttt{Op}.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Using maps as associative arrays}
\bigbreak \noindent 
Associative containers don’t typically provide abilities for direct element access. Instead, you must
use iterators. For maps, as well as for unordered maps, however, there is an exception to this rule. Nonconstant maps provide a subscript operator for direct element access. In addition, since C++11, a corresponding member function at() is provided for constant and
nonconstant maps 
\bigbreak \noindent 
at() yields the value of the element with the passed key and throws an exception object of type
out\_of\_range if no such element is present
\bigbreak \noindent 
For operator [ ], the index also is the key that is used to identify the element. This means that
for operator [ ], the index may have any type rather than only an integral type. Such an interface is
the interface of a so-called associative array.
\bigbreak \noindent 
For operator [ ], the type of the index is not the only difference from ordinary arrays. In addition,
you can’t have a wrong index. If you use a key as the index for which no element yet exists, a new
element gets inserted into the map automatically. The value of the new element is initialized by the
default constructor of its type. Thus, to use this feature, you can’t use a value type that has no default
constructor. Note that the fundamental data types provide a default constructor that initializes their
values to zero

\bigbreak \noindent 
\subsubsection{Constructors}
\begin{itemize}
    \item \texttt{map c} Default constructor; creates an empty map/multimap without any elements
    \item \texttt{map c(op)} Creates an empty map/multimap that uses \texttt{op} as the sorting criterion
    \item \texttt{map c(c2)} Copy constructor; creates a copy of another map/multimap of the same type (all elements are copied)
    \item \texttt{map c = c2} Copy constructor; creates a copy of another map/multimap of the same type (all elements are copied)
    \item \texttt{map c(rv)} Move constructor; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{map c = rv} Move constructor; creates a new map/multimap of the same type, taking the contents of the rvalue \texttt{rv} (since C++11)
    \item \texttt{map c(beg,end)} Creates a map/multimap initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{map c(beg,end,op)} Creates a map/multimap with the sorting criterion \texttt{op}, initialized by the elements of the range \texttt{[beg,end)}
    \item \texttt{map c(initlist)} Creates a map/multimap initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{map c = initlist} Creates a map/multimap initialized with the elements of initializer list \texttt{initlist} (since C++11)
    \item \texttt{c.\~{}map()} Destroys all elements and frees the memory
\end{itemize}
\bigbreak \noindent
\begin{itemize}
    \item \texttt{map<Key,Val>} A map that by default sorts keys with \texttt{less<>} (\texttt{operator <})
    \item \texttt{map<Key,Val,Op>} A map that by default sorts keys with \texttt{Op}
    \item \texttt{multimap<Key,Val>} A multimap that by default sorts keys with \texttt{less<>} (\texttt{operator <})
    \item \texttt{multimap<Key,Val,Op>} A multimap that by default sorts keys with \texttt{Op}
\end{itemize}

\pagebreak 
\subsection{Example of bounds and equal range}








   \pagebreak 
   \subsection{STL Unordered containers}
   \bigbreak \noindent 
   Strictly speaking, the C++ standard library calls unordered containers “unordered associative
containers.” However, I will just use “unordered containers” when I refer to them. With “associative
containers,” I still refer to the “old” associative containers, which are provided since C++98 and
implemented as binary trees (set, multiset, map, and multimap).
\bigbreak \noindent 
Conceptionally, unordered containers contain all the elements you insert in an arbitrary order . That is, you can consider the container to be a bag: you can put in elements,
but when you open the bag to do something with all the elements, you access them in a random
order. So, in contrast with (multi)sets and (multi)maps, there is no sorting criterion; in contrast with
sequence containers, you have no semantics to put an element into a specific position.
\bigbreak \noindent 
\subsubsection{Implementation}
\bigbreak \noindent 
All standardized unordered container classes are implemented as hash tables, which nonetheless still have a variety of implementation options.
\bigbreak \noindent 
\subsubsection{Abilities}
\bigbreak \noindent 
\begin{enumerate}
    \item The hash tables use the “chaining” approach, whereby a hash code is associated with a linked list. (This technique, also called “open hashing” or “closed addressing,” should not be confused with “open addressing” or “closed hashing.”)
    \item Whether these linked lists are singly or doubly linked is open to the implementers. For this reason, the standard guarantees only that the iterators are “at least” forward iterators.
    \item Various implementation strategies are possible for rehashing:
        \begin{itemize}
            \item With the traditional approach, a complete reorganization of the internal data happens from time to time as a result of a single insert or erase operation.
            \item With incremental hashing, a resizing of the number of bucket or slots is performed gradually, which is especially useful in real-time environments, where the price of enlarging a hash table all at once can be too high.
        \end{itemize}
    \item Unordered containers allow both strategies and give no guarantee that conflicts with either of them.

\end{enumerate}
\bigbreak \noindent 
y. For each value to store, the hash function maps it to a
bucket (slot) in the hash table. Each bucket manages a singly linked list containing all the elements
for which the hash function yields the same value.
\bigbreak \noindent 
The major advantage of using a hash table internally is its incredible running-time behavior.
Assuming that the hashing strategy is well chosen and well implemented, you can guarantee amortized constant time for insertions, deletions, and element search (“amortized” because the occasional
rehashing happens that occurs can be a large operation with a linear complexity).
\bigbreak \noindent 
The expected behavior of nearly all the operations on unordered containers, including copy construction and assignment, element insertion and lookup, and equivalence comparison, depends on
the quality of the hash function. If the hash function generates equal values for different elements, which also happens if an unordered container that allows duplicates is populated with equivalent
values or keys, any hash table operation results in poor runtime performance. This is a fault not so
much of the data structure itself but rather of its use by unenlightened clients

\bigbreak \noindent 
\subsubsection{Disadvantages}
\begin{itemize}
    \item Unordered containers don’t provide operators $<$, $>$, $<=$, and $>=$ to order multiple instances of these containers. However, == and != are provided (since C++11).
    \item lower\_bound() and upper\_bound() are not provided.
    \item Because the iterators are guaranteed only to be forward iterators, reverse iterators, including rbegin(), rend(), crbegin(), and crend(), are not supported, and you can’t use algorithms that require bidirectional iterators, or at least this is not portable
\end{itemize}
\bigbreak \noindent 
Because the (key) value of an element specifies its position — in this case, its bucket entry — you
are not allowed to modify the (key) value of an element directly. Therefore, much as with associative
containers, to modify the value of an element, you must remove the element that has the old value
and insert a new element that has the new value
\bigbreak \noindent 
\begin{itemize}
    \item Unordered containers don’t provide operations for direct element access.
    \item Indirect access via iterators has the constraint that, from the iterator’s point of view, the element’s (key) value is constant.
\end{itemize}

   \pagebreak 
    \subsection{STL Containers: Implementations}
\begin{itemize}
    \item \textbf{std::vector}
    \begin{itemize}
        \item Implemented as a dynamically resizable array with contiguous memory.
    \end{itemize}

    \item \textbf{std::deque}
    \begin{itemize}
        \item Implemented as a sequence of dynamically allocated arrays (blocks) for efficient insertion/removal at both ends.
    \end{itemize}

    \item \textbf{std::list}
    \begin{itemize}
        \item Implemented as a doubly linked list, where each node contains pointers to the previous and next nodes.
    \end{itemize}

    \item \textbf{std::forward\_list}
    \begin{itemize}
        \item Implemented as a singly linked list, where each node contains a pointer to the next node.
    \end{itemize}

    \item \textbf{std::set} / \textbf{std::multiset}
    \begin{itemize}
        \item Implemented as a self-balancing binary search tree (typically Red-Black Tree).
    \end{itemize}

    \item \textbf{std::unordered\_set} / \textbf{std::unordered\_multiset}
    \begin{itemize}
        \item Implemented as a hash table with separate chaining or open addressing for collision resolution.
    \end{itemize}

    \item \textbf{std::map} / \textbf{std::multimap}
    \begin{itemize}
        \item Implemented as a self-balancing binary search tree (typically Red-Black Tree) for sorted key-value pairs.
    \end{itemize}

    \item \textbf{std::unordered\_map} / \textbf{std::unordered\_multimap}
    \begin{itemize}
        \item Implemented as a hash table with separate chaining or open addressing for key-value pairs.
    \end{itemize}
\end{itemize}


\pagebreak 
\subsection{STL Containers: Iterator Functions}
\begin{itemize}
    \item \textbf{Containers with all the iterator functions (begin(), end(), cbegin(), cend(), rbegin(), rend(), crbegin(), crend())}: 
        \begin{enumerate}
            \item Vector
            \item Deque
            \item List
            \item Set 
            \item Muliset
            \item Map
            \item Mulimap
            \item Unordered set
            \item unordered multiset
            \item unordered map
            \item unordered multimap
        \end{enumerate}
    \item \textbf{Containers with limited iterator support:}
        \begin{enumerate}
            \item \textbf{Forward\_list}: Only supports forward iterators (begin(), end(), cbegin(), cend()).
        \end{enumerate}
\end{itemize}


   \pagebreak 
   \subsection{STL containers: Main concepts, differences, uses}
   \begin{itemize}
       \item \textbf{Vectors}: 
           \begin{itemize}
               \item Dynamic array, automatic resizing. 
               \item We have access to capacity and reserve methods. 
               \item Fast at end operations. 
               \item Contiguous memory, random access. 
               \item at() method to index with error checking.
           \end{itemize}

        \item \textbf{Deque}: 
            \begin{itemize}
                \item Multiple blocks / Dynamic arrays to give access to both ends. 
                \item Fast at both ends. 
                \item Front and back operations. 
                \item Slower iterator access compared to vectors. 
                \item Iterators are smart pointers. 
                \item No capacity access
            \end{itemize}
        \item \textbf{List:}
            \begin{itemize}
                \item Doubly-linked list
                \item Insertion and removing is fast
                \item Access at any element thats not the first or last is slow.
                \item NO random access
                \item Member method to sort
                \item Splice
                \item Unique
                \item Merge
            \end{itemize}
        \item \textbf{Forward\_list}
            \begin{itemize}
                \item Singly linked list
                \item No size method
                \item No reverse iterators
                \item No pointer to last element, no back(), push\_back(), or pop\_back() methods
                \item For all member functions that modify forward lists in a way that elements are inserted or deleted at a specific position, special versions for forward lists are provided. The reason is that you have to pass the position of the element before the first element that gets manipulated, because there you have to assign a new successor element. Because you can’t navigate backwards (at least not in constant time), for all these member functions you have to pass the position of the preceding element. Because of this difference, these member functions have a after suffix in their name. For example, instead of insert(), insert\_after() is provided, which inserts new elements after the element passed as first argument; that is, it appends an element at that position.
                    \bigbreak \noindent 
                    For this reason, forward lists provide before\_begin() and cbefore\_begin(), which yield the position of a virtual element before the first element (technically speaking, the anchor of the linked list), which can be used to let built-in algorithms ending with after exchange even the first element
            \end{itemize}
        \item \textbf{Sets and multisets}
            \begin{itemize}
                \item Height balanced bst
                \item No duplicates in set, can have duplicates in multiset
                \item logarithmic searching
                \item logarithmic insertion and deletion
                \item Automatic sorting
                \item Can't change elements directly
                \item No direct element access
                \item Constant iterators
            \end{itemize}
   \end{itemize}
   

   \pagebreak 
   \subsection{STL Containers: Iterator invalidation}
   \begin{itemize}
       \item \textbf{Vectors:} 
           \begin{itemize}
               \item \textbf{Insertion:} All iterators are invalidated if a reallocation occurs; otherwise, only iterators at or after the point of insertion are invalidated.
               \item \textbf{Deletion:} Iterators at or after the point of deletion are invalidated.
           \end{itemize}
        \item \textbf{Deque}: 
            \begin{itemize}
                \item \textbf{Insertion/Deletion:} At beginning or end, no invalidation unless reallocation occurs. Inserting or deleting in the middle invalidates all iterators.
            \end{itemize}
        \item \textbf{List}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{Forward list}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{Set/multiset}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{unordered set/unordered multiset}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation unless rehashing occurs.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
                \item \textbf{Rehashing:} All iterators are invalidated.
            \end{itemize}
        \item \textbf{Map/Multimap}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
            \end{itemize}
        \item \textbf{Unordered map/unordered multimap}:
            \begin{itemize}
                \item \textbf{Insertion:} No invalidation unless rehashing occurs.
                \item \textbf{Deletion:} Only the iterator to the erased element is invalidated.
                \item \textbf{Rehashing:} All iterators are invalidated.
            \end{itemize}
   \end{itemize}

   \pagebreak 
   \subsection{STL Containers: Reallocation}
   \begin{itemize}
       \item \textbf{Vectors}: Reallocation occurs when inserting elements exceeds the current capacity.
       \item \textbf{Deque}: Reallocation occurs when inserting elements requires more blocks (typically at both ends, but can happen internally).
        \item \textbf{List, forward list}: No reallocation occurs, as they allocate nodes dynamically and do not store elements contiguously.
        \item \textbf{set, multiset, map, multimap}: No reallocation occurs, as they use balanced trees, and elements are not stored contiguously.
        \item \textbf{unordered set, unordered multiset, unordered map, unordered multimap}:  Reallocation occurs when the load factor exceeds a threshold, triggering a rehash to a larger bucket array.
   \end{itemize}

   \pagebreak 
   \subsection{STL Containers: Element access}
\begin{itemize}
    \item \textbf{std::vector}
    \begin{itemize}
        \item Direct access via index: \texttt{v[i]}, \texttt{v.at(i)}
        \item Front element: \texttt{v.front()}
        \item Back element: \texttt{v.back()}
    \end{itemize}
    
    \item \textbf{std::deque}
    \begin{itemize}
        \item Direct access via index: \texttt{d[i]}, \texttt{d.at(i)}
        \item Front element: \texttt{d.front()}
        \item Back element: \texttt{d.back()}
    \end{itemize}
    
    \item \textbf{std::list}
    \begin{itemize}
        \item No direct access via index.
        \item Front element: \texttt{l.front()}
        \item Back element: \texttt{l.back()}
    \end{itemize}
    
    \item \textbf{std::forward\_list}
    \begin{itemize}
        \item No direct access via index.
        \item Front element: \texttt{fl.front()}
    \end{itemize}
    
    \item \textbf{std::set} / \textbf{std::multiset}
    \begin{itemize}
        \item No direct access via index.
        \item Access via iterator or functions like \texttt{find()}, \texttt{lower\_bound()}, \texttt{upper\_bound()}.
    \end{itemize}
    
    \item \textbf{std::unordered\_set} / \textbf{std::unordered\_multiset}
    \begin{itemize}
        \item No direct access via index.
        \item Access via iterator or \texttt{find()}.
    \end{itemize}
    
    \item \textbf{std::map} / \textbf{std::multimap}
    \begin{itemize}
        \item Access by key: \texttt{m[key]} (for \texttt{std::map} only, not \texttt{std::multimap}).
        \item Access via iterator or functions like \texttt{find()}, \texttt{lower\_bound()}, \texttt{upper\_bound()}.
    \end{itemize}
    
    \item \textbf{std::unordered\_map} / \textbf{std::unordered\_multimap}
    \begin{itemize}
        \item Access by key: \texttt{um[key]} (for \texttt{std::unordered\_map} only, not \texttt{std::unordered\_multimap}).
        \item Access via iterator or \texttt{find()}.
    \end{itemize}
\end{itemize}



   \pagebreak 
   \subsection{STL Containers: Uses and advantages}
   \begin{itemize}
    \item \textbf{std::vector}
    \begin{itemize}
        \item Advantages: Fast random access, contiguous memory, efficient for dynamic arrays.
        \item Uses: When frequent random access and dynamic resizing are needed.
    \end{itemize}
    
    \item \textbf{std::deque}
    \begin{itemize}
        \item Advantages: Fast insertion/removal at both ends, efficient dynamic array.
        \item Uses: Double-ended queue operations, efficient at both front and back.
    \end{itemize}
    
    \item \textbf{std::list}
    \begin{itemize}
        \item Advantages: Constant time insertion/removal anywhere, no reallocation.
        \item Uses: When frequent insertions/removals in the middle are needed.
    \end{itemize}
    
    \item \textbf{std::forward\_list}
    \begin{itemize}
        \item Advantages: Singly linked list, smaller memory overhead, constant time insertion/removal.
        \item Uses: Memory-constrained environments, where only forward traversal is needed.
    \end{itemize}
    
    \item \textbf{std::set} / \textbf{std::multiset}
    \begin{itemize}
        \item Advantages: Sorted elements, fast lookup (logarithmic time).
        \item Uses: When you need a sorted collection with unique or non-unique elements.
    \end{itemize}
    
    \item \textbf{std::unordered\_set} / \textbf{std::unordered\_multiset}
    \begin{itemize}
        \item Advantages: Fast average-time lookup (constant time), no sorting.
        \item Uses: When fast lookup is needed without element ordering.
    \end{itemize}
    
    \item \textbf{std::map} / \textbf{std::multimap}
    \begin{itemize}
        \item Advantages: Sorted key-value pairs, fast lookup (logarithmic time).
        \item Uses: Key-value pairs where keys must remain sorted.
    \end{itemize}
    
    \item \textbf{std::unordered\_map} / \textbf{std::unordered\_multimap}
    \begin{itemize}
        \item Advantages: Fast average-time lookup (constant time), no sorting.
        \item Uses: Key-value pairs where fast lookup is needed without ordering.
    \end{itemize}
\end{itemize}






   \pagebreak 
   \subsection{STL Iterators}
    An object that iterates/navigates over elements in the container. They are essentially an abstraction of pointer
   \begin{itemize}
       \item \textbf{Some notes about iterators}: 
           \begin{enumerate}
               \item each container provides its own iterator
               \item interfaces of iterators of different containers are largely the same
               \item internal behaviors depend on the data structure of the container
           \end{enumerate}
       \item \textbf{Operations}: 
            \begin{enumerate}
                \item operator * returns the element of the current positions
                \item operator -> access a member of the element
                \item operator ++ step forward
                \item operator -- step backward
                \item operator == and != whether two iterators represent the same position
                \item operator = assign an iterator
            \end{enumerate}
        \item \textbf{Important iterators}:
            \begin{enumerate}
                \item begin() gets you the beginning of a container
                \item end() gets you just past the end
            \end{enumerate}
        \item \textbf{Iterator types}
            \begin{itemize}
                \item \textbf{iterator}
                \item \textbf{reverse\_iterator}
                \item \textbf{const\_iterator}
                \item \textbf{const\_reverse\_iterator}
            \end{itemize}
        \item \textbf{Iterator categories}
            \begin{enumerate}
                \item \textbf{Input Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose:} Read-only access to elements in a single-pass manner.
                        \item \textbf{Operations:} Can be incremented (++), compared for equality (==), and dereferenced (*) to access elements.
                    \end{itemize}
                \item \textbf{Output Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose:} Write-only access to elements in a single-pass manner.
                        \item \textbf{Operations:} Can be incremented (++) and dereferenced (*) to assign values.
                    \end{itemize}
                \item \textbf{Forward Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose:} Read and write access to elements; can traverse the container in a single direction.
                        \item \textbf{Operations:} Can be incremented (++), compared for equality (==), and dereferenced (*).
                    \end{itemize}
                \item \textbf{Bidirectional iterator}:
                    \begin{itemize}
                        \item \textbf{Purpose:} Read and write access to elements; can traverse the container in both directions.
                        \item \textbf{Operations:} Supports both increment (++) and decrement (--) operations.
                    \end{itemize}
                    \pagebreak 
                \item \textbf{Random Access Iterator:}
                    \begin{itemize}
                        \item \textbf{Purpose}: Read and write access with the ability to jump to any element in constant time.
                        \item \textbf{Operations:} Supports all operations of bidirectional iterators plus direct arithmetic operations like addition (+), subtraction (-), and subscript ([]).
                    \end{itemize}
            \end{enumerate}
        \item \textbf{Containers and their iterators}:
            \begin{enumerate}
                \item \textbf{Vector}: Random access iterator
                \item \textbf{Deque}: Random access iterator
                \item \textbf{List}: Bidirectional iterator
                \item \textbf{Forward\_list}: Forward iterator
                \item \textbf{Set}: Bidirectional iterator
                \item \textbf{Multiset}: Bidirectional iterator
                \item \textbf{Map}: Bidirectional iterator
                \item \textbf{Multimap}: Bidirectional iterator
                \item \textbf{Unordered\_map}: Forward iterator
            \end{enumerate}
        \item \textbf{Insert iterators}: Insert iterators in C++ are special types of iterators that allow you to insert elements into a container at specific positions rather than overwriting existing elements. There are three primary types of insert iterators provided by the C++ Standard Library:
            \bigbreak \noindent 
            if a container has an insert method, you can and often should use it directly when inserting elements, especially if you want to insert a single element or a specific range of elements into the container.
            \bigbreak \noindent 
            Containers that have an insert method are: vector, deque, list, forward list, set, multiset, unordered set, unordered multiset,map, multimap, unordered map, unordered multi map.
            \bigbreak \noindent 
            Insert iterators (std::back\_inserter, std::front\_inserter, and std::inserter) should be used when working with algorithms or situations where automatic insertion logic simplifies your code.
            \bigbreak \noindent 
            Some things in <algorithm> require these inserters
            \begin{enumerate}
                \item \textbf{std::front\_inserter}: Inserts elements at the front of a container. Calls the container's push\_front method to add elements to the front. Used with containers that support push\_front 
                    \bigbreak \noindent 
                    \begin{cppcode}
                        #include <list>
                        #include <algorithm>
                        #include <iterator>

                        int main() {
                            std::list<int> lst = {1, 2, 3};
                            std::list<int> to_add = {4, 5, 6};

                            // Insert elements at the front of lst
                            std::copy(to_add.begin(), to_add.end(), std::front_inserter(lst));

                            // lst now contains: 6, 5, 4, 1, 2, 3
                        }
                    \end{cppcode}
                \item \textbf{std::back\_inserter}: Inserts elements at the end of a container. Inserts elements at the end of a container. Used with containers that support push\_back 
                    \bigbreak \noindent 
                    \begin{cppcode}
                        #include <vector>
                        #include <algorithm>
                        #include <iterator>

                        int main() {
                            std::vector<int> vec = {1, 2, 3};
                            std::vector<int> to_add = {4, 5, 6};

                            // Insert elements at the end of vec
                            std::copy(to_add.begin(), to_add.end(), std::back_inserter(vec));

                            // vec now contains: 1, 2, 3, 4, 5, 6
                        }
                    \end{cppcode}
                \item \textbf{std::inserter}: Inserts elements at a specific position in a container.  Takes an iterator indicating the insertion position and calls the container's insert method. Used with containers that support insertion at arbitrary positions
                    \bigbreak \noindent 
                    \begin{cppcode}
                        #include <vector>
                        #include <algorithm>
                        #include <iterator>

                        int main() {
                            std::vector<int> vec = {1, 2, 3};
                            std::vector<int> to_add = {4, 5, 6};

                            // Insert elements starting at the second position (before 2)
                            std::copy(to_add.begin(), to_add.end(), std::inserter(vec, vec.begin() + 1));

                            // vec now contains: 1, 4, 5, 6, 2, 3
                        }
                    \end{cppcode}
            \end{enumerate} 
    \end{itemize}

    \pagebreak 
    \subsection{Complexity of container operations}
    \begin{center}
        \begin{tabular}{|>{\raggedright}m{4cm}|>{\centering}m{2.5cm}|>{\centering}m{2.5cm}|>{\centering}m{3cm}|>{\centering\arraybackslash}m{3cm}|}
            \hline
            \textbf{Container} & \textbf{Access} & \textbf{Search} & \textbf{Insertion} & \textbf{Deletion} \\ \hline
            \texttt{vector} & O(1) & O(n) & O(n) (amortized O(1) at end) & O(n) \\ \hline
            \texttt{deque} & O(1) & O(n) & O(n) (amortized O(1) at ends) & O(n) \\ \hline
            \texttt{list} & O(n) & O(n) & O(1) (if position known), O(n) (worst case) & O(1) (if position known), O(n) (worst case) \\ \hline
            \texttt{forward\_list} & O(n) & O(n) & O(1) (if position known), O(n) (worst case) & O(1) (if position known), O(n) (worst case) \\ \hline
            \texttt{set} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{multiset} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{map} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{multimap} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\ \hline
            \texttt{unordered\_set} & O(n) & O(n) & O(n) & O(n) \\ \hline
            \texttt{unordered\_multiset} & O(n) & O(n) & O(n) & O(n) \\ \hline
            \texttt{unordered\_map} & O(n) & O(n) & O(n) & O(n) \\ \hline
            \texttt{unordered\_multimap} & O(n) & O(n) & O(n) & O(n) \\ \hline
        \end{tabular}
   \end{center}
   \bigbreak \noindent 
   Unordered container operations are for the most part constant time operations, but worst case they are linear.











   % \subsection{The Basics of STL containers}
   % \bigbreak \noindent 
   % The STL is a generic library that manages collections of data with efficient algorithms. It has template classes, functions, parameters. The idea is to have the same/single implementation works for many data types
   % \bigbreak \noindent 
   % \textbf{Components:}
   % \begin{enumerate}
   %     \item \textbf{Containers}: manage collections of data
   %         \begin{itemize}
   %             \item \textbf{sequence containers e.g. vector, list, deque}: Sequence containers store elements in a linear sequence, where the order of elements is strictly maintained. They allow for sequential access to elements
   %             \item \textbf{associative containers e.g. set, map}: Associative containers store elements in a way that allows for fast retrieval based on keys. They automatically order elements based on their keys or some criterion.
   %                 \bigbreak \noindent 
   %                 \textbf{Note:} Sets in C++ are considered associative containers because they store elements in a way that allows for efficient retrieval based on the value of the elements themselves. This differs fundamentally from sequence containers, which maintain elements in a specific order based on the sequence of insertion.
   %         \end{itemize}
   %     \item \textbf{Iterators}: Step through elements in an container
   %     \item \textbf{Algorithms}: Procedures that process the elements of collections
   % \end{enumerate}
   % \bigbreak \noindent 
   % \textbf{Global algorithms for all containers in the <algorithm> header}:
   % \begin{itemize}
   %     \item \textbf{copy}: Copies elements from one range to another.
   %     \item \textbf{transform}: Applies a function to each element in a range and stores the result in another range.
   %     \item \textbf{find}: Searches for the first occurrence of a value in a range.
   %     \item \textbf{search}: Searches for a subsequence within a range.
   %     \item \textbf{mismatch}: Finds the first position where two ranges differ.
   %     \item \textbf{fill}: Assigns a value to each element in a range.
   %     \item \textbf{replace}: Replaces occurrences of a value in a range with another value.
   %     \item \textbf{sort}: Sorts elements in a range.
   % \end{itemize}
   % \pagebreak \bigbreak \noindent 
   % \textbf{Signatures}:
   % \begin{cppcode}
   %     template <class InputIterator, class OutputIterator>
   %     OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);
   %
   %     template <class InputIterator, class OutputIterator, class UnaryOperation>
   %     OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);
   %
   %     template <class InputIterator, class T>
   %     InputIterator find(InputIterator first, InputIterator last, const T& value);
   %
   %     template <class ForwardIterator1, class ForwardIterator2>
   %     ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);
   %
   %
   %     template <class InputIterator1, class InputIterator2>
   %     std::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
   % \end{cppcode}
   %
   % \pagebreak 
   % \begin{cppcode}
   %     template <class ForwardIterator, class T>
   %     void fill(ForwardIterator first, ForwardIterator last, const T& value);
   %
   %     template <class ForwardIterator, class T>
   %     void replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);
   %
   %     template <class RandomAccessIterator>
   %     void sort(RandomAccessIterator first, RandomAccessIterator last);
   % \end{cppcode}
   % \bigbreak \noindent 
   % \textbf{Note:} This is not an exhaustive list of signatures for these procedures
   % \bigbreak \noindent 
   % \textbf{Vectors}: One of the sequence containers
   % \begin{itemize}
   %  \item \textbf{Properties of vectors}:
   %      \begin{enumerate}
   %          \item The order of elements in the container depends on the time/space of the insertion(s) of the elements. This means that the elements in a std::vector are stored in the order in which they are inserted.
   %          \item dynamic array
   %          \item random access
   %          \item adding/removing elements at the end is fast
   %          \item inserting/removing in the middle/beginning is slow 
   %      \end{enumerate}
   %  \item \textbf{Vector constructors}
   %      \begin{enumerate}
   %          \item default constructor
   %          \item copy constructor
   %          \item constructor with given range from another (type of) container, with an array, from standard input, type may be even different provided automatic conversion
   %      \end{enumerate}
   %  \item \textbf{Vector destructor}: When dealing with vectors, destructors automatically call the destructor of each element stored in the vector in reverse order of their insertion. After destroying each element, the vector's destructor releases the internal memory used by the vector itself.
   %  \item \textbf{Vector methods}:
   %      \begin{enumerate}
   %          \item size - the actual number of elements in the vector
   %          \item empty - whether the vector is empty or not
   %          \item max\_size - the maximum number of elements a container may contain. - a constraint from the system or library implementation. this is different from capacity().
   %          \item capacity - the number of elements a vector could contain in its actual memory.
   %          \item resize - resize the vector. in case of larger size, fill the rest with a certain value. - different from reserve().
   %          \item reserve - change the capacity of the vector. exception is thrown if not successful.
   %      \end{enumerate}
   %  \item \textbf{Element access methods}:
   %      \begin{enumerate}
   %          \item operator[ ] - access the element at a certain position. it does not check the valid range.
   %          \item at() – similar to [ ]. it checks range, and throws exception.
   %          \item front() – returns a reference to the first element
   %          \item back() – returns a reference to the last element
   %      \end{enumerate}
   %  \item \textbf{assignments and assignment methods}
   %      \begin{enumerate}
   %          \item operator= - copy from another vector containing the same type
   %          \item assign() - assigns new content to the current vector. overloaded.
   %          \item swap() - exchange two vectors.
   %      \end{enumerate}
   %  \item \textbf{Insertion methods}
   %      \begin{enumerate}
   %          \item insert() - insert new element in front of a specified position
   %          \item push\_back() - append a new element to the end of the vector
   %          \item emplace\_back() - construct a new element in-place at the end, used if inserting objects that need to be constructed
   %      \end{enumerate}
   %  \item \textbf{Removal methods}
   %      \begin{enumerate}
   %          \item erase - remove an element or a range of elements
   %          \item pop\_back - remove the last element
   %          \item resize - change the number of elements
   %          \item clear - remove all elements from the vector
   %      \end{enumerate}
   %  \item \textbf{what operations may cause reallocation of the internal array?}:
   %      \begin{enumerate}
   %          \item reserve
   %          \item push\_back, emplace\_back
   %          \item insert, emplace
   %      \end{enumerate}
   %      \bigbreak \noindent 
   %      \textbf{Note:} Note that pop\_back, erase, clear do not cause reallocation
   %      \bigbreak \noindent 
   %      When reallocation happens, all references, pointers, and iterators referring to elements of the original vector become invalidated.
   %  \item \textbf{what if do want to reduce memory size for unused positions?}
   %      \begin{enumerate}
   %          \item shrink\_to\_fit() - reduce memory usage by freeing unused memory
   %      \end{enumerate}
   %  \item \textbf{Time complexity of the operations}:
   %      \begin{enumerate}
   %          \item \textbf{Linear time O(n):} clear, insert, erase, assign, resize, destructor, operator=, copy constructor, constructor with a given rang
   %              \bigbreak \noindent 
   %              \textbf{Note:} push\_back and emplace\_back are O(n) because in the worst case, the vector needs to be resized in order to fit the new elements.
   %          \item \textbf{linear time o(n):} clear, insert, erase, assign, resize, destructor, operator=, copy constructor, constructor with a given rang
   %      \end{enumerate}
   %
   % \end{itemize}
   %
   % \pagebreak 
   % \bigbreak \noindent 
   % \textbf{Deque (Double ended queue)}: Another sequence container <deque>. Involves dynamic arrays, similar to vectors, but involves multiple ararys. Random access to its elements but a little slower than vectors, because of the multiple arrays.
   % \bigbreak \noindent 
   %   almost the same interface as vector
   % \begin{itemize}
   %     \item \textbf{different from vector:} deque has two open ends
   %      \item fast for adding/removing at both ends
   %      \item \textbf{Capacity stuff}: 
   %          \begin{enumerate}
   %              \item capacity() and reserve() are not available for deque
   %              \item capacity and allocation are completely automatically managed for deque, no user suppor
   %          \end{enumerate}
   %      \item \textbf{Extra modifiers}: In deques, we have 
   %          \begin{enumerate}
   %              \item \textbf{push\_front()}
   %              \item \textbf{pop\_front()}
   %              \item \textbf{emplace\_front()}
   %          \end{enumerate}
   %          Along with the back stuff that vectors have.
   %      \item \textbf{Internal memory}: internal memory is not contiguous (split into multiple arrays). Although we can use random access is if it were. element access and iterator movement involves more calculation comparing to vector
   %          \bigbreak \noindent 
   %          Iterators may need to jump between different memory blocks. max\_size may be larger because a deque may occupy multiple blocks of memory
   %      \item \textbf{Adding at front or end}:  All iterators are invalidated; references are not invalidated
   %          \bigbreak \noindent 
   %      \item \textbf{Removing from front or end}: Iterators and references of other positions are not invalidated. end() is invalidated
   %      \item \textbf{adding or removing anywhere other than two ends}: All iterators and references are invalidated
   %      \item \textbf{Advantages of deques}:
   %          \begin{enumerate}
   %              \item fast adding/removing at both ends (though still slow inadding/removing in the middle)
   %              \item possiblely larger max\_size
   %              \item massive reallocations are avoided
   %          \end{enumerate}
   % \end{itemize}
   %
   % \pagebreak \bigbreak \noindent 
   % \textbf{List}: (doubly linked list) Another sequence container <list>
   % \begin{itemize}
   %     \item \textbf{Properties}:
   %         \begin{enumerate}
   %             \item Doubly-linked list
   %              \item No random access of elements
   %              \item Adding or removing \textbf{anywhere} is fast, as long as you have reference to the location where you want to add/remove, otherwise you need to traverse the list to reach the location
   %              \item adding/removing does not invalidate pointers, references, and iterators to other elements
   %              \item there is no reallocation
   %         \end{enumerate}
   %      \item \textbf{Capacity stuff}: Capacity and reserve are not available for lists, each element of the list has its own memory. Elements occupy non-contiguous memory.
   %      \item \textbf{Element access}: No [], no at().
   %      \item \textbf{Operations on lists}:
   %          \begin{enumerate}
   %              \item remove( ): remove all elements with a certain value
   %              \item remove\_if( ): remove all elements that satisfy certain criterion.
   %              \item erase( ): remove an element with a specified iterator (note that erase here returns an iterator for next pos.)
   %              \item unique( ): remove duplicates of consecutive elements
   %              \item splice( ): move elements from one list to another
   %              \item sort( ): sort all elements with $<$ or defined comparison
   %              \item merge( ): merge two sorted lists
   %              \item reverse( ): reverse the order of all elements
   %              \item many above methods are overloaded
   %          \end{enumerate}
   %      \item \textbf{Splicing (splice method)}: We pass iterator for position of insertion, list object to take elements from, begin, end range of source list
   % \end{itemize}
   %
   % \pagebreak 
   % \bigbreak \noindent 
   % \textbf{forward\_list}: Another sequence container <forward\_list>. Internally implemented by singly linked list. No random access of elements
   % \bigbreak \noindent 
   % Adding/removing does not invalidate pointers, references, and iterators to other elements. there is no reallocation
   % \begin{itemize}
   %     \item Only support forward iterators. (no -- operation), only forward traversal
   %      \item forward lists are more memory efficient than lists in some cases
   %      \item \textbf{Adding / removing properties}
   %          \begin{enumerate}
   %              \ite madding/removing at begin of a list is fast
   %              \item adding/removing at the next position of a given element is fast
   %      \item adding/removing anywhere requires traversal from head
   %          \end{enumerate}
   % \end{itemize}
   %
   % \pagebreak \bigbreak \noindent 
   % \textbf{Associative containers}
   % \begin{itemize}
   %     \item \textbf{Sorted}: Elements (or keys) are sorted. Internally height balanced binary search tree. 
   %         \bigbreak \noindent 
   %         orted according to a certain sorting criterion, by default its the < operator. You can provide you own criteria
   %         \bigbreak \noindent 
   %         Order of insertion does not matter
   %         \begin{enumerate}
   %             \item \textbf{Set:} Elements are sorted according to their own values. Each element only occurs once
   %             \item \textbf{multiset}: Set that allows duplicates
   %             \item \textbf{map}: each element is a key/value pair. Key is used for sorting elements. Each key occurs only once
   %             \item \textbf{multimap}: similar to map, except that it allows duplicates 
   %         \end{enumerate}
   %      \item \textbf{Unsorted}: Not sorted, internally organized as hash table
   %          \begin{enumerate}
   %              \item unordered set
   %              \item unordered multiset
   %              \item unordered map
   %              \item unordered multimap
   %          \end{enumerate}
   % \end{itemize}
   %
   % \bigbreak \noindent 
   % \textbf{Set and multiset}: When an element is added to a set, it’s automatically placed in a position to maintain the sorting status.
   % \bigbreak \noindent 
   % One cannot change an element value directly Otherwise the new value may break the correct order
   % \begin{itemize}
   %     \item No direct element access
   %     \item Elements referenced by iterators are constants
   % \end{itemize}
   % \bigbreak \noindent 
   % In order to change value, one needs to remove the element with the old value, add the new element with the new value
   % \bigbreak \noindent 
   % Sets and multisets are efficient for searching.
   % \bigbreak \noindent 
   % \textbf{Special search operations}
   % \begin{itemize}
   %     \item \textbf{count(elem)} : the number of elements with the value elem
   %     \item \textbf{find(elem)} : the position of the first element with value elem Note that it’s different from find() in <algorithm>
   %     \item \textbf{lower\_bound(elem)} : the position of first element $>=$ elem
   %     \item \textbf{upper\_bound(elem)} : the position of first element $>$ elem
   %     \item \textbf{equal\_range(elem)} : the range of elements == elem. The return value is a pair<iterator, iterator>
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Inserting and removing elements}
   % \begin{itemize}
   %     \item \textbf{insert( elem )}: Returns pair<iterator, bool>. The second field indicates the insertion is successful or not (since an element may already exists)
   %      \item \textbf{insert( pos, elem)}:
   %      \item \textbf{insert(begin, end)}:
   %      \item \textbf{erase(element)}:
   %      \item \textbf{erase(pos)}:
   %      \item \textbf{erase(begin, end)}
   %      \item \textbf{clear()}
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{size related operations}:
   % \begin{itemize}
   %     \item \textbf{size()}
   %      \item \textbf{empty()}
   %      \item \textbf{max\_size()}
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Assignments}
   % \begin{itemize}
   %     \item \textbf{operator=}
   %      \item \textbf{swap()}
   % \end{itemize}
   %
   % \pagebreak 
   % \bigbreak \noindent 
   % \textbf{map \& multimap}: Manage key/value pairs as elements
   % \bigbreak \noindent 
   % Multimap allows duplicate, while map does not. Elements are automatically sorted based on keys according to a certain sorting criterion
   % \bigbreak \noindent 
   % \textbf{Properties}
   % \begin{itemize}
   %     \item \textbf{Automatic sorting}: When a key/value pair is added to a map, it’s automatically placed in a position to maintain the sorting status based on the key
   %     \item \textbf{One cannot change the key of an element directly}: Otherwise the new value may break the correct order based on keys The keys of elements referenced by iterators are constants
   %      \item \textbf{In order to change a key, one needs to}: Remove the element with the old key, add the new element with the new key.
   %      \item \textbf{Efficient for searching based on keys}: Not efficient for searching based on values of elements
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Note:} One can still modify the value of an element directly
   % \bigbreak \noindent 
   % \textbf{Search operations}: 
   % \begin{itemize}
   %     \item \textbf{count(key)} : the number of elements with the key
   %     \item  \textbf{find(key)} : the position of the first element with the key
   %     \item \textbf{lower\_bound(key)} : the position of first element whose key $>=$ key
   %     \item \textbf{upper\_bound(key)} : the position of first element whose key $>$ key
   %     \item \textbf{equal\_range(key)} : the range of elements whose key == key. The return value is a pair
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Inserting and removing elements}
   % \begin{itemize}
   %     \item \textbf{insert( elem )}: The return type for map is pair<iterator, bool> The second field indicates the insertion is successful or not (since an element may already exists)
   %     \item \textbf{insert( pos, elem)}:
   %     \item \textbf{insert( beg, end )}:
   %     \item \textbf{erase(elem )}:
   %     \item \textbf{erase( pos )}: Note that in sequence containers, erase returns the position after the removed element, but in associative containers, erase does not return such position because it needs to traverse to find successor.
   %     \item \textbf{erase( beg, end )}:
   %     \item \textbf{clear()}:
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Size related operations}
   % \begin{itemize}
   %     \item \textbf{size()}:
   %      \item \textbf{empty()}:
   %      \item \textbf{max\_size()}:
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Assignments}
   % \begin{itemize}
   %     \item \textbf{operator=}:
   %      \item \textbf{sawp}:
   % \end{itemize}
   % \bigbreak \noindent 
   % \textbf{Return of [] operator}
   % \begin{itemize}
   %     \item \textbf{m[k]}: Returns a reference to the value of the element with key k. Inserts an element with k if it does not yet exist
   % \end{itemize}
   %
   %
   %
   %
   %
   %
   % \pagebreak \bigbreak \noindent 

   \pagebreak 
   \unsect{STL Algorithms}
   \subsection{<algorithm>}

   \pagebreak 
   \subsection{<numeric>}
   \bigbreak \noindent 
   \subsubsection{transform\_reduce}
   \bigbreak \noindent
   std::transform\_reduce is a function introduced in C++17 as part of the <numeric> header. It combines the functionality of both std::transform and std::reduce (also known as std::accumulate in earlier C++ standards). This algorithm applies a transformation to elements from one or two ranges and then reduces (aggregates) the results of that transformation using a specified binary operation.
   \bigbreak \noindent 
   The signature of std::transform\_reduce has several overloads, but it can be summarized in two forms:
   \bigbreak \noindent 
   \paragraph{Unary transform and reduce}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{cppcode}
    template <typename InputIt, typename T, typename BinaryOp1, typename UnaryOp>
    T transform_reduce(InputIt first, InputIt last, T init, BinaryOp1 binary_op, UnaryOp unary_op);
   \end{cppcode}
   \bigbreak \noindent 
   \begin{itemize}
       \item \textbf{first, last:} Input range [first, last).
       \item \textbf{init:} Initial value for the reduction.
       \item \textbf{binary\_op:} Binary operation to reduce the transformed values (e.g., std::plus<>() for summation).
       \item \textbf{unary\_op:} Unary operation to transform each element before reducing
   \end{itemize}
   \bigbreak \noindent 
   This version is for a single input range, where each element is transformed and then the transformed results are reduced.
   \bigbreak \noindent 
   Example
   \bigbreak \noindent 
   \begin{cppcode}
       #include <numeric>
       #include <vector>
       #include <iostream>

       int main() {
           std::vector<int> v = {1, 2, 3, 4, 5};
           int result = std::transform_reduce(v.begin(), v.end(), 0, std::plus<>(), [](int x) { return x * x; });
           std::cout << "Sum of squares: " << result << std::endl;
       }

   \end{cppcode}
   \begin{itemize}
       \item The unary\_op is the lambda function, which squares each element.
       \item The binary\_op is std::plus<>, which adds the squares together.
       \item The result will be $1^{2} + 2^{2} + 3^{2} + 4^{2} + 5^{2} = 55$.
   \end{itemize}

   \bigbreak \noindent 
   \paragraph{Binary transform and reduce}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{cppcode}
    template <typename InputIt1, typename InputIt2, typename T, typename BinaryOp1, typename BinaryOp2>
    T transform_reduce(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init, BinaryOp1 binary_op, BinaryOp2 binary_transform_op);
   \end{cppcode}
   \begin{itemize}
       \item \textbf{first1, last1:} First input range [first1, last1).
       \item \textbf{first2}: Second input range, assumed to have at least the same length as the first.
       \item \textbf{init:} Initial value for the reduction.
       \item \textbf{binary\_op:} Binary operation to reduce the transformed values.
       \item \textbf{binary\_transform\_op:} Binary operation to transform elements from both ranges before reducing.
   \end{itemize}
   \bigbreak \noindent 
   This version is for two input ranges, where pairs of elements from both ranges are transformed and then the transformed results are reduced.

   \bigbreak \noindent 
   Example
   \bigbreak \noindent 
   \begin{cppcode}
       #include <numeric>
       #include <vector>
       #include <iostream>

       int main() {
           std::vector<int> v1 = {1, 2, 3};
           std::vector<int> v2 = {4, 5, 6};
           int result = std::transform_reduce(v1.begin(), v1.end(), v2.begin(), 0, std::plus<>(), std::multiplies<>());
           std::cout << "Dot product: " << result << std::endl;
       }
   \end{cppcode}

   \pagebreak \bigbreak \noindent 
   \paragraph{std::plus<> and std::multiplies<>}
   \bigbreak \noindent \bigbreak \noindent 
   std::plus<> and std::multiplies<> are implemented as function objects
   \bigbreak \noindent 
   \begin{cppcode}
   template<typename T=void>
   struct plus {
       constexpr operator()(const T& lhs, const T& rhs) const {
           return lhs + rhs;
       }
   };

   template<typename T=void>
   struct multiplies {
       constexpr operator()(const T& lhs, const T& rhs) const {
           return lhs * rhs;
       }
   };
   \end{cppcode}
   \bigbreak \noindent 
   The \texttt{T = void} in function objects like std::plus and std::multiplies allows for more flexibility and generic usage.
   \bigbreak \noindent 
   The T = void part enables a more generic specialization for void, which allows the function object to work with mixed types (as long as the types support the required operation) or automatically deduce the argument types
   \bigbreak \noindent 
   By specializing for void, the compiler can automatically deduce the types of lhs and rhs. This means that you don’t have to explicitly specify a type when you use std::multiplies<>. For example, you can apply std::multiplies<> to two arguments of different types (e.g., int and float), and it will work as long as the multiplication operator (*) is defined for them.

   \bigbreak \noindent 
   \paragraph{Other key function objects}
   \bigbreak \noindent  \bigbreak \noindent 
   \begin{itemize}
       \item \texttt{std::plus}
       \item \texttt{std::minus}
       \item \texttt{std::multiplies}
       \item \texttt{std::divides}
       \item \texttt{std::modulus}
       \item \texttt{std::negate}
       \item \texttt{std::equal\_to}
       \item \texttt{std::not\_equal\_to}
       \item \texttt{std::greater}
       \item \texttt{std::less}
       \item \texttt{std::greater\_equal}
       \item \texttt{std::less\_equal}
       \item \texttt{std::logical\_and}
       \item \texttt{std::logical\_or}
       \item \texttt{std::logical\_not}
   \end{itemize}

   \pagebreak 
   \unsect{Labels and goto}
   \bigbreak \noindent 
   goto is a statement that allows you to jump directly to a labeled section of code within the same function. The target of a goto statement is called a label, which is defined by writing a name followed by a colon (:).
   \bigbreak \noindent 
   \begin{cppcode}
       #include <iostream>
       using namespace std;

       int main() {
           cout << "Start of program" << endl;
           goto skip;  // Jumps to the 'skip' label

           // This line is skipped because of the goto
           cout << "This line will be skipped" << endl;

           skip:
           cout << "Jumped to label 'skip'" << endl;
           return 0;
       }
   \end{cppcode}


   \pagebreak 
   \unsect{Type traits}
   \bigbreak \noindent 
   Type traits are a collection of template-based utilities that allow you to perform compile-time introspection and manipulation of types. They are part of the Standard Template Library (STL) and are available through the header <type\_traits>. These utilities help you gather information about types (e.g., whether a type is an integer or floating-point, whether it is const-qualified, etc.) and perform transformations on them (e.g., remove const, add reference, etc.).
   \begin{itemize}
       \item \textbf{Type Properties:} These allow you to query certain properties of a type
       \item \textbf{Type Modifications}: These traits allow you to modify types, like adding or removing qualifiers
        \item \textbf{Conditional Typing:} These help you select types conditionally:
        \item \textbf{Transformation Traits:} These are useful when you need to change a type in a generic way:
   \end{itemize}

   \bigbreak \noindent 
   \subsection{Nonstandard type of types}
   \bigbreak \noindent 
   \begin{itemize}
       \item \textbf{Fundamental:} Includes basic types like int, float, char, void, and nullptr\_t. They are built-in types in the language.
       \item \textbf{Arithmetic:} Includes all integral types (like int, char) and floating-point types (like float, double).
       \item \textbf{Scalar:} Includes arithmetic types, pointers, and nullptr\_t. Essentially, types that hold a single value.
       \item \textbf{Object:} Any type that can hold data in memory, including scalar types, arrays, and classes/structs.
       \item \textbf{Compound:} Any type built from other types, such as arrays, pointers, references, classes, or unions.
       \item \textbf{Trivial:} A type that has a trivial constructor, destructor, and copy/move operations. It means they can be easily copied or constructed without any custom behavior.
       \item \textbf{Trivially copyable:} A type that can be copied using simple memory operations, such as memcpy, without needing any special handling.
       \item \textbf{Polymorphic:} A class type that contains at least one virtual function, enabling runtime polymorphism through inheritance.
       \item \textbf{Abstract:} A class type with at least one pure virtual function, making it impossible to instantiate directly.
       \item \textbf{Final:} A class or virtual function marked as final cannot be derived from or overridden further.
       \item \textbf{Aggregate:} A simple class or struct with no private or protected members, no constructors, and no virtual functions, allowing it to be initialized with a brace-enclosed initializer list.
   \end{itemize}


   \bigbreak \noindent 
   \subsection{::value, ::type, and ::value\_type}
   \bigbreak \noindent 
   ::value, ::type, and ::value\_type are commonly seen in template metaprogramming, especially with traits and type manipulation.
   \begin{itemize}
       \item \textbf{::value}: Used in type traits to access a constant value. Typically, this is a static constexpr or enum that holds an integral value. 
           \bigbreak \noindent 
           \begin{cppcode}
           std::is_integral<int>::value  // true (1)
           \end{cppcode}
        \item \textbf{::type}: Refers to a type alias or typedef within a template. It is commonly used in type traits to represent the result of a type transformation or query.
            \bigbreak \noindent 
            \begin{cppcode}
            std::remove_const<const int>::type  // int (removes const qualifier)
            \end{cppcode}
        \item \textbf{::value\_type}: A member type that typically represents the type of elements stored in a container. Found in STL containers like std::vector or custom types.
            \bigbreak \noindent 
            \begin{cppcode}
            std::vector<int>::value_type  // int
            \end{cppcode}

   \end{itemize}

   \pagebreak 
   \unsect{Function Objects}
   \bigbreak \noindent 
   Functional arguments for algorithms don’t have to be functions. As seen with lambdas, functional arguments can be objects that behave like functions. Such an object is called a function object, or functor. Instead of using a lambda, you can define a function object as an object of a class that provides a function call operator
   \bigbreak \noindent 
   Function objects are another example of the power of generic programming and the concept of pure
   abstraction. You could say that anything that behaves like a function is a function. So, if you define
   an object that behaves as a function, it can be used like a function.
   \bigbreak \noindent 
   So, what is the behavior of a function? A functional behavior is something that you can call by
   using parentheses and passing arguments
   \bigbreak \noindent 
   All you have to do is define operator () with the appropriate parameter types:
   \bigbreak \noindent 
   \begin{cppcode}
       class c {
           public:
           void operator() (int x) {
               cout << "The value is: " << x << endl;
           }
       };

       c c1;
       c1(2); // Call the object as a function

       vector<int> v({1,2,3});
       std::for_each(b(v), e(v), c()); // Use function object for algorithms
   \end{cppcode}

   \bigbreak \noindent 
   \paragraph{Why?}
   \bigbreak \noindent \bigbreak \noindent 
   You may be wondering what all this is good for. You might even think that function objects look
   strange, nasty, or nonsensical. It is true that they do complicate code. However, function objects are
   more than functions, and they have some advantages:
   \begin{enumerate}
       \item Function objects are “functions with state.” Objects that behave like pointers are smart pointers. This is similarly true for objects that behave like functions: They can be “smart functions” because they may have abilities beyond operator (). Function objects may have other member functions and attributes. This means that function objects have a state. In fact, the same functionality, represented by two different function objects of the same type, may have different states at the same time. This is not possible for ordinary functions. Another advantage of function objects is that you can initialize them at runtime before you use/call them.
       \item Each function object has its own type. Ordinary functions have different types only when their signatures differ. However, function objects can have different types even when their signatures are the same. In fact, each functional behavior defined by a function object has its own type. This is a significant improvement for generic programming using templates because you can pass functional behavior as a template parameter. Doing so enables containers of different types to use the same kind of function object as a sorting criterion, ensuring that you don’t assign, combine, or compare collections that have different sorting criteria. You can even design hierarchies of function objects so that you can, for example, have different, special kinds of one general criterion.
       \item Function objects are usually faster than ordinary functions. The concept of templates usually allows better optimization because more details are defined at compile time. Thus, passing function objects instead of ordinary functions often results in better performance.
   \end{enumerate}

   \bigbreak \noindent 
   \paragraph{Predefined function objects}
   \bigbreak \noindent \bigbreak \noindent 
   \begin{itemize}
       \item LESS<T>
       \item GREATER<T>
    \end{itemize}
   We can use these for example, in constructor of set:
   \bigbreak \noindent 
   \begin{cppcode}
       set<ELEM> C // A SET THAT SORTS WITH LESS<>
        set<ELEM, OPERATION> C // A SET THAT SORTS WITH OP
   \end{cppcode}
   \bigbreak \noindent 
     Examples:
   \begin{itemize}
       \item SET<INT> S1; // INTEGERS ARE SORTED BY <
       \item SET<INT, GREATER<INT> > S2; // INTEGERS ARE SORTED BY >
   \end{itemize}

   \bigbreak \noindent 
   \unsect{Decltype}
   \bigbreak \noindent 
   \begin{concept}
       \textbf{decltype} is a keyword in C++ introduced in C++11, which stands for "declared type". It is used to query the type of an expression without actually evaluating that expression. This can be particularly useful in template programming and type deduction, where the type of an expression might not be known until compile time.
   \end{concept}
   \bigbreak \noindent 
   \subsection{Syntax}
   \bigbreak \noindent 
   \begin{cppcode}
       decltype(expression) variable_name;
   \end{cppcode}
   \bigbreak \noindent 
   Here, \textbf{variable\_name} will have the same type as the type of \textbf{expression}. It's important to note that \textbf{expression} is not evaluated; \textbf{decltype} only deduces its type.
   \bigbreak \noindent 
   \subsection{Example}
   \bigbreak \noindent 
   \begin{cppcode}
       int a = 5;
       decltype(a) b = 5;

       cout << typeid(b).name() << endl; // Output: i
   \end{cppcode}

   \bigbreak \noindent 
   \subsection{Things to pair with decltype}
   \begin{itemize}
       \item \textbf{std::decay\_t} is commonly used with decltype to remove references and qualifiers from a type. It transforms types to their "decayed" forms, similar to what happens when passing an argument to a function.
           \bigbreak \noindent 
           \begin{cppcode}
               auto var = someFunction();
               using DecayedType = std::decay_t<decltype(var)>;
           \end{cppcode}
        \item \textbf{std::remove\_reference / std::remove\_const / std::remove\_cv:}: These traits can be used to strip references, const, and volatile qualifiers from the type deduced by decltype.
            \bigbreak \noindent 
            \begin{cppcode}
            using NonConstType = std::remove_const_t<decltype(someVar)>;
            \end{cppcode}
        \item \textbf{std::is\_same}: Useful when you want to compare the type deduced by decltype with some other type to perform type-checking in templates.
            \bigbreak \noindent 
            \begin{cppcode}
            static_assert(std::is_same_v<decltype(var), int>, "Type must be int");
            \end{cppcode}
        \item \textbf{std::common\_type:} It computes the common type between two or more types, which is useful when you want to get a type that can hold the result of an expression involving multiple types deduced by decltype.
            \bigbreak \noindent 
            \begin{cppcode}
            using CommonType = std::common_type_t<decltype(a), decltype(b)>;
            \end{cppcode}
        \item \textbf{std::conditional}: This allows for conditional type selection based on a compile-time boolean value, often paired with decltype to determine types based on some logic.
            \bigbreak \noindent 
            \begin{cppcode}
            using ConditionalType = std::conditional_t<some_condition, decltype(a), decltype(b)>;
            \end{cppcode}
            \bigbreak \noindent 
            $a$ if true, $b$ if false. A compile-time boolean value is a value that is determined during the compilation phase, rather than at runtime. You typically get these compile-time boolean values from type traits or constexpr values
   \end{itemize}

   Where $\_t$ is shorthand for $::type$ and $\_v$ is shorthand for $::value$

   \pagebreak 
   \unsect{Constexpr}
   \bigbreak \noindent 
   In C++, constexpr is a keyword that allows you to declare that a variable or function can be evaluated at compile time if its inputs are known during compilation. It is used to define constant expressions, which are expressions that can be computed at compile time, leading to potential performance improvements and safer code by ensuring certain values are computed early.
   \bigbreak \noindent 
   \subsection{Variables}
   \bigbreak \noindent 
   A constexpr variable is guaranteed to have a constant value, and that value is computed at compile time. This is useful for things like array sizes or any situation where you need a compile-time constant.
   \bigbreak \noindent 
   \begin{cppcode}
       constexpr int size = 10;  // size is computed at compile time
       int arr[size];            // Valid because size is constant
   \end{cppcode}

   \bigbreak \noindent 
   \subsection{Functions}
   \bigbreak \noindent 
   A constexpr function can be evaluated at compile time if its arguments are known at compile time. If the arguments are not known until runtime, it will behave like a regular function and be evaluated at runtime.
   \bigbreak \noindent 
   constexpr functions must have a single return statement, or all branches must return a value.
   \bigbreak \noindent 
   \begin{cppcode}
       constexpr int square(int x) {
           return x * x;
       }

       constexpr int result = square(5);  // This will be computed at compile time
   \end{cppcode}

   \pagebreak 
   \subsection{Object Constructors}
   \bigbreak \noindent 
   You can also mark constructors as constexpr, meaning you can create objects that are initialized at compile time
   \bigbreak \noindent 
   \begin{cppcode}
       struct Point {
           constexpr Point(int x, int y) : x(x), y(y) {}
           int x, y;
       };

       constexpr Point p(3, 4);  // Object created at compile time
   \end{cppcode}

   \bigbreak \noindent 
   \subsection{constexpr vs const}
   \bigbreak \noindent 
   const variables are constant at runtime but not necessarily at compile time. You can initialize const with runtime values.
   \bigbreak \noindent 
    constexpr implies const but guarantees that the value or function result is computed at compile time if possible.


    \pagebreak 
    \unsect{Function pointers and callable parametrs}
    \bigbreak \noindent 
    \subsection{Function pointers}
    \bigbreak \noindent 
    Function pointers are variables that store the address of a function. They can be passed as parameters to other functions, allowing the called function to invoke the pointed-to function.
    \bigbreak \noindent 
    \subsubsection{As types}
    \bigbreak \noindent 
    \begin{cppcode}
        void fn(unsigned short a) {
            cout << "Arg is: " << a << '\n';
        }

        void (*f)(unsigned short) = &fn;
        void (*f)(unsigned short) = fn;
        f(20);
    \end{cppcode}
    Here $f$ is a pointer to function that takes an unsigned short and returns void. You may notice that we can omit the address of operator. In C++, function names can implicitly convert to pointers to those functions. This behavior is similar to how array names decay to pointers to their first elements.
    \bigbreak \noindent 
    \bigbreak \noindent 
    \subsubsection{As function paramater}
    \begin{cppcode}
        void fn(unsigned short a) {
            cout << "Arg is: " << a << '\n';
        }

        void fun(void (*f)(unsigned short), int n) {
            f(n);
        }

        void (*f)(unsigned short) = &fn;
        fun(f, 12);
    \end{cppcode}
    \bigbreak \noindent 
    Here, fun is a function that has two parameters, a pointer a function that takes an unsigned short and returns void, and an integer n.
    \pagebreak \bigbreak \noindent 
    We can also pass lambdas.
    \bigbreak \noindent 
    \begin{cppcode}
        void fun(void (*f)(unsigned short), unsigned short x) {
            f(x);
        }

        auto lambda = [] (unsigned short n) -> void {
            cout << n << endl;
        };

        fun(lambda, 12);
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Function pointers to member functions}
    \bigbreak \noindent 
    Function pointers to member functions in C++ are a way to refer to non-static member functions of a class. They differ from regular function pointers because member functions implicitly take a this pointer to operate on a specific instance of the class.
    \bigbreak \noindent 
    To declare a pointer to a member function of a class ClassName with a signature ReturnType(ClassName::*)(Arguments)
    \bigbreak \noindent 
    \begin{cppcode}
        ReturnType (ClassName::*pointerName)(Arguments);
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            void print() {
                cout << "Hello world" << endl;
            }
        };

        void (foo::*f)() = &foo::print;
        foo f1;
        (f1.*f)();

        foo* fptr = &f1; // Through a ptr
        (fptr->*f)();
    \end{cppcode}

    \pagebreak \bigbreak \noindent 
    \subsection{Using std::function}
    \bigbreak \noindent 
    We can also define function types with std::function.
    \bigbreak \noindent 
    \begin{cppcode}
        void fn(unsigned short a) {
            cout << "Arg is: " << a << '\n';
        }

        void fun(std::function<void(unsigned short)> f, int x) {
            f(x);
        }

        fun(fn, 12);

        std::function<void(unsigned short)> f = [] (unsigned short a) -> void {
            cout << a << endl;
        };

        fun(f, 13);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{With forwarding references}
    \bigbreak \noindent 
    F\&\& in a template context allows you to accept any callable (function, lambda, functor) while preserving its lvalue/rvalue nature. This is a common pattern for writing generic functions that can accept various types of arguments and forward them to other functions without losing efficiency.
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename F>
    void fn(F&& fun) {
        std::invoke(std::forward<F>(fun));
    }
    \end{cppcode}
    \bigbreak \noindent 
    We used std::forward<F>(fun) instead of just fun. This ensures that if fun is an rvalue, it gets forwarded correctly as an rvalue; if it's an lvalue, it stays an lvalue. This is part of perfect forwarding.
    






    \pagebreak 
    \unsect{Templates}
    \bigbreak \noindent 
    Templates in C++ are a powerful feature that allows writing generic and reusable code. They enable functions and classes to operate with different data types without being rewritten for each specific type.
    \bigbreak \noindent 
    \subsection{Template Function}
    \bigbreak \noindent 
    A template function defines a family of functions that work with different data types. Here's how to write and use a template function:
    \bigbreak \noindent 
    \begin{cppcode}
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add<int>(3, 4) << std::endl; // Instantiates add<int>
    std::cout << add<double>(2.5, 3.1) << std::endl; // Instantiates add<double>
    return 0;
}
    \end{cppcode}

    \bigbreak \noindent 
    \pagebreak 
    \subsection{Template Class}
    \bigbreak \noindent 
    \begin{cppcode}
template <typename T>
class Stack {
    std::vector<T> data;

public:
    void push(T value) {
        data.push_back(value);
    }
    void pop() {
        data.pop_back();
    }
    T top() const {
        return data.back();
    }
    bool empty() const {
        return data.empty();
    }
};

int main() {
    Stack<int> intStack; // Instantiates Stack<int>
    intStack.push(10);
    intStack.push(20);
    std::cout << intStack.top() << std::endl;

    Stack<double> doubleStack; // Instantiates Stack<double>
    doubleStack.push(1.1);
    doubleStack.push(2.2);
    std::cout << doubleStack.top() << std::endl;
    return 0;
}
    \end{cppcode}










    \bigbreak \noindent 
    \subsection{Class vs typename keyword}
    \bigbreak \noindent 
    The choice between using \textbf{class} and \textbf{typename} in template declarations in C++ is largely a matter of style and historical context, as both keywords serve the same purpose

    \bigbreak \noindent 
    \subsection{Handle friend functions}
    \bigbreak \noindent 

    \subsubsection{Friendship to a Non-Template Function}
    \bigbreak \noindent 
    This is straightforward. You directly declare a non-template function as a friend inside your template class. This grants that specific function access to all instances of the template class, regardless of the type parameter.
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        class MyClass {
            friend void someFunction(MyClass<T>&);
        };
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{Friendship to a Template Function}
    \bigbreak \noindent 
    More commonly, you want a template function to be a friend to a template class. This allows each instantiation of the function template to access the corresponding instantiation of the class template.To achieve this, you need to forward declare the function template and then declare it as a friend inside your class template. The tricky part is that the syntax for declaring a template function as a friend inside a template class can vary based on what you're trying to achieve:
     \bigbreak \noindent 
    \textbf{How to forward declare:}
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    class myclass;

    template<typename T>
    void foo(myclass<T>&); 


    template<typename T>
    class myclass {
    public:
        friend void foo <T>(const myclass<T>& obj);
    };

    template <typename T>
    void foo(myclass<T>& obj) {
        // Define
    }
    \end{cppcode}
    \pagebreak 
    \textbf{Different types:}
    \begin{itemize}
        \item More general form used when you want the friendship to apply to all instantiations of the function template
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    friend void someFunction<>(MyClass<T>&); // Specific instantiation
                };
            \end{cppcode}
        \item All instantiations of the function template are friends:
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    template <typename U>
                    friend void someFunction(MyClass<U>&); // All instantiations
                };
            \end{cppcode}
        \item This form ties the friendship to the specific template instantiation of both MyClass and someFunction using the same template argument T. The function template that takes the same template parameters:
            \bigbreak \noindent 
            \begin{cppcode}
                template <typename T>
                class MyClass {
                    friend void someFunction<T>(MyClass<T>&); // Matched instantiation
                };
            \end{cppcode}
    \end{itemize}

    \pagebreak 
    \subsection{Function Template Specialization}
    \bigbreak \noindent 
    \begin{concept}
        \textbf{Template specialization} allows you to define a different implementation for a particular data type.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
    template <typename T>
    T min(T x, T y) {
        return (x < y) ? x : y;
    }

    template <>
    const char* min(const char* x, const char* y) {
        return (strcmp(x, y) < 0) ? x : y;
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Class/Struct Template Specialization}
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    struct foo {
        T x = 20;
    };

    template<>
    struct foo<char> {
        char x = 'z';
    };
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Template Parameters}
    \bigbreak \noindent 
    \begin{concept}
        Templates can have more than one parameter, including non-type parameters.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T, int size>
        class FixedArray {
            private:
            T arr[size];
            // implementation
        };
    \end{cppcode}

     \bigbreak \noindent 
    \subsection{Trailing return type}
    \bigbreak \noindent 
    In traditional C++, the return type of a function is declared at the beginning of the function declaration. However, C++11 introduced a new syntax that allows the return type to be specified after the parameter list, using auto at the beginning and -> Type after the parameter list.
    \bigbreak \noindent 
    \subsubsection{Syntax}
    \bigbreak \noindent 
    \begin{cppcode}
    auto functionName(parameters) -> returnType {
        // function body
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    auto foo(int a, int b) -> int {
        return a + b;
    }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Template functions with mixed types (Trailing return type)}
    \bigbreak \noindent 
    \begin{concept}
        To address the challenge of determining the return type for a template function that accepts two different types, we can utilize a strategy involving \textbf{auto} and a \textbf{trailing return type} with \textbf{decltype}. This approach effectively resolves the ambiguity of the return type in such template functions.
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        auto add(T t, U u) -> decltype(t + u) {
            return t + u;
        }
    \end{cppcode}

    \pagebreak 
    \subsection{Template functions with mixed types (Deduced return type)}
    Alternatively, C++14 introduced the concept \textbf{deduced return type}. Which provides a simpler way to handle the situation described above
    \bigbreak \noindent 
    \begin{cppcode}
        template<typename T, typename U>
        decltype(auto) foo(T a, U b)  {
            return a + b;
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Dependent name resolution}
    \bigbreak \noindent 
    Suppose we have the code
    \begin{cppcode}
    template <typename T>
    void showcont(const T& cont) {
        typename T::iterator it;
        for (it = cont.begin(); it! = cont.end(); ++it) 
            cout << *it << endl;
    }
    \end{cppcode}
    \bigbreak \noindent 
    Why do we need the word "\texttt{typename}" before the iterator \texttt{it} is declared?
    \bigbreak \noindent 
    This concept is called "\textbf{dependent name resolution}" in C++. Specifically, it falls under the broader topic of dependent types and dependent names in template programming.
    \bigbreak \noindent 
    \subsubsection{Dependent names}
    \bigbreak \noindent 
    In templates, a dependent name is any name that depends on a template parameter. For example, \texttt{T::iterator} in the code above depends on the template parameter \texttt{T}. The compiler cannot determine the exact meaning of T::iterator until the template is instantiated with a concrete type.
    \bigbreak \noindent 
    \subsubsection{Typename Keyword}
    \bigbreak \noindent 
     In C++, the typename keyword is used to indicate that a dependent name refers to a type. Without typename, the compiler might interpret T::iterator as something else, such as a static member variable or a constant. Using typename helps disambiguate and ensures the compiler treats T::iterator as a type.
     \bigbreak \noindent 
     \textit{Dependent name resolution} is the process by which the compiler determines the meaning of dependent names during template instantiation. When the template is instantiated with a specific type, the compiler resolves T::iterator to the actual nested type within T.
     \bigbreak \noindent 
     C++ uses a two-phase name lookup process for templates. In the first phase, the compiler parses the template without knowing the actual template arguments. In the second phase, the compiler instantiates the template with the provided arguments. Since T::iterator cannot be resolved in the first phase (before knowing what T actually is), typename is required to instruct the compiler that iterator is indeed a type
     \bigbreak \noindent 
     \subsubsection{Nested types}
     \bigbreak \noindent 
     Any nested type within a template parameter requires the typename keyword. For example:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         void foo() {
             typename T::value_type val; // T::value_type is a nested type within T
         }
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Prereq: Using aliases defined in classes}
     \bigbreak \noindent 
     We can define aliases inside classes, but then we need to reference them outside the class by using the \textit{scope resolution operator}
     \bigbreak \noindent 
     \begin{cppcode}
        class foo {
        public:
            alias ll = long long;
            ll b = 10;
         };

         int main() {
             foo::ll a = 5;
             return 0;
         }
     \end{cppcode}
     \bigbreak \noindent 
     This also applies to typedefs...
    \bigbreak \noindent 
    \begin{cppcode}
        class foo {
        public:
            typedef long long ll;
        }

        int main() {
            foo::ll a = 10;
            return 0;
        }
    \end{cppcode}

     \bigbreak \noindent 
     \nt{We can define aliases inside functions, but we can't use them outside the function they are defined in}

     \bigbreak \noindent 
     \subsubsection{Type Aliases}
     \bigbreak \noindent 
     If a class template has a type alias defined inside it, you need to use typename when referring to that alias in another template. For example:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         class Wrapper {
             public:
             using PointerType = T*; // A type alias within Wrapper
         };

         template <typename T>
         void bar() {
             typename Wrapper<T>::PointerType ptr; // typename is required here
         }
     \end{cppcode}

     \pagebreak 
     \subsubsection{Return Types in Template Functions}
     \bigbreak \noindent 
     When using a dependent type as a return type for a function within a template, typename is necessary:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         typename T::value_type getValue(const T& container) {
             return *container.begin();
         }
     \end{cppcode}
     \bigbreak \noindent 
     \subsubsection{Base Class Members}
     \bigbreak \noindent 
     When accessing a member of a base class that is a dependent type, typename is required. 
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         class foo {
         public:
             typedef T* tp;
         };

         template <typename T>
         class bar : public foo<T> {
         public:
             typename foo<T>::tp a;
         };
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Dependent Types in Expressions}
     \bigbreak \noindent 
     If you use a dependent type within an expression, you must indicate it with typename:
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         void example(const T& cont) {
             typename T::size_type size = cont.size(); // typename required here
         }
     \end{cppcode}
     \bigbreak \noindent 
     Where size\_type is a type alias defined inside the class or container type T. In this context, size\_type typically represents an unsigned integer type used to express sizes and counts of elements in the container.

     \bigbreak \noindent 
     \subsection{Variadic templates with functions}
     \bigbreak \noindent 
     Variadic templates in C++ allow you to write functions or classes that can take an arbitrary number of template arguments
     \bigbreak \noindent 
     A variadic template is defined by using an ellipsis (...) both in the template parameter list and in the function arguments. 
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename... Args>
         void print(Args... args) {
             // function body
         }
     \end{cppcode}
     \bigbreak \noindent 
     \begin{itemize}
         \item \textbf{typename...} Args declares a parameter pack named Args, which can hold zero or more template arguments.
         \item \textbf{Args...} args is another parameter pack that holds the function parameters of arbitrary types and numbers.
     \end{itemize}
     \bigbreak \noindent 
     A parameter pack in C++ is a feature of variadic templates that represents zero or more template parameters or function arguments. It allows functions or classes to handle an arbitrary number of arguments.
     \bigbreak \noindent 
     To process the elements of the parameter pack, you can use a technique called pack expansion. A common way to do this is by recursively calling the variadic function. 
     \bigbreak \noindent 
     \begin{cppcode}
         #include <iostream>

         void print() {
             std::cout << std::endl;
         }

         template<typename T, typename... Args>
         void print(T first, Args... args) {
             std::cout << first << " ";
             print(args...);  // recursive call with remaining arguments
         }

         int main() {
             print(1, 2.5, "Hello", 'A');
             return 0;
        }
     \end{cppcode}
     \bigbreak \noindent 
     In C++17, fold expressions simplify handling variadic templates by eliminating the need for recursion. You can apply an operation over the entire parameter pack in a single expression
     \bigbreak \noindent 
     \begin{cppcode}
         #include <iostream>

         template<typename... Args>
         void print(Args... a) {
             ((std::cout << a << std::endl) , ...); // Right fold
              (..., (std::cout << a << endl)); // Left fold
              // Both folds output the same, more on this later
         }

         int main() {
             print(1, 2.5, "Hello", 'A');
             return 0;
         }
     \end{cppcode}
     \bigbreak \noindent 
     The ellipsis ... is part of the fold expression syntax, and here it’s applied to the entire operation inside the parentheses: (cout << a << endl). This means the expression cout << a << endl will be expanded for each argument a in the parameter pack.
     \bigbreak \noindent 
     The comma operator (operator,) allows multiple expressions to be evaluated in sequence. It guarantees that for each a, the expression cout << a << endl will be executed. This effectively prints each argument followed by a newline.
     \bigbreak \noindent 
     \bigbreak \noindent 
     The expanded form of ((cout << a << endl), ...) would look something like:
     \bigbreak \noindent 
     \begin{cppcode}
         (cout << arg1 << endl, cout << arg2 << endl, cout << arg3 << endl, ...);
     \end{cppcode}
     \bigbreak \noindent 
     To exapand upon this...
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename ... args>
         void fn(args ... a) {
             ((std::cout << a << endl) , ...);
         }

         void f(int a, int b, int c) {
             cout << a << endl, cout << b << endl, cout << c << endl;
         }

         fn(1,2,3);
         cout << endl;
         f(1,2,3);
     \end{cppcode}
     \bigbreak \noindent 
     Both functions have the same output.
     \bigbreak \noindent 
     In the example above we are using the comma operator, but it could be any operator
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename T, typename... Args>
         T fn(Args ... a) {
             int sum = 0;
             sum = (sum + ... + a); // Expand: sum = (0 + a_1 + a_2 + ... + a_n);
             (sum += ... += a); // Expand: sum += a_1 += a_2 += a_3 += ... += a_n
             sum += (... + a); // Expand: sum += (a-1 + ... + a_n)
             return sum;
         }
     \end{cppcode}
     \bigbreak \noindent
     Recall, assignment operators in c++ are right to left

     \pagebreak \bigbreak \noindent 
     \subsection{Left vs right folds}
     \bigbreak \noindent 
     A left fold applies the operator from left to right.
     \bigbreak \noindent 
     \begin{cppcode}
         (... op pack)
     \end{cppcode}
     \bigbreak \noindent 
     The operator op is applied between the leftmost elements first, and then successively to the rest of the elements.
     \bigbreak \noindent 
     A right fold applies the operator from right to left.
     \bigbreak \noindent 
     \begin{cppcode}
     pack op ...
     \end{cppcode}
     \bigbreak \noindent 
     The operator op is applied between the rightmost elements first, and then successively to the remaining elements.

     \pagebreak \bigbreak \noindent 
     \subsection{Parentheses in fold expressions}
     \bigbreak \noindent 
     The parentheses in fold expressions in C++ are used to ensure correct grouping and to determine how the fold expression expands over the parameter pack. They help dictate the precedence and associativity of the operation being applied to the elements of the parameter pack, ensuring the operator is applied in the desired order.
     \bigbreak \noindent 
     Parentheses are necessary to group the fold expression correctly, especially when using operators like +, -, +=, etc., which need to be explicitly applied across the elements of a parameter pack.
     \bigbreak \noindent 
     The parentheses ensure that the fold applies the operator across the entire parameter pack and handles the result correctly.
     \bigbreak \noindent 
     \begin{cppcode}
     (sum += ... + args);
     \end{cppcode}
     \bigbreak \noindent 
     Here, the parentheses ensure that the += is applied between sum and the result of the left fold ... + args.
     \bigbreak \noindent 
     Without parentheses, operator precedence could cause the fold expression to be parsed incorrectly by the compiler, leading to syntax errors or unintended behavior.

     \bigbreak \noindent 
     \subsection{Pack size}
     \bigbreak \noindent 
     sizeof...(Args) (also called "pack size") is a compile-time operator that gives you the number of template arguments in the parameter pack Args.... It works for both types and non-type template parameter packs. This can be helpful in function calls, especially when you're dealing with variadic templates and need to know the size of the pack for controlling logic or iteration.
     \bigbreak \noindent 
     \begin{cppcode}
         // Function template using sizeof... to count the number of arguments
         template<typename... Args>
         void countArguments(Args... args) {
             std::cout << "Number of arguments: " << sizeof...(Args) << std::endl;
         }
     \end{cppcode}

     \pagebreak 
     \subsection{Function calls in fold expressions}
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename T>
         void print(T t) {
             cout << t << endl;
         }

         template<typename... args>
         void f(args...a) {
             (print(a),...);
             (..., print(a)); // Does the same
         }

     \end{cppcode}

     


     \pagebreak \bigbreak \noindent 
     \subsection{Variadic templates with classes}
     \bigbreak \noindent 
     A variadic class template is defined in much the same way as a variadic function template, but it applies to classes. You use typename... (or class...) to declare a parameter pack in the class definition, which allows the class to accept multiple template arguments.
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename... Args>
         class MyClass {
             // Use Args... in the class definition
         };
     \end{cppcode}
     \bigbreak \noindent 
     In this example, Args... is a parameter pack that can hold any number of types.
     \bigbreak \noindent 
     \begin{cppcode}
         // Variadic class template
         template<typename... Args>
         class MyClass {};

         // Specialization for one type argument
         template<typename T>
         class MyClass<T> {
             public:
             void display() {
                 std::cout << "One template argument: " << typeid(T).name() << std::endl;
             }
         };

         // Specialization for two type arguments
         template<typename T1, typename T2>
         class MyClass<T1, T2> {
             public:
             void display() {
                 std::cout << "Two template arguments: "
                 << typeid(T1).name() << " and " << typeid(T2).name() << std::endl;
             }
         };

         // Specialization for more than two arguments
         template<typename T, typename... Rest>
         class MyClass<T, Rest...> {
             public:
             void display() {
                 std::cout << "First argument: " << typeid(T).name() << std::endl;
                 std::cout << "Number of remaining arguments: " << sizeof...(Rest) << std::endl;
             }
         };
     \end{cppcode}
     \bigbreak \noindent 
     \begin{cppcode}
         template<typename...Args>
         struct foo {

             void printargs(Args...args) {
                 ((cout << args << endl), ...);
             }
         };

         foo<int,string,double> a;
         a.printargs(1,"foo",3.14f);
     \end{cppcode}


     \pagebreak 
     \subsection{std::forward}
     \bigbreak \noindent 
     std::forward is a utility function in C++ that is used primarily in template functions to enable perfect forwarding. It is part of the C++ Standard Library and is typically used to forward arguments while preserving their value category (whether they are lvalues or rvalues).
     \bigbreak \noindent 
     In generic template code, when you want to pass arguments to another function or callable, you need to preserve whether those arguments were passed as lvalues (references to existing objects) or rvalues (temporary objects). std::forward allows you to forward arguments while ensuring that their value category is preserved.
     \bigbreak \noindent 
     Without std::forward, arguments passed to template functions would often lose their original value category, especially when working with rvalues
     \bigbreak \noindent 
     \begin{cppcode}
         template< class T >
         T&& forward( typename std::remove_reference<T>::type\& arg ) noexcept;
     \end{cppcode}
     \bigbreak \noindent 
     If the argument is an rvalue std::forward will cast it to an rvalue (i.e., T\&\&), allowing the function to move the argument if appropriate (typically used in move semantics).
     \bigbreak \noindent 
     If the argument is an lvalue std::forward will cast it to an lvalue reference (T\&), ensuring that the original object is used and not moved or copied unnecessarily.
     \bigbreak \noindent 
     \begin{cppcode}
         template <typename T>
         void wrapper(T&& arg) {
             func(std::forward<T>(arg));  // Perfectly forward arg, preserving its value category
         }
     \end{cppcode}
     \bigbreak \noindent 
     Now, std::forward<T>(arg) ensures that if arg was originally passed as an rvalue, it remains an rvalue when forwarded to func, enabling func to take advantage of move semantics. Similarly, if arg was an lvalue, it is passed as an lvalue.
     \bigbreak \noindent 
     \subsubsection{Key Differences Between std::forward and std::move}
     \bigbreak \noindent 
     std::move Unconditionally casts the argument to an rvalue, suggesting that it can be "moved from" (even if it was originally an lvalue). It doesn't preserve the original value category but rather forces the argument to be treated as an rvalue.
     \bigbreak \noindent 
     std::forward Conditionally casts the argument, preserving its value category. It is only used in template code and requires knowledge of whether the argument was an lvalue or rvalue (via the type deduction)

     \pagebreak \bigbreak \noindent 
     \begin{cppcode}
         #include <iostream>
         #include <utility>

         void process(const std::string& s) {
             std::cout << "Lvalue: " << s << '\n';
         }

         void process(std::string&& s) {
             std::cout << "Rvalue: " << s << '\n';
         }

         template <typename T>
         void wrapper(T&& arg) {
             process(std::forward<T>(arg));  // Forward arg to process
         }

         int main() {
             std::string str = "Hello";

             wrapper(str);            // Lvalue is forwarded, calls process(const std::string&)
             wrapper(std::move(str)); // Rvalue is forwarded, calls process(std::string&&)
         }

     \end{cppcode}

     \pagebreak 
     \subsection{Universal reference (forwarding reference)}
     \bigbreak \noindent 
     Universal references (also called forwarding references) in C++ are template parameters declared as T\&\& that can bind to both lvalues and rvalues. The behavior of a universal reference depends on the type of the argument passed:
     \bigbreak \noindent 
     If an lvalue is passed, T\&\& becomes an lvalue reference (T\&).
    If an rvalue is passed, T\&\& remains an rvalue reference (T\&\&).
    \bigbreak \noindent 
    Universal references are typically used with perfect forwarding, allowing you to forward arguments to other functions while preserving their value category (lvalue or rvalue).
    \bigbreak \noindent 
    \begin{cppcode}
    template<typename T>
    void bar(T&& x) {
        cout << x << '\n';
    }

    template<typename T>
    void foo(T&& x) {
        bar(std::forward<T>(x));
    }

    template<typename T>
    void fn(T&& x) {
        cout << x << endl;
    }

    int x = 20;
    decltype(x)& y = x;
    fn(std::forward<decltype(y)>(y));
    \end{cppcode}

    \pagebreak 
    \subsection{Concepts}
    \bigbreak \noindent 
    Concepts are a feature introduced in C++20 that allow you to specify constraints on template parameters in a clear, concise, and readable way. They improve the expressiveness, safety, and usability of templates by providing a mechanism to enforce specific requirements on the types passed to a template.
    \bigbreak \noindent 
    A concept is defined using the concept keyword and is essentially a compile-time boolean expression that evaluates to true or false.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <concepts>

        // Define a concept

        // This is std::integral
        template <typename T>
        concept Integral = std::is_integral_v<T>;

        // This is std::floating_point
        template <typename T>
        concept FloatingPoint = std::is_floating_point_v<T>;
    \end{cppcode}
    \bigbreak \noindent 
    You can constrain template parameters directly using a concept.
    \bigbreak \noindent 
    \begin{cppcode}
        template <Integral T>
        T add(T a, T b) {
            return a + b;
        }

        add(40,20) // OK
        add(40.0f, 20.0f) // ERROR
    \end{cppcode}
    \bigbreak \noindent 
    Alternatively, you can use a requires clause:
    \bigbreak \noindent 
    \begin{cppcode}
        template <typename T>
        requires Integral<T>
        T add(T a, T b) {
            return a + b;
        }
    \end{cppcode}
    \bigbreak \noindent 
    You can combine concepts with auto for a more concise syntax:
    \bigbreak \noindent 
    \begin{cppcode}
        auto add(Integral auto a, Integral auto b) {
            return a + b;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Concepts can also be used to constrain class templates.
    \bigbreak \noindent 
    \begin{cppcode}
        template <Integral T>
        class Calculator {
            T value;
        };
    \end{cppcode}
    \bigbreak \noindent 
    Concepts can be combined using logical operators (\&\&, ||, !).
    \bigbreak \noindent 
    \begin{cppcode}
    template <typename T>
    concept Numeric = Integral<T> || FloatingPoint<T>;
\end{cppcode}
\bigbreak \noindent 
The <concepts> header provides a set of predefined concepts for common use cases:
\begin{itemize}
    \item std::same\_as<T, U>	Ensures T is the same type as U.
    \item std::convertible\_to<T, U>	Ensures T can be converted to U.
    \item std::derived\_from<T, U>	Ensures T is derived from U.
    \item std::integral	Matches integral types (int, char, etc.).
    \item std::floating\_point	Matches floating-point types (float, double).
    \item std::assignable\_from<T, U>	Ensures T = U is valid.
\end{itemize}












     \pagebreak 
     \unsect{More on the comma operator}
     \bigbreak \noindent 
     The comma acts as both a separator and an operator, depending on the context.
     \bigbreak \noindent 
     As a separator, The comma separates elements in lists, such as function arguments, initializer lists, or variables in declarations. This much is trivial
     \bigbreak \noindent 
     As an Operator, the comma operator (when used in expressions) evaluates two or more expressions from left to right, and the result of the entire comma expression is the result of the right-most expression.
     \bigbreak \noindent 
     \begin{cppcode}
     int a = (1, 2);  // a gets the value of 2
     \end{cppcode}
     \bigbreak \noindent 
     In this case, 1 is evaluated first, then 2 is evaluated, and the result of the entire expression is 2.
     \bigbreak \noindent 
     In loops, 
     \bigbreak \noindent 
     \begin{cppcode}
         for (int i = 0, j = 10; i < j; ++i, --j) {
             // Do something
         }
     \end{cppcode}
     \bigbreak \noindent 
     Here, the comma separates the initialization of $i$ and $j$ as well as the increment and decrement operations in the loop.









     \pagebreak 
     \unsect{More on Lambdas}
     \bigbreak \noindent 
     \subsection{Auto in lambda args}
     \bigbreak \noindent 
     In C++, the auto keyword is used in lambda expressions to infer the type of the parameters or the return type. It helps make lambda functions more flexible and convenient to use without explicitly specifying types, especially when types are complex or unknown at compile time.
     \bigbreak \noindent 
     \begin{cppcode}
         struct foo {
             int x = 0, y = 0;

             foo() = default;
             foo(int a, int b) : x(a), y(b) {}

             friend std::ostream& operator<<(std::ostream& os, foo f);
         };

         std::ostream& operator<<(std::ostream& os, foo f) {
             os << "x: " << f.x << endl << "y: " << f.y << endl;
             return os;
         }

         foo f1(1,2), f2(3,4);

         auto fn = [] (const auto& a, const auto& b) -> auto {
             cout << a << endl << b;
         };

         fn(f1,f2);
     \end{cppcode}
     \bigbreak \noindent 
     It should be noted that you cannot do this with regular functions
     \bigbreak \noindent 
     \begin{cppcode}
         // Not allowed!
         void fn(const auto& a, const auto& b) { 
             cout << a << endl << b;
         }
     \end{cppcode}


     \subsection{Template lambdas}
     \bigbreak \noindent 
     Since C++20, we can make template lambdas.
     \bigbreak \noindent 
     \begin{cppcode}
         auto fn = []<typename T>(const T& a, const T& b) -> auto{
             cout << a << endl << b;
         };
         fn(f1,f2); // No need for <> notation, auto deduced
     \end{cppcode}
     

     \pagebreak 
     \subsection{Recursive lambdas}
     \bigbreak \noindent 
     In C++, you cannot use auto to declare a recursive lambda directly because lambdas do not have a name. Since they are anonymous, you can't directly reference the lambda within its own body. For recursion, a function needs to call itself, but without a name, the lambda cannot do that.
     \bigbreak \noindent 
     As a side note, we also must capture the lambda by reference.
     \bigbreak \noindent 
     \begin{cppcode}
         auto lambda = [&lambda](int x, int n) { // ERROR 
             if (n == 0) return 1;

             return x * lambda(x,n-1);
        };
     \end{cppcode}
     \bigbreak \noindent 
     This code gives the error "Variable 'lambda' declared with deduced type 'auto' cannot appear in its own initializer".
     \bigbreak \noindent 
     We can use std::function to explicitly define the type of the lambda. This works because std::function provides a way to store callable objects with a known signature.
     \bigbreak \noindent 
     \begin{cppcode}
         std::function<int(int,int)> lambda = [&lambda](int x, int n) { // Works
             if (n == 0) return 1;

             return x * lambda(x,n-1);
         };
     \end{cppcode}






    \pagebreak 
    \unsect{When initializer lists are required}
    \bigbreak \noindent 
    Using initialization lists to initialize data members in a constructor can be convenient if you don't need to do any error-checking on the constructor arguments. There are also several instances in C++ where the use of an initializer list to initialize a data member is actually required:

    \begin{itemize}
        \item Data members that are const but not static must be initialized using an initialization list.
        \item Data members that are references must be initialized using an initialization list.
        \item An initialization list can be used to explicitly call a constructor that takes arguments for a data member that is an object of another class (see the employee constructor example above).
        \item In a derived class constructor, an initialization list can be used to explicitly call a base class constructor that takes arguments.
    \end{itemize}

    \pagebreak 
    \unsect{Inheritence and Subtype Polymorphism}
    \bigbreak \noindent 
    \subsection{OOP Main Concepts}
    \bigbreak \noindent 
    An \textbf{object} is a software bundle of related state (data members or properties) and behavior (member functions or methods). Software objects are often used to model the real-world objects that you find in everyday life.
    \bigbreak \noindent 
    A \textbf{class} is a blueprint or prototype from which objects are created. A class is an abstract definition that is made concrete at run-time when objects based upon the class are created.
    \bigbreak \noindent 
    \textbf{Encapsulation}, also known as data hiding, is the act of concealing the functionality of a class so that the internal operations are hidden, and irrelevant, to the programmer. With correct encapsulation, the developer does not need to understand how the class actually operates in order to communicate with it via its publicly available member functions and data members, known as its public interface. Encapsulation is essential to creating maintainable object-oriented programs. When the interaction with an object uses only the publicly available interface of member functions and properties, the class of the object becomes a correctly isolated unit. This unit can then be replaced independently to fix bugs, to change internal behavior or to improve functionality or performance. Encapsulation also promotes data integrity by allowing public "set" member functions to validate new values that are to be assigned to private data members.
    \bigbreak \noindent 
    \textbf{Message passing}, also known as interfacing, describes the communication between objects using their public interfaces. The primary way of passing a message to an object in C++ is to call a member function for that object.
    \bigbreak \noindent 
    \textbf{Abstraction} is the process of representing simplified versions of real-world objects in your classes and objects. A car class does not describe every possible detail of a car, only the relevant parts for the system being developed. Modeling software around real-world objects can vastly reduce the time required to understand a solution and be able to develop and maintain it.
    \bigbreak \noindent 
    \subsection{Object Relationships}
    \bigbreak \noindent 
    Objects can work together in many ways within a system. In some situations, classes and objects can be tightly coupled together to provide more complex functionality. This "has-a" relationship is known as composition. For example, modeling a car might involve creating individual classes such as wheel, engine, and transmission. The car class could then contain objects of these classes as data members, since a car "has" an engine, wheels, and a transmission. The internal workings of each class are not important due to encapsulation as the communication between the objects is still via passing messages to their public interfaces.
    \bigbreak \noindent 
    Other types of relationships may be modeled. A class may simply "use" an object of another class (perhaps creating the object as a local variable in one of its member functions). A class may also "know" about an object of another class without owning it (in C++, this association relationship might be modeled using a pointer or reference to the object).
    \bigbreak \noindent 
    Inheritance is an object-oriented programming concept used to model an "is-a" relationship between two classes. It allows one class (the derived class or subclass) to be based upon another (the base class or superclass) and inherit all of its functionality automatically. Additional code may then be added to create a more specialized version of the base class.

    \bigbreak \noindent 
    \subsection{Ineritance}
    \bigbreak \noindent 
    A \textbf{derived class} is more specific than its base class and represents a smaller group of objects.
    \bigbreak \noindent 
    A \textbf{direct base class} is the base class from which a derived class explicitly inherits. An indirect base class is inherited from two or more levels up the class hierarchy.
    \bigbreak \noindent 
    In the case of single inheritance, a class is derived from one base class. C++ also supports multiple inheritance, in which a derived class inherits from multiple (possibly unrelated) classes. Single inheritance is straightforward. Multiple inheritance can be complex and error prone.
    \bigbreak \noindent 
    Single-inheritance relationships form tree-like hierarchical structures - a base class exists in a hierarchical relationship with its derived classes.
    \bigbreak \noindent 
    C++ offers three kinds of inheritance - public, protected, and private. public inheritance in C++ is used to model "is a" relationships. Every object of a derived class is also an object of that derived class's base class. However, base-class objects are not objects of their derived classes. For example, all car objects are also vehicle objects, but not all vehicle objects are car objects.
    \bigbreak \noindent 
    With public inheritance, a derived class may
    \begin{itemize}
        \item add new data members
        \item add new member functions
        \item override member functions defined in the base class
    \end{itemize}
    private and protected inheritance do not model "is-a" relationships and are not used as frequently.

    \bigbreak \noindent 
    \subsection{Inheritance and Member Access}
    \bigbreak \noindent 
    \begin{center}
        \begin{tabular}{c|c|c|c}
            Base class modifier	& public Inheritance	& protected Inheritance	& private Inheritance \\
            \hline
            public	&public 	&protected 	&Hidden  \\
            protected &	protected 	&protected 	&Hidden  \\
            private	&Hidden 	&Hidden 	&Hidden 
        \end{tabular}

    \end{center}
    \bigbreak \noindent 
    A base class's public members are accessible anywhere that the program has a "handle" to an object (an object name or a pointer or reference to an object) of the base class or to an object of one of that base class's derived classes. Derived class member functions can access public base class data members directly.
    \bigbreak \noindent 
    A base class's private members are "hidden" - they are accessible only within the definition of that base class or from a friend of that class. A derived class cannot access the private members of its base class directly; allowing this would violate the encapsulation of the base class. A derived class can only access private base-class members through non-private member functions defined in the base class and inherited by the derived class.
    \bigbreak \noindent 
    A base class's protected members have an intermediate level of protection between public and private access. A base class's protected members can be directly accessed by member functions of that base class, by a friend of that base class, by member functions of a class derived from that base class, and by a friend of a class derived from that base class.
    \bigbreak \noindent 
    The use of protected data members allows for a slight increase in performance, because we avoid incurring the overhead of a call to a "set" or "get" member function. Unfortunately, protected data members often yield two major problems. First, the derived class object does not have to use a "set" member function to change the value of the base class's protected data. A derived class object can easily assign an illegal value to a protected data member. Second, derived class member functions are more likely to depend on base class implementation details. Changes to the base class may require changes to some or all of the derived classes of that base class.
    \bigbreak \noindent 
    Declaring data members private, while providing non-private member functions to manipulate and perform validation checking on this data, enforces good software engineering. The programmer should be able to change the base class implementation freely, while still providing the same services to the derived class. The performance increases gained by using protected data members are often negligible compared to the optimizations that compilers can perform. It is appropriate to use the protected access modifier when a base class should provide a service (i.e., a member function) only to its derived classes and should not provide the service to other clients.
    \bigbreak \noindent 
    When a base class member function is inappropriate for a derived class, that member function can be redefined in the derived class with an appropriate implementation. This is called overriding the base class member function.
    \bigbreak \noindent 
    When a derived class member function overrides a base class member function, the base class member function can still be accessed from the derived class by preceding the base class member function name with the base class name and the scope resolution operator (::).
    \bigbreak \noindent 
    When an object of a derived class is created, the base class's constructor is called immediately (either explicitly or implicitly) to initialize the base class data members in the derived class object (before the derived class data members are initialized). Explicitly calling a base class constructor requires using the same special "member initialization list syntax" used with composition and const data members.
    \bigbreak \noindent 
    When a derived class object is destroyed, the destructors are called in the reverse order of the constructors - first the derived class destructor is called, then the base class destructor is called.
    \bigbreak \noindent 
    \bigbreak \noindent 

    \subsection{Inheritance Syntax}
    \bigbreak \noindent 
    To declare a derived class:
    \bigbreak \noindent 
    \begin{cppcode}
        // car is a derived class of vehicle.
        class car : public vehicle
        {
            // Car data members and member functions
        };
    \end{cppcode}
    \bigbreak \noindent 
    A constructor initialization list can be used to pass arguments from a derived class constructor to a base class constructor:
    \bigbreak \noindent 
    \begin{cppcode}
        // Pass the string color to the base class vehicle constructor.
        car::car(const string& color, int num_doors) : vehicle(color)
        {
            this->num_doors = num_doors;
        }
    \end{cppcode}
    \bigbreak \noindent 
    A derived class member function that overrides a base class member function can call the base class version of the function to do part of its work:
    \begin{cppcode}
        void car::print() const
        {
            vehicle::print();   // Call the vehicle version of print() to print the car's color.
            cout << num_doors;
        }
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Upcasting and Downcasting}
    \bigbreak \noindent 
    \textbf{Upcasting} is converting a derived class pointer (or reference) to a pointer (or reference) of the derived class's base class. In other words, upcasting allows us to treat a derived type as though it were its base type. It is always allowed for public inheritance, without an explicit type cast. This is a result of the "is-a" relationship between the base and derived classes. For example, if car is a class derived from vehicle, the following code is legal:
    \bigbreak \noindent 
    \begin{cppcode}
        vehicle* vptr = new car();
    \end{cppcode}
    \bigbreak \noindent 
    The car object does not actually become a vehicle object as a result of this type cast (in a sense, it already is one). However, the vehicle pointer can only be used to access parts of the car object that are defined in the vehicle class. For example, you can only call member functions that are defined in the vehicle class. The car object is treated like any other vehicle, and its car-specific data members and member functions are unavailable.
    \bigbreak \noindent 
    \begin{cppcode}
        vehicle* vptr = (vehicle*) new car();
        vehicle* vptr = dynamic_cast<vehicle*>(new car()); // Using c++ casting
        vehicle* vptr = static_cast<vehicle*>(new car()); // Using c++ casting
    \end{cppcode}
    \bigbreak \noindent 
    The opposite process, converting a base class pointer (or reference) to a derived class pointer (or reference) is called \textbf{downcasting}. Downcasting is not allowed without an explicit type cast. The reason for this restriction is that the "is-a" relationship is not always symmetric. A car is a vehicle, but a vehicle may or may not be a car. For example:
    \bigbreak \noindent 
    \begin{cppcode}
        car c1;

        vehicle* vptr = &c1;          // Upcast - no type cast required.

        car* car_ptr = (car*) vptr;   // Downcast - type cast required.
    \end{cppcode}
    \bigbreak \noindent 
    The code shown above works, because the object pointed to by vptr actually is a car object. If it wasn't, the results could lead to an unsafe operation.
    \bigbreak \noindent 
    \begin{cppcode}
        bus b1;                       // Assume bus is also a derived class of vehicle.

        vehicle* vptr = &b1;          // Upcast - no type cast required.

        car* car_ptr = (car*) vptr;   // Downcast - type cast required. Fails because vptr
                                        // points to a bus, not a car.
    \end{cppcode}
    \bigbreak \noindent 
    C++ provides a special explicit cast called \textbf{dynamic\_cast} that allows for safe downcasting. If the type cast fails, it will return nullptr rather than crashing your program:
    \bigbreak \noindent 
    \begin{cppcode}
        car* carptr = dynamic_cast<car*>(vptr);
        if (carptr != nullptr)
        {
            // Type cast succeeded, vptr was pointing to a car object
            // Can now safely call car-specific member functions using carptr
        }
    \end{cppcode}
        \bigbreak \noindent 
    \subsection{More on Downcasting}
    \bigbreak \noindent 
    Downcasting is the process of converting a base class pointer or reference to a derived class pointer or reference
    \begin{itemize}
        \item Downcasting is potentially unsafe, so it requires an explicit cast.
        \item dynamic\_cast should be used for safe downcasting to check if the cast is valid at runtime.
        \item Downcasting typically requires polymorphic classes with virtual functions to enable dynamic\_cast.
    \end{itemize}

    \bigbreak \noindent 
    In C++, the dynamic\_cast operator, used for safe downcasting, requires that the base class has at least one virtual function. This is because dynamic\_cast relies on runtime type information (RTTI), which is only available for polymorphic classes.
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{RTTI Availability:}
            \begin{itemize}
                \item RTTI is used to store type information at runtime, which dynamic\_cast uses to determine the exact type of the object being cast.
                \item RTTI is only generated by the compiler for polymorphic classes, which are classes that have at least one virtual function.
            \end{itemize}
        \item \textbf{Polymorphic Behavior:} Virtual functions enable polymorphic behavior, allowing derived classes to override base class functions. This is the essence of polymorphism, which dynamic\_cast utilizes to ensure safe downcasting.
        \item \textbf{Checking Actual Type:} The type information stored in RTTI allows dynamic\_cast to check if the object being cast is indeed of the target derived type. If not, it returns nullptr (for pointers) or throws a std::bad\_cast exception (for references).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{What Happens Without Virtual Functions}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{No RTTI:} If the base class has no virtual functions, it is not polymorphic, and the compiler doesn't generate RTTI for it. Without RTTI, dynamic\_cast cannot validate types at runtime.
        \item \textbf{Compile-Time Error:} Attempting to use dynamic\_cast on a class without virtual functions will lead to a compile-time error indicating that the class type is not polymorphic.

    \end{itemize}

    \pagebreak 
    \subsubsection{Downcasting example}
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Base {
            public:
            virtual ~Base() = default; // Make the class polymorphic
        };

        class Derived1 : public Base {
            public:
            void func1() {
                std::cout << "Derived1 Function\n";
            }
        };

        class Derived2 : public Base {
            public:
            void func2() {
                std::cout << "Derived2 Function\n";
            }
        };

        int main() {
            // Case 1: Valid downcast, will not get nullptr
            Base* basePtr1 = new Derived1(); // Base pointer to Derived1
            Derived1* derived1Ptr = dynamic_cast<Derived1*>(basePtr1);
            if (derived1Ptr) {
                derived1Ptr->func1(); // This will execute correctly
            } else {
                std::cout << "Downcast to Derived1 failed\n";
            }

            // Case 2: Invalid downcast, will get nullptr
            Base* basePtr2 = new Derived2(); // Base pointer to Derived2
            Derived1* derived1PtrInvalid = dynamic_cast<Derived1*>(basePtr2);
            if (derived1PtrInvalid) {
                derived1PtrInvalid->func1(); // This will not execute
            } else {
                std::cout << "Downcast to Derived1 failed\n"; // This will be printed
            }

            // Clean up
            delete basePtr1;
            delete basePtr2;

            return 0;
        }
    \end{cppcode}

    \pagebreak 
    \nt{When a Base* points to a Base object and we attempt to downcast it to a derived type using dynamic\_cast, the cast will fail and return nullptr. This is because the actual type of the object being pointed to is Base, not the derived type.}

    \bigbreak \noindent 
    \subsubsection{Base class pointer example}
    \bigbreak \noindent 
    \begin{cppcode}
class base {

public:
    virtual void print() const {
        cout << "Base class" << endl;
    }

};


class derived : public base {
    void print() const override {
        cout << "Child class" << endl;
    }
};


int main(int argc, char* argv[]) {

    base* bptr = new derived();

    bptr->print(); // Child class
    bptr->base::print(); // Base class

    return EXIT_SUCCESS;
}
    \end{cppcode}
    \bigbreak \noindent 
    \nt{Notice we are able to call the private method, this is because the virtual function mechanism directs the call to the most derived method.}

    \bigbreak \noindent 
    \subsection{Object Slicing}
    \bigbreak \noindent 
    Object slicing occurs when a derived class object is assigned or copied to a base class object, causing the derived class's specific members to be "sliced off."
    \bigbreak \noindent 
    \begin{cppcode}
    base b1 = base();
    derived d1 = derived();

    b1 = d1; // Slicing
    d1 = b1; // Does not work
    \end{cppcode}

        \pagebreak 
    \subsection{Multiple Inheritance}
    \bigbreak \noindent 
    Multiple inheritance is a feature in C++ that allows a derived class to inherit from more than one base class.
    \bigbreak \noindent 
    \subsubsection{Why Use Multiple Inheritance?}
    \begin{itemize}
        \item \textbf{Combining Functionality:} When a derived class needs to combine the functionalities of multiple base classes.
        \item \textbf{Mixins:} Allows implementing mixins, which are small base classes that provide specific functionalities to derived classes.
        \item \textbf{Interface Implementation:} Multiple inheritance can also be used to implement interfaces (abstract base classes) in C++.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
#include <iostream>

class Base1 {
public:
    void func1() {
        std::cout << "Base1 Function" << std::endl;
    }
};

class Base2 {
public:
    void func2() {
        std::cout << "Base2 Function" << std::endl;
    }
};

class Derived : public Base1, public Base2 {
    // Derived class inherits from both Base1 and Base2
public:
    void func3() {
        std::cout << "Derived Function" << std::endl;
    }
};

int main() {
    Derived d;
    d.func1(); // Inherited from Base1
    d.func2(); // Inherited from Base2
    d.func3(); // Own function

    return 0;
}
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Issues with Multiple Inheritance}
    \begin{enumerate}
        \item \textbf{Ambiguity:}
        \begin{itemize}
            \item If two base classes have the same method or attribute name, calling it from the derived class can cause ambiguity.
            \item This can be resolved using the scope resolution operator :: to specify which base class method to call.
        \end{itemize}
    \item \textbf{Diamond Problem:}
        \begin{itemize}
            \item If two base classes inherit from the same class and a derived class inherits from both base classes, it leads to ambiguity in the derived class about which base class's implementation to use.
            \item This can be addressed using virtual inheritance to ensure only one copy of the shared base class exists.
        \end{itemize}
    \end{enumerate}
    \pagebreak 
    \subsection{Virtual inheritance}
    \bigbreak \noindent 
    Virtual inheritance in C++ is a mechanism to prevent multiple "copies" of a base class when using multiple inheritance. It ensures that the derived class has only one shared instance of the base class, thus preventing ambiguity and redundant base class objects.
    \bigbreak \noindent 
    \subsubsection{The Diamond Problem}
    \bigbreak \noindent 
    The diamond problem occurs when two classes inherit from the same base class and another class inherits from those two classes. This results in ambiguity and multiple copies of the shared base class.
    \bigbreak \noindent 
    \begin{cppcode}
        #include <iostream>

        class Base {
            public:
            int data;
            Base() : data(0) {}
        };

        class Derived1 : public Base {};

        class Derived2 : public Base {};

        class FinalDerived : public Derived1, public Derived2 {};

        int main() {
            FinalDerived obj;

            // Error: Ambiguity, which Base::data to access?
            // obj.data = 10;
            // Explicit resolution:
            obj.Derived1::data = 10;
            obj.Derived2::data = 20;

            std::cout << obj.Derived1::data << ", " << obj.Derived2::data << std::endl;

            return 0;
        }
    \end{cppcode}
    \bigbreak \noindent 
    There are two separate instances of the Base class, one inherited through Derived1 and one through Derived2 This leads to ambiguity and multiple instances.
    \pagebreak 
    \subsubsection{Solution with Virtual Inheritance}
    \bigbreak \noindent 
    Virtual inheritance addresses this problem by ensuring that the shared base class is inherited virtually. This makes the derived class have a single, shared instance of the base class.
    \bigbreak \noindent 
    \begin{cppcode}
#include <iostream>
class Base {
public:
    int data;
    Base() : data(0) {}
};

class Derived1 : virtual public Base {};

class Derived2 : virtual public Base {};

class FinalDerived : public Derived1, public Derived2 {};

int main() {
    FinalDerived obj;

    // No ambiguity, only one instance of Base exists
    obj.data = 10;

    std::cout << obj.data << std::endl;

    return 0;
}
    \end{cppcode}


    \bigbreak \noindent 
    \subsection{Subtype Polymorphism}
    \bigbreak \noindent 
    The term binding means matching a function or member function call to a function or member function definition.
    \bigbreak \noindent 
    In C++, binding normally takes place when the program is compiled and linked. This is referred to as early binding or static binding.
    \bigbreak \noindent 
    In object-oriented programming, subtype polymorphism refers to the ability of objects belonging to different types to respond to member function calls of the same name, each one according to an appropriate type-specific behavior. The calling code does not have to know the exact type of the called object; which member function definition is called is determined at run-time (this is called late binding or dynamic binding).
    \bigbreak \noindent 
    In order for dynamic binding to take place in C++, several conditions must be met:
    \bigbreak \noindent 
    \begin{enumerate}
        \item The call must be to a member function, not a standalone function. Function calls in C++ always use static binding.
        \item The member function must have been declared using the keyword virtual. Calls to non-virtual member functions always use static binding.
        \item The member function must be called through a pointer or reference to an object, not an object name. All calls to member functions (including those to virtual member functions) through object names use static binding.
    \end{enumerate}
    \bigbreak \noindent 
    With dynamic binding, C++ distinguishes between a static type and a dynamic type of a variable. The static type is determined at compile time. It's the type specified in the pointer declaration. For example, the static type of vptr is vehicle*. However, the dynamic type of the pointer is determined by the type of object to which it actually points: car* in this case. When a virtual member function is called using vptr, C++ resolves the dynamic type of vptr and ensures that the appropriate version of the member function is invoked, a process referred to as virtual dispatch.
    \bigbreak \noindent 
    Dynamic binding exacts a toll. Resolving the dynamic type of an object takes place at runtime and therefore incurs performance overhead. However, this penalty is negligible in most cases.
    \bigbreak \noindent 
    One of the most common runtime techniques for implementing virtual dispatch is a virtual member function table, or v-table. A v-table is simply an array of pointers to member functions. Each class that contains virtual member functions has a v-table. Each object that is an instance of a class with virtual member functions contains, as a hidden field, a pointer to the class's v-table. The compiler encodes a member function call as an offset into a v-table, and the appropriate v-table is used with that offset at runtime to access the correct member function.
    \bigbreak \noindent 
    \subsection{Declaring Virtual Member Functions}
    \bigbreak \noindent 
    Declaring Virtual Member Functions
    \bigbreak \noindent 
    \begin{cppcode}
        virtual void print() const;
    \end{cppcode}
    \bigbreak \noindent 
    \nt{A member function in a derived class that overrides a virtual member function in a base class is automatically virtual as well.
        \bigbreak \noindent 
        Destructors may also be virtual. You should make the destructor for your class virtual if it contains any virtual member functions.
    }
    \bigbreak \noindent 
    In C++, when you overload a virtual function from a base class in a derived class, you do not necessarily need to mark the function in the derived class as virtual again for it to behave as a virtual function. It will still be virtual in any further derived classes. However, explicitly marking it as virtual in the derived class can improve code readability and make the class's design intentions clearer.
    \bigbreak \noindent 
    \subsubsection{The override keyword}
    \bigbreak \noindent 
    Using override: Instead of (or in addition to) marking functions as virtual in derived classes, C++11 introduced the override specifier. This ensures that the function is intended to override a virtual function in a base class. Using override helps catch errors at compile-time where the function signature does not match any virtual function in the base class, thus preventing unintended behavior.
    \bigbreak \noindent 
    \begin{cppcode}
        class Base {
            public:
            virtual void foo() { /* implementation */ }
        };

        class Derived : public Base {
            public:
            virtual void foo() override { /* new implementation */ }  // Using 'virtual' and 'override' for clarity
            void foo() override; // Better approach... no need for another virtual keyword
        };
        void Base::foo() {
            // Base class definition
        }
        void Derived::foo() {
            // Derived class definition
        }
    \end{cppcode}


    \bigbreak \noindent 
    \subsection{Abstract or Pure virtual Member Functions}
    \bigbreak \noindent 
    An abstract member function is a member function that has a special prototype, but no definition. C++ refers to abstract member functions as pure virtual member functions. The prototype for a pure virtual member function ends with = 0, like this:
    \bigbreak \noindent 
    \begin{cppcode}
        virtual void earnings() const = 0;
    \end{cppcode}
    \bigbreak \noindent 
    \nt{Since a pure virtual member function has no definition, you can't really call it. However, if a base class contains a pure virtual member function, a derived class is allowed to override the member function and provide a definition.}
    \bigbreak \noindent 
    \subsection{Abstract Classes}
    \bigbreak \noindent 
    A class that contains one or more pure virtual member functions is called an abstract class (as opposed to a concrete class that provides definitions for all of its member functions).
    \bigbreak \noindent 
    You cannot create an object of an abstract class. However, an abstract class can be used as a base class for inheritance purposes. A class derived from an abstract class must provide definitions for any pure virtual member functions that it inherits, or it is also an abstract class.
    \bigbreak \noindent 
    You can also declare a pointer (or a reference) of an abstract class type. Such a pointer (or reference) would typically be used to point to a derived class object.
    \bigbreak \noindent 
    \subsection{Interface Inheritance}
    \bigbreak \noindent 
    \textbf{Interface inheritance} allows a derived class to inherit a base class's data type (which can be useful for subtype polymorphism) without actually inheriting any of the base class's implementation (member function definitions, etc.).
    \bigbreak \noindent 
        An interface can be defined in C++ as an abstract class that contains only pure virtual member functions and symbolic constants (public data members that are static and const).






    \pagebreak 
    \unsect{<regex.h> Pattern Matching and String Validation}
    \bigbreak \noindent 
    \subsection{regcomp}
    \bigbreak \noindent 
    \begin{concept}
        Compiles a regular expression into a format that the \textbf{regexec()} function can use to perform pattern matching.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
       int regcomp(regex_t *preg, const char *regex, int cflags) 
    \end{cppcode}
    \begin{itemize}
        \item \textbf{preg:} A pointer to a regex\_t structure that will store the compiled regular expression.
        \item \textbf{regex:} The regular expression to compile.
        \item \textbf{cflags:} Compilation flags that modify the behavior of the compilation. Common flags include REG\_EXTENDED (use extended regular expression syntax), REG\_ICASE (ignore case in match), REG\_NOSUB (don't report the match), and REG\_NEWLINE (newline-sensitive matching).
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Return value}
    \bigbreak \noindent 
    Upon successful completion, the regcomp() function shall return 0. Otherwise, it shall return an integer value indicating an error as described in <regex.h>, and the content of preg is undefined.

    \bigbreak \noindent 
    \subsubsection{Return errors}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{REG\_NOMATCH}: regexec() failed to match.
        \item \textbf{REG\_BADPAT}: Invalid regular expression.
        \item \textbf{REG\_ECOLLATE}: Invalid collating element referenced.
        \item \textbf{REG\_ECTYPE}: Invalid character class type referenced.
        \item \textbf{REG\_EESCAPE}: Trailing '\textbackslash' in pattern.
        \item \textbf{REG\_ESUBREG}: Number in "\textbackslash digit" invalid or in error.
        \item \textbf{REG\_EBRACK}: "$[]$" imbalance.
        \item \textbf{REG\_EPAREN}: "\textbackslash(\textbackslash)" or "()" imbalance.
        \item \textbf{REG\_EBRACE}: "\textbackslash\{\textbackslash\}" imbalance.
        \item \textbf{REG\_BADBR}: Content of "\textbackslash\{\textbackslash\}" invalid: not a number, number too large, more than two numbers, first larger than second.
        \item \textbf{REG\_ERANGE}: Invalid endpoint in range expression.
        \item \textbf{REG\_ESPACE}: Out of memory.
        \item \textbf{REG\_BADRPT}: '?', '*', or '+' not preceded by valid regular expression.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Flags}
    \begin{itemize}
        \item \textbf{REG\_EXTENDED:} Enables the use of Extended Regular Expressions (ERE) rather than Basic Regular Expressions (BRE). EREs allow a broader set of regex features, such as more flexible quantifiers and additional metacharacters without needing to escape them.
        \item \textbf{REG\_ICASE:} Makes the pattern matching case-insensitive. This means that characters will match regardless of being in upper or lower case. For example, using REG\_ICASE, the pattern "a" would match both 'a' and 'A'.
        \item \textbf{REG\_NOSUB:} Disables the reporting of the position of matches. This flag is useful when you only need to know if a match occurred but not where it occurred. It can lead to performance improvements because the regex engine does not need to track and store the match positions.
        \item \textbf{REG\_NEWLINE:} Alters the handling of newline characters in the text. Specifically, it:
            \begin{itemize}
                \item Prevents the match from spanning multiple lines. The $\land$ and \$ metacharacters will match the start and end of the input string but not the start or end of a line within the string.
                \item Causes the dot . metacharacter to stop matching at a newline, which it normally would match.
                \item Treats newline characters in the input as a boundary that cannot be crossed by the quantifiers $*$, $+$, ?, and $\{n\}$ unless explicitly included in a character class.
            \end{itemize}
        \item \textbf{REG\_NOTBOL and REG\_NOTEOL:}
            \begin{itemize}
                \item \textbf{REG\_NOTBOL (Not Beginning Of Line):} Tells the regex engine that the beginning of the provided string should not be treated as the beginning of the line. This affects how the $\land$ anchor (which normally matches the start of the string) behaves. Use this if the string is a substring that does not start at the beginning of a new line.
                \item \textbf{REG\_NOTEOL (Not End Of Line):} Indicates that the end of the provided string should not be treated as the end of the line. This affects how the \$ anchor (which normally matches the end of the string) behaves. Use this if the string is a substring that does not end at the end of a line.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Regexec}
    \bigbreak \noindent 
    \begin{concept}
        After compiling a regular expression, we can use regexec to match against strings.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
         int regexec(const regex\_t *preg, const char *string, size\_t nmatch, regmatch\_t pmatch[], int eflags)
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{preg:} The compiled regular expression.
        \item \textbf{string:} The string to match against the regular expression.
        \item \textbf{nmatch:} The maximum number of matches and submatches to find.
        \item \textbf{pmatch:} An array of regmatch\_t structures that will hold the offsets of matches and submatches.
        \item \textbf{eflags:} Execution flags that modify the behavior of the match. A common flag is REG\_NOTBOL which indicates that the beginning of the specified string is not the beginning of a line.
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{Return value}
    \bigbreak \noindent 
    Upon successful completion, the regexec() function shall return 0. Otherwise, it shall return REG\_NOMATCH to indicate no match.

    \bigbreak \noindent 
    \subsection{Regerror}
    \bigbreak \noindent 
    \begin{concept}
        This function translates error codes from regcomp() and regexec() into human-readable messages.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
        size_t regerror(int errcode, const regex\_t *preg, char *errbuf, size\_t errbuf\_size)
    \end{cppcode}
    \begin{itemize}
        \item \textbf{errcode:} The error code returned by regcomp() or regexec().
        \item \textbf{preg:} The compiled regular expression (if the error is related to regexec()).
        \item \textbf{errbuf:} The buffer where the error message will be stored.
        \item \textbf{errbuf\_size:} The size of the buffer.
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Return value}
    \bigbreak \noindent 
    Upon successful completion, the regerror() function shall return the number of bytes needed to hold the entire generated string, including the null termination. If the return value is greater than errbuf\_size, the string returned in the buffer pointed to by errbuf has been truncated.

    \bigbreak \noindent 
    \subsection{Regfree}
    \bigbreak \noindent 
    \begin{concept}
        Frees the memory allocated to the compiled regular expression.
    \end{concept}
    \bigbreak \noindent 
    \subsubsection{Signature}
    \bigbreak \noindent 
    \begin{cppcode}
        void regfree(regex_t *preg)
    \end{cppcode}
    \begin{itemize}
        \item \textbf{preg:} The compiled regular expression to free.
    \end{itemize}
    \bigbreak \noindent 

    \pagebreak 
    \subsection{regmatch\_t and pmatch}
    \bigbreak \noindent 
    \subsubsection{regmatch\_t}
    \bigbreak \noindent 
    regmatch\_t is a structure used to describe a single match (or submatch) found by regexec(). It contains at least the following two fields:
    \begin{itemize}
        \item \textbf{rm\_eo:} This is the end offset of the match, which is one more than the index of the last character of the match. In other words, rm\_eo - rm\_so gives the length of the match.
        \item \textbf{rm\_so:} This is the start offset of the match, relative to the beginning of the string passed to regexec(). If the match is successful, rm\_so will be the index of the first character of the match.
    \end{itemize}
    \pagebreak 
    \subsubsection{pmatch array}
    \bigbreak \noindent 
    When you call regexec(), you can pass it an array of regmatch\_t structures as the pmatch argument. This array is where regexec() will store information about the matches (and submatches) it finds. The size of this array (nmatch) determines how many matches regexec() will look for and fill in. The zeroth element of this array corresponds to the entire pattern's match, and the subsequent elements correspond to parenthesized subexpressions (submatches) within the regular expression, in the order they appear.

    \bigbreak \noindent 
    \subsection{Regex Example}
    \bigbreak \noindent 
    \begin{cppcode}
        regex_t regex;
        int reti;
        char msgbuf[100];
        regmatch_t pmatch[1]; // Array to store the match positions
        const char* search = "abc";

        // Compile regular expression
        reti = regcomp(&regex, "^a[[:alnum:]]", REG_EXTENDED);
        if (reti) {
            fprintf(stderr, "Could not compile regex\n");
            exit(EXIT_FAILURE);
        }

        // Execute regular expression
        // Note: Changed the third argument to 1 to indicate we want to capture up to 1 match
        // and the fourth argument to pmatch to store the match position.
        reti = regexec(&regex, search, 1, pmatch, 0);
        if (!reti) {
            printf("Match\n");
            // If you want to use the match information, you can do so here.
            // For example, to print the start and end positions of the match:
            printf("Match at position %d to %d\n", (int)pmatch[0].rm_so, (int)pmatch[0].rm_eo - 1);
        }
        else if (reti == REG_NOMATCH) {
            printf("No match\n");
        }
        else {
            regerror(reti, &regex, msgbuf, sizeof(msgbuf));
            fprintf(stderr, "Regex match failed: %s\n", msgbuf);
            exit(EXIT_FAILURE);
        }regex_t regex;
    int reti;
    char msgbuf[100];
    regmatch_t pmatch[1]; // Array to store the match positions

    // Compile regular expression
    reti = regcomp(&regex, "^a[[:alnum:]]", REG_EXTENDED);
    if (reti) {
        fprintf(stderr, "Could not compile regex\n");
        exit(EXIT_FAILURE);
    }
    \end{cppcode}

    \pagebreak 
    \begin{cppcode}
    // Execute regular expression
    // Note: Changed the third argument to 1 to indicate we want to capture up to 1 match
    // and the fourth argument to pmatch to store the match position.
    reti = regexec(&regex, "abc", 1, pmatch, 0);
    if (!reti) {
        printf("Match\n");
        // If you want to use the match information, you can do so here.
        // For example, to print the start and end positions of the match:
        printf("Match at position %d to %d\n", (int)pmatch[0].rm_so, (int)pmatch[0].rm_eo - 1);
    }
    else if (reti == REG_NOMATCH) {
        printf("No match\n");
    }
    else {
        regerror(reti, &regex, msgbuf, sizeof(msgbuf));
        fprintf(stderr, "Regex match failed: %s\n", msgbuf);
        exit(EXIT_FAILURE);
    }

    // Free the compiled regular expression
    regfree(&regex);

        for (int i=(int)pmatch[0].rm_so; i<=(int)pmatch[0].rm_eo; ++i) {
            cout << search[i];
        }
        cout << endl;

        regfree(&regex);
    \end{cppcode}


    \pagebreak 
    \unsect{Structured bindings}
    \bigbreak \noindent 
    Structured bindings in C++ (introduced in C++17) allow you to unpack or "decompose" tuples, pairs, or other structured objects into separate variables in a concise way. This makes it easier to work with multiple return values or complex data structures.
    \bigbreak \noindent 
    \subsection{As unpacks}
    \bigbreak \noindent 
    \begin{cppcode}
        int arr[3] = {1,2,3};
        auto [x,y,z] = arr;

        cout << x << '\n' << y << '\n' << z;
        // 1
        // 2 
        // 3
    \end{cppcode}
    \bigbreak \noindent 
    This works for a number of containers
    \begin{itemize}
        \item std::Tuple
        \item std::Pairs
        \item Fixed-sized arrays
        \item std::Array
        \item Structs/Classes
    \end{itemize}

    \bigbreak \noindent 
    \subsection{With returning}
    \bigbreak \noindent 
    \begin{cppcode}
        std::pair<int,int> foo() {
            std::pair<int,int> p = {1,2};
            return p;
        }

        auto [a,b] = foo();
        cout << a << endl << b << endl;
        // 1
        // 2
    \end{cppcode}

    \pagebreak \bigbreak \noindent 
    \subsection{With structs and classes}
    \bigbreak \noindent 
    \begin{cppcode}
        struct foo {
            int x;
            int y;
            int z;
        };

        foo f1{1,2,3};

        auto [a,b,c] = f1;

        cout << a << endl << b << endl << c << endl;
        // 1
        // 2
        // 3
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{With maps}
    \bigbreak \noindent 
    Since we can unpack std::pairs, we can use structured bindings in map range-based loops
    \bigbreak \noindent 
    \begin{cppcode}
        map<int, int> a = {{0,1}, {1,2}};

        for (const auto& [key,value] : a) {
            cout << key << " " << value << endl;
        }
    \end{cppcode}

    \pagebreak 
    \unsect{Attributes in c++}
    \bigbreak \noindent 
    In C++, attributes are a way to provide additional information or hints to the compiler without affecting the actual logic of the program. They can be used to optimize the program, check for potential issues, or control specific aspects of how the compiler processes the code. Attributes are written inside double square brackets ([[ ... ]]) and can be attached to various elements of the code, such as functions, variables, types, and control structures
    \bigbreak \noindent 
    \begin{cppcode}
        [[attribute-name]]
        [[attribute-name(arg1, arg2, ...)]]
    \end{cppcode}
    \bigbreak \noindent 
    Attributes can be placed in various locations:
    \begin{itemize}
        \item Before a function or variable declaration
        \item Before a class or struct declaration
        \item In the middle of a function, such as on a statement in a switch case
    \end{itemize}

    \bigbreak \noindent 
    \subsection{General Attributes}
    \bigbreak \noindent 
    These attributes are part of the standard C++ specification and are supported across most modern compilers.
    \begin{itemize}
        \item \textbf{[[nodiscard]]:} Ensures that the return value of a function is not ignored.
            \bigbreak \noindent 
            \begin{cppcode}
                [[nodiscard]] int calculate() { return 42; }
                int main() {
                    calculate(); // Compiler warning: return value ignored
                }
            \end{cppcode}
        \item \textbf{[[deprecated]]:} Marks code elements like functions or variables as deprecated. Using them will generate a warning, helping to phase out old or unsafe functionality.
            \bigbreak \noindent 
            \begin{cppcode}
                [[deprecated("Use newFunction() instead")]]
                void oldFunction() {}
            \end{cppcode}
        \item \textbf{[[maybe\_unused]]:} Suppresses compiler warnings for unused variables or parameters, often useful in code that will vary between different builds (e.g., debug vs release builds)
            \begin{cppcode}
                void fn([[maybe\_unused]] int a);
                [[maybe\_unused]] int x = 5;
            \end{cppcode}
        \item \textbf{[[fallthrough]]}: Used in switch statements to indicate that a case is intentionally falling through to the next one, preventing warnings from the compiler in such cases.
            \bigbreak \noindent 
            \begin{cppcode}
                switch (value) {
                    case 1:
                        // Some code
                        [[fallthrough]];  // Intentional fallthrough to the next case
                    case 2:
                        // More code
                        break;
                }
            \end{cppcode}
        \item \textbf{[[likely]] and [[unlikely]]}: (since C++20): Provide hints to the compiler about the likelihood of branches in if or switch statements. These hints allow the compiler to optimize for the most likely or unlikely branches.
            \bigbreak \noindent 
            \begin{cppcode}
                if ([[likely]] condition) {
                    // Optimized assuming this is more likely
                }
            \end{cppcode}
        \item \textbf{[[alignas(n)]]:} Specifies the memory alignment for a variable or type. It ensures that the object is aligned on a boundary of n bytes.
            \bigbreak \noindent 
            \begin{cppcode}
                alignas(16) int alignedInt;  // Ensures the integer is aligned on a 16-byte boundary
            \end{cppcode}
        \item \textbf{[[no\_unique\_address]]}: (since C++20): Allows the compiler to optimize the memory layout of a class or struct by not requiring a unique address for certain members (e.g., empty classes).
            \bigbreak \noindent 
            \begin{cppcode}
                struct Empty {};
                struct S {
                    [[no_unique_address]] Empty e;
                    int x;
                };
            \end{cppcode}
        \item \textbf{[[noreturn]]:} Marks a function as one that will never return to the caller (e.g., functions that throw exceptions or terminate the program).
            \bigbreak \noindent 
            \begin{cppcode}
            [[noreturn]] void fatalError() {
                throw std::runtime_error("Critical error!");
            }
        \end{cppcode}
    \item \textbf{[[gnu::always\_inline]]:} Forces the compiler to inline the function, even when optimizations are disabled. This attribute is specific to certain compilers like GCC or Clang.
        \bigbreak \noindent 
        \begin{cppcode}
            [[gnu::always_inline]] void inlineFunction() {
                // The function will always be inlined
            }

            \end{cppcode}
        \item \textbf{[[gnu::pure]]:} Marks a function as "pure," meaning its return value depends only on its parameters and has no side effects, allowing the compiler to perform certain optimizations.
            \bigbreak \noindent 
            \begin{cppcode}
                [[gnu::pure]] int square(int x) {
                    return x * x;
                }

            \end{cppcode}
    \end{itemize}

    \pagebreak 
    \unsect{Inline functions}
    \bigbreak \noindent 
    In C++, an inline function is a function where the compiler attempts to replace the function call with the actual function code itself (i.e., inline expansion) rather than generating a normal function call. The goal of inlining is to reduce the overhead of function calls, especially for small functions, and potentially improve performance.
    \bigbreak \noindent 
    However, inline is a request or hint to the compiler, not a command. The compiler may ignore the request to inline the function, particularly if the function is too complex or if it would increase the code size too much.
    \bigbreak \noindent 
    To declare a function as inline, you use the inline keyword in its declaration or definition:
    \bigbreak \noindent 
    \begin{cppcode}
        inline int add(int a, int b) {
            return a + b;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Consider the following example
    \bigbreak \noindent 
    \begin{cppcode}
        inline int square(int x) {
            return x * x;
        }

        int main() {
            int result = square(5);
        }
    \end{cppcode}
    \bigbreak \noindent 
    Without inline, the function call square(5) would generate assembly code that jumps to the function definition, executes it, and returns the result. With inline, the compiler might replace the square(5) call directly with 5 * 5 in the code, eliminating the need for a function call.

    \pagebreak 
    \unsect{Advanced iterator usage}
    \bigbreak \noindent 
    \subsection{base()}
    \bigbreak \noindent 
    The function base() is used when working with reverse iterators in C++. It converts a reverse iterator (i.e., one that iterates from the end of a container to the beginning) into a regular iterator that points to the corresponding element in the normal (forward) iteration sequence.
    \bigbreak \noindent 
    When you reverse iterate through a container (like a std::string or std::vector), the reverse iterator rbegin() points to the last element in the container, and as you increment it, it moves backward through the container. When you reach an element using the reverse iterator and want to switch back to normal (forward) iteration, you use the base() method. It returns a forward iterator that points just past the element that the reverse iterator refers to.

    \pagebreak 
    \unsect{Regular expressions in c++}
    \bigbreak \noindent 
    To use regex expressions, we include <regex>
    \bigbreak \noindent 
    \begin{cppcode}
    #include <regex>
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Basic components}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{std::regex:} Represents the regular expression pattern.
        \item \textbf{std::smatch:} Used for storing results of a match against a std::string.
        \item \textbf{std::regex\_match:} Tests whether an entire string matches the regex.
        \item \textbf{std::regex\_search:} Searches a string for any sequence matching the regex.
        \item \textbf{std::regex\_replace:} Replaces parts of a string that match the regex pattern.
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{The regex object}
    \bigbreak \noindent 
    The regex object is used to store a pattern.
    \bigbreak \noindent 
    \begin{cppcode}
        std::regex pattern("^\\w+$");
        std::regex pattern(R"(^\w+$)"); // With raw strings
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{The smatch array}
    \bigbreak \noindent 
    We can store captures in the smatch array
    \bigbreak \noindent 
    \begin{cppcode}
        string s = "     hello     ";
        regex pattern1(R"(\s*((\w)+)\s*)");
        regex pattern2(R"(\s*(\w+)\s*)"); // Does the same as pattern one
        smatch capture_space;

        // Strips leading and trailing spaces
        if (regex_match(s, capture_space, pattern1)) {
            cout << capture_space[1] << endl;
        }
    \end{cppcode}
    \bigbreak \noindent 
    capture\_space[0] is the entire string, capture\_space[1-n] are the captures 1-n. In the example above capture\_space[1] holds the trimmed string. We index with one because it is the first (and only) capture.

    \pagebreak 
    \subsubsection{regex\_match}
    \bigbreak \noindent 
    We can use the std::regex\_match function to match entire strings against a defined pattern, like we did in the example above. Returns true if the string was matched, false otherwise.
    \bigbreak \noindent 
    \begin{cppcode}
        bool regex_match(const string& s, smatch& capture_space, const regex& pattern);
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{regex\_search}
    \bigbreak \noindent 
    Searches a string for any match of a regular expression pattern. Unlike regex\_match, it doesn't require the entire string to match the pattern, just a part of it.
    \bigbreak \noindent 
    \begin{cppcode}
        bool regex_search(const string& s, smatch& capture_space, const regex& pattern);
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
        std::string s = "abc123";
        std::regex pattern("\\d+");
        std::smatch match;

        if (std::regex_search(s, match, pattern)) {
            std::cout << "Found match: " << match.str() << '\n';
        }
    \end{cppcode}
    \bigbreak \noindent 
    Note that we can always use regex\_match in places where regex\_search is required. Consider the pattern from the example above
    \bigbreak \noindent 
    \begin{cppcode}
        std::string s = "abc123";
        std::regex pattern("\\d+"); // Suitable  for regex_search
        std::regex pattern(".*\\d+.*"); // Suitable  for regex_match
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{Note:} Note that regex\_search will put only the first matching part in the smatch array. For example
    \bigbreak \noindent 
    \begin{cppcode}
        string s = "key1=value1 key2=value2 key3=value3";
        smatch capture_space;

        if (regex_search(s, capture_space, regex(R"(\s*(\w+)=(\w+)\s*)"))) {
            for (const auto& item : capture_space) {
                cout << item << endl;
            }
        }
        /* Outputs: 
            key1=value1 
            key1
            value1
        */
    \end{cppcode}
    

    \pagebreak 
    \subsubsection{regex\_replace}
    \bigbreak \noindent 
    Replaces occurrences of a pattern in a string with a specified replacement string.
    \bigbreak \noindent 
    \begin{cppcode}
        std::string regex_replace(const string& s, const regex& pattern, const string& replacement) 
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{Note:} This function will not modify the original string, it always returns a new string. 

    \bigbreak \noindent 
    \subsection{match\_results}
    \bigbreak \noindent 
    std::match\_results is a template class in C++ that holds the results of a regular expression match operation, such as those produced by std::regex\_search or std::regex\_match. It is typically used with std::smatch (for std::string matches) or std::cmatch (for C-style string matches).
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{std::smatch:} A typedef for \texttt{std::match\_results<std::string::const\_iterator>}.
        \item \textbf{std::cmatch:} A typedef for \texttt{std::match\_results<const char*>}.
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Methods}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{str():} Returns the matched string or a submatch as a \texttt{std::string}.
        \item \textbf{size():} Returns the number of matches (main match + submatches).
        \item \textbf{position():} Returns the position in the input string where the match begins.
        \item \textbf{length():} Returns the length of the match.
        \item \textbf{operator[]:} Access individual submatches via index.
        \item \textbf{prefix():} Returns the part of the input string that precedes the match as a \texttt{sub\_match} object.
        \item \textbf{suffix():} Returns the part of the input string that follows the match as a \texttt{sub\_match} object.
        \item \textbf{empty():} Checks if the match was successful (returns \texttt{true} if no match was found).
        \item \textbf{ready():} Checks if the \texttt{match\_results} object is ready and valid for use after a regex search.
        \item \textbf{format():} Returns the formatted string based on the matched results using a specified format string.
        \item \textbf{begin():} Returns an iterator to the first submatch (constant iterator).
        \item \textbf{end():} Returns an iterator past the last submatch (constant iterator).
    \end{itemize}

    \pagebreak 
    \subsection{sub\_match}
    \bigbreak \noindent 
    \texttt{std::sub\_match} is a class template that represents a single match or submatch from a regular expression search. It typically stores a reference to the portion of the input string that matched a particular capture group.
    \bigbreak \noindent 
    It behaves like a \texttt{std::pair<BidirectionalIterator, BidirectionalIterator>}, storing the start and end iterators of the matched range.
    \bigbreak \noindent 
    You can access the matched string using the str() method.
    \bigbreak \noindent 
    It supports comparison operators (==, !=) and conversion to std::string.
    \bigbreak \noindent 
    It is often used with \texttt{std::match\_results} to represent the main match or submatches (captured groups).
    \bigbreak \noindent 
    \begin{cppcode}
        string s = "key1=value1 key2=value2 key3=value3";

        smatch capture_space;
        string::const_iterator curr = s.begin();

        if (regex_search(curr, s.cend(), capture_space, regex(R"(\s*(\w+)=(\w+)\s*)"))) {
            cout << capture_space[1] << endl; // key1

            std::sub_match<string::const_iterator> sm = capture_space[1];
            cout << *sm.first << endl << *sm.second << endl; 
            // k
            // =
        }
    \end{cppcode}

    \pagebreak 
    \subsection{Passing string iterators}
    \bigbreak \noindent 
    We can also pass iterators to the regex functions.
    \bigbreak \noindent 
    \begin{cppcode}
        string s = "key1=value1 key2=value2 key3=value3";
        smatch capture_space;
        string::const_iterator curr = s.begin();

        if (regex_search(s, capture_space, regex(R"(\s*(\w+)=(\w+)\s*)"))) {
            for (const auto& item : capture_space) {
                cout << item << endl;
            }
        }
    \end{cppcode}
    \bigbreak \noindent 
    \textbf{Note:} The string iterators passed must be constant.
    \bigbreak \noindent 
    \subsubsection{Getting all matches}
    \bigbreak \noindent 
    To get all matches, we can search in a loop, updating our start iterator after each match. For example
    \bigbreak \noindent 
    \begin{cppcode}
        string s = "key1=value1 key2=value2 key3=value3";

        smatch capture_space;
        string::const_iterator curr = s.begin();
        while (regex_search(curr, s.cend(), capture_space, regex(R"(\s*(\w+)=(\w+)\s*)"))) {
            cout << "key: " << capture_space[1] << '\n' << "value: " << capture_space[2] << '\n';

            sub_match<string::const_iterator> sm = capture_space[2];
            curr = sm.second;

            */ 
                key: key1
                value: value1
                key: key2
                value: value2
                key: key3
                value: value3
            */
        }
    \end{cppcode}
    \bigbreak \noindent 
    The sub match object we created captures the second match group (the value) into a std::sub\_match object. The std::sub\_match object provides the iterators (.first and .second) that point to the start and end of the matched portion of the string.
    \bigbreak \noindent 
    The iterator \texttt{sm.second} points to the first character after the matched value. By setting \texttt{curr = sm.second}, we move the search position forward, skipping over the current match so that the next iteration of regex\_search starts searching after the last key=value pair.

    \pagebreak 
    \subsection{smatch prefix and suffix}
    \bigbreak \noindent 
    Consider the code
    \bigbreak \noindent 
    \begin{cppcode}
        string s = "key1=value1 key2=value2 key3=value3";

        smatch capture_space;
        string::const_iterator curr = s.begin();
        if (regex_search(curr, s.cend(), capture_space, regex(R"(\s*(\w+)=(\w+)\s*)"))) {
            for (const auto& item : capture_space) {
                cout << "capture space item : " << item << endl;
            }

            cout << "prefix first: " << *capture_space.prefix().first << endl;
            cout << "prefix second: " << *capture_space.prefix().second << endl;

            cout << "Suffix first: " << *capture_space.suffix().first << endl;
            cout << "Suffix second: " << *(capture_space.suffix().second - 1) << endl;

            /*
                capture space item : key1=value1 
                capture space item : key1
                capture space item : value1
                prefix first: k
                prefix second: k
                Suffix first: k
                Suffix second:
            */
        }
    \end{cppcode}
    \bigbreak \noindent 
    The prefix() and suffix() methods in std::smatch provide access to the parts of the string outside of the matched portion:
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{prefix():} Returns a std::sub\_match object that represents the part of the string before the match.
        \item \textbf{suffix():} Returns a std::sub\_match object that represents the part of the string after the match.
    \end{itemize}
    \bigbreak \noindent 
    In the code above:
    \begin{itemize}
        \item \textbf{prefix().first:} Points to the first character before the match (which is the first character of the string, 'k'), since the match starts at the beginning of the string.
        \item \textbf{prefix().second:} Points to the same location as .first, which is the beginning of the string. This is why both prefix first and prefix second are printing 'k'.
    \end{itemize}
    Because there is no actual prefix in this case, both prefix().first and prefix().second are equal to the first character of the string.
    \begin{itemize}
        \item \textbf{suffix()} refers to the part of the string after the match. In this case, the match is "key1=value1", so the suffix is everything after that: " key2=value2 key3=value3".
        \item \textbf{suffix().first:} Points to the first character after the match, which is the space between "key1=value1" and "key2=value2". The character it points to is ' ' (a space), but since spaces are sometimes not visible in output, it is displaying the next visible character, which is 'k', from "key2=value2".
        \item \textbf{suffix().second:} Points to the end of the string, so dereferencing it is undefined behavior. In this case, the output doesn't display a value for suffix().second because it points to the end of the string, and dereferencing an iterator at the end is unsafe.
    \end{itemize}
    \bigbreak \noindent 
    Let's consider the code example above, where we used a while loop and sub\_match objects to get all matches in a string. Instead of using
    \bigbreak \noindent 
    \begin{cppcode}
    sub_match<string::const_iterator> sm = capture_space[2];
    curr = sm.second;
    \end{cppcode}
    \bigbreak \noindent 
    To update the curr iterator, let's use suffix.
    \bigbreak \noindent 
    \begin{cppcode}
        string s = "key1=value1 key2=value2 key3=value3";

        smatch capture_space;
        string::const_iterator curr = s.begin();
        while (regex_search(curr, s.cend(), capture_space, regex(R"(\s*(\w+)=(\w+)\s*)"))) {
            cout << "key: " << capture_space[1] << '\n' << "value: " << capture_space[2] << '\n';

            curr = capture_space.suffix().first;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Generates the same output
    \bigbreak \noindent 
    \begin{cppcode}
        key: key1
        value: value1
        key: key2
        value: value2
        key: key3
        value: value3
    \end{cppcode}






    \pagebreak 
    \unsect{Standard namespace}
    \bigbreak \noindent 
    \subsection{std::bind}
    \bigbreak \noindent 
    \subsubsection{std::placeholders}
    \bigbreak \noindent 
    Before we get into std::bind, we must discuss std::placeholders
    \bigbreak \noindent 
    std::placeholders is a namespace in C++ that provides placeholder objects like std::placeholders::\_1, std::placeholders::\_2, and so on, which are used in conjunction with std::bind. These placeholders represent arguments that will be supplied when the resulting callable object (created by std::bind) is invoked.
    \bigbreak \noindent 
    Each placeholder corresponds to a positional argument that the function object will expect at the time of calling. For example:
    \begin{itemize}
        \item std::placeholders::\_1 represents the first argument.
        \item std::placeholders::\_2 represents the second argument, and so on.
    \end{itemize}

    \bigbreak \noindent 
    std::bind in C++ is used to create a function object (or a callable) by binding specific arguments to a function or member function, essentially "fixing" some of its arguments ahead of time. This allows the resulting function object to be called later with fewer arguments, as some are already provided.
    \bigbreak \noindent 
    \begin{cppcode}
        int add(int a, int b) {
            return a + b;
        }

        auto addtwo = std::bind(add, 2, std::placeholders::_1);
        cout << addtwo(4) << '\n'; // 6
    \end{cppcode}
    \bigbreak \noindent 
    Here, std::bind(add, 2, std::placeholders::\_1) binds 2 as the first argument of add, leaving the second argument to be provided later. The placeholder \_1 indicates where future arguments should be inserted.

    \pagebreak 
    \subsubsection{Using std::ref with bind}
    \bigbreak \noindent 
    std::ref is a utility in C++ that allows you to create reference wrappers for objects. It's commonly used when you need to pass objects by reference to functions that usually take arguments by value, such as when using function objects or lambdas with standard algorithms (like std::for\_each or std::thread).
    \bigbreak \noindent 
    It provides a way to pass a reference to an object where an argument would otherwise be copied.
    \bigbreak \noindent 
    It’s especially useful when the function you're working with doesn’t explicitly accept references but you want to pass one anyway.
    \bigbreak \noindent 
    \begin{cppcode}
        void add(int& a) {
            ++a;
        }

        int local = 0;

        auto f = std::bind(add, local);
        f();
        f();
        cout << local << endl; // Outputs zero

        auto f = std::bind(add, std::ref(local)); // Outputs two
        f();
        f();
        cout << local << endl;
    \end{cppcode}

    \bigbreak \noindent 
    \textbf{Note:} std::ref makes a std::reference\_wrapper<Type>...
    \bigbreak \noindent 
    \begin{cppcode}
        int local = 0;
        std::reference_wrapper<int> rlocal = local; 

        auto f = std::bind(add, rlocal); // Outputs two
    \end{cppcode}

     \pagebreak 
     \subsection{std::invoke}
     \bigbreak \noindent 
     std::invoke is a utility function in C++ (introduced in C++17) that allows you to invoke a callable object in a uniform way, regardless of whether the callable is a regular function, a member function, or a function object (like a lambda or std::function). The main benefit of std::invoke is that it simplifies calling different types of callable objects without needing to worry about the specific calling syntax.
     \bigbreak \noindent 
     \begin{cppcode}
         template< class F, class... Args >
         decltype(auto) invoke(F&& f, Args&&... args);
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Calling a regular function}
     \bigbreak \noindent 
     \begin{cppcode}
         int add(int a, int b) {
             return a + b;
         }

         int result = std::invoke(add, 2, 3);  // Calls add(2, 3)
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Calling a member function}
     \bigbreak \noindent 
     \begin{cppcode}
         struct MyClass {
             int multiply(int x) { return x * 2; }
         };

         MyClass obj;
         int result = std::invoke(&MyClass::multiply, obj, 5);  // Calls obj.multiply(5)
     \end{cppcode}
     \pagebreak \bigbreak \noindent 
     \subsubsection{Accessing a member variable}
     \bigbreak \noindent 
     \begin{cppcode}
         struct MyClass {
             int value;
         };

         MyClass obj{42};
         int value = std::invoke(&MyClass::value, obj);  // Accesses obj.value
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{Calling a lambda}
     \bigbreak \noindent 
     \begin{cppcode}
         auto lambda = [](int a, int b) { return a + b; };
         int result = std::invoke(lambda, 2, 3);  // Calls lambda(2, 3)
     \end{cppcode}

     \pagebreak 
     \subsection{std::exchange}
     \bigbreak \noindent 
     std::exchange is a utility function in the C++ Standard Library that is used to replace the value of an object with a new value and return the old value. This can be very handy for implementing things like move operations, resetting variables, or swapping values efficiently.
     \bigbreak \noindent 
     \begin{cppcode}
         template< class T, class U = T >
         T exchange( T& obj, U&& new_value );
     \end{cppcode}
     \bigbreak \noindent 
     It takes a reference to an object obj and replaces it with a new value new\_value. It returns the original value of the object before the replacement.
     \bigbreak \noindent 
     \begin{cppcode}
         int a = 5;
        int b = std::exchange(a, 10); // a becomes 10, b takes the old value of a, which was 5
     \end{cppcode}

     \pagebreak 
     \subsection{std::swap}
     \bigbreak \noindent 
     Swap exchanges the values of two objects
     \bigbreak \noindent 
     \begin{cppcode}
         template< class T >
         void swap( T& a, T& b );
     \end{cppcode}
     \bigbreak \noindent 
     \begin{cppcode}
     int x=5, y=10;
     std::swap(x,y);

     // Swaps the values of x and y
     \end{cppcode}

     \pagebreak 
     \subsection{std::get}
     \bigbreak \noindent 
     Allows access to elements from containers like std::tuple, std::pair, std::array, and std::variant either by index or type.
     \bigbreak \noindent 
     Tuple has no .at() method or subscript operator, so this utility function can be very useful to retrieve things from tuples.

     \bigbreak \noindent 
     \begin{cppcode}
         std::tuple<int, string> v{1, "abc"};

         cout << std::get<string>(v); // "abc"
         cout << std::get<1>(v); // "abc"
         cout << std::get<int>(v); // 1
         cout << std::get<0>(v); // 1
     \end{cppcode}

     \pagebreak 
     \subsection{std::tuple}
     \bigbreak \noindent 
     In C++, a tuple is a fixed-size collection of elements that can hold objects of different types. Tuples are part of the <tuple> header and can store an arbitrary number of values of varying types in a single object.
     \bigbreak \noindent 
     \subsubsection{std::tuple and std::make\_tuple}
     \bigbreak \noindent 
     You can create a tuple using std::tuple and std::make\_tuple
     \bigbreak \noindent 
     \begin{cppcode}
         std::tuple<int, float, string> t = std::make_tuple(1,1.0f, "hello");
     \end{cppcode}
     \bigbreak \noindent 
     As we saw above, we can retrieve elements in a tuple with std::get
     \bigbreak \noindent 
     \subsubsection{Modifying elements}
     \bigbreak \noindent 
     You can modify elements directly if the tuple is non-const
     \bigbreak \noindent 
     \begin{cppcode}
         std::tuple<int, float, string> t = std::make_tuple(1,1.0f, "hello");
         std::get<0> t = 12;
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{std::tuple\_size}
     \bigbreak \noindent 
     Use std::tuple\_size to get the number of elements
     \bigbreak \noindent 
     \begin{cppcode}
        std::tuple<int, float, string> t = std::make_tuple(1,1.0f, "hello");

        constexpr size_t tsize = std::tuple_size<tuple<int, float,string>>::value;
        constexpr size_t tsize2 = std::tuple_size<decltype(t)>::value;
     \end{cppcode}

     \pagebreak 
     \subsubsection{Unpacking with std::tie}
     \bigbreak \noindent 
     We can unpack tuple elements into variables using std::tie:
     \bigbreak \noindent 
     \begin{cppcode}
        std::tuple<int, float, string> t = std::make_tuple(1,1.0f, "hello");

        int x; float y; string z;
        std::tie(x,y,z) = t;
     \end{cppcode}
     \bigbreak \noindent 
     \textbf{Note:} std::tie requires existing variables to tie to the elements of the tuple. std::tie doesn't create new variables; it binds existing ones to the values in the tuple.

     \bigbreak \noindent 
     \subsubsection{std::tie with std::ignore}
     \bigbreak \noindent 
     If you don’t need all the values from the tuple or pair, you can use std::ignore to ignore specific elements.
     \bigbreak \noindent 
     \begin{cppcode}
         std::tuple<int, float, string> t = std::make_tuple(1,1.0f, "hello");

         int x; [[maybe_unused]] float y; string z;
         std::tie(x,std::ignore,z) = t;
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{std::optional <optional>}
     \bigbreak \noindent 
     std::optional (introduced in C++17) is a utility that represents an optional value—a value that may or may not be present. It provides a safer and clearer alternative to using raw pointers or special values like nullptr or -1 for optional semantics.
     \bigbreak \noindent 
     Either contains a value or is empty (no value).
     \bigbreak \noindent 
     Useful Methods:
     \begin{itemize}
         \item std::optional<T>::has\_value() – Checks if a value is present.
         \item std::optional<T>::value() – Accesses the contained value (throws if empty).
         \item std::optional<T>::value\_or(default\_value) – Returns the value or a default if empty.
     \end{itemize}
     \bigbreak \noindent 
     Once set, it behaves like a \texttt{T}.
     \bigbreak \noindent 
     \begin{cppcode}
         std::optional<int> divide(int a, int b) {
             if (b == 0) return std::nullopt; // No value
             return a / b; // Contains a value
         }
         auto x = f(10,0);
         // We get "undefined", since b is zero and nullopt is returned
         if (x.has_value()) cout << x.value() << endl;
         else cout << "undefined" << endl;
         cout << x.value_or(-1); // -1
     \end{cppcode}
     \bigbreak \noindent 
     std::nullopt is a constant of type std::nullopt\_t. Used to indicate that an std::optional does not contain a value.

     \bigbreak \noindent 
     \subsubsection{std::expected <expected>}
     \bigbreak \noindent 
     std::expected<T, E> (introduced in C++23) is a monadic type that represents either a successfully computed value (T) or an error (E). It is useful for error handling without exceptions.
     \bigbreak \noindent 
     \begin{itemize}
         \item \textbf{Success Case:} Holds a value of type T, accessible via .value() or the dereference operator *.
         \item \textbf{Error Case:} Holds an error of type E, accessible via .error().
         \item \textbf{Check Status:} Use .has\_value() to determine if it contains a valid result.
         \item \textbf{Comparison with std::optional:} Unlike std::optional<T>, which only distinguishes between presence or absence of a value, std::expected<T, E> explicitly represents an error.
     \end{itemize}

     \bigbreak \noindent 
     \begin{cppcode}
         std::expected<int, string> f2(int a, int b) {
             if (b == 0) return std::unexpected("Cannot divide by zero");
             return a/b;
         }
         auto x = f2(10,0);
         // Outputs "cannot divide by zero"
         if (x.has_value()) {
             cout << x.value() << endl;
         } else {
             cout << x.error() << endl;
         }
     \end{cppcode}

     \bigbreak \noindent 
     \subsubsection{std::format <format>}
     \bigbreak \noindent 
     std::format (from <format>) provides a Python-like string formatting mechanism
     \bigbreak \noindent 
     \begin{cppcode}
         int age = 21;
         std::string name = "Nate";

         std::string message = std::format("Hello, {}! You are {} years old.", name, age);
     \end{cppcode}

     \bigbreak \noindent 
     \subsection{std::bitset <bitset>}
     \bigbreak \noindent 
     A bitset in C++ (std::bitset) is a fixed-size sequence of bits (0s and 1s). It provides a way to store and manipulate binary data efficiently, offering operations similar to those in bitwise manipulation.
     \begin{itemize}
         \item \textbf{Fixed-size:} The size of a bitset must be known at compile-time.
         \item \textbf{Efficient storage:} Stores bits compactly.
         \item \textbf{Bitwise operations:} Supports operations like AND (\&), OR (|), XOR ($^{\land}$), shifting (<<, >>).
         \item \textbf{Access and manipulation:} Allows access to individual bits using indexing.
     \end{itemize}
     \bigbreak \noindent 
     \subsubsection{Operations on bitset}
     \bigbreak \noindent 
     Setting, Resetting, and Flipping Bits
     \bigbreak \noindent 
     \begin{cppcode}
         std::bitset<8> b("00001111"); 

         b.set(5);    // Sets bit at index 5 (0-based) to 1
         b.reset(3);  // Resets bit at index 3 to 0
         b.flip(2);   // Flips bit at index 2 (1 → 0, 0 → 1)
         b.flip();    // Flips all bits

         std::cout << b << "\n";
     \end{cppcode}
     \bigbreak \noindent 
     Accessing Bits
     \bigbreak \noindent 
     \begin{cppcode}
         std::bitset<8> b("11001010");
         std::cout << "Bit at index 2: " << b[2] << "\n"; // Output: 0
     \end{cppcode}
     \bigbreak \noindent 
     Count Operations
     \bigbreak \noindent 
     \begin{cppcode}
         std::bitset<8> b("10101010");
         std::cout << "Number of set bits: " << b.count() << "\n";      // 4
         std::cout << "Total bits: " << b.size() << "\n";               // 8
         std::cout << "Is any bit set? " << b.any() << "\n";            // true
         std::cout << "Are all bits set? " << b.all() << "\n";          // false
         std::cout << "Are all bits zero? " << b.none() << "\n";        // false
     \end{cppcode}
     \bigbreak \noindent 
     Conversion to Other Types
     \bigbreak \noindent 
     \begin{cppcode}
         std::bitset<8> b("1101");

         unsigned long num = b.to_ulong();  // Convert to unsigned long
         std::cout << "Decimal: " << num << "\n";  // 13

         std::string str = b.to_string();  // Convert to string
         std::cout << "String: " << str << "\n";  // 00001101
     \end{cppcode}
     \bigbreak \noindent 
     Bitwise Shift Operations
     \bigbreak \noindent 
     \begin{cppcode}
         std::bitset<8> b("00001111");

         std::cout << "Left shift by 2: " << (b << 2) << "\n";  // 00111100
         std::cout << "Right shift by 2: " << (b >> 2) << "\n"; // 00000011
     \end{cppcode}



     \pagebreak 
     \unsect{Views and Ranges}
     \bigbreak \noindent 
     \subsection{Views}
     \bigbreak \noindent 
     A view is a lightweight, non-owning adaptor in the C++20 Ranges library that lazily transforms, filters, or otherwise manipulates a range without creating a new container. Views enable the efficient and expressive processing of data using pipelines.
     \begin{itemize}
         \item \textbf{Non-Owning:}: A view does not own the underlying data. It operates on a range or another view.
         \item \textbf{Lazy Evaluation:} Computations are deferred until the elements are accessed, which improves performance by avoiding unnecessary computations.
         \item \textbf{Composable:} Views can be chained together using the | operator, creating expressive pipelines.
         \item \textbf{Efficient}: Since views are non-owning and lazy, they avoid copying or storing intermediate results, minimizing memory overhead.
     \end{itemize}
     \bigbreak \noindent 
     Views are built on the concept of range adaptors, which modify or filter ranges. For example:
     \begin{itemize}
         \item \textbf{std::ranges::views::filter:} Filters elements based on a predicate.
         \item \textbf{std::ranges::views::transform:} Transforms elements using a function.
     \end{itemize}
     \bigbreak \noindent 
     \subsubsection{Filter and transform}
     \begin{cppcode}
         #include <ranges>
         #include <vector>
         #include <iostream>

         int main() {
             std::vector<int> nums = {1, 2, 3, 4, 5, 6};

             auto evens = nums | std::ranges::views::filter([](int n) { return n % 2 == 0; });

                 for (int n : evens) {
                     std::cout << n << " "; // Output: 2 4 6
                 }
             }
         \end{cppcode}
         \bigbreak \noindent 
         \begin{cppcode}
         auto squares = nums | std::ranges::views::transform([](int n) { return n * n; });
         \end{cppcode}
         \bigbreak \noindent 
         We can also combine views
         \bigbreak \noindent 
         \begin{cppcode}
             auto evens_squared = v | filter([](int n) { return !(n % 2); }) | transform([](int n) {return n*n;});
         \end{cppcode}


         \bigbreak \noindent 
         \subsubsection{Iota}
         \bigbreak \noindent 
         std::ranges::views::iota Generates a sequence of numbers.
         \bigbreak \noindent 
         \begin{cppcode}
         auto numbers = std::ranges::views::iota(1, 10); // [1, 2, ..., 9]

         for (auto i : std::ranges::views::iota(1,10)) cout << i << " ";
         \end{cppcode}

         \bigbreak \noindent 
         \subsubsection{Take and drop}
         \bigbreak \noindent 
         \begin{itemize}
             \item \textbf{std::ranges::views::take:} Takes the first $n $ elements from a range.
            \item \textbf{std::ranges::views::drop:} Drops the first n elements from a range.
         \end{itemize}
         \bigbreak \noindent 
         \begin{cppcode}
             auto firstThree = numbers | std::ranges::views::take(3); // [1, 2, 3]
             auto afterThree = numbers | std::ranges::views::drop(3); // [4, 5, ...]
         \end{cppcode}

         \bigbreak \noindent 
         \subsection{The ranges library}
         \bigbreak \noindent 
         The ranges library is an extension and generalization of the algorithms and iterator libraries that makes them more powerful by making them composable and less error-prone.
         \bigbreak \noindent 
         The library creates and manipulates range views, lightweight objects that indirectly represent iterable sequences (ranges).

         \bigbreak \noindent 
         \subsection{std::span}
         \bigbreak \noindent 
         std::span is a lightweight, non-owning view of a contiguous sequence of elements. Introduced in C++20, it provides a way to access and manipulate arrays, std::vectors, or other contiguous containers without copying or transferring ownership of the data.
         \bigbreak \noindent 
         \begin{cppcode}
             int arr[] = {1,2,3,4};
             std::span<int> sp(arr);

             for (const auto& item : sp) cout << item;

             vector<int> v{1,2,3,4};
             std::span<int> sp(v.data(),3); // First three elements

             for (const auto& item : sp) cout << item;
         \end{cppcode}

         \bigbreak \noindent 
         \begin{cppcode}
             vector<int> v{1,2,3,4,5};

             std::span<int> sp(v.data(),3);

             cout << sp[0] << endl;
             sp[0] = 5;

             cout << "Observing v:" << endl;
             for (const auto& item : v) cout << item << " ";
             cout << endl << endl;

             cout << "Observing span:" << endl;
             for (const auto& item : sp) cout << item << " ";

             /*
             1
             Observing v:
             5 10 3 4 5 

             Observing span:
             5 10 3 ⏎
             */
         \end{cppcode}
         \bigbreak \noindent 
         Notice that when we change an element of $sp$, that same element of $v$ gets changed, and when we change an element of $v$, that same element of $sp$ gets changed. 

         \bigbreak \noindent 
         \subsubsection{What does it mean to be "non-owning"}
         \bigbreak \noindent 
         when we say that std::span is "non-owning," we mean that it does not manage the lifetime of the objects it refers to. Instead, it provides a lightweight view over a contiguous sequence of elements in memory without copying or taking ownership of the data.
         \bigbreak \noindent 
         \begin{itemize}
             \item \textbf{No Memory Allocation or Deallocation:} std::span does not allocate or free memory—it merely observes an existing range of elements.
             \item \textbf{References Existing Data:} It simply stores a pointer to the first element and a size, allowing it to access a subset of an array, std::vector, or other contiguous memory.
             \item \textbf{Does Not Extend Lifetime:} If a std::span outlives the data it points to, it becomes dangling (undefined behavior), as it does not keep the underlying data alive.
             \item \textbf{Lightweight \& Cheap to Copy:} Since std::span only holds a pointer and a size, copying a std::span is as cheap as copying two integers, unlike std::vector, which involves deep copies of data.
         \end{itemize}

         \bigbreak \noindent 
         \subsubsection{subspans}
         \bigbreak \noindent 
         \begin{cppcode}
             int arr[] = {1, 2, 3, 4, 5};
             std::span<int> sp(arr, 5);
             auto sub = sp.subspan(1, 3); // Elements 1 to 3
         \end{cppcode}
         \bigbreak \noindent 
         \subsubsection{Key member functions}
         \begin{itemize}
             \item \textbf{.at()}
             \item \textbf{.size()}
             \item \textbf{.subspan()}
             \item \textbf{.data()}
         \end{itemize}




     \pagebreak 
     \unsect{constexpr, consteval, and constinit}
     \bigbreak \noindent 
     constexpr is a keyword introduced in C++11 and enhanced in later standards. It is used to indicate that the value of a variable, function, or object can be evaluated at compile time, provided all inputs and operations are also constant expressions. This helps in improving performance by allowing certain computations to be done during compilation rather than runtime.
     \begin{itemize}
         \item \textbf{Compile-Time Evaluation:} If possible, constexpr ensures computations are performed at compile time, resulting in faster execution.
         \item \textbf{Constants:} Variables declared as constexpr must be initialized with constant expressions.
         \item \textbf{Functions:} A constexpr function can be evaluated at compile time if called with constant arguments. It can also be called at runtime with non-constant arguments.
     \end{itemize}
     \bigbreak \noindent 
     \begin{cppcode}
         constexpr int x = 5; // Compile-time constant
         constexpr int square(int n) { return n * n; }

         constexpr int result = square(4); // Evaluated at compile time
     \end{cppcode}
     \bigbreak \noindent 
     \begin{cppcode}
     constexpr int factorial(int n) {
         return (n <= 1) ? 1 : n * factorial(n - 1);
     }

     constexpr int result = factorial(5); // Computed at compile time
 \end{cppcode}
 \bigbreak \noindent 
If result is not declared as constexpr, it would simply be a regular, non-constant integer variable. The compiler would still attempt to evaluate the factorial(5) call at compile time if the inputs and the function itself meet the requirements for a constexpr evaluation. However, since result is not explicitly marked as constexpr, its value would be treated as a runtime constant.

 \bigbreak \noindent 
 \subsection{constexpr Objects}
 \bigbreak \noindent 
 You can use constexpr constructors to define constant objects:
 \bigbreak \noindent 
 \begin{cppcode}
     struct Point {
         int x, y;
         constexpr Point(int x_val, int y_val) : x(x_val), y(y_val) {}
     };

     constexpr Point p(3, 4); // p is a constant expression
 \end{cppcode}

 \bigbreak \noindent 
 \subsection{More on constexpr variables}
 \bigbreak \noindent 
 If a variable is declared as constexpr in C++, it means that:
 \begin{itemize}
     \item The value of the variable must be known and evaluated at compile time.
     \item The initializer for a constexpr variable must be a constant expression (an expression that the compiler can evaluate during compilation).    
 \end{itemize}
 Consider the code
 \bigbreak \noindent 
 \begin{cppcode}
     constexpr int x = 42; // Compile-time constant
     constexpr int y = x + 10; // Also a compile-time constant
 \end{cppcode}
 Here, both x and y are evaluated at compile time, and their values are embedded into the compiled program as constants.
 \bigbreak \noindent 
 constexpr variables are read-only after they are initialized. Once assigned, their value cannot be changed
 \bigbreak \noindent 
 If $x$ is not constexpr, it is treated as a regular variable, and the compiler cannot guarantee that its value is a compile-time constant.
 \bigbreak \noindent 
    Since the initializer for $y$ depends on $x$, and $x$ is not constexpr, $y$ would fail to meet the requirement of being initialized with a constant expression.



 \bigbreak \noindent 
 A constexpr variable can be used in contexts where a constant expression is required, such as
 \bigbreak \noindent 
 \begin{itemize}
     \item Array sizes
     \item Template parameters
     \item static\_assert conditions
\end{itemize}
\bigbreak \noindent 
Because the value of a constexpr variable is computed at compile time, it eliminates the need for runtime computation, which can improve performance.

\bigbreak \noindent 
\subsection{When const Can Make a Compile-Time Constant}
\bigbreak \noindent 
Whether a const variable is a compile-time constant depends on how and where it is initialized.
\bigbreak \noindent 
A const variable is considered a compile-time constant if its value is known at compile time. This typically occurs in the following scenarios
\begin{itemize}
    \item \textbf{Literal Initialization}: If a const variable is initialized with a literal or a constant expression, it is a compile-time constant.
        \bigbreak \noindent 
        \begin{cppcode}
            const int x = 10;  // Compile-time constant
            const double pi = 3.14159;  // Compile-time constant
        \end{cppcode}
    \item \textbf{Constant Expressions}: If a const variable is initialized with a constant expression (an expression that can be evaluated at compile time), it is a compile-time constant.
        \bigbreak \noindent 
        \begin{cppcode}
            const int y = x + 5;  // Compile-time constant if `x` is a compile-time constant
            const int z = sizeof(int) * 2;  // Compile-time constant
        \end{cppcode}
    \item \textbf{constexpr Variables:} The constexpr keyword explicitly indicates that a variable must be a compile-time constant. If a variable is declared with constexpr, it must be initialized with a constant expression.
        \bigbreak \noindent 
        \begin{cppcode}
            constexpr int a = 10;  // Compile-time constant
            constexpr int b = a * 2;  // Compile-time constant
        \end{cppcode}
\end{itemize}
\bigbreak \noindent 
A const variable is not a compile-time constant if its value is determined at runtime. This happens in the following cases
\begin{itemize}
    \item \textbf{Dynamic Initialization:} If a const variable is initialized with a value that is not known until runtime, it is not a compile-time constant.
        \bigbreak \noindent 
        \begin{cppcode}
            int input;
            std::cin >> input;
            const int c = input;  // Not a compile-time constant
        \end{cppcode}
    \item \textbf{Function Return Values:} If a const variable is initialized with the return value of a function (unless the function is constexpr), it is not a compile-time constant.
        \bigbreak \noindent 
        \begin{cppcode}
            int getValue() { return 42; }
            const int d = getValue();  // Not a compile-time constant
        \end{cppcode}
\end{itemize}



\bigbreak \noindent 
\subsection{if constexpr}
\bigbreak \noindent 
if constexpr is a feature introduced in C++17 that allows conditional branching at compile-time. Unlike a regular if statement, the condition in if constexpr must be a compile-time constant expression that the compiler can evaluate during compilation. This enables writing more efficient, type-safe, and flexible code, especially in template programming.
\begin{itemize}
    \item \textbf{Compile-Time Condition:} The condition inside if constexpr is evaluated during compilation.
        \bigbreak \noindent 
        Only the branch corresponding to the true condition is compiled; other branches are ignored.
\item \textbf{Dead Code Removal:} Unreachable branches are completely removed by the compiler, so there is no runtime overhead.
\end{itemize}
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
void printType(T value) {
    if constexpr (std::is_integral<T>::value) {
        std::cout << "Integral type: " << value << '\n';
    } else if constexpr (std::is_floating_point<T>::value) {
        std::cout << "Floating-point type: " << value << '\n';
    } else {
        std::cout << "Other type\n";
    }
}
\end{cppcode}

\bigbreak \noindent 
\subsection{Is constexpr const}
\bigbreak \noindent 
Is constexpr const? Does it make read-only variables? The short answer is yes, constexpr implies const for variables, but not for functions or class members.
\bigbreak \noindent 
When you declare a variable as constexpr, it is implicitly const, meaning it cannot be modified after initialization.
\bigbreak \noindent 
\begin{cppcode}
constexpr int x = 42;
x = 10;  // ERROR: x is read-only (implicitly `const`)
\end{cppcode}
\bigbreak \noindent 
This is equivalent to 
\bigbreak \noindent 
\begin{cppcode}
const int x = 42;
\end{cppcode}

\bigbreak \noindent 
\subsection{consteval}
\bigbreak \noindent 
consteval is a keyword introduced in C++20 that specifies a function must be evaluated exclusively at compile time. Unlike constexpr, which allows a function to be evaluated at either compile time or runtime, consteval ensures that the function is always evaluated at compile time. This makes it a stricter form of constexpr.
\bigbreak \noindent 
A consteval function can only be called in a context where the result can be computed at compile time.
\bigbreak \noindent 
If you try to call a consteval function in a runtime context, the code will not compile.
\bigbreak \noindent 
constexpr functions can be called at runtime if their arguments are not compile-time constants.
\bigbreak \noindent 
consteval functions cannot be called at runtime under any circumstances.
\bigbreak \noindent 
Since consteval functions are evaluated at compile time, they introduce no runtime overhead.
\bigbreak \noindent 
The result of the function is "baked into" the compiled code.
\bigbreak \noindent 
Understand that to call a consteval function, the functions must be called with compile time expressions
\bigbreak \noindent 
\begin{cppcode}
    consteval int f(int x) {
        return x;
    }
    constexpr x = 20;
    f(x);
\end{cppcode}
\bigbreak \noindent 
Consider the following code
\bigbreak \noindent 
\begin{cppcode}
    consteval int f(int x) {
        int y = 20;
        return x+y;
    }
    constexpr int x = 20;
    cout << f(x) << endl;
\end{cppcode}
\bigbreak \noindent 
Why does this work? Isn't \texttt{int y = 20} a runtime operation?  The key here is understanding the distinction between compile-time evaluation and runtime behavior in the context of consteval functions. Let’s clarify why int y = 20 inside a consteval function is not a runtime thing and how the compiler handles it.
\bigbreak \noindent 
A consteval function is required to be evaluated at compile time. This means that everything inside the function (including local variables like int y = 20) is processed and computed during compilation, not at runtime.
\bigbreak \noindent 
The compiler treats the entire body of a consteval function as a compile-time context.
\bigbreak \noindent 
When you declare a local variable inside a consteval function, such as int y = 20, the compiler does not allocate memory for it at runtime.
\bigbreak \noindent 
Instead, the compiler treats y as a compile-time constant because:
\begin{itemize}
    \item It is initialized with a literal value (20), which is a compile-time constant.
    \item The function itself is required to be evaluated at compile time.
\end{itemize}
\bigbreak \noindent 
Therefore, you can essentially create constexpr variables without the use of constexpr or const if the variable is initialized inside a consteval function?
\bigbreak \noindent 
Next, consider
\bigbreak \noindent 
\begin{cppcode}
    consteval void f() {
        int data;
        cout << "Enter: ";
        cin >>  data;
    }
    f();
\end{cppcode}
\bigbreak \noindent 
This code violates the fundamental requirement of consteval functions: they must be evaluated entirely at compile time
\bigbreak \noindent 
A consteval function is required to be evaluated exclusively at compile time. This means that all computations and operations inside the function must be resolvable during compilation.
\bigbreak \noindent 
The compiler must be able to determine the result of the function without executing any runtime code.

\bigbreak \noindent 
\subsection{constinit}
\bigbreak \noindent 
the constinit keyword was introduced to ensure that a variable is initialized at compile-time with a constant expression. This keyword is used to enforce that the initialization of a variable is done in a way that is compatible with constant initialization, which can help catch errors early and improve performance by guaranteeing that the initialization happens at compile-time.
\bigbreak \noindent 
Unlike constexpr, constinit does not imply that the variable is immutable (const). The variable can still be modified at runtime, but its initial value must be a compile-time constant.
\bigbreak \noindent 
constinit is typically used with static or thread\_local variables, as these are the kinds of variables that benefit from compile-time initialization.
\bigbreak \noindent 
A variable cannot be declared with both constinit and constexpr because constexpr already implies compile-time initialization and immutability.
\bigbreak \noindent 
If the initialization expression is not a constant expression, the compiler will generate an error, helping to catch mistakes early.
\bigbreak \noindent 
Note that constinit cannot be used with local variables

\bigbreak \noindent 
\subsection{constexpr and consteval functions are implicitly inline}
\bigbreak \noindent 
All constexpr functions are implicitly treated as inline by the compiler. This is because constexpr functions are often evaluated at compile-time, and their definitions need to be available in every translation unit where they are used.
\bigbreak \noindent 
Like constexpr functions, consteval functions are also implicitly inline.
\bigbreak \noindent 
This ensures that their definitions are available wherever they are used, as they must always be evaluated at compile-time.





\pagebreak 
\unsect{Smart pointers}
\bigbreak \noindent 
We know that pointers are important but are a source of trouble. One reason to use pointers is to have reference semantics outside the usual boundaries of scope. However, it can be very tricky to ensure that their lifetime and the lifetime of the objects they refer to match, especially when multiple pointers refer to the same object. For example, to have the same object in multiple collections , you have to pass a pointer into each collection, and ideally there should be no problems when one of the pointers gets destroyed (no “dangling pointers” or multiple deletions of the referenced object) and when the last reference to an object gets destroyed (no “resource leaks”).
\bigbreak \noindent 
A usual approach to avoid these kinds of problems is to use “smart pointers.” They are “smart”
in the sense that they support programmers in avoiding problems such as those just described. For
example, a smart pointer can be so smart that it “knows” whether it is the last pointer to an object
and uses this knowledge to delete an associated object only when it, as “last owner” of an object,
gets destroyed.
\bigbreak \noindent 
Note, however, that it is not sufficient to provide only one smart pointer class. Smart pointers can
be smart about different aspects and might fulfill different priorities, because you might pay a price
for the smartness. Note that with a specific smart pointer, it’s still possible to misuse a pointer or to
program erroneous behavior.
\bigbreak \noindent 
Since C++11, the C++ standard library provides two types of smart pointer:
\begin{itemize}
    \item \textbf{Class shared\_ptr}: for a pointer that implements the concept of shared ownership. Multiple smart pointers can refer to the same object so that the object and its associated resources get released whenever the last reference to it gets destroyed. To perform this task in more complicated scenarios, helper classes, such as weak\_ptr, bad\_weak\_ptr, and enable\_shared\_from\_this, are provided.
    \item \textbf{Class unique\_ptr}: for a pointer that implements the concept of exclusive ownership or strict ownership. This pointer ensures that only one smart pointer can refer to this object at a time. However, you can transfer ownership. This pointer is especially useful for avoiding resource leaks, such as missing calls of delete after or while an object gets created with new and an exception occurred.
\end{itemize}
\textbf{Quick note}: When an object is created using the new operator in C++ and an exception occurs during its construction, C++ ensures that
\begin{itemize}
    \item \textbf{Memory Allocated by new is Automatically Freed:} If the constructor of the object throws an exception, the memory allocated by new is automatically released to prevent a memory leak.
        \bigbreak \noindent 
        This behavior is part of the C++ standard, ensuring robust exception safety during dynamic allocation.
    \item \textbf{The Destructor is Not Called:}: Since the object's construction is incomplete, its destructor will not be called. Only fully constructed objects have their destructors called.
\end{itemize}
\bigbreak \noindent 
Historically, C++98 had only one smart pointer class provided by the C++ standard library, class
auto\_ptr<>, which was designed to perform the task that unique\_ptr now provides. However,
due to missing language features, such as move semantics for constructors and assignment operators
and other flaws, this class turned out to be difficult to understand and error prone. So, after class
shared\_ptr was introduced with TR1 and class unique\_ptr was introduced with C++11, class
auto\_ptr officially became deprecated with C++11, which means that you should not use it unless
you have old existing code to compile.
\bigbreak \noindent 
All smart pointer classes are defined in the <memory> header file.
\bigbreak \noindent 
\subsection{Class shared\_ptr}
\bigbreak \noindent 
Almost every nontrivial program needs the ability to use or deal with objects at multiple places at the
same time. Thus, you have to “refer” to an object from multiple places in your program. Although
the language provides references and pointers, this is not enough, because you often have to ensure
that when the last reference to an object gets deleted, the object itself gets deleted, which might
require some cleanup operations, such as freeing memory or releasing a resource
\bigbreak \noindent 
So we need a semantics of “cleanup when the object is nowhere used anymore.” Class shared\_ptr provides this semantics of shared ownership. Thus, multiple shared\_ptrs are able to share, or “own,” the same object. The last owner of the object is responsible for destroying it and cleaning up all resources associated with it.
\bigbreak \noindent 
By default, the cleanup is a call of delete, assuming that the object was created with new. But you can (and often must) define other ways to clean up objects. You can define your own destruction policy. For example, if your object is an array allocated with new[], you have to define that the cleanup performs a delete[]. Other examples are the deletion of associated resources, such as handles, locks, associated temporary files, and so on
\bigbreak \noindent 
To summarize, the goal of shared\_ptrs is to automatically release resources associated with objects when those objects are no longer needed (but not before).
\bigbreak \noindent 
\subsubsection{Using Class shared\_ptr}
\bigbreak \noindent 
You can use a shared\_ptr just as you would any other pointer. Thus, you can assign, copy, and
compare shared pointers, as well as use operators * and ->, to access the object the pointer refers to.
Consider the following example
\bigbreak \noindent 
\begin{cppcode}
    shared_ptr<string> pNico(new string("nico"));
    shared_ptr<string> pJutta(new string("jutta"));

    // capitalize person names
    (*pNico)[0] = 'N';
    pJutta->replace(0,1,"J");

    // put them multiple times in a container
    vector<shared_ptr<string>> whoMadeCoffee;
    whoMadeCoffee.push_back(pJutta);
    whoMadeCoffee.push_back(pJutta);
    whoMadeCoffee.push_back(pNico);
    whoMadeCoffee.push_back(pJutta);
    whoMadeCoffee.push_back(pNico);

    // print all elements
    for (auto ptr : whoMadeCoffee) {
        cout << *ptr << " ";
    }
    cout << endl;

    // overwrite a name again
    *pNico = "Nicolai";

    // print all elements again
    for (auto ptr : whoMadeCoffee) {
        cout << *ptr << " ";
    }
    cout << endl;

    // print some internal data
    cout << "use_count: " << whoMadeCoffee[0].use_count() << endl;
\end{cppcode}
\bigbreak \noindent 
After including <memory>, where shared\_ptr class is defined, two shared\_ptrs representing pointers to strings are declared and initialized:
\bigbreak \noindent 
Note that because the constructor taking a pointer as single argument is explicit, you can’t use the assignment notation here because that is considered to be an implicit conversion. However, the new initialization syntax is also possible:
\bigbreak \noindent 
\begin{cppcode}
shared_ptr<string> pNico = new string("nico"); // ERROR
shared_ptr<string> pNico{new string("nico")}; // OK
\end{cppcode}
\bigbreak \noindent 
You can also use the convenience function make\_shared() here:
\bigbreak \noindent 
\begin{cppcode}
shared_ptr<string> pNico = make_shared<string>("nico");
shared_ptr<string> pJutta = make_shared<string>("jutta");
\end{cppcode}
\bigbreak \noindent 
This way of creation is faster and safer because it uses one instead of two allocations: one for the object and one for the shared data the shared pointer uses to control the object
\bigbreak \noindent 
Alternatively, you can declare the shared pointer first and assign a new pointer later on. However, you can’t use the assignment operator; you have to use reset() instead
\bigbreak \noindent 
\begin{cppcode}
shared_ptr<string> pNico4;
pNico4 = new string("nico"); // ERROR: no assignment for ordinary pointers
pNico4.reset(new string("nico")); // OK
\end{cppcode}
\bigbreak \noindent 
\fig{.9}{./figures/1.png}
\bigbreak \noindent 
We insert both pointers multiple times into a container of type vector<>. The container usually creates its own copy of the elements passed, so we would insert
copies of strings if we inserted the strings directly. However, because we pass pointers to the strings,
these pointers are copied, so the container now contains multiple references to the same object. This
means that if we modify the objects, all occurrences of this object in the container get modified.
Thus, after replacing the value of the string pNico, all occurrences of this object now refer to the new value.\bigbreak \noindent 
The last row of the output is the result of calling use\_count() for the first shared pointer in the
vector. use\_count() yields the current number of owners an object referred to by shared pointers
has. As you can see, we have four owners of the object referred to by the first element in the vector:
pJutta and the three copies of it inserted into the container
\bigbreak \noindent 
At the end of the program, when the last owner of a string gets destroyed, the shared pointer calls
delete for the object it refers to. Such a deletion does not necessarily have to happen at the end of
the scope. For example, assigning the nullptr to pNico or resizing
the vector so that it contains only the first two elements would delete the last owner of the string
initialized with nico.
\bigbreak \noindent 
\subsubsection{Defining a Deleter}
\bigbreak \noindent 
We can declare our own deleter, which, for example, prints a message before it deletes the referenced object:
\bigbreak \noindent 
\begin{cppcode}
    shared_ptr<string> pNico(new string("nico"),
    [](string* p) {
        cout << "delete " << *p << endl;
        delete p;
    });
    ...
    pNico = nullptr; // pNico does not refer to the string any longer
    whoMadeCoffee.resize(2); // all copies of the string in pNico are destroyed
\end{cppcode}
\bigbreak \noindent 
The lambda function gets called when the last owner of a string gets destroyed. So the preceding program with this modification would print
\bigbreak \noindent 
\begin{cppcode}
delete Nicolai
\end{cppcode}
\bigbreak \noindent 
when resize() gets called after all statements as discussed before. The effect would be the same if we first changed the size of the vector and then assigned nullptr or another object to pNico.
\bigbreak \noindent 
\subsubsection{Dealing with Arrays}
\bigbreak \noindent 
Note that the default deleter provided by shared\_ptr calls delete, not delete[]. This means
that the default deleter is appropriate only if a shared pointer owns a single object created with new.
Unfortunately, creating a shared\_ptr for an array is possible but wrong:
\bigbreak \noindent 
\begin{cppcode}
std::shared_ptr<int> p(new int[10]); // ERROR, but compiles
\end{cppcode}
\bigbreak \noindent 
So, if you use new[] to create an array of objects you have to define your own deleter. You can do
that by passing a function, function object, or lambda, which calls delete[ ] for the passed ordinary
pointer
\bigbreak \noindent 
\begin{cppcode}
    std::shared_ptr<int> p(new int[10],
    [](int* p) {
        delete[] p;
    });
\end{cppcode}
\bigbreak \noindent 
You can also use a helper officially provided for unique\_ptr, which calls delete[] as deleter
\bigbreak \noindent 
\begin{cppcode}
    std::shared_ptr<int> p(new int[10], std::default_delete<int[]>());
\end{cppcode}
\bigbreak \noindent 
Note, however, that shared\_ptr and unique\_ptr deal with deleters in slightly different ways. For
example, unique\_ptrs provide the ability to own an array simply by passing the corresponding
element type as template argument, whereas for shared\_ptrs this is not possible:
\bigbreak \noindent 
\begin{cppcode}
std::unique_ptr<int[]> p(new int[10]); // OK
std::shared_ptr<int[]> p(new int[10]); // ERROR: does not compile
\end{cppcode}
\bigbreak \noindent 
std::unique\_ptr can handle arrays natively because its design allows for specialization to manage arrays directly. std::unique\_ptr has a specialized version for arrays (std::unique\_ptr<T[]>), which ensures that the correct delete[] operator is called for arrays.
\bigbreak \noindent 
In addition, for unique\_ptrs, you have to specify a second template argument to specify your own deleter:
\bigbreak \noindent 
\begin{cppcode}
    std::unique_ptr<int,void(*)(int*)> p(new int[10],
    [](int* p) {
        delete[] p;
    });
\end{cppcode}
\bigbreak \noindent 
Note also that shared\_ptr does not provide an operator [ ]. For unique\_ptr, a partial specialization for arrays exists, which provides operator [ ] instead of operators * and ->. The reason for
this difference is that unique\_ptr is optimized for performance and flexibility

\bigbreak \noindent 
\subsubsection{More on make\_shared}
\bigbreak \noindent 
Recall the two methods used above 
\bigbreak \noindent 
\begin{cppcode}
std::shared_ptr<std::string> ptr(new std::string("Hello"));
std::shared_ptr<std::string> ptr = std::make_shared<std::string>("Hello");
\end{cppcode}
\bigbreak \noindent 
For the first method, memory gets allocated twice, once for the std::string object, again for the control block. This results in two separate memory allocations, which is less efficient.
\bigbreak \noindent 
If an exception is thrown between the allocation of the object and the creation of the shared\_ptr, the memory allocated for the object will leak because the shared\_ptr never takes ownership of it. If the constructor of std::string throws an exception, the new operation has already allocated memory, and there’s no shared\_ptr to clean it up.
\bigbreak \noindent 
For the second method, memory gets allocated once. std::make\_shared allocates memory for both the control block and the object in a single allocation. This reduces heap fragmentation and improves performance.
\bigbreak \noindent 
std::make\_shared ensures that the object and the shared\_ptr's control block are created together in a single step. If any part of the process throws an exception, no memory leak occurs because all cleanup is handled by make\_shared.

\bigbreak \noindent 
\subsubsection{Understanding the reference count}
\bigbreak \noindent 
Consider the following code
\bigbreak \noindent 
\begin{cppcode}
auto a = make_shared<string>("Hello");
\end{cppcode}
A std::shared\_ptr named $a$ is created. It dynamically allocates a std::string with the value "Hello". The shared\_ptr internally manages the resource using reference counting. The reference count for the managed resource is 1 because a owns it.
\bigbreak \noindent 
When main ends, $a$ goes out of scope. The destructor of $a$ is called automatically, which 
\begin{itemize}
    \item  Decrements the reference count for the managed resource.
    \item Since the reference count becomes 0, the std::string object is destroyed, and its memory is deallocated.
\end{itemize}
\bigbreak \noindent 
Next, consider
\bigbreak \noindent 
\begin{cppcode}
    auto a = std::make_shared<string>("Hello");
    shared_ptr<string> b = a;
\end{cppcode}
\bigbreak \noindent 
We creates a dynamically allocated std::string with the value "Hello". A std::shared\_ptr named $a$ is created to manage this resource. The reference count for the resource is now 1.
\bigbreak \noindent 
Then, a new std::shared\_ptr named $b$ is created by copying $a$ Both $a$ and $b$ now share ownership of the same std::string resource. The reference count for the resource is incremented to 2.
\bigbreak \noindent 
When main ends, both $a$ and $b$ go out of scope.
Their destructors are called in the reverse order of creation:
\begin{itemize}
    \item $b$ is destroyed first, decrementing the reference count to 1.
    \item Then $a$ is destroyed, decrementing the reference count to 0.
\end{itemize}
Since the reference count reaches 0, the managed resource (the std::string) is destroyed, and its memory is deallocated.
\bigbreak \noindent 
Understand that the reference count is stored in a control block that is managed internally by std::shared\_ptr. This control block is allocated when the first std::shared\_ptr is created for a given resource (in your case, when a is initialized using std::make\_shared).
\bigbreak \noindent 
The control block is a separate structure that contains:
\begin{itemize}
    \item \textbf{The reference count (use\_count):} Tracks how many std::shared\_ptr instances share ownership of the resource.
    \item \textbf{The weak reference count:} Tracks how many std::weak\_ptr instances observe the resource.
    \item \textbf{A pointer to the managed resource}: (e.g., the std::string in your code).
\end{itemize}
\bigbreak \noindent 
Both $a$ and $b$ in the above code point to the same control block, which manages the reference count and the std::string resource.
\bigbreak \noindent 
\subsubsection{Cyclic references}
\bigbreak \noindent 
Cyclic references occur when two or more objects reference each other in a way that creates a loop, preventing them from being deallocated properly
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
struct A {
    shared_ptr<A> adjacent;
};

shared_ptr<A> p_a1(new A());
shared_ptr<A> p_a2(new A());
\end{cppcode}
\bigbreak \noindent 
So we have two objects, call them $a_{1}$, and $a_{2}$, and pointers $p_{a_1}$, and $p_{a_2}$ to them.
\bigbreak \noindent 
\begin{figure}[ht]
    \centering
    \incfig{shared2}
    \label{fig:shared2}
\end{figure}
\bigbreak \noindent 
Now, define
\bigbreak \noindent 
\begin{cppcode}
    p_a1->adjacent = p_a2;
    p_a2->adjacent = p_a1;
\end{cppcode}
\bigbreak \noindent 
\begin{figure}[ht]
    \centering
    \incfig{shared3}
    \label{fig:shared3}
\end{figure}
\bigbreak \noindent 
When the program ends, $p_{a_2}$ will be destroyed, but the object that it points to still has a reference count of one, because $a_1$ "owns" it, so it will not be destroyed. Similarly, when $p_a_1$ gets destroyed, the object that it refers to ($a_1$) still has a reference count of one, because $a_2$ still remains and "owns" $a_1$. This is a cyclic reference.
\bigbreak \noindent 
Introduced in the next section, we use weak\_ptr to solve this issue. If we adjust the code
\bigbreak \noindent 
\begin{cppcode}
struct A {
    weak_ptr<A> adjacent;
};

shared_ptr<A> p_a1(new A());
shared_ptr<A> p_a2(new A());

p_a1->adjacent = p_a2;
p_a2->adjacent = p_a1;
\end{cppcode}
\bigbreak \noindent 
Our problem is resolved. A std::weak\_ptr is a smart pointer in C++ that provides a non-owning reference to an object managed by a std::shared\_ptr. Unlike std::shared\_ptr, a std::weak\_ptr does not increase the reference count of the object it observes, making it useful for breaking cyclic references.
\bigbreak \noindent 
When $p_{a_2}$ gets destroyed, the object that it manages ($a_2$) has no references to it. That is, its reference count will be zero because it has instead a weak\_ptr to it. Then, when $p_{a_1}$ gets destroyed, $a_2$ will have already been destroyed, and thus $a_1$ has no references to it, and is therefore also destroyed.

\bigbreak \noindent 
\subsubsection{Practical use of owner\_before()}
\bigbreak \noindent 
The owner\_before method is used to compare ownership order of std::shared\_ptr (or std::weak\_ptr). It does not compare the actual pointer values but rather their control blocks (ownership metadata).
\bigbreak \noindent 
\begin{cppcode}
    std::shared_ptr<int> sp1 = std::make_shared<int>(10);
    std::shared_ptr<int> sp2 = std::make_shared<int>(20);

    if (sp1.owner_before(sp2)) {
        std::cout << "sp1's ownership is before sp2\n";
    } else if (sp2.owner_before(sp1)) {
        std::cout << "sp2's ownership is before sp1\n";
    } else {
        std::cout << "sp1 and sp2 have the same ownership\n";
    }
\end{cppcode}
\bigbreak \noindent 
Let's examine a practical use case in std::set
\bigbreak \noindent 
\begin{cppcode}
    std::set<std::shared_ptr<int>, std::owner_less<std::shared_ptr<int>>> spSet;

    auto sp1 = std::make_shared<int>(10);
    auto sp2 = std::make_shared<int>(20);

    spSet.insert(sp1);
    spSet.insert(sp2);

    std::cout << "Stored shared_ptr objects in set:\n";
    for (const auto& sp : spSet) {
        std::cout << *sp << " ";
    }
\end{cppcode}

\bigbreak \noindent 
 Here, std::owner\_less<std::shared\_ptr<int>> ensures std::set is ordered based on ownership metadata, not the actual pointer values.








\bigbreak \noindent 
\subsection{Class weak\_ptr}
\bigbreak \noindent 
The major reason to use shared\_ptrs is to avoid taking care of the resources a pointer refers to. As written, shared\_ptrs are provided to automatically release resources associated with objects no longer needed.
\bigbreak \noindent 
However, under certain circumstances, this behavior doesn’t work or is not what is intended:
\begin{itemize}
    \item One example is cyclic references. If two objects refer to each other using shared\_ptrs, and you want to release the objects and their associated resource if no other references to these objects exist, shared\_ptr won’t release the data, because the use\_count() of each object is still 1. You might want to use ordinary pointers in this situation, but doing so requires explicitly caring for and managing the release of associated resources
    \item Another example occurs when you explicitly want to share but not own an object. Thus, you have the semantics that the lifetime of a reference to an object outlives the object it refers to. Here, shared\_ptrs would never release the object, and ordinary pointers might not notice that the object they refer to is not valid anymore, which introduces the risk of accessing released data
\end{itemize}
\bigbreak \noindent 
For both cases, class weak\_ptr is provided, which allows sharing but not owning an object. This
class requires a shared pointer to get created. Whenever the last shared pointer owning the object
loses its ownership, any weak pointer automatically becomes empty. Thus, besides default and copy
constructors, class weak\_ptr provides only a constructor taking a shared\_ptr
\bigbreak \noindent 
You can’t use operators * and -> to access a referenced object of a weak\_ptr directly. Instead, you have to create a shared pointer out of it. This makes sense for two reasons:
\begin{itemize}
    \item Creating a shared pointer out of a weak pointer checks whether there is (still) an associated object. If not, this operation will throw an exception or create an empty shared pointer (what exactly happens depends on the operation used).
    \item While dealing with the referenced object, the shared pointer can’t get released.
\end{itemize}
As a consequence, class weak\_ptr provides only a small number of operations: Just enough to create, copy, and assign a weak pointer and convert it into a shared pointer or check whether it refers to an object.
\bigbreak \noindent 
\subsubsection{Using a weak\_ptr}
\bigbreak \noindent 
std::weak\_ptr is used as a companion to std::shared\_ptr to prevent circular references, which can lead to memory leaks. It provides a way to observe an object managed by a std::shared\_ptr without affecting its reference count
\bigbreak \noindent 
Characteristics:
\begin{itemize}
    \item \textbf{No Ownership:} A std::weak_ptr does not own the object it observes. It does not contribute to the reference count of the std::shared_ptr it observes.
    \item \textbf{Temporary Access:} You must convert a std::weak_ptr to a std::shared_ptr to safely access the managed object.
    \item \textbf{Null Safety:} If the managed object has been destroyed, the std::weak_ptr becomes expired.
\end{itemize}
\bigbreak \noindent 
You create a std::weak\_ptr from a std::shared\_ptr:
\bigbreak \noindent 
\begin{cppcode}
std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
std::weak_ptr<int> weakPtr = sharedPtr; // weakPtr observes sharedPtr
\end{cppcode}
\bigbreak \noindent 
You must lock a std::weak\_ptr to get a std::shared\_ptr. This ensures the object is not destroyed while you're using it
\bigbreak \noindent 
\begin{cppcode}
if (auto locked = weakPtr.lock()) { // lock() returns a std::shared_ptr
    std::cout << "Value: " << *locked << std::endl;
} else {
    std::cout << "The object has been destroyed." << std::endl;
}
\end{cppcode}
\bigbreak \noindent 
You can check whether the object managed by a std::weak\_ptr still exists using expired()
\bigbreak \noindent 
\begin{cppcode}
if (weakPtr.expired()) {
    std::cout << "The object has expired." << std::endl;
}
\end{cppcode}
\bigbreak \noindent 
You do not need to convert a std::shared\_ptr back to a std::weak\_ptr when you're done accessing the object.
\begin{itemize}
    \item \textbf{Temporary Ownership via std::shared\_ptr:} When you convert a std::weak\_ptr to a std::shared\_ptr using lock(), the resulting std::shared\_ptr takes temporary ownership of the managed object for as long as it is in scope. Once the std::shared\_ptr goes out of scope, it automatically releases this ownership, reducing the reference count.
    \item \textbf{std::weak\_ptr Remains Unchanged:} The original std::weak\_ptr remains intact and continues observing the managed object, if it still exists. There is no need to explicitly convert a std::shared\_ptr back to a std::weak\_ptr
\end{itemize}

\bigbreak \noindent
\subsection{Unique\_ptr}
\bigbreak \noindent 
The unique\_ptr type, provided by the C++ standard library since C++11, is a kind of a smart pointer that helps to avoid resource leaks when exceptions are thrown. In general, this smart pointer implements the concept of exclusive ownership, which means that it ensures that an object and its associated resources are “owned” only by one pointer at a time. When this owner gets destroyed or becomes empty or starts to own another object, the object previously owned also gets destroyed, and any associated resources are released.
\bigbreak \noindent 
Class unique\_ptr succeeds class auto\_ptr, which was originally introduced with C++98 but is deprecated now. Class unique\_ptr provides a simple and clearer interface, making it less error prone than auto\_pointers have been
\bigbreak \noindent 
If bound to local objects, the resources acquired on entry get freed automatically on function exit
because the destructors of those local objects are called. But if resources are acquired explicitly
and are not bound to any object, they must be freed explicitly. Resources are typically managed
explicitly when pointers are used.
\bigbreak \noindent 
A typical example of using pointers in this way is the use of new and delete to create and destroy an object
\bigbreak \noindent 
\begin{cppcode}
    void f()
    {
        ClassA* ptr = new ClassA; // create an object explicitly
        ... // perform some operations
        delete ptr; // clean up (destroy the object explicitly)
    }
\end{cppcode}
\bigbreak \noindent 
This function is a source of trouble. One obvious problem is that the deletion of the object might be
forgotten, especially if you have return statements inside the function. There also is a less obvious
danger that an exception might occur. Such an exception would exit the function immediately,
without calling the delete statement at the end of the function. The result would be a memory leak
or, more generally, a resource leak
\bigbreak \noindent 
Avoiding such a resource leak usually requires that a function catch all exceptions. For example:
\bigbreak \noindent 
\begin{cppcode}
    void f()
    {
        ClassA* ptr = new ClassA; // create an object explicitly
        try {
            ... // perform some operations
        }
        catch (...) { // for any exception
            delete ptr; // - clean up
            throw; // - rethrow the exception
        }
        delete ptr; // clean up on normal end
    }
\end{cppcode}
\bigbreak \noindent 
To handle the deletion of this object properly in the event of an exception, the code gets more complicated and redundant. If a second object is handled in this way, or if more than one catch clause is used, the problem gets worse. This is bad programming style and should be avoided because it is complex and error prone.
\bigbreak \noindent 
A smart pointer can help here. The smart pointer can free the data to which it points whenever the pointer itself gets destroyed. Furthermore, because it is a local variable, the pointer gets destroyed automatically when the function is exited, regardless of whether the exit is normal or is due to an exception. The class unique\_ptr was designed to be such a smart pointer
\bigbreak \noindent 
A unique\_ptr is a pointer that serves as a unique owner of the object to which it refers. As a result, an object gets destroyed automatically when its unique\_ptr gets destroyed. A requirement of a unique\_ptr is that its object have only one owner
\bigbreak \noindent 
Here is the previous example rewritten to use a unique\_ptr:
\bigbreak \noindent 
\begin{cppcode}
    // header file for unique_ptr
    #include <memory>
    void f()
    {
        // create and initialize an unique_ptr
        std::unique<ClassA> ptr(new ClassA);
        ... // perform some operations
    }
\end{cppcode}
\bigbreak \noindent 
That’s all. The delete statement and the catch clause are no longer necessary.
\bigbreak \noindent 
\subsubsection{Using a unique\_ptr}
\bigbreak \noindent 
A unique\_ptr has much the same interface as an ordinary pointer; that is, operator * dereferences the object to which it points, whereas operator -> provides access to a member if the object is a class or a structure:
\bigbreak \noindent 
However, no pointer arithmetic, such as ++, is defined (this counts as an advantage because pointer arithmetic is a source of trouble). Pointer arithmetic allows you to move a pointer beyond the bounds of an array or allocated memory. Accessing memory outside valid bounds results in undefined behavior
\bigbreak \noindent 
Note that class unique\_ptr<> does not allow you to initialize an object with an ordinary pointer
by using the assignment syntax. Thus, you must initialize the unique\_ptr directly, by using its
value:
\bigbreak \noindent 
\begin{cppcode}
std::unique_ptr<int> up = new int; // ERROR
std::unique_ptr<int> up(new int); // OK
\end{cppcode}
\bigbreak \noindent 
A unique\_ptr does not have to own an object, so it can be empty. This is, for example, the case when it is initialized with the default constructor:
\bigbreak \noindent 
\begin{cppcode}
std::unique_ptr<std::string> up;
\end{cppcode}
\bigbreak \noindent 
You can also assign the nullptr or call reset() :
\begin{align*}
    up = nullptr;
    up.reset();
\end{align*}
\bigbreak \noindent 
n addition, you can call release(), which yields the object a unique\_ptr owned, and gives up ownership so that the caller is responsible for its object now
\bigbreak \noindent 
\begin{cppcode}
    std::unique_ptr<std::string> up(new std::string("nico"));
    ...
    std::string* sp = up.release(); // up loses ownership
\end{cppcode}
\bigbreak \noindent 
You can check whether a unique pointer owns an object by calling operator bool():
\bigbreak \noindent 
\begin{cppcode}
    if (up) { // if up is not empty
        std::cout << *up << std::endl;
    }
\end{cppcode}
\bigbreak \noindent 
Instead, you can also compare the unique pointer with nullptr or query the raw pointer inside the unique\_ptr, which yields nullptr if the unique\_ptr doesn’t own any object
\begin{cppcode}
    if (up != nullptr) // if up is not empty
    if (up.get() != nullptr) // if up is not empty
\end{cppcode}
\bigbreak \noindent 
\subsubsection{Transfer of Ownership by unique\_ptr}
\bigbreak \noindent 
A unique\_ptr provides the semantics of exclusive ownership. However, it’s up to the programmer to ensure that no two unique pointers are initialized by the same pointer:
\bigbreak \noindent 
\begin{cppcode}
std::string* sp = new std::string("hello");
std::unique_ptr<std::string> up1(sp);
std::unique_ptr<std::string> up2(sp); // ERROR: up1 and up2 own same data
\end{cppcode}
\bigbreak \noindent 
Unfortunately, this is a runtime error, so the programmer has to avoid such a mistake.
\bigbreak \noindent 
This leads to the question of how the copy constructor and the assignment operator of
unique\_ptrs operate. The answer is simple: You can’t copy or assign a unique pointer if you use
the ordinary copy semantics. However, you can use the move semantics provided since C++11. In that case, the constructor or assignment operator transfers the ownership
to another unique pointer
\bigbreak \noindent 
\begin{cppcode}
    // initialize a unique_ptr with a new object
    std::unique_ptr<ClassA> up1(new ClassA);
    // copy the unique_ptr
    std::unique_ptr<ClassA> up2(up1); // ERROR: not possible
    // transfer ownership of the unique_ptr
    std::unique_ptr<ClassA> up3(std::move(up1)); // OK
\end{cppcode}
\bigbreak \noindent 
After the first statement, up1 owns the object that was created with the new operator. The second,
which tries to call the copy constructor, is a compile-time error because up2 can’t become another
owner of that object. Only one owner at a time is allowed. However, with the third statement, we
transfer ownership from up1 to up3. So afterward, up3 owns the object created with new, and up1
no longer owns the object. The object created by new ClassA gets deleted exactly once: when up3
gets destroyed
\bigbreak \noindent 
The assignment operator behaves similarly:
\bigbreak \noindent 
\begin{cppcode}
    // initialize a unique_ptr with a new object
    std::unique_ptr<ClassA> up1(new ClassA);
    std::unique_ptr<ClassA> up2; // create another unique_ptr
    up2 = up1; // ERROR: not possible
    up2 = std::move(up1); // assign the unique_ptr
    // - transfers ownership from up1 to up2
\end{cppcode}
\bigbreak \noindent 
Here, the move assignment transfers ownership from up1 to up2. As a result, up2 owns the object previously owned by up1.
\bigbreak \noindent 
If up2 owned an object before an assignment, delete is called for that object. A unique\_ptr that loses the ownership of an object without getting a new ownership refers to no object.
\bigbreak \noindent 
To assign a new value to a unique\_ptr, this new value must also be a unique\_ptr. You can’t assign an ordinary pointer:
\bigbreak \noindent 
\begin{cppcode}
    std::unique_ptr<ClassA> ptr; // create a unique_ptr
    ptr = new ClassA; // ERROR
    ptr = std::unique_ptr<ClassA>(new ClassA); // OK, delete old object
    // and own new
\end{cppcode}
\bigbreak \noindent 
Assigning nullptr is also possible, which has the same effect as calling reset():
\bigbreak \noindent 
\begin{cppcode}
up = nullptr; // deletes the associated object, if any
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Source and Sink}
\bigbreak \noindent 
The transfer of ownership implies a special use for unique\_ptrs; that is, functions can use them to transfer ownership to other functions. This can occur in two ways:
\begin{enumerate}
    \item A function can behave as a \textit{sink} of data. This happens if a unique\_ptr is passed as an argument to the function by rvalue reference created with std::move(). In this case, the parameter of the called function gets ownership of the unique\_ptr. Thus, if the function does not transfer it again, the object gets deleted on function exit:
        \bigbreak \noindent 
        \begin{cppcode}
            void sink(std::unique_ptr<ClassA> up) // sink() gets ownership
            {
                ...
            }
            std::unique_ptr<ClassA> up(new ClassA);
            ...
            sink(std::move(up)); // up loses ownership
        \end{cppcode}
    \item A function can behave as a \textit{source} of data. When a unique\_ptr is returned, ownership of the returned value gets transferred to the calling context. The following example shows this technique
        \bigbreak \noindent 
        \begin{cppcode}
            std::unique_ptr<ClassA> source()
            {
                std::unique_ptr<ClassA> ptr(new ClassA); // ptr owns the new object
                ...
                return ptr; // transfer ownership to calling function
            }
            void g()
            {
                std::unique_ptr<ClassA> p;
                for (int i=0; i<10; ++i) {
                    p = source(); // p gets ownership of the returned object
                    // (previously returned object of f() gets deleted)
                    ...
                }
            } // last-owned object of p gets deleted
        \end{cppcode}
        \bigbreak \noindent 
        Each time source() is called, it creates an object with new and returns the object, along with its ownership, to the caller. The assignment of the return value to p transfers ownership to p. In the second and additional passes through the loop, the assignment to p deletes the object that p owned previously. Leaving g(), and thus destroying p, results in the destruction of the last object owned by p. In any case, no resource leak is possible. Even if an exception is thrown, any unique\_ptr that owns data ensures that this data is deleted.
\end{enumerate}

\bigbreak \noindent 
\subsubsection{unique\_ptrs as Members}
\bigbreak \noindent 
By using unique\_ptrs within a class, you can also avoid resource leaks. If you use a unique\_ptr
instead of an ordinary pointer, you no longer need a destructor because the object gets deleted with
the deletion of the member. In addition, a unique\_ptr helps to avoid resource leaks caused by
exceptions thrown during the initialization of an object. Note that destructors are called only if any
construction is completed. So, if an exception occurs inside a constructor, destructors are called
only for objects that have been fully constructed. This can result in resource leaks for classes with
multiple raw pointers if during the construction the first new was successful but the second was not.

\bigbreak \noindent 
\begin{cppcode}
    class ClassB {
    private:
        ClassA* ptr1; // pointer members
        ClassA* ptr2;
    public:
        // constructor that initializes the pointers
        // - will cause resource leak if second new throws
        ClassB (int val1, int val2)
        : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
        }
        ~ClassB () {
            delete ptr1;
            delete ptr2;
        }
\end{cppcode}
\bigbreak \noindent 
To avoid such a possible resource leak, you can simply use unique\_ptrs:
\bigbreak \noindent 
\begin{cppcode}
    class ClassB {
    private:
        std::unique_ptr<ClassA> ptr1; // unique_ptr members
        std::unique_ptr<ClassA> ptr2;
    public:
        // constructor that initializes the unique_ptrs
        // - no resource leak possible
        ClassB (int val1, int val2)
        : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
        }
    };
\end{cppcode}
\bigbreak \noindent 
Note, first, that you can skip the destructor now because unique\_ptr does the job for you. You also
have to implement the copy constructor and assignment operator. By default, both would try to copy
or assign the members, which isn’t possible. If you don’t provide them, ClassB also would provide
only move semantics.

\bigbreak \noindent 
\subsubsection{Dealing with arrays}
\bigbreak \noindent 
By default, unique\_ptrs call delete for an object they own if they lose ownership (because they
are destroyed, get a new object assigned, or become empty). Unfortunately, due to the language rules
derived from C, C++ can’t differentiate between the type of a pointer to one object and an array of
objects. However, according to language rules for arrays, operator delete[] rather than delete
has to get called. So, the following is possible but wrong:
\bigbreak \noindent 
\begin{cppcode}
std::unique_ptr<std::string> up(new std::string[10]); // runtime ERROR
\end{cppcode}
\bigbreak \noindent 
Now, you might assume that as for class shared\_ptr, you have to define your own deleter to deal with arrays. But this is not necessary.
\bigbreak \noindent 
Fortunately, the C++ standard library provides a partial specialization of class unique\_ptr for
arrays, which calls delete[ ] for the referenced object when the pointer loses the ownership to it.
So, you simply have to declare:
\bigbreak \noindent 
\begin{cppcode}
std::unique_ptr<std::string[]> up(new std::string[10]); // OK
\end{cppcode}
\bigbreak \noindent 
Note, however, that this partial specialization offers a slightly different interface. Instead of operators * and ->, operator [ ] is provided to access one of the objects inside the referenced array
\bigbreak \noindent 
As usual, it’s up to the programmer to ensure that the index is valid. Using an invalid index results in undefined behavior.

\bigbreak \noindent 
\subsubsection{Double ownership}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    int* ptr = new int(5);

    std::unique_ptr<int> up1(ptr);
    std::unique_ptr<int> up2(ptr);

    /*
    fish: Job 1, './bin' terminated by signal SIGABRT (Abort)
    free(): double free detected in tcache 2
    */
\end{cppcode}
\bigbreak \noindent 
The issue with this code is that it results in double ownership of the dynamically allocated memory, which leads to undefined behavior due to double deletion.
\bigbreak \noindent 
Since std::unique\_ptr is designed for exclusive ownership, when up1 and up2 both attempt to delete the same pointer upon going out of scope, you get double deletion, which results in undefined behavior.
\bigbreak \noindent 
C++ does not automatically track raw pointers, and std::unique\_ptr's constructor does not check if another std::unique\_ptr is already managing the same pointer. Since ptr is just a raw pointer, nothing stops you from using it to initialize multiple unique\_ptr instances.
\bigbreak \noindent 
To transfer ownership, we must use the move constructor
\bigbreak \noindent 
\begin{cppcode}
    std::unique_ptr<int> up1(ptr);
    std::unique_ptr<int> up2(std::move(up1));
\end{cppcode}
\bigbreak \noindent 
The move constructor will ensure that up1 is set to a valid state (nullptr)

\bigbreak \noindent 
\subsection{Smart pointers to stack memory?}
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
    int x=10;
    int* ptr = &x;

    std::unique_ptr<int> up1(ptr);

    /*
    free(): invalid pointer
    fish: Job 1, './bin' terminated by signal SIGABRT (Abort)
    */
\end{cppcode}
\bigbreak \noindent 
The issue is that up1 tries to delete a non-heap-allocated memory when it goes out of scope, leading to undefined behavior (usually a crash).
\bigbreak \noindent 
When up1 is destroyed (out of scope), it tries to call delete ptr, which is invalid because $x$ was never allocated using new.

\pagebreak 
\unsect{Three way comparisons (spaceship operator) <compare>}
\bigbreak \noindent 
Suppose we had a Point structure
\bigbreak \noindent 
\begin{cppcode}
    struct Point {
        int x,y;
    };
\end{cppcode}
\bigbreak \noindent 
Then if we tried to compare say to objects of type Point, C++ would not know how to handle the comparisons unless we overloaded the comparison operators. We would generally need to write overloads for all the comparison operators we need. $<, >, <=, >=, ==$, etc. 
\bigbreak \noindent 
Since c++20, we can get the compiler to generate default comparison overloads with some simple syntax. Observe
\bigbreak \noindent 
\begin{cppcode}
    #include <compare>
    struct Point {
        int x,y;

        auto operator <=>(const Point& other) const = default;
    }

    Point p1{1,2},p2{3,4};

    cout << (p1 < p2) << 
        (p1 > p2) << 
        (p1 == p2) << endl;
\end{cppcode}
\bigbreak \noindent 
\subsection{Custom <=> logic}
\bigbreak \noindent 
We can also define specific details for the spaceship operator
\bigbreak \noindent 
struct Rect {
    int width, height;

    auto operator<=>(const Rec& other) const {
        return (width * height) <=> (other.width * other.height);
    }
};

\bigbreak \noindent 
\subsection{Return types}
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{std::strong\_ordering:} For classes where all comparisons (<, <=, >, >=, ==, !=) are meaningful and consistent.
    \item \textbf{std::weak\_ordering:} For cases where equivalence (==) is consistent with ordering but doesn't imply substitutability.
    \item \textbf{std::partial\_ordering:} For cases where not all values are always comparable (e.g., floating-point numbers).
\end{itemize}

\bigbreak \noindent 
\subsection{Spaceship on primitive types}
\bigbreak \noindent 
Consider the spaceship operator no integers
\bigbreak \noindent 
\begin{cppcode}
int a = 5, b = 10;
std::strong_ordering c = a <=> b;

if (c == std::strong_ordering::less) {
    ...
} else if (c == std::strong_ordering::greater) {
    ...
} else if (c == std::strong_ordering::equal)
\end{cppcode}

\pagebreak 
\unsect{Single Dispatch and Overload Resolution}
\bigbreak \noindent 
\subsection{Single dispatch}
\bigbreak \noindent 
Single dispatch in C++ refers to the mechanism where the function that gets called is determined by the dynamic type of a single object at runtime. This is typically achieved using virtual functions in a class hierarchy.
\begin{itemize}
    \item A base class defines a virtual function.
    \item Derived classes override that function.
    \item A pointer or reference to the base class calls the function.
    \item The actual function executed depends on the runtime type of the object.
\end{itemize}
\bigbreak \noindent 
Uses virtual table (vtable) lookup. Only considers one object's dynamic type (hence, single dispatch). C++ lacks multiple dispatch natively (where function resolution depends on multiple object types).

\bigbreak \noindent 
\subsection{Overload resolution (compile time)}
\bigbreak \noindent 
Involves selecting the best-matching function at compile-time based on function arguments. Uses static (compile-time) polymorphism. Does not rely on runtime object types.
\bigbreak \noindent 
"the function is chosen at compile-time" in the context of overload resolution means that the C++ compiler determines which function to call based on the types of arguments provided in the function call, without needing any runtime information.
\bigbreak \noindent 
At compile-time, the compiler
\begin{enumerate}
    \item Examines the available overloaded functions (functions with the same name but different parameter types).
    \item Matches the function call to the best candidate based on:
        \begin{itemize}
            \item Exact match (best case).
            \item Implicit conversions (if needed).
            \item Function templates (if applicable).
        \end{itemize}
    \item Generates a direct function call to the resolved function.
\end{enumerate}
\bigbreak \noindent 
Once the best match is found, the function call is hardcoded into the compiled binary, meaning there is no runtime lookup.
\bigbreak \noindent 
At runtime, no decision-making occurs—each call directly jumps to the compiled function.


\pagebreak 
\unsect{Bitfields}
\bigbreak \noindent 
A bitfield in C++ is a special way of defining and manipulating groups of bits within a structure (struct) or class to optimize memory usage. It allows you to allocate a specific number of bits to a variable, making it useful for situations where you need to store multiple small values compactly.
\bigbreak \noindent 
A bitfield is declared inside a struct or class using an integer type followed by a colon (:) and the number of bits it should occupy.
\bigbreak \noindent 
\begin{cppcode}
struct Example {
    unsigned int a : 3;  // 3-bit field
    unsigned int b : 5;  // 5-bit field
    int c : 2;  // 2-bit field
};
\end{cppcode}
\bigbreak \noindent 
$a$ takes 3 bits, $b$ takes 5 bits, and $c$ takes 2 bits. The type must be an integer type (int, unsigned int, char, etc.), but the exact storage behavior depends on the compiler. The total struct size depends on the compiler's memory alignment rules.
\bigbreak \noindent 
\begin{cppcode}
struct A{
    unsigned x : 1;
};
A a{0};
A b{1};
A c{10}; // Implicit truncation from 'int' to bit-field changes value from 10 to 0
A d{11}; // Implicit truncation from 'int' to bit-field changes value from 11 to 1
\end{cppcode}
\bigbreak \noindent 
\begin{cppcode}
struct A{
    int x : 1;
};
\end{cppcode}
\bigbreak \noindent 
Since $x$ is an signed int, valid values are  $0,-1$, $1$ changes to $-1$, even integers change to $0$, odd integers change to $-1$.
\bigbreak \noindent 
Observe
\bigbreak \noindent 
\begin{cppcode}
    struct A{
        unsigned x : 1;
    };
    cout << sizeof(A) << endl; // still 4
\end{cppcode}
\bigbreak \noindent 
The reason sizeof(A) still returns 4 (or another word-aligned size depending on the system) is due to memory alignment and storage unit limitations in C++.
\bigbreak \noindent 
Even though the struct contains only a 1-bit field, the compiler allocates memory in units of int or a similar word-aligned type, typically 4 bytes (on most 32-bit and 64-bit systems).
\bigbreak \noindent 
So what is efficient about bitfields? Consider the example
\bigbreak \noindent 
\begin{cppcode}
struct A {
    unsigned a : 3;  // 3 bits
    unsigned b : 5;  // 5 bits
    unsigned c : 8;  // 8 bits
}; // Total: 4 bytes (or slightly more, but much smaller than 12)
\end{cppcode}
\bigbreak \noindent 
The bitfield version can store three values within a single int (4 bytes) instead of requiring 12 bytes.
\bigbreak \noindent 
When multiple small values need to be stored, bitfields can significantly reduce memory usage.

\bigbreak \noindent 
\subsubsection{Address operator on a bitfield?}
\bigbreak \noindent 
Consider 
\begin{cppcode}
struct A {
    int x : 3;
    int y;
};
A a;
cout << (&a.x < &a.y) << endl;
\end{cppcode}
\bigbreak \noindent 
int var1 : 3; declares a bit-field, and you can not apply operator\& to a bit-field.
\bigbreak \noindent 
The address-of operator \& shall not be applied to a bit-field, so there are no pointers to bit-fields.
\bigbreak \noindent 
Bitfields in C++ are special because they do not have independent memory addresses. The key reason why you cannot take the address of a bitfield is that bitfields are packed into a single integer storage unit, rather than existing as independent variables in memory.
\bigbreak \noindent 
Bitfields do not have their own memory locations. Instead, multiple bitfields share a single underlying storage unit (typically an int or char).
\bigbreak \noindent 
Unlike normal variables, which reside at specific memory addresses, bitfields exist within a packed storage unit.
\bigbreak \noindent 
If we allowed \&a.x, what would it return? There's no separate memory location for x, only an address for the whole storage unit.
\bigbreak \noindent 
Since bitfields are stored efficiently, the compiler manipulates bits directly using bitwise operations instead of treating them as full memory objects.
\bigbreak \noindent 
Allowing \& would require breaking this optimization and making bitfields behave like regular variables, which defeats their purpose.

\pagebreak 
\unsect{Ref qualifiers}
\bigbreak \noindent 
Regarding member functions, we can add \textit{ref qualifers} to our function signatures, which look like this
\bigbreak \noindent 
\begin{cppcode}
struct s{
    void print() & { // Called when *this is an lvalue
        cout << "lvalue" << endl;
    }

    void print() && { // Called when *this is an rvalue
        cout << "rvalue" << endl;
    }
};
s s1;
s1.print(); // lvalue
s().print(); // rvalue
\end{cppcode}
\bigbreak \noindent 
The Compiler selects which one to call based on whether the object that calls it is an rvalue or an lvalue.
\bigbreak \noindent 
\begin{itemize}
    \item \& (lvalue reference qualifier) means the member function can only be called when the object is an lvalue.
    \item \&\& (rvalue reference qualifier) means the member function can only be called when the object is an rvalue.
\end{itemize}

\pagebreak 
\unsect{Understanding function types}
\bigbreak \noindent 
In C++, functions have types that specify
\begin{itemize}
    \item The return type.
    \item The parameter list.
    \item (For member functions) The class they belong to.
    \item (Optional) cv-qualifiers (const, volatile).
    \item (Optional) reference qualifiers (\&, \&\&).
\end{itemize}
\bigbreak \noindent 
For a simple function:
\bigbreak \noindent 
\begin{cppcode}
int f();
\end{cppcode}
\bigbreak \noindent 
The type is int() (function taking no arguments, returning int).
\bigbreak \noindent 
For a member function:
\bigbreak \noindent 
\begin{cppcode}
struct X {
    int f();
};
\end{cppcode}
\bigbreak \noindent 
The function type is still int(). But a pointer to this function inside X is of type
\bigbreak \noindent 
\begin{cppcode}
int (X::*ptr)();
\end{cppcode}
\begin{itemize}
    \item It is a pointer to a member function of X.
    \item The function returns int and takes no parameters.
    \item The syntax X::* means "a member of X".
\end{itemize}
\bigbreak \noindent 
\subsection{free functions}
\bigbreak \noindent 
A free function is any function that is not a member of a class or struct. It exists at the global scope (or inside a namespace) and operates independently of any class instances.

\pagebreak 
\unsect{Covariant return types}
\bigbreak \noindent 
Covariant return types in C++ allow a derived class to override a virtual function from a base class while changing the return type, as long as the new return type is a pointer or reference to a derived class of the original return type. This feature enables more specific return types in overridden methods without breaking polymorphism.
\bigbreak \noindent 
\subsection{Rules for Covariant Return Types}
\bigbreak \noindent 
\begin{itemize}
    \item The base class function must be virtual.
    \item The return type of the overridden function in the derived class must be a pointer or reference to a class that is derived from the base class's return type.
    \item Function parameters must remain exactly the same.
    \item The function name and signature (excluding return type) must be identical.
\end{itemize}
\bigbreak \noindent 
\begin{cppcode}
    class Base {
        public:
        virtual Base* clone() const {
            std::cout << "Base clone\n";
            return new Base(*this);
        }

        virtual ~Base() = default;
    };

    class Derived : public Base {
        public:
        Derived* clone() const override {  // Covariant return type
            std::cout << "Derived clone\n";
            return new Derived(*this);
        }
    };
    Base* b = new Derived();
    Base* copy = b->clone();  // Calls Derived::clone() and returns Derived*
\end{cppcode}
\bigbreak \noindent 

\subsection{Why Use Covariant Return Types?}
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{Avoids explicit downcasting:} Without covariant return types, clone() would always return a Base*, requiring explicit casting to Derived* when dealing with derived objects.
    \item \textbf{Preserves type information:} The overridden function naturally returns the most specific type possible.
    \item \textbf{Useful in factory patterns:} It allows object creation methods (clone(), createInstance()) to return specialized types.
\end{itemize}

\pagebreak 
\unsect{declval}
\bigbreak \noindent 
std::declval is a template function in C++ that is used to obtain an rvalue reference to a type, primarily in unevaluated contexts such as decltype and sizeof. It is particularly useful in generic programming and template metaprogramming scenarios where it is necessary to deduce types or perform operations on types without having an actual object instance.
\bigbreak \noindent 
\begin{cppcode}
template <class T>
typename std::add_rvalue_reference<T>::type declval() noexcept;
\end{cppcode}
\bigbreak \noindent 
It takes a type T as a template argument and returns an rvalue reference to that type (T\&\&). However, std::declval itself does not produce an actual object of type T. It's a compiler trick that allows you to work with types as if they were objects in contexts where no actual object is needed.
\bigbreak \noindent 
std::declval is commonly used with decltype to determine the return type of a function or operation without actually calling the function or performing the operation. For example:
\bigbreak \noindent 
\begin{cppcode}
    struct MyClass {
        int method() const { return 42; }
    };

    int main() {
        using ResultType = decltype(std::declval<MyClass>().method());
        // ResultType is int
        return 0;
    }
\end{cppcode}
\bigbreak \noindent 
It's important to note that std::declval can only be used in unevaluated contexts. It is an error to evaluate an expression that contains std::declval at runtime
\bigbreak \noindent 
"Unevaluated contexts" in C++ refer to parts of the code where expressions are analyzed for their type or other properties but are not actually executed. In other words, the compiler processes these expressions without generating executable code for them.


\pagebreak 
\unsect{Value Categories}
\bigbreak \noindent 
\subsection{Lvalue (Locator Value)}
\bigbreak \noindent 
An lvalue (locator value) represents an object that persists beyond a single expression. It has a distinct memory location (an address) and can appear on the left-hand side of an assignment.
\bigbreak \noindent 
\begin{itemize}
    \item Has an identifiable memory location.
    \item Can be assigned a new value.
    \item Includes named variables, function calls returning lvalue references, dereferenced pointers, and array elements.
\end{itemize}

\bigbreak \noindent 
\subsection{Rvalue (Right Value)}
\bigbreak \noindent 
An rvalue (temporary value) is an expression that does not have a persistent memory address and typically exists only within a single expression. It cannot be assigned to unless bound to an rvalue reference.
\begin{itemize}
    \item Cannot appear on the left-hand side of an assignment.
    \item Typically includes literals, temporary results of expressions, and function calls returning non-references.
\end{itemize}

\bigbreak \noindent 
\subsection{Xvalue (Expiring Value)}
\bigbreak \noindent 
An xvalue (eXpiring value) is an rvalue that has a memory address and is eligible to be moved from. It is often associated with rvalue references and move semantics
\begin{itemize}
    \item Represents a temporary object that can be moved instead of copied.
    \item Commonly arises from calls to std::move() and functions returning rvalue references.
\end{itemize}
\bigbreak \noindent 
\begin{cppcode}
    std::string foo() {
        return "temporary"; // The returned temporary string is an xvalue
    }

    std::string&& r = std::move(foo()); // std::move forces an xvalue
\end{cppcode}
\bigbreak \noindent 
\subsubsection{Why Does an Xvalue Have a Memory Address?}
\bigbreak \noindent 
An xvalue represents an object whose resources can be reused via move semantics. Unlike prvalues, which are purely temporary values without a persistent memory address, xvalues still represent objects in memory but are treated as temporary.
\bigbreak \noindent 
When we use std::move(), it casts an expression to an rvalue reference (T\&\&), making it an xvalue. This means the object still exists somewhere in memory, and it can be safely moved.

\bigbreak \noindent 
When an lvalue is passed through std::move(), it is no longer an lvalue—instead, it becomes an xvalue (expiring value).
\bigbreak \noindent 
lvalues have an identifiable memory location and can be assigned to.
\bigbreak \noindent 
std::move(lvalue) turns the lvalue into an xvalue, meaning it is now an rvalue but still has a memory address.
\bigbreak \noindent 
An xvalue can be moved from, which allows move constructors and move assignment operators to optimize performance.



\bigbreak \noindent 
\subsection{PRvalue (Pure Rvalue)}
\bigbreak \noindent 
A prvalue (pure rvalue) is an rvalue that does not have a specific memory location. It is typically used for temporary computations.
\begin{itemize}
    \item Cannot have its address taken.
    \item Typically used in expressions that produce temporary values.
\end{itemize}
\bigbreak \noindent 
\begin{cppcode}
int z = 42;         // '42' is a prvalue
std::string s = "Hello"; // "Hello" is a prvalue
int sum = x + y;    // 'x + y' is a prvalue
\end{cppcode}

\bigbreak \noindent 
\subsection{Glvalue (Generalized Lvalue)}
\bigbreak \noindent 
A glvalue (generalized lvalue) is any expression that has an address in memory. This includes both lvalues and xvalues.
\bigbreak \noindent 
\begin{cppcode}
int a = 10;
int& ref = a;  // 'a' is a glvalue
int&& r = std::move(a); // 'std::move(a)' is an xvalue, hence a glvalue
\end{cppcode}

\bigbreak \noindent 
\subsection{Summary}
\bigbreak \noindent 
\fig{.5}{./figures/2.png}


\pagebreak 
\unsect{Deleting functions}
\bigbreak \noindent 
Suppose we had a situation
\bigbreak \noindent 
\begin{cppcode}
    void print(int x) {}
\end{cppcode}
\bigbreak \noindent 
But we wanted to stop calls to this function that are called with a less precise type like char, or bool, we can use =delete
\bigbreak \noindent 
\begin{cppcode}
    void print(int x) {}
    void print(char x) = delete;
    void print(bool x) = delete;
\end{cppcode}
\bigbreak \noindent 
Now calls to print with char or bool will not allow the program to compile. Without this method, calls to print with a char or bool argument would promote that argument to int when print(int x) is invoked.
\bigbreak \noindent 
\subsection{Deleting all non-matching overloads }
\bigbreak \noindent 
Deleting a bunch of individual function overloads works fine, but can be verbose. There may be times when we want a certain function to be called only with arguments whose types exactly match the function parameters. We can do this by using a function template
\bigbreak \noindent 
\begin{cppcode}
    void print(int x) {}
    
    template<typename T>
    void print(T x) = delete;

    printInt(97);   // okay
    printInt('a');  // compile error
    printInt(true); // compile error
\end{cppcode}




\pagebreak 
\unsect{Copy elision}
\bigbreak \noindent 
Copy elision is an optimization technique used by C++ compilers to eliminate unnecessary copying or moving of objects. Instead of creating temporary objects and then copying or moving them, the compiler constructs objects directly in their target memory locations. This not only improves performance by reducing overhead but also avoids invoking copy or move constructors—even when they might have side effects.
\begin{itemize}
    \item \textbf{Direct Construction:} Instead of creating an object in one location and then copying it to another, the object is built directly where it is needed. This is common when a function returns a local object.
    \item \textbf{Return Value Optimization (RVO) and Named RVO (NRVO):} These are specific instances of copy elision. For example, when you write a function that returns an object, the compiler may construct that object directly in the caller’s space rather than copying it from a temporary location.
    \item \textbf{Mandatory Elision in C++17:} Prior to C++17, copy elision was an optimization that compilers could apply. Since C++17, in certain cases (like when returning a prvalue), the standard mandates copy elision, which means the copy or move constructor does not need to be available or even accessible.
    \item \textbf{Performance Benefits:} By eliminating unnecessary copies or moves, programs can run faster and use fewer resources. This is particularly significant in resource-intensive applications where objects are large or expensive to copy.
\end{itemize}


\pagebreak 
\unsect{User defined literals}
\bigbreak \noindent 
User defined literals (UDLs) are a feature introduced in C++11 that allow programmers to define custom literal suffixes to create objects of user-defined types directly from literal values. This makes code more expressive and type-safe
\bigbreak \noindent 
A UDL is implemented by defining a literal operator. The operator’s name is always of the form operator "" \_suffix, where \_suffix is the literal suffix you choose
\bigbreak \noindent 
UDL functions can accept different types of parameters based on the literal:
\begin{itemize}
    \item \textbf{Integer literals:} Typically handled by a parameter of type unsigned long long
    \item \textbf{Floating-point literals:} Typically handled by a parameter of type long double
    \item \textbf{Character and string literals:} Handled by parameters like const char*, a pointer with a length, or even a template parameter pack (e.g., template<char...> for compile-time processing).
\end{itemize}
\bigbreak \noindent 
Once defined, you can append the custom suffix to literal values, which automatically calls your UDL function to convert the literal into your user-defined type
\bigbreak \noindent 
Consider a simple example where we define a UDL for distances in meters:
\bigbreak \noindent 
\begin{cppcode}
    class Distance {
        public:
        double meters;
        explicit Distance(double m) : meters(m) {}
    };

    // UDL for floating-point literals
    constexpr Distance operator"" _m(long double d) {
        return Distance(static_cast<double>(d));
    }

    // UDL for integer literals
    constexpr Distance operator"" _m(unsigned long long d) {
        return Distance(static_cast<double>(d));
    }

    Distance d1 = 3.5_m;  // Calls the long double version
    Distance d2 = 10_m;   // Calls the unsigned long long version
\end{cppcode}
\bigbreak \noindent 
\subsubsection{Why unsigned long long and long double?}
\bigbreak \noindent 
The parameter types for user-defined literal (UDL) operators aren’t chosen arbitrarily—they’re dictated by the C++ standard to ensure consistency and unambiguity when converting literal values.
\bigbreak \noindent 
























\pagebreak 
\unsect{C++ versions and their additions}
\begin{itemize}
    \item \textbf{c++11}: 
        \begin{itemize}
            \item make\_shared
            \item Move Semantics
            \item Automatic Type Deduction (auto keyword)
            \item Lambdas
            \item Range-Based For Loops
            \item constexpr
            \item Smart Pointers
            \item Threading
            \item nullptr
            \item Uniform initialization with \{\} braces
            \item threading and concurrency
            \item std::array
            \item std::unordered\_map
            \item std::tuple
            \item <type\_traits>
            \item Trailing return type
            \item Variadic templates
            \item Override keyword
            \item Constructors implicitly constexpr
            \item destructors implicitly noexcept
            \item Enum classes
            \item User defined literals with the operator"" \_suffix syntax
            \item Constructor delegation
        \end{itemize}
    \item \textbf{c++14}: 
        \begin{itemize}
            \item Relaxed constexpr to allow for control flow (if, for, etc) in constexpr functions. 
            \item Generic Lambdas,
            \item lambdas parameters can be set auto,
            \item std::make\_unique,
            \item Return type deduction for normal functions,
            \item make\_unique
            \item function returns auto without TRT (Trailing return type)
            \item decltype(auto)
            \item Lambda by reference or copy captures with default initializers
        \end{itemize}
    \item \textbf{c++17}: 
        \begin{itemize}
            \item Structured Bindings
            \item if constexpr (Compile-time conditional branching)
            \item std::optional
            \item std::variant
            \item Fold expressions
            \item static constexpr members can be initialized inside the class definition (without inline keyword)
            \item \textbf{Mandatory Elision}: Prior to C++17, copy elision was an optimization that compilers could apply. Since C++17, in certain cases (like when returning a prvalue), the standard mandates copy elision, which means the copy or move constructor does not need to be available or even accessible.
        \end{itemize}
    \item \textbf{c++20}: 
        \begin{itemize}
            \item Ranges library
            \item concepts library
            \item modules
            \item coroutines
            \item spaceship operator
            \item std::span
            \item std::format
            \item consteval, constinit
        \end{itemize}
    \item \textbf{c++23}: 
        \begin{itemize}
            \item \textbf{std::expected}: Represents a value or an error, simplifying error handling.
                \bigbreak \noindent 
                \begin{cppcode}
                std::expected<int, std::string> result = 42;
                \end{cppcode}
            \item \textbf{Extended constexpr}: Nearly all standard library functions are constexpr.
            \item \textbf{Improved Pattern Matching}: Early steps toward native pattern-matching constructs.
        \end{itemize}
\end{itemize}

























    
\end{document}
