\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{GUI Applications with C++} \\
           Build GUI apps for linux with QT
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           November 23, 2023\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak
    \unsect{Preface}
    \bigbreak \noindent 
    Creating a simple GUI application with Qt in C++ involves several steps. First, ensure you have the Qt framework installed on your Linux system. You can download QT on arch linux using pacman.
    \bigbreak \noindent 
    \begin{bashcode}
pacman -Sy qt5
    \end{bashcode}

    \pagebreak
    \unsect{Source File (Simple GUI)}
    \bigbreak \noindent 
    Here we make a simple GUI to show how the projects are built
    \bigbreak \noindent 
    \begin{cppcode}
#include <QApplication>
#include <QProcess>
#include <QWidget>
#include <QPushButton>
#include <iostream>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    QWidget window;

    QPushButton *button = new QPushButton("Click me", &window);
    button->setGeometry(50, 50, 80, 30);

    window.resize(250, 150);
    window.setWindowTitle("Button Example");
    window.show();

    return app.exec();
}
    \end{cppcode}

    \pagebreak
    \unsect{.pro file (Making project)}
    \bigbreak \noindent 
    To build our projects, we need to assemble a .pro file. A sample .pro file for the file above would look something like
    \bigbreak \noindent 
    \begin{cppcode}
TEMPLATE = app
TARGET = your_app_name
CONFIG += console c++11
QT += widgets

# Input
SOURCES += main.cpp

# If you have additional source files, list them here
# SOURCES += source1.cpp source2.cpp

# If you have header files, list them here
# HEADERS += header1.h header2.h

# If you have UI files created using Qt Designer, list them here
# FORMS += mainwindow.ui
    \end{cppcode}
    \begin{itemize}
        \item \textbf{TEMPLATE=app} tells Qt's build system, qmake, that your project is an application. This means qmake will generate a Makefile to build an executable.
        \item \textbf{TARGET=you\_app\_name} specifies the name for the executable
        \item \textbf{CONFIG += console c++11} is used to define various configuration options for the build process
            \begin{itemize}
                \item \textbf{console:} This option is used to specify that the application is a console application. This is particularly relevant on Windows, where it determines whether a console window is opened alongside your application. For GUI applications, you typically wouldn't include console, as GUI applications on Windows usually don't need a console window. On Linux and macOS, the distinction is less significant, as terminal-based and graphical applications are not as strictly separated as on Windows.
                \item \textbf{c++11} tells the compiler to use the C++11 standard
            \end{itemize}
        \item \textbf{QT += widgets} is used to add the widgets module form the list of modules to be included in the application 
        \item \textbf{SOURCES += main.cpp} is used to add source files in the build process
    \end{itemize}

    \bigbreak \noindent 
    \unsect{Building the application}
    \bigbreak \noindent 
    Once we have made the .pro file, we can begin the build process
    \bigbreak \noindent 
    \begin{bashcode}
qmake filename.pro # First
make # Then
    \end{bashcode}

    \pagebreak
    \unsect{Other options for pro file variables}
    \begin{itemize}
        \item \textbf{TEMPLATE:} 
            \begin{itemize}
                \item \textbf{app:} This is used for building an application. It will create an executable. When you're developing a typical GUI or console application, you use TEMPLATE = app.
                \item \textbf{lib:} This is used for building a library. If you're developing a library (either static or dynamic), you would use TEMPLATE = lib. When you choose this, qmake will generate a Makefile suitable for building a library instead of an executable.
                \item \textbf{subdirs:} This is used for a project that contains multiple subprojects. The subdirs template is useful when your project is large and split across multiple directories, each of which is a different project (either an application or a library). With TEMPLATE = subdirs, qmake will manage these subprojects according to the instructions you provide in the .pro file.
                \item \textbf{aux:} This template is used for auxiliary files that are not compiled but are included in the project. It's less commonly used compared to the other templates.
                \item \textbf{vcapp and vclib:} These are for Visual Studio integration on Windows.
            \end{itemize}
        \item \textbf{CONFIG:}
            \begin{itemize}
                \item \textbf{debug:} Builds the application with debugging symbols. Useful for debugging the application.
                \item \textbf{release:} Builds the application in release mode, which typically includes optimizations and lacks debugging symbols.
                \item \textbf{qml\_debug:} Enables debugging of QML code. Useful if you are using QML for your application's UI.
                \item \textbf{qt:} Ensures that Qt-specific build steps are executed, like running the Meta-Object Compiler (MOC) on classes that use Qt's signal and slot mechanism.
                \item \textbf{c++11, c++14, c++17, c++20:} Specifies the C++ standard to be used. You should match this with the version of C++ your code is written in.
                \item \textbf{warn\_on:} Enables all compiler warnings. This is useful for ensuring that potential code issues are highlighted during the build process.
                \item \textbf{static:} When building a library, this option specifies that the library should be static rather than dynamic.
                \item \textbf{shared:} Opposite of static, this is used for building shared libraries.
                \item \textbf{testcase:} Used when building a project as a test case using Qt Test.
                \item \textbf{lex yacc:} Includes support for Lex and Yacc if you are using these tools in your project.
                \item \textbf{thread:} Enables multi-threading support in your application.
                \item \textbf{exceptions:} Enables support for C++ exceptions.
                \item \textbf{no\_keywords:} Disables the use of Qt-specific keywords like slots, signals, and emit to avoid conflicts with third-party libraries.
                \item \textbf{opengl:} Enables the use of OpenGL in the application.
                \item \textbf{widgets:} Includes the QtWidgets module, necessary for applications using Qt Widgets.
                \item \textbf{network:} Includes the QtNetwork module for network programming.
                \item \textbf{sql:} Includes the Qt SQL module for database operations.
                \item \textbf{xml:} Includes the Qt XML module for XML processing.
                \item \textbf{link\_pkgconfig:} Allows the use of pkg-config to find libraries.
                \item \textbf{precompile\_header:} Enables the use of precompiled headers to speed up compilation.
            \end{itemize}
            \pagebreak
        \item \textbf{QT: (List of modules we can add or remove)}
            \begin{itemize}
                    \item \textbf{core:} This is included by default and provides core non-GUI functionality. It's essential for any Qt application.
                   \item \textbf{gui:} Also included by default in most cases, this module is necessary for any application that uses Qt's graphical user interface elements.
                \item \textbf{widgets:} For applications that use QWidget-based user interfaces. This is a key module for traditional desktop GUI applications.
                \item \textbf{network:} Adds network communication capabilities, like handling TCP/IP connections, for your application.
                \item \textbf{sql:} If your application needs to interact with SQL databases, this module provides the necessary functionality.
                \item \textbf{qml:} Necessary for applications that use the QML language for designing user interfaces, especially in combination with the Qt Quick module.
                \item \textbf{quick:} Used in conjunction with QML to create fluid, dynamic user interfaces. It's a part of the Qt Quick framework.
                \item \textbf{multimedia:} For applications that need to handle audio, video, radio, and camera functionality.
                \item \textbf{bluetooth:} Provides classes for writing Bluetooth applications.
                \item \textbf{concurrent:} Enables easier use of multi-threading in applications.
                \item \textbf{printsupport:} For applications that require printing capabilities.
                \item \textbf{webkit or webengine:} For applications that need to embed web content using WebKit or Qt WebEngine.
                \item \textbf{xml:} Adds support for reading and writing XML data.
                \item \textbf{opengl:} For applications that use OpenGL for rendering graphics.
                \item \textbf{testlib:} For writing unit tests.
                \item \textbf{positioning:} For applications that require location and positioning functionality.
                \item \textbf{sensors:} Access to various hardware sensors like accelerometers, gyroscopes, etc.
                \item \textbf{serialport:} For applications that communicate with devices over serial ports.
                \item \textbf{svg:} Support for Scalable Vector Graphics (SVG) files.
                \item \textbf{dbus:} For applications that communicate with other applications using the D-Bus protocol (mostly relevant on Linux). 
            \end{itemize}
    \end{itemize}

    \pagebreak
    \unsect{Includes}
    \bigbreak \noindent 
    The main include we need to build our GUI apps is <QApplication>, this class manages the GUI application's control flow and main settings
    \bigbreak \noindent 
    The <QWidget> class is the base class of all user interface objects. 
    \bigbreak \noindent 
    The <QProcess> allows us to launch external processes

    \pagebreak 
    \unsect{Example Application}
    \bigbreak \noindent 
    Here is a sample application which creates a clickable button that takes us to a certain directory in a new terminal window
    \bigbreak \noindent 
    \begin{cppcode}
#include <QApplication>
#include <QWidget>
#include <QPushButton>
#include <QProcess>
#include <iostream>

class MyWindow : public QWidget {
    Q_OBJECT // Must be in the private sector

public:
    MyWindow(QWidget *parent = nullptr) : QWidget(parent) {
        QPushButton *button = new QPushButton("Open Terminal", this);
        button->setGeometry(50, 50, 120, 30);
        connect(button, &QPushButton::clicked, this, &MyWindow::onButtonClicked);
    }

public slots:
    void onButtonClicked() {
        QProcess::startDetached("kitty --working-directory=/home/datura/tmp/cpp");
    }
};

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    MyWindow window;
    window.resize(250, 150);
    window.setWindowTitle("Button Example");
    window.show();

    return app.exec();
}

#include "main.moc"
    \end{cppcode}

    \pagebreak
    \unsect{Q\_OBJECT}
    \bigbreak \noindent 
    The Q\_OBJECT macro is essential in Qt applications for any class that defines signals or slots, and it enables several key features provided by Qt's meta-object system.
    \bigbreak \noindent 
    \nt{Must be in the private sector}

    \bigbreak \noindent 
    \unsect{Signals and Slots}
    \bigbreak \noindent 
    Signals and slots are fundamental aspects of Qt and form the basis of its event communication system. They are used for communication between objects and are an integral part of Qt's programming model, especially in GUI applications. Here's a breakdown of what they are and how they work:
    \bigbreak \noindent 
    \subsection{Signals}
    \bigbreak \noindent 
    \textbf{Definition:} A signal is a message sent by an object to indicate that some event has occurred or some state has changed. In Qt, signals are declared in a class, but they are not implemented in the class. They are just emitted (or "fired") when the event they represent occurs.
    \bigbreak \noindent 
    \textbf{Usage:} Signals are used to broadcast information. Any number of slots can listen and react to a particular signal.
    \bigbreak \noindent 
    \textbf{Syntax:} In Qt, signals are declared with the signals keyword.
    \bigbreak \noindent 
    \begin{cppcode}
signals:
    void mySignal();
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Slots}
    \bigbreak \noindent 
    \textbf{Definition:} A slot is a function that is used to receive and respond to a signal. Slots can be normal member functions of a class.
    \bigbreak \noindent 
    \textbf{Usage:} Slots are used to perform actions in response to the occurrence of the event signified by a signal. A slot does not know if it has received a signal from a signal or directly as a regular function call.
    \bigbreak \noindent 
    \textbf{Syntax:} Slots are declared with the slots keyword or can be just regular member functions. They can also be private or protected.
    \bigbreak \noindent 
    \begin{cppcode}
public slots:
    void mySlot();
    \end{cppcode}

    \pagebreak
    \subsection{Connecting Signals to Slots}
    \bigbreak \noindent 
    \textbf{Mechanism:} In Qt, objects communicate with each other via signals and slots. When a signal is emitted, all connected slots are called.
    \bigbreak \noindent 
    \textbf{Dynamic Connection:} The connection between signals and slots can be made at runtime using the QObject::connect() function.
    \bigbreak \noindent 
    \begin{cppcode}
    connect(sender, SIGNAL(mySignal()), receiver, SLOT(mySlot()));
    \end{cppcode}

    \bigbreak \noindent 
    \unsect{The MyWindow Constructor and Widget Hierarchy}
    \bigbreak \noindent
    In Qt, the concept of parent-child relationships is pivotal for managing widgets (the graphical user interface elements). When you create a custom widget like MyWindow, which inherits from QWidget, you often include a constructor that allows for specifying a parent widget. This relationship is crucial for several aspects of a widget's behavior and lifecycle.
    \bigbreak \noindent 
    \begin{cppcode}
MyWindow(QWidget *parent = nullptr) : QWidget(parent) {
    // Constructor body
}
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Optional Parent Argument:} The constructor of MyWindow takes an optional parameter parent, which is a pointer to a QWidget. The default value of this parameter is nullptr.
        \item \textbf{Delegating to QWidget Constructor:} Inside the constructor, we use an initialization list to call the base class QWidget's constructor with the parent argument. This is a common C++ technique for initializing base class members.
        \item \textbf{Behavior Based on parent Argument:}
        \begin{itemize}
            \item \textbf{Top-Level Window:} If nullptr is passed to MyWindow (or no argument is provided), it implies that MyWindow does not have a parent widget. In this case, MyWindow acts as a top-level window. This means it can be a standalone window with its own window decorations (like a title bar, minimize/maximize buttons, etc.).
            \item \textbf{Child Widget:} If a valid QWidget pointer is passed as the parent, MyWindow becomes a child widget of the specified parent widget. As a child widget, it will be contained within the parent widget's window and subject to its geometry and visibility. Additionally, the parent widget will manage the lifetime of MyWindow, automatically deleting it when the parent widget is destroyed.
        \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    This constructor design allows MyWindow to be versatile: it can either be an independent window or part of a larger interface, depending on how it's instantiated. This flexibility is a key feature of Qt's approach to building user interfaces, where the composition of widgets can be dynamically arranged.

    \pagebreak
    \unsect{Main Semantics}
    \bigbreak \noindent 
    In a Qt application, the main function serves as the entry point and is responsible for setting up and running the application's main event loop
    \bigbreak \noindent 
    \subsection{QApplication Initialization:}
    \bigbreak \noindent 
    \begin{cppcode}
    QApplication app(argc, argv);
    \end{cppcode}
    \begin{itemize}
        \item QApplication is a class that manages application-wide resources and is necessary for any Qt GUI application.
        \item It needs to be instantiated at the beginning of main.
        \item argc and argv are passed to QApplication to handle any command-line arguments that are relevant to Qt applications (like GUI style, plugin paths, etc.).
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Creating a Window}
    \bigbreak \noindent 
    If no custom window class is made, we can create a window with
    \bigbreak \noindent 
    \begin{cppcode}
Qwidget window;
window.resize(250, 150);
window.setWindowTitle("Title Text");
Window.show();
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Starting the Event Loop:}
    \bigbreak \noindent 
    \begin{cppcode}
    return app.exec();
    \end{cppcode}
    \begin{itemize}
        \item app.exec() starts the application's event loop. This is a crucial call; it enters the main loop where events (like mouse clicks, keypresses, or custom events) are received and dispatched to the appropriate widgets.
        \item The event loop continues to run until exit() is called, usually as a response to events like closing the main window.
    \end{itemize}

    \pagebreak
    \unsect{main.moc}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{What is main.moc?:} The .moc files are generated by the Meta-Object Compiler (MOC) in Qt. MOC is a tool that processes Qt's specific extensions, like the Q\_OBJECT macro, signals, and slots. It generates standard C++ code from these extensions, enabling features like signal-slot connections and introspection.
        \item \textbf{Role of main.moc:} Typically, for classes that include the Q\_OBJECT macro or define signals and slots, a corresponding .moc file is generated. However, it's unusual to have a main.moc. In standard Qt applications, the main function usually doesn't define a new class and doesn't include Q\_OBJECT. If your main.cpp includes definitions of such Qt classes, then main.moc might be generated and should be included at the end of the main.cpp file. This is not common practice and usually indicates that the application structure could be improved by moving Qt class definitions out of main.cpp.
    \end{itemize}

    \bigbreak \noindent 
    \unsect{Defining our own window object}
    \bigbreak \noindent 
    \begin{cppcode}
#include <QApplication>
#include <QWidget>
#include <iostream>
#include <iomanip>

class MainWindow : public QWidget {
private:
    Q_OBJECT;

public:
    MainWindow(QWidget* parent=nullptr) : QWidget(parent) {

    }

};

int main(int argc, char* argv[]) {
    QApplication app(argc, argv);

    MainWindow window;
    window.resize(1080,700);
    window.setWindowTitle("Title Name");
    window.show();

    return app.exec();
}
#include "main.moc"
    \end{cppcode}

    \pagebreak
    \unsect{Creating a button}
    \bigbreak \noindent 
    Now that we have most of the jargon out of the way, lets create some stuff.
    \bigbreak \noindent 
    \subsection{Include Necessary Headers}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QPushButton>
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Creation}
    \bigbreak \noindent 
    In our custom window class, 
    \bigbreak \noindent 
    \begin{cppcode}
    MainWindow(QWidget *parent = nullptr) : QWidget(parent) {
        QPushButton *button = new QPushButton("Do Something", this);
        button->setGeometry(50, 50, 120, 30);
    }
    \end{cppcode}
    \begin{itemize}
        \item \textbf{QPushButton *button = new QPushButton("Open Terminal", this):} creates a new instance of QPushButton. The text "Open Terminal" is set as the button's label. The this pointer is passed as the parent of the button, which means the button is a child widget of MyWindow. As a child widget, it will be displayed within MyWindow and will be deleted when MyWindow is deleted (automatic memory management by Qt).
        \item \textbf{button->setGeometry(50, 50, 120, 30):} sets the position and size of the button within its parent widget (MyWindow). The button is placed at coordinates (50, 50) with a width of 120 pixels and a height of 30 pixels.
    \end{itemize}
    
    \bigbreak \noindent 
    \subsection{Making the button do something}
    \bigbreak \noindent 
    First, lets create a member function for our window class that provides functionality for our button
    \bigbreak \noindent 
    \begin{cppcode}
#include <QProcess>
    \end{cppcode}
    \bigbreak \noindent 
    \begin{cppcode}
public slots:
    void onButtonClick() {
        QProcess::startDetached("kitty --working-directory=$HOME/tmp/cpp");

    }
    \end{cppcode}
    \pagebreak
    Then in the constructor we can add the connection 
    \bigbreak \noindent 
    \begin{cppcode}
    connect(object1, signal1, object2, slot2);
    connect(button, &QPushButton::clicked, this, &MainWindow::onButtonClicked);
    \end{cppcode}
    \begin{itemize}
        \item connect(button, \&QPushButton::clicked, this, \&MainWindow::onButtonClicked); establishes a connection between the clicked signal of the button and the onButtonClicked slot method of MainWindow. This is using the signal-slot mechanism in Qt.
        \item When the button is clicked, the clicked signal is emitted. Because of the connection established by connect, this will trigger the onButtonClicked method in the MainWindow class.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Args}
    \begin{itemize}
        \item \textbf{First Argument - button:}
            \begin{itemize}
                \item This is the source object that emits the signal. In your case, it's the pointer to the QPushButton instance you've created. The signal will be emitted from this button.
            \end{itemize}
        \item \textbf{Second Argument - \&QPushButton::clicked:}
            \begin{itemize}
                \item  This specifies the signal you want to connect from the source object. The \&QPushButton::clicked is a pointer to the clicked signal of the QPushButton class. This signal is emitted by Qt when the button is clicked.
            \end{itemize}
        \item \textbf{Third Argument - this:}
            \begin{itemize}
               \item This is the receiver object, which is the object that owns the slot method you want to call. In this case, this refers to the current instance of the MainWindow class, indicating that the slot method belongs to this instance.
            \end{itemize}
        \item \textbf{Fourth Argument - \&MainWindow::onButtonClicked:}
            \begin{itemize}
                \item  This specifies the slot, which is the method that will be called in response to the signal. \&MainWindow::onButtonClicked is a pointer to the onButtonClicked method of the Wainwindow class. This method should be defined in MainWindow and will be executed when the button is clicked.
            \end{itemize}
    \end{itemize}

    \pagebreak
    \unsect{Creating Labels}
    \bigbreak \noindent 
    First, we need to make sure that we have <QLabel> included 
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QLabel>
    \end{cppcode}
    \bigbreak \noindent 
    Then, in our windows constructor, we can create the label
    \bigbreak \noindent 
    \begin{cppcode}
    label = new QLabel("Hello, World!", this);
    label->setAlignment(Qt::AlignCenter);
    label->setGeometry(0, 75, 250, 50); // Adjust geometry as needed
    label->hide();
    \end{cppcode}

    \pagebreak 
    \unsect{Fonts}
    \bigbreak \noindent 
    \begin{concept}
        Fonts in Qt are handled through the QFont class, which provides extensive support for defining and manipulating font properties. The QFont class encapsulates the characteristics of fonts, such as family, point size, weight, style, and more. Here's a breakdown of the key aspects and functionalities of fonts in Qt:
    \end{concept}
    \bigbreak \noindent 
    \subsection{Creating the font object}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QFont>

    QFont font;
    font.setFamily("Arial");      // Set font family
    font.setPointSize(12);        // Set font point size
    font.setWeight(QFont::Bold);  // Set font weight to bold
    font.setItalic(true);         // Set font style to italic
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Specifying Properties at Construction}
    \bigbreak \noindent 
    \begin{cppcode}
    QFont font("Times", 10, QFont::Bold, true);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Using the font object}
    \bigbreak \noindent 
    \begin{cppcode}
    QFont font;
    font.setFamily("Arial");      // Set font family
    font.setPointSize(12);        // Set font point size
    font.setWeight(QFont::Bold);  // Set font weight to bold
    font.setItalic(true);         // Set font style to italic

    QLabel *label = new QLabel("Hello World", this);
    label->setFont(font);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Setting the font for a label}
    \bigbreak \noindent 
    In QT, after we create a font object, we can use it for our labels. Consider the following code
    \bigbreak \noindent 
    \begin{cppcode}
    QLabel* mylabel("Hello World", this);
    QFont myfont;

    mylabel->setFont(myfont);
    \end{cppcode}


    \pagebreak 
    \unsect{QStrings}
    \bigbreak \noindent 
    QString is a fundamental part of the Qt framework, designed to represent strings of text in a way that is optimized for performance and flexibility, especially in the context of internationalization. It's a powerful alternative to standard C++ string types like std::string and C-style strings (char*).
    \bigbreak \noindent 
    We must use QStrings instead of std::string in our applications to avoid getting errors.
    \bigbreak \noindent 
    \subsection{Creating a QString}
    \bigbreak \noindent 
    Before we create any Qstrings, we must include the header.
    \bigbreak \noindent 
    \begin{cppcode}
#include <QString>
    \end{cppcode}
    \bigbreak \noindent 
    Then we can create our QString objects
    \bigbreak \noindent 
    \begin{cppcode}
    QString a = "My QString";
    \end{cppcode}
    \bigbreak \noindent 
    \subsection{Converting to QString}
    \bigbreak \noindent 
    \begin{cppcode}
std::string a = "String"
QString b = QString::fromStdString(a); // QString::toStdString() for the reverse
    \end{cppcode}

    \pagebreak
    \subsection{Converting numeric types to QString}
    \bigbreak \noindent 
    \begin{cppcode}
    QString a = QString::number(20);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{QStringList}
    \bigbreak \noindent 
    To use QStringList objcets, we first must include the necessary header
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QStringList>
    \end{cppcode}
    \bigbreak \noindent 
    Then to create a QStringList objcet
    \bigbreak \noindent 
    \begin{cppcode}
    QStringList mylist;
    mylist << "item1" << "item2";

    list.append("Item 4");
    list.insert(2, "Inserted Item");  // Inserts at the specified index
    \end{cppcode}
    \bigbreak \noindent 


    \pagebreak 
    \unsect{Creating shapes (QPainter)}
    \bigbreak \noindent 
    Creating shapes in a Qt application typically involves using the QPainter class, which provides a rich set of functions to draw various shapes and figures. Here's a guide on how to create different shapes:

    \bigbreak \noindent 
    \subsection{Headers}
    \bigbreak \noindent 
    \begin{cppcode}
        #include <QPainter>      // Used for drawing graphics in widgets
        #include <QPoint>        // Represents x and y coordinates in a 2D space
        #include <QRect>         // Defines a rectangle in the plane using integer precision
        #include <QPolygon>      // Represents a polygon defined by a vector of points
        #include <QBrush>        // Used for filling shapes with solid colors, patterns, or gradients
        #include <QPen>          // Used for drawing lines and outlines of shapes
        #include <QImage>        // Represents an image; used in conjunction with QPainter
        #include <QGradient>     // To create gradient objects
    \end{cppcode}
    \pagebreak 
    \subsection{Creating a shape}
    \bigbreak \noindent 
    To create shapes, we typically  subclass the QWidget class. However, since this document has examples that already have a QWidget derived class (the window class), we use this class insstead. Then we override the paintEvent
    \bigbreak \noindent 
    \begin{cppcode}
class MyWidget : public MainWindow {
protected:
    void paintEvent(QPaintEvent *event) override;
};
void MyWidget::paintEvent(QPaintEvent *event) {
    QPainter painter(this);

    // Draw a rectangle
    painter.drawRect(10, 10, 100, 50);

    // Draw a circle
    painter.drawEllipse(10, 70, 50, 50);

    // Draw a line
    painter.drawLine(10, 130, 110, 130);

    // Draw a polygon (triangle in this case)
    QPolygon polygon;
    polygon << QPoint(130, 140) << QPoint(180, 190) << QPoint(80, 190);
    painter.drawPolygon(polygon);
}
    \end{cppcode}


    \pagebreak
    \unsect{QColor (defining colors)}
    \bigbreak \noindent 
    \begin{concept}
        In Qt, you can use HTML-style color codes with QColor and then set that QColor to a QBrush. HTML-style color codes are typically hex values prefixed with a hash (\#). Here's how you can modify your code to use an HTML color for your QBrush:
    \end{concept}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QColor>

    QColor mycolor("#808080");
    QBrush newbrush(mycolor);
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Gradients}
    \subsubsection{Header}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QGradient>
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Types of Gradients}
    \begin{itemize}
        \item \textbf{QLinearGradient(x1,y1,x2,y2)}
            \begin{itemize}
                \item (x1, y1) and (x2, y2) are the starting and ending points of the gradient line.
            \end{itemize}
        \item \textbf{QRadialGradient(cx, cy, radius, fx, fy)}
            \begin{itemize}
                \item (cx, cy) is the center of the circle.
                \item radius is the radius of the circle.
                \item (fx, fy) is the focal point of the gradient; if not set, it defaults to the center.
            \end{itemize}
        \item \textbf{QConicalGradient(cx, cy, startAngl)}
            \begin{itemize}
                \item (cx, cy) is the center point of the gradient.
                \item startAngle is the angle in degrees at which the gradient starts.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{setColorAt}
    \bigbreak \noindent 
    To set the colors of the Gradient objects, we use the \textbf{setColorAt()} function. This function has the following signature
    \begin{itemize}
        \item \textbf{setColorAt(qreal position, const QColor\& color)}
            \begin{itemize}
                \item \textbf{position:} A qreal value (a floating-point number) that represents the position along the gradient's axis. For linear and radial gradients, this value is typically between 0.0 and 1.0, where 0.0 represents the start of the gradient and 1.0 represents the end. In a conical gradient, it represents an angle in degrees.
                \item \textbf{color:} A QColor object representing the color to be used at the specified position.
            \end{itemize}
    \end{itemize}


    \pagebreak
    \unsect{Stylesheets}
    \bigbreak \noindent 
    \begin{concept}
        Qt Stylesheets provide a powerful mechanism for customizing the appearance of widgets in a Qt application, similar to how CSS is used for styling web pages. Here's a brief overview of how they work: 
        \begin{itemize}
            \item \textbf{CSS-like Syntax:} Qt Stylesheets use a syntax similar to Cascading Style Sheets (CSS) in web development. They allow you to define the appearance of widgets using style rules.
            \item \textbf{Selector and Declaration:} Each stylesheet rule consists of a selector and a declaration block. The selector specifies which widget or widgets the rule applies to, and the declaration block defines one or more properties to style these widgets.
        \end{itemize}
    \end{concept}
    \bigbreak \noindent 
    \textbf{Example:}
    \bigbreak \noindent 
    \begin{cppcode}
        button = new QPushButton("Example", this);
        button->setGeometry(50,50,150,100);
        button->setStyleSheet("QPushButton {"
                      "  border: 2px solid black;"  
                      "  border-radius: 50px;"
                      "  background-color: lightgray;"  
                      "  color: black;"  
                      "}"
                      "QPushButton:hover {"
                      "  background-color: gray;"  
                      "}"
                      "QPushButton:pressed {"
                      "  background-color: darkgray;"  
                      "}");
    \end{cppcode}

    \pagebreak 
    \unsect{Responsive Design}
    \bigbreak \noindent 
    \begin{concept}
       Responsive design in Qt refers to the practice of creating user interfaces (UIs) that adapt to various screen sizes and resolutions, ensuring a consistent and functional experience across different devices. Qt, being a versatile framework for both widget-based and QML-based UI development, provides several tools and techniques to achieve responsive design: 
    \end{concept}
    \begin{enumerate}
        \item \textbf{Layout Managers:}
            \begin{itemize}
                \item Qt's layout managers (QHBoxLayout, QVBoxLayout, QGridLayout, etc.) automatically adjust the size and position of widgets within a window or a parent widget.
                \item They respond to window resize events and reorganize the contained widgets accordingly, maintaining their relative positions and sizes.
           \end{itemize}
       \item \textbf{Size Policies:}
           \begin{itemize}
               \item Widgets in Qt have size policies (QSizePolicy) that determine how they grow or shrink in response to available space.
               \item These policies can be set to make widgets more flexible or rigid in their size adjustments.
           \end{itemize}
       \item \textbf{Scalable Units:}
           \begin{itemize}
               \item Using scalable units like points or ems for dimensions instead of fixed pixel sizes helps maintain the UI's appearance across different screen resolutions.
               \item Qt Quick's GridUnit and dp (density-independent pixels) are examples of scalable units.
           \end{itemize}
    \end{enumerate}

    \bigbreak \noindent 
    \subsection{Layout Managers}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QLayout>
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{QHBoxLayout} 
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QHBoxLayout>
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Purpose:} QHBoxLayout arranges child widgets in a horizontal line.
        \item \textbf{Usage:} It's typically used when you want to place widgets next to each other from left to right.
        \item \textbf{Spacing and Alignment:} It automatically manages the spacing between widgets and can align them in various ways (left, center, right).
        \item \textbf{Stretch Factors:} You can assign stretch factors to child widgets to control how much space each widget occupies relative to the others.
        \item \textbf{Example:} Placing a label and a line edit horizontally, where the label is the description and the line edit is the field for user input.
    \end{itemize}

    \pagebreak 
    \subsubsection{QVBoxLayout}
    \bigbreak \noindent 
    \begin{cppcode}
    #include <QVBoxLayout>
    \end{cppcode}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Purpose:} QVBoxLayout arranges child widgets in a vertical column.
        \item \textbf{Usage:} It's used when you want to stack widgets on top of each other from top to bottom.
        \item \textbf{Spacing and Alignment:} Like QHBoxLayout, it manages the spacing and supports various alignment options (top, center, bottom).
        \item \textbf{Stretch Factors:} You can also assign stretch factors to dictate the relative space each widget takes up.
        \item \textbf{Example:} Creating a form layout where each label and input field pair is stacked vertically.
    \end{itemize}

    \end{enumerate}

    \pagebreak \bigbreak \noindent 
    \subsection{QVBoxLayout Example}
    \bigbreak \noindent 
    Consider the code snippet
    \bigbreak \noindent 
    \begin{cppcode}

        // Create a container for our vboxlayout and the vboxlayout itself
        QWidget* layoutContainer = new QWidget(this);
        QVBoxLayout* layout = new QVBoxLayout;

        // Create some buttons
        QPushButton* button1 = new QPushButton("1", this);
        QPushButton* button2 = new QPushButton("1", this);

        // Add the buttons to the layout
        layout->addWidget(button1);
        layout->addWidget(button2);

        // Set the container as the container
        layoutContainer->setLayout(layout);

    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Importance of Setting the Layout at the End}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Layout Initialization:} It's crucial to add all widgets you want to be managed by the layout before setting the layout on the container. This ensures that when the layout is applied, it already contains all the widgets it needs to manage.
        \item \textbf{Efficient Redrawing:} Setting a layout on a widget can trigger a redraw of the widget and its children. If you set the layout before adding all the widgets, there could be unnecessary redraws and layout recalculations each time a new widget is added.
        \item \textbf{Avoiding Layout Conflicts:} Once a layout is set on a widget, adding the widget to another layout would cause issues, as a widget (or layout) can only belong to one layout at a time. Setting the layout at the end avoids such conflicts or double management.
    \end{itemize}

    \pagebreak 
    \unsect{The resizeEvent override}
    \bigbreak \noindent 
    \begin{concept}
        The resizeEvent is an important event in Qt that is triggered whenever a widget undergoes a resize operation. This event is part of the event handling mechanism in Qt, which is central to its graphical user interface (GUI) framework.
    \end{concept}
    \begin{itemize}
        \item \textbf{What is resizeEvent?}
            \begin{itemize}
                \item The resizeEvent is a function that is called automatically by the Qt framework when the size of a widget changes. This includes when the widget is first shown (as it is sized to fit the contents or the specified dimensions), and when it is resized manually by the user (like adjusting the size of a window).
            \end{itemize}
        \item \textbf{Declaration and Usage:}
            \begin{itemize}
                \item The resizeEvent is a protected member function of the QWidget class. It can be overridden in a subclass to implement custom behavior when the widget is resized.
                \item The function signature is: void resizeEvent(QResizeEvent *event);
            \end{itemize}
        \item \textbf{Purpose:}
            \begin{itemize}
                \item The primary purpose of overriding resizeEvent is to perform tasks that are necessary when the widget changes size. This could include adjusting the layout of child widgets, reallocating resources, or redrawing graphics.
                \item For example, in a custom widget displaying a graph, you might need to recalculate the graph's dimensions and redraw it to fit the new size.
            \end{itemize}
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
void MainWindow::resizeEvent(QResizeEvent* event) override {
    // Call base class implementation (important for proper functionality)
    QWidget::resizeEvent(event);

    // Recalculate the width of the left divider
    leftDividerEndX = (this->width() / 5) - 15;

    for (auto it = buttons.begin(); it != buttons.end(); ++it) {
        (*it)->setFixedWidth(leftDividerEndX);
    }

    if (selectorHead) {
        selectorHead->setFixedWidth(leftDividerEndX);
    }
}

    \end{cppcode}
    
    
\end{document}
