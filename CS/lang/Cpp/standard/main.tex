\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\lhead{Warner \thepage}
\rhead{}
% \lhead{\leftmark}
\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ STL} \\
           Standard library (Functions etc.)
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak \bigbreak \noindent
    \section{\LARGE C++ Strings (<string>)}
    \bigbreak \noindent 
    \begin{interlude}
       Before we begin with the C++ string methods, there are two things to know.
       \begin{itemize}
           \item \textbf{size\_t}: an unsigned integral type, and it's designed to be able to represent the size of any object in bytes
            \item \textbf{npos}: (Constant) It's the largest possible value representable by the size\_type of std::string
       \end{itemize}
    \end{interlude}
    \bigbreak \noindent 
    \nt{size\_t is used as the return value for methods such as "find" to indicate unsuccessful}
    
    \bigbreak \noindent 
    \subsection{Element Access}
    \begin{itemize}
        \item \textbf{at(r:size\_t pos):}$\mapsto$ \texttt{char}\& --- Returns a reference to the character at the specified position. Store return value in char\&
        \item \textbf{str.front():}$\mapsto$ \texttt{char}\& --- returns reference to the first character. 
        \item \textbf{str.back():}$\mapsto$ \texttt{char}\& --- returns a reference to the last character. 
        \item \textbf{str.c\_str():}$\rightarrow$ const char* pointing to the null-terminated character array.
        \item \textbf{str.data():}$\to$ const char* pointing to the underlying character array.        
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Capacity}
    \begin{itemize}
        \item \textbf{str.length():}$\mapsto$ \texttt{size}\_t --- Returns the number of characters in the string 
        \item \textbf{str.size():}$\mapsto$ \texttt{size}\_t --- Returns the number of characters in the string 
        \item \textbf{str.empty():}$\mapsto$ \texttt{bool} --- Returns true if the string is empty, false otherwise 
        \item \textbf{resize(r:size\_t n, o:char c):}$\mapsto$ \texttt{void} --- Resizes the string to contain $n$ characters.
        \item \textbf{capacity():}$\mapsto$ \texttt{size}\_t --- Returns the size of the storage space currently allocated 
        \item \textbf{reserve(size\_t new\_cap):}$\mapsto$ \texttt{void} --- Reserves storage (increases capacity).
        \item \textbf{max\_size():}$\mapsto$ \texttt{size}\_t --- Returns the maximum number of characters the string can hold 
        \item \textbf{shrink\_to\_fit():}$\mapsto$ \texttt{void} --- Reduces memory usage by freeing unused memory 
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Modifiers}
    \begin{itemize}
        \item \textbf{append(string str):}$\mapsto$ \texttt{std}::string\& mutated\_string --- String to append. (Has other overloads.) (Doesnt need to be saved in T\&)
        \item \textbf{push\_back(char c):}$\mapsto$ \texttt{void} --- Character to append.
        \item \textbf{assign(string str, o:start,o:stop):}$\mapsto$ \texttt{std}::string\& mutated\_string  --- used to replace the current content of the string with a new set of characters. (Has other overloads.)
        \item \textbf{insert(size\_t pos, string str):}$\mapsto$ \texttt{std}::string\& mutated\_str --- Position and string to insert. (Has other overloads.)
        \item \textbf{replace(size\_t pos, size\_t len, string str):}$\mapsto $ \texttt{mutated}\_string --- Position, length, and string for replacement. (Has other overloads.)
        \item \textbf{swap(string str):}$\mapsto$ \texttt{void} --- String to swap with.
        \item \textbf{pop\_back():} $\mapsto$ \texttt{void} --- Removes the last character in the string
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \subsection{String Operations}
    \begin{itemize}
        \item \textbf{substr(pos, o:len):}$\mapsto$ \texttt{string} --- Generate a substr from a string 
        \item \textbf{copy(char[] dest, o:len, pos):}$\mapsto$ \texttt{size}\_t (number of characters that were copied) send contents of string to some character array
        \item \textbf{find(substr, o:pos):}$\mapsto$ \texttt{size}\_t=npos find a substr from within a string
        \item \textbf{rfind(substr, o:pos):}$\mapsto$ \texttt{size}\_t=npos  find a substr form withing as string, starting search from the end of the string
        \item \textbf{find\_first\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos Find character in string (public member function)
        \item \textbf{find\_last\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos	Find character in string from the end (public member function)
        \item \textbf{find\_first\_not\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos	Find absence of character in string (public member function)
        \item \textbf{find\_last\_not\_of(substr (or char), o:pos)}$\mapsto$ \texttt{size}\_t=npos	Find non-matching character in string from the end (public member function)
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Comparison}
    \begin{itemize}
        \item \textbf{compare(o:pos, o:len, str):}$\mapsto$ \texttt{unsigned} integral
            \begin{itemize}
                \item 0: they compare equal 
                \item <0: Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter.
                \item >0: Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer.
            \end{itemize}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversions (These are functions)}
    \begin{itemize}
        \item \textbf{stoi(str, o:idx, o:base):}$\mapsto$ \texttt{int} (idx is a pointer to a size\_t object)
        \item \textbf{stol(str, o:idx, o:base):}$\mapsto$ \texttt{long}
        \item \textbf{stoul(str, o:idx, o:base):}$\mapsto$ \texttt{unsigned} long
        \item \textbf{stoll(str, o:idx, o:base):}$\mapsto$ \texttt{long} long
        \item \textbf{stoull(str, o:idx, o:base):}$\mapsto$ \texttt{unsigned} long long
        \item \textbf{stof(str, o:idx):}$\mapsto$ \texttt{float}
        \item \textbf{stod(str, o:idx):}$\mapsto$ \texttt{double}
        \item \textbf{stold(str, o:idx):}$\mapsto$ \texttt{long} double
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE C-strings (<cstring>)}
    \bigbreak \noindent 
    \subsection{Manipulation}
    \begin{itemize}
        \item \textbf{strncpy(char[] dest, char[] src, size\_t n):}$\mapsto$ \texttt{const} char* --- Copy up to n characters from the string src to dest.
        \item \textbf{strcpy(char[] dest, char[] src)}$\mapsto$ \texttt{const} char* ---- Copies the C string pointed by source into the array pointed by destination
        \item \textbf{strncat(char[] dest, char[] src, size\_t n):}$\mapsto$ \texttt{const} char* --- Append up to n characters from the string src onto the end of dest.
        \item \textbf{strcat(char[] dest, char[] src)}$\mapsto$ \texttt{const} char* --- Appends a copy of the source string to the destination string.
        \bigbreak \noindent 
        \textbf{Note:} cpy functions return a const char* comprised of the characters from the src array that were used.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Examination}
    \begin{itemize}
        \item \textbf{strnlen(char[] src, size\_t maxlen)}$\mapsto$ \texttt{size}\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strlen(char[] src):}$\mapsto$ \texttt{size}\_t --- Return the length of the string (not including the null terminator).
        \item \textbf{strncmp(char[] src1, char[] src2, size\_t n):}$\mapsto$ \texttt{uint} (value varies) --- Compare up to n characters of two strings.
        \item \textbf{strcmp(char[] src1, char[] src2)}$\mapsto$ \texttt{size}\_t (value varires) --- compare two strings
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Searching}
    \begin{itemize}
        \item \textbf{strchr(char[] src, char c):}$\mapsto$ \texttt{char}* ---- get pointer to the first occurrence of character c in the string s, or nullptr if c is not found.
        \item \textbf{strrchr(char[] src, char c):}$\mapsto$ \texttt{char}* --- get pointer to the last occurrence of character c in the string s.
        \item \textbf{strstr(char[] src, char[] str):}$\mapsto$ \texttt{const} char* --- Return a pointer to the first occurrence of the substring 
        \item \textbf{strspn(char[] src, char[] charset):}$\mapsto$ \texttt{size}\_t --- Returns the length of the initial portion of str1 which consists only of characters that are part of str2.
        \item \textbf{strcspn(char[] src, char[] charset):}$\mapsto$ \texttt{size}\_t --- Get position of first character found from charset 
        \item \textbf{strpbrk(char[] src, char[] charset):}$\mapsto$ \texttt{const} char* --- Return string consisting of first match form character set in string onward
        \item \textbf{strtok(char[] src, const char* delims):}$\mapsto$ \texttt{char*}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Error}
    \begin{itemize}
        \item \textbf{strerror(errno)}$\mapsto$ \texttt{const} char* ---  Get pointer to error message string (we are literally passing in the defined variable \textit{errno})
            \begin{verbatim}
std::ifstream inf("file.txt");
if (inf.fail()) { cout << strerrror(errno); } // No such file in directory 
(Because that is what the error string is set to after inf.fail())
            \end{verbatim}
        we also have control over the error we can pass in, errors that are defined in <cerrno>. Rather than leaving it up to errno. We have:

    \bigbreak \noindent 
    \begin{description}
      \item[E2BIG (C++11)] Argument list too long (macro constant)
      \item[EACCES (C++11)] Permission denied (macro constant)
      \item[EADDRINUSE (C++11)] Address in use (macro constant)
      \item[EADDRNOTAVAIL (C++11)] Address not available (macro constant)
      \item[EAFNOSUPPORT (C++11)] Address family not supported (macro constant)
      \item[EAGAIN (C++11)] Resource unavailable, try again (macro constant)
      \item[EALREADY (C++11)] Connection already in progress (macro constant)
      \item[EBADF (C++11)] Bad file descriptor (macro constant)
      \item[EBADMSG (C++11)] Bad message (macro constant)
      \item[EBUSY (C++11)] Device or resource busy (macro constant)
      \item[ECANCELED (C++11)] Operation canceled (macro constant)
      \item[ECHILD (C++11)] No child processes (macro constant)
      \item[ECONNABORTED (C++11)] Connection aborted (macro constant)
      \item[ECONNREFUSED (C++11)] Connection refused (macro constant)
      \item[ECONNRESET (C++11)] Connection reset (macro constant)
      \item[EDEADLK (C++11)] Resource deadlock would occur (macro constant)
      \item[EDESTADDRREQ (C++11)] Destination address required (macro constant)
      \item[EDOM] Mathematics argument out of domain of function (macro constant)
      \item[EEXIST (C++11)] File exists (macro constant)
      \item[EFAULT (C++11)] Bad address (macro constant)
      \item[EFBIG (C++11)] File too large (macro constant)
      \item[EHOSTUNREACH (C++11)] Host is unreachable (macro constant)
      \item[EIDRM (C++11)] Identifier removed (macro constant)
      \item[EILSEQ] Illegal byte sequence (macro constant)
      \item[EINPROGRESS (C++11)] Operation in progress (macro constant)
      \item[EINTR (C++11)] Interrupted function (macro constant)
      \item[EINVAL (C++11)] Invalid argument (macro constant)
      \item[EIO (C++11)] I/O error (macro constant)
      \item[EISCONN (C++11)] Socket is connected (macro constant)
      \item[EISDIR (C++11)] Is a directory (macro constant)
      \item[ELOOP (C++11)] Too many levels of symbolic links (macro constant)
      \item[EMFILE (C++11)] File descriptor value too large (macro constant)
      \item[EMLINK (C++11)] Too many links (macro constant)
      \item[EMSGSIZE (C++11)] Message too large (macro constant)
      \item[ENAMETOOLONG (C++11)] Filename too long (macro constant)
      \item[ENETDOWN (C++11)] Network is down (macro constant)
      \item[ENETRESET (C++11)] Connection aborted by network (macro constant)
      \item[ENETUNREACH (C++11)] Network unreachable (macro constant)
      \item[ENFILE (C++11)] Too many files open in system (macro constant)
      \item[ENOBUFS (C++11)] No buffer space available (macro constant)
      \item[ENODATA (C++11)(deprecated in C++23)] No message is available on the STREAM head read queue (macro constant)
      \item[ENODEV (C++11)] No such device (macro constant)
      \item[ENOENT (C++11)] No such file or directory (macro constant)
      \item[ENOEXEC (C++11)] Executable file format error (macro constant)
      \item[ENOLCK (C++11)] No locks available (macro constant)
      \item[ENOLINK (C++11)] Link has been severed (macro constant)
      \item[ENOMEM (C++11)] Not enough space (macro constant)
      \item[ENOMSG (C++11)] No message of the desired type (macro constant)
      \item[ENOPROTOOPT (C++11)] Protocol not available (macro constant)
      \item[ENOSPC (C++11)] No space left on device (macro constant)
      \item[ENOSR (C++11)(deprecated in C++23)] No STREAM resources (macro constant)
      \item[ENOSTR (C++11)(deprecated in C++23)] Not a STREAM (macro constant)
      \item[ENOSYS (C++11)] Function not supported (macro constant)
      \item[ENOTCONN (C++11)] The socket is not connected (macro constant)
      \item[ENOTDIR (C++11)] Not a directory (macro constant)
      \item[ENOTEMPTY (C++11)] Directory not empty (macro constant)
      \item[ENOTRECOVERABLE (C++11)] State not recoverable (macro constant)
      \item[ENOTSOCK (C++11)] Not a socket (macro constant)
      \item[ENOTSUP (C++11)] Not supported (macro constant)
      \item[ENOTTY (C++11)] Inappropriate I/O control operation (macro constant)
      \item[ENXIO (C++11)] No such device or address (macro constant)
      \item[EOPNOTSUPP (C++11)] Operation not supported on socket (macro constant)
      \item[EOVERFLOW (C++11)] Value too large to be stored in data type (macro constant)
      \item[EOWNERDEAD (C++11)] Previous owner died (macro constant)
      \item[EPERM (C++11)] Operation not permitted (macro constant)
      \item[EPIPE (C++11)] Broken pipe (macro constant)
      \item[EPROTO (C++11)] Protocol error (macro constant)
      \item[EPROTONOSUPPORT (C++11)] Protocol not supported (macro constant)
      \item[EPROTOTYPE (C++11)] Protocol wrong type for socket (macro constant)
      \item[ERANGE] Result too large (macro constant)
      \item[EROFS (C++11)] Read-only file system (macro constant)
      \item[ESPIPE (C++11)] Invalid seek (macro constant)
      \item[ESRCH (C++11)] No such process (macro constant)
      \item[ETIME (C++11)(deprecated in C++23)] Stream ioctl() timeout (macro constant)
      \item[ETIMEDOUT (C++11)] Connection timed out (macro constant)
      \item[ETXTBSY (C++11)] Text file busy (macro constant)
      \item[EWOULDBLOCK (C++11)] Operation would block (macro constant)
      \item[EXDEV (C++11)] Cross-device link (macro constant)
    \end{description}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Conversion Found in <cstdlib>}
    \begin{itemize}
        \item \textbf{atoi(char[])} - Converts a C-string to an int.
        \item \textbf{atol(char[])} - Converts a C-string to a long.
        \item \textbf{atoll(char[])} - Converts a C-string to a long long.
        \item \textbf{atof(char[])} - Converts a C-string to a double.
        \item \textbf{strtol(char[], endptr, base)} - Converts a C-string to a long int, with error checking and more flexibility with base representations.
        \item \textbf{strtoul(char[], endptr, base)} - Converts a C-string to an unsigned long int.
        \item \textbf{strtoll(char[], endptr, base)} - Converts a C-string to a long long int.
        \item \textbf{strtoull(char[], endptr, base)} - Converts a C-string to an unsigned long long int.
        \item \textbf{strtof(char[], endptr)} - Converts a C-string to a float.
        \item \textbf{strtod(char[], endptr)} - Converts a C-string to a double.
        \item \textbf{strtold(char[], endptr)} - Converts a C-string to a long double.
    \end{itemize}
    \bigbreak \noindent 
    \textbf{Note:} Consider the codeblock
    \begin{verbatim}
const char* a = "12.322string";
char* ptr;

double val = strtod(a, &ptr); // ptr will hold the value "string"
    \end{verbatim}
    \bigbreak \noindent 
    In this example, you can see that we are making use of the endptr optional parameter, \textit{endptr} is the address to a char pointer. It allows us to send all the string data that is not able to be converted to the requested data type . It allows us to send all the string data that is not able to be converted to the requested data type to this pointer. Only data AFTER the converted data will be sent.
    
    \bigbreak \noindent 
    \section{\LARGE Numeric to string conversions <string>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{to\_string(n):}$\mapsto$ \texttt{string} --- converts numeric type to c++ string
    \end{itemize}



    \bigbreak \noindent
    \section{\LARGE Characters (<cctype>)}
    \bigbreak \noindent 
    \subsection{Character Classification}
    \begin{itemize}
        \item \textbf{isalpha(char c):} Checks if the character is an alphabet (either uppercase or lowercase).
        \item \textbf{isdigit(char c):} Checks if the character is a digit (0-9).
        \item \textbf{isalnum(char c):} Checks if the character is either an alphabet or a digit.
        \item \textbf{isspace(char c):} Checks if the character is a whitespace character (like space, tab, newline, etc.).
        \item \textbf{isupper(char c):} Checks if the character is uppercase.
        \item \textbf{islower(char c):} Checks if the character is lowercase.
        \item \textbf{ispunct(char c):} Checks if the character is a punctuation character.
        \item \textbf{isprint(char c):} Checks if the character is printable.
        \item \textbf{iscntrl(char c):} Checks if the character is a control character.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Character Conversion:}
    \begin{itemize}
        \item \textbf{toupper(char c):} Converts the character to uppercase (if it's lowercase).
        \item \textbf{tolower(char c):} Converts the character to lowercase (if it's uppercase).
    \end{itemize}

    % \pagebreak \bigbreak \noindent 
    % \section{\LARGE Numeric types}

    \pagebreak \bigbreak \noindent 
    \section{C++ Arrays <array>}
    \bigbreak \noindent 
    \textbf{Note:} C++ Arrays are defined
    \smallbreak \noindent
    \begin{verbatim}
std::array<T,N> name;
    \end{verbatim}
    \begin{itemize}
        \item \textbf{at(size\_t)}$\mapsto$ \texttt{T}\&: Accesses the element at the specified \textit{position} with bounds checking.
        \item \textbf{front()}$\mapsto$ \texttt{T}\&: Returns a reference to the first element.
        \item \textbf{back()}$\mapsto$ \texttt{T}\&: Returns a reference to the last element.
        \item \textbf{data()}$\mapsto$ \texttt{T}*: Returns a direct pointer to the first element in the array, usefull if we want to use our std::array as if it were a c-style array
        \item \textbf{empty()}$\mapsto$ \texttt{bool}: Checks if the container has no elements.
        \item \textbf{size()}$\mapsto$ \texttt{size}\_t: Returns the number of elements in the container.
        \item \textbf{max\_size()}$\mapsto$ \texttt{size}\_t: Returns the maximum number of elements the container can hold (same as size).
        \item \textbf{fill(value)}$\mapsto$ \texttt{void}: Fills the array with the specified \textit{value}.
        \item \textbf{swap(other)}$\mapsto$ \texttt{void}: Swaps the contents of the array with those of \textit{other}.
        \item \textbf{begin()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the first element.
        \item \textbf{cbegin()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to the first element.
        \item \textbf{end()}\(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to one-past-the-last element.
        \item \textbf{cend()}\(\mapsto\) \texttt{Const\_Iterator}: Returns a const iterator pointing to one-past-the-last element.
        \item \textbf{rbegin()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to the last element.
        \item \textbf{crbegin()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to the last element.
        \item \textbf{rend()}\(\mapsto\) \texttt{Reverse\_Iterator}: Returns a reverse iterator pointing to one-past-the-first element.
        \item \textbf{crend()}\(\mapsto\) \texttt{Const\_Reverse\_Iterator}: Returns a const reverse iterator pointing to one-past-the-first element.
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Algorithms <algorithm> }
    \bigbreak \noindent 
    Prereq: Vocab
    \begin{itemize}
        \item An \textbf{InputIterator} is a type of iterator that can be used to read data from a sequence of elements. It supports operations like incrementing (to move to the next element in the sequence), dereferencing (to access the value of the element it currently points to), and comparing with other iterators (to check for the end of the sequence). Input iterators are the least powerful, but most widely applicable kind of iterator, as they only require single-pass, read-only access.
        \item An \textbf{ForwardIterator} is a type of iterator that has all the capabilities of an InputIterator but with some additional properties:
            \begin{itemize}
                \item It can be incremented multiple times and will always give the same sequence of results (multi-pass guarantee).
                \item It supports both it++ and ++it operations with the same effect.
                \item Two dereferenced copies of a ForwardIterator are guaranteed to reference the same element (if neither is modified).
            \end{itemize}
            ForwardIterator is used in contexts where an algorithm might need to pass over a range of elements multiple times.
        \item A \textbf{UnaryPredicate} is a function or a function object that takes a single argument and returns a bool. It is used to test whether a certain condition is true for the elements in a sequence. The predicate can be a regular function, a lambda expression, or an object of a class that overloads the function call operator.
        \item A \textbf{UnaryOperator} refers to a function or a function object that takes a single argument and returns some value.
        \item An \textbf{OutputIterator} is a type of iterator that can be used to write to a sequence of elements. It's a concept from the C++ Standard Library that defines the requirements for an iterator that can be used to output or write data to a container. 
            \bigbreak \noindent 
            \textbf{Note:} A standard iterator can be used in place of a outputiterator, however, here is how we can use a outputiterator to write contents of an array to the output buffer
            1br
            \begin{cppcode}
                int arr[5] = {1,2,3,4,5};
                std::copy(std::begin(arr), std::end(arr), std::ostream_iterator<int>(cout, " "));
            \end{cppcode}
    \end{itemize}
    \bigbreak \noindent  
    \textbf{std::pair type}: std::pair is a class template that provides a way to store two heterogeneous objects as a single unit. The way we access the elements is with .first and .second
    \subsection{Non-Modifying}
    \begin{itemize}
        \item \textbf{all\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{bool}: Returns true if the predicate is true for all elements in the given range.
        \item \textbf{any\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{bool}: Returns true if the predicate is true for any element in the range.
        \item \textbf{none\_of(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{bool}: Returns true if the predicate is false for all elements in the range.
        \item \textbf{for\_each(InputIterator, InputIterator, Function)} \(\mapsto\) \texttt{Function}: Applies a function to each element in the range.
        \item \textbf{count(InputIterator, InputIterator, const T\&)} \(\mapsto\) \texttt{size\_t}: Counts elements equal to the specified value.
        \item \textbf{count\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{size\_t}: Counts elements for which the predicate is true.
        \item \textbf{mismatch(InputIterator1, InputIterator1, InputIterator2)} \(\mapsto\) \texttt{pair<InputIterator1, InputIterator2>}: Finds the first position where two ranges differ.
        \item \textbf{find(InputIterator, InputIterator, const T\&)} \(\mapsto\) \texttt{InputIterator}: Finds the first element equal to the specified value.
        \item \textbf{find\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Finds the first element for which the predicate is true.
        \item \textbf{find\_if\_not(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Finds the first element for which the predicate is false.
        \item \textbf{find\_end(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) \texttt{InputIterator}: Finds the last occurrence of a subsequence.
        \item \textbf{find\_first\_of(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) \texttt{InputIterator}: Finds the first element that matches any element in another range.
        \item \textbf{adjacent\_find(InputIterator, InputIterator, o:UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Finds the first two adjacent items that are equal (or satisfy a given predicate).
        \item \textbf{search(InputIterator, InputIterator, InputIterator, InputIterator)} \(\mapsto\) \texttt{InputIterator}: Searches for the first occurrence of a subsequence.
        \item \textbf{search\_n(InputIterator, InputIterator, size\_t, const T\&)} \(\mapsto\) \texttt{InputIterator}: Searches for a sequence of repeated elements.
    \end{itemize}
    \bigbreak \noindent 
    \begin{notebox}
       The for\_each function returns the function that was used to map each element.
    \end{notebox}

    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{copy(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Copies a range of elements to a new location.
        \item \textbf{copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate)} \(\mapsto\) \texttt{OutputIterator}: Copies elements satisfying a condition to a new location.
        \item \textbf{copy\_n(InputIterator, Size, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Copies a number of elements to a new location.
        \item \textbf{copy\_backward(BidirectionalIterator1, BidirectionalIterator1, BidirectionalIterator2)} \(\mapsto\) \texttt{BidirectionalIterator2}: Copies elements in reverse order.
        \item \textbf{move(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Moves a range of elements to a new location.
        \item \textbf{move\_backward(BidirectionalIterator1, BidirectionalIterator1, BidirectionalIterator2)} \(\mapsto\) \texttt{BidirectionalIterator2}: Moves elements in reverse order.
        \item \textbf{fill(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{void}: Assigns a value to all elements in a range.
        \item \textbf{fill\_n(OutputIterator, Size, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Assigns a value to a number of elements.
        \item \textbf{transform(InputIterator, InputIterator, OutputIterator, UnaryOperation)} \(\mapsto\) \texttt{OutputIterator}: Applies a function to a range of elements.
        \item \textbf{generate(ForwardIterator, ForwardIterator, Generator)} \(\mapsto\) \texttt{void}: Fills a range with the results of successive function calls.
        \item \textbf{generate\_n(OutputIterator, Size, Generator)} \(\mapsto\) \texttt{OutputIterator}: Fills a range with N results of successive function calls.
        \item \textbf{remove(InputIterator, InputIterator, const T\&)} \(\mapsto\) \texttt{InputIterator}: Removes elements equal to a value.
        \item \textbf{remove\_if(InputIterator, InputIterator, UnaryPredicate)} \(\mapsto\) \texttt{InputIterator}: Removes elements satisfying a condition.
        \item \textbf{remove\_copy(InputIterator, InputIterator, OutputIterator, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Copies elements not equal to a value.
        \item \textbf{remove\_copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate)} \(\mapsto\) \texttt{OutputIterator}: Copies elements not satisfying a condition.
        \item \textbf{replace(InputIterator, InputIterator, const T\&, const T\&)} \(\mapsto\) \texttt{void}: Replaces all values equal to a specified value.
        \item \textbf{replace\_if(InputIterator, InputIterator, UnaryPredicate, const T\&)} \(\mapsto\) \texttt{void}: Replaces values satisfying a condition.
        \item \textbf{replace\_copy(InputIterator, InputIterator, OutputIterator, const T\&, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Copies and replaces values.
        \item \textbf{replace\_copy\_if(InputIterator, InputIterator, OutputIterator, UnaryPredicate, const T\&)} \(\mapsto\) \texttt{OutputIterator}: Copies and replaces values based on a condition.
        \item \textbf{swap(T\&, T\&)} \(\mapsto\) \texttt{void}: Swaps the values of two objects.
        \item \textbf{swap\_ranges(ForwardIterator1, ForwardIterator1, ForwardIterator2)} \(\mapsto\) \texttt{ForwardIterator2}: Swaps two ranges of elements.
        \item \textbf{iter\_swap(ForwardIterator1, ForwardIterator2)} \(\mapsto\) \texttt{void}: Swaps elements pointed to by two iterators.
        \item \textbf{reverse(BidirectionalIterator, BidirectionalIterator)} \(\mapsto\) \texttt{void}: Reverses the order of elements in a range.
        \item \textbf{reverse\_copy(BidirectionalIterator, BidirectionalIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Creates a reversed copy of a range.
        \item \textbf{rotate(ForwardIterator, ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Rotates the order of elements in a range.
        \item \textbf{rotate\_copy(ForwardIterator, ForwardIterator, ForwardIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Copies and rotates a range of elements.
        \item \textbf{shift\_left(ForwardIterator, ForwardIterator, Size)} \(\mapsto\) \texttt{ForwardIterator}: Shifts elements in a range to the left.
        \item \textbf{shift\_right(ForwardIterator, ForwardIterator, Size)} \(\mapsto\) \texttt{ForwardIterator}: Shifts elements in a range to the right.
        \item \textbf{random\_shuffle(RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Randomly re-orders elements in a range.
        \item \textbf{shuffle(RandomAccessIterator, RandomAccessIterator, URNG\&)} \(\mapsto\) \texttt{void}: Randomly re-orders elements in a range using a generator.
        \item \textbf{sample(InputIterator, InputIterator, OutputIterator, Size, URNG\&)} \(\mapsto\) \texttt{OutputIterator}: Selects N random elements from a sequence.
        \item \textbf{unique(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Removes consecutive duplicate elements in a range.
        \item \textbf{unique\_copy(InputIterator, InputIterator, OutputIterator)} \(\mapsto\) \texttt{OutputIterator}: Creates a copy of a range without consecutive duplicates.
        \item \textbf{partition(BidirectionalIterator, BidirectionalIterator, UnaryPredicate)}$\mapsto$ \texttt{Iterator}: Partition range in two
        \item \textbf{partition\_copy(BidirectionalIterator, BidirectionalIterator, UutputIterator)}$\mapsto $ \texttt{OutputIterator}: Partition range in two
        \item \textbf{stable\_partition(BidirectionalIterator, BidirectionalIterator, UnaryPredicate)}$\mapsto $ \texttt{Iterator}: Partition range in two - stable ordering 
    \end{itemize}
    
    \bigbreak \noindent 
    \subsection{Using lambdas for these functions}
    \bigbreak \noindent 
    \begin{cppcode}
        int arr[]  = {1,2,3};
        std::for_each(arr, arr+3, [](int& a) -> int { return ++x; });
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Getting position of element from returned iterator}
    \bigbreak \noindent 
    \begin{concept}
        If we subtract the iterator (which is the address of the array element) from the beginning of the array, we get the distance between the two pointers (so the index position of the iterator value) 
        \bigbreak \noindent 
        \begin{cppcode}
        idx = it - std::begin(array);
        \end{cppcode}
    \end{concept}

    \bigbreak \noindent 
    \subsection{Using shuffle and sample}
    \bigbreak \noindent 
    For these functions we need two components, a seed and a random engine
    \bigbreak \noindent 
    \begin{cppcode}
#include <chrono>
#include <random>

unsigned seed std::chrono::system_clock::now().time_since_epoch().count();
std::default_random_engine engine(seed);
    \end{cppcode}
    \bigbreak \noindent 
    We then use the engine variable in place of URNG\&

    \bigbreak \noindent 
    \subsection{Sorting operations}
    \begin{itemize}
        \item \textbf{is\_sorted(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{bool}: Checks whether a range is sorted into ascending order.
        \item \textbf{is\_sorted\_until(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Finds the largest sorted subrange.
        \item \textbf{sort(RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Sorts a range into ascending order.
        \item \textbf{partial\_sort(RandomAccessIterator, RandomAccessIterator, RandomAccessIterator, comp)} \(\mapsto\) \texttt{void}: Sorts the first N elements of a range.
        \item \textbf{partial\_sort\_copy(InputIterator, InputIterator, RandomAccessIterator, RandomAccessIterator, comp)} \(\mapsto\) \texttt{RandomAccessIterator}: Copies and partially sorts a range of elements.
        \item \textbf{stable\_sort(RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Sorts a range of elements while preserving order between equal elements.
        \item \textbf{nth\_element(RandomAccessIterator, RandomAccessIterator, RandomAccessIterator)} \(\mapsto\) \texttt{void}: Partially sorts the given range making sure that it is partitioned by the given element.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Binary search operations (on sorted ranges)}
    \begin{itemize}
          \item \textbf{lower\_bound(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the first element in the range [first, last) that is not less than (i.e., greater or equal to) the given value.
        \item \textbf{upper\_bound(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the first element in the range [first, last) that is greater than the given value.
        \item \textbf{binary\_search(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{bool}: Determines if an element equal to the given value exists within the range [first, last).
        \item \textbf{equal\_range(ForwardIterator, ForwardIterator, const T\&)} \(\mapsto\) \texttt{pair<ForwardIterator, ForwardIterator>}: Returns a range containing all elements equivalent to the given value in the range [first, last).
    \end{itemize}


    \bigbreak \noindent 
    \subsection{Minimum/maximum operations}
    \begin{itemize}
         \item \textbf{max(const T\&, const T\&)} \(\mapsto\) \texttt{T}: Returns the greater of the two given values.
        \item \textbf{max\_element(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the largest element in the range [first, last).
        \item \textbf{min(const T\&, const T\&)} \(\mapsto\) \texttt{T}: Returns the smaller of the two given values.
        \item \textbf{min\_element(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator to the smallest element in the range [first, last).
        \item \textbf{minmax(const T\&, const T\&)} \(\mapsto\) \texttt{pair<T, T>}: Returns a pair consisting of the smaller and larger of the two elements.
        \item \textbf{minmax\_element(ForwardIterator, ForwardIterator)} \(\mapsto\) \texttt{pair<ForwardIterator, ForwardIterator>}: Returns a pair of iterators to the smallest and the largest elements in the range [first, last).
        \item \textbf{clamp(const T\&, const T\&, const T\&)} \(\mapsto\) \texttt{T}: Clamps a value between a pair of boundary values.  If the value is less than the lower bound, it returns the lower bound. If it's greater than the upper bound, it returns the upper bound. Otherwise, it returns the value itself.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Other}
    \begin{itemize}
        \item \textbf{merge(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Merges two sorted ranges [first1, last1) and [first2, last2). The resulting range is also sorted.
        \item \textbf{inplace\_merge(BidirectionalIterator, BidirectionalIterator, BidirectionalIterator)} $\mapsto$ \texttt{void}: Merges two consecutive ordered ranges [first, middle) and [middle, last) into a single ordered range [first, last).
        \item \textbf{equal(InputIterator1, InputIterator1, InputIterator2)} $\mapsto$ \texttt{bool}: Determines if the range [InputIterator1, InputIterator1) is equal to the range starting at Inputiterator2.
        \item \textbf{is\_permutation(ForwardIterator1, ForwardIterator1, ForwardIterator2)} $\mapsto$ \texttt{bool} (C++11): Determines if the range [first1, last1) is a permutation of the range starting at first2.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Set Operations}
    \begin{itemize}
        \item \textbf{includes(InputIterator1, InputIterator1, InputIterator2, InputIterator2)} $\mapsto$ \texttt{bool}: Returns true if the range [first2, last2) is a subsequence of the range [first1, last1).
        \item \textbf{set\_difference(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the difference of two sets. The result contains elements that are in the first set but not in the second.
        \item \textbf{set\_intersection(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the intersection of two sets. The result contains elements that are present in both sets.
        \item \textbf{set\_symmetric\_difference(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the symmetric difference between two sets. The result contains elements that are in either of the sets but not in their intersection.
        \item \textbf{set\_union(InputIterator1, InputIterator1, InputIterator2, InputIterator2, OutputIterator)} $\mapsto$ \texttt{OutputIterator}: Computes the union of two sets. The result contains all elements that are present in either of the sets, without duplicates.
    \end{itemize}

    \pagebreak \bigbreak \noindent
    \section{\LARGE Iterators <iterator>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{advance(Iterator\&, Distance)}$\mapsto$ \texttt{void}: Advances the iterator by the given distance.
        \item \textbf{distance(InputIterator, InputIterator)} \(\mapsto\) \texttt{typename iterator\_traits<InputIterator>::difference\_type}: Returns the number of steps between two iterators.
        \item \textbf{begin(Container\&)} \(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the first element of the container.
        \item \textbf{end(Container\&)} \(\mapsto\) \texttt{Iterator}: Returns an iterator pointing to the past-the-end element of the container.
        \item \textbf{prev(BidirectionalIterator)} \(\mapsto\) \texttt{BidirectionalIterator}: Returns an iterator pointing to the element immediately before the given iterator.
        \item \textbf{next(ForwardIterator)} \(\mapsto\) \texttt{ForwardIterator}: Returns an iterator pointing to the element immediately after the given iterator.
    \end{itemize}


    \bigbreak \noindent 
    \subsection{Iterator generators:}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{back\_inserter(Container\&)} \(\mapsto\) \texttt{BackInsertIterator}: Constructs a back-insert iterator that appends new elements to the end of the specified container.
        \item \textbf{front\_inserter(Container\&)} \(\mapsto\) \texttt{FrontInsertIterator}: Constructs a front-insert iterator that prepends new elements to the beginning of the specified container.
        \item \textbf{inserter(Container\&, Iterator)} \(\mapsto\) \texttt{InsertIterator}: Constructs an insert iterator for inserting new elements into the container at the position specified by the given iterator.
        \item \textbf{make\_move\_iterator(Iterator)} \(\mapsto\) \texttt{MoveIterator}: Converts a regular iterator into a move iterator, causing the elements to be moved rather than copied.
    \end{itemize}
    

    \pagebreak \bigbreak \noindent 
    \section{\LARGE cstdarg (For variadic functions)}
    \bigbreak \noindent 
    \subsection{Types}
    \begin{itemize}
        \item \textbf{va\_list} Type to hold information about variable arguments 
    \end{itemize}
    \bigbreak \noindent 
    \subsection{Functions}
    \begin{itemize}
        \item \textbf{va\_start}	Initialize a variable argument list 
        \item \textbf{va\_arg} Retrieve next argument 
        \item \textbf{va\_end} End using variable argument list 
        \item \textbf{va\_copy} Copy variable argument list 
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \section{\LARGE Functional}
    \bigbreak \noindent 

    \pagebreak \bigbreak \noindent 
    \unsect{Memory stuff from Cstdlib and <cstring>}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{calloc(size\_t num, size\_t size)} $\mapsto$ \texttt{void*}: Allocate and zero-initialize an array. Returns a pointer to the allocated memory, or NULL if the allocation fails.
        \item \textbf{free(void* ptr)} $\mapsto$ \texttt{void}: Deallocate memory block. Frees the memory space pointed to by \texttt{ptr}, which must have been returned by a previous call to \texttt{malloc}, \texttt{calloc}, or \texttt{realloc}. Otherwise, or if \texttt{free(ptr)} is called more than once, undefined behavior occurs.
        \item \textbf{malloc(size\_t size)} $\mapsto$ \texttt{void*}: Allocate a memory block. Returns a pointer to the allocated memory, or NULL if the allocation fails.
        \item \textbf{realloc(void* ptr, size\_t new\_size)} $\mapsto$ \texttt{void*}: Reallocate a memory block. Changes the size of the memory block pointed to by \texttt{ptr} to \texttt{new\_size}. The function may move the memory block to a new location, in which case the new location is returned. Returns NULL if the allocation fails.
         \item \textbf{memchr(const void* str, int c, size\_t n)} $\mapsto$ \texttt{void*}: Searches for the first occurrence of the character \texttt{c} (an unsigned char) in the first \texttt{n} bytes of the string pointed to by \texttt{str}. Returns a pointer to the matching byte or NULL if the character does not occur in the given memory area.
        \item \textbf{memcmp(const void* str1, const void* str2, size\_t n)} $\mapsto$ \texttt{int}: Compares the first \texttt{n} bytes of the memory areas \texttt{str1} and \texttt{str2}. Returns an integer less than, equal to, or greater than zero if \texttt{str1} is found, respectively, to be less than, to match, or be greater than \texttt{str2}.
        \item \textbf{memset(void* str, int c, size\_t n)} $\mapsto$ \texttt{void*}: Fills the first \texttt{n} bytes of the memory area pointed to by \texttt{str} with the constant byte \texttt{c}. Returns a pointer to the memory area \texttt{str}.
        \item \textbf{memcpy(void* dest, const void* src, size\_t n)} $\mapsto$ \texttt{void*}: Copies \texttt{n} bytes from memory area \texttt{src} to memory area \texttt{dest}. The memory areas must not overlap. Returns a pointer to \texttt{dest}.
        \item \textbf{memmove(void* dest, const void* src, size\_t n)} $\mapsto$ \texttt{void*}: Moves \texttt{n} bytes from memory area \texttt{src} to memory area \texttt{dest}. The memory areas may overlap. Returns a pointer to \texttt{dest}.
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \unsect{Exception Classes <std::except>}
    \bigbreak \noindent 
    \subsection{Objects}
    \begin{itemize}
        \item \textbf{logic\_error:} exception class to indicate violations of logical preconditions or class invariants
        \item \textbf{invalid\_argument:} exception class to report invalid arguments
        \item \textbf{domain\_error:} exception class to report domain errors
        \item \textbf{length\_error:} exception class to report attempts to exceed maximum allowed size
        \item \textbf{out\_of\_range:} exception class to report arguments outside of expected range
        \item \textbf{runtime\_error:} exception class to indicate conditions only detectable at run time
        \item \textbf{range\_error:} exception class to report range errors in internal computations
        \item \textbf{overflow\_error:} exception class to report arithmetic overflows
        \item \textbf{underflow\_error:} exception class to report arithmetic underflows
    \end{itemize}
    \bigbreak \noindent 
    \nt{All of these constructors have four overloads
        \begin{enumerate}
            \item \textbf{std::string}
            \item \textbf{C-String}
            \item \textbf{Other of same type}
            \item \textbf{Other of same type (noexcept version)}
        \end{enumerate}
    }

    \bigbreak \noindent 
    \subsection{Methods}
    \begin{itemize}
        \item \textbf{what()}
    \end{itemize}

    \pagebreak 
    \unsect{c-style IO operations <cstdio>}

    \bigbreak \noindent 
    \subsection{Operations on files}
    \begin{itemize}
        \item \textbf{remove(const char* filename)} $\mapsto$ \texttt{int}: Removes the file specified by \texttt{filename}. Returns zero on success, or nonzero if an error occurs.
        \item \textbf{rename(const char* oldname, const char* newname)} $\mapsto$ \texttt{int}: Renames the file or directory specified by \texttt{oldname} to \texttt{newname}. Returns zero on success, or nonzero if an error occurs.
        \item \textbf{tmpfile(void)} $\mapsto$ \texttt{FILE*}: Creates a temporary file in binary update mode (\texttt{wb+}) that is automatically deleted when it is closed or the program terminates. Returns a pointer to the \texttt{FILE} object that represents the temporary file.
        \item \textbf{tmpnam(char* str)} $\mapsto$ \texttt{char*}: Generates and returns a unique temporary filename. If \texttt{str} is a null pointer, the temporary filename is stored in a static internal array and returned. If \texttt{str} is not a null pointer, the temporary filename is stored in \texttt{str}. Returns a pointer to the temporary filename.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{File Access}
    \begin{itemize}
        \item \textbf{fclose(FILE* stream)} $\mapsto$ \texttt{int}: Closes the file associated with the stream. Returns zero on success, or EOF if an error occurs.
        \item \textbf{fflush(FILE* stream)} $\mapsto$ \texttt{int}: Flushes the output buffer of a stream. If \texttt{stream} is NULL, flushes all output buffers. Returns zero on success, or EOF if an error occurs.
        \item \textbf{fopen(const char* filename, const char* mode)} $\mapsto$ \texttt{FILE*}: Opens the file specified by \texttt{filename} using the mode specified by \texttt{mode}. Returns a pointer to the \texttt{FILE} object associated with the opened file, or NULL if the file cannot be opened.
        \item \textbf{freopen(const char* filename, const char* mode, FILE* stream)} $\mapsto$ \texttt{FILE*}: Frees the stream and reopens the file specified by \texttt{filename} using the mode specified by \texttt{mode}. Returns a pointer to the \texttt{FILE} object associated with the reopened file, or NULL if the file cannot be opened.
        \item \textbf{setbuf(FILE* stream, char* buf)} $\mapsto$ \texttt{void}: Sets the buffer to be used by the stream for I/O operations to \texttt{buf}. If \texttt{buf} is NULL, buffering is disabled for the stream.
        \item \textbf{setvbuf(FILE* stream, char* buf, int mode, size\_t size)} $\mapsto$ \texttt{int}: Sets the buffer to be used by the stream for I/O operations to \texttt{buf} and specifies the mode of buffering. The \texttt{size} parameter specifies the size of the buffer. Returns zero on success, or nonzero if an error occurs.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Formatted input/output}
    \begin{itemize}
        \item \textbf{fprintf(FILE* stream, const char* format, ...)} $\mapsto$ \texttt{int}: Writes formatted data to the given output stream. Returns the number of characters written, or a negative value if an error occurs.
        \item \textbf{fscanf(FILE* stream, const char* format, ...)} $\mapsto$ \texttt{int}: Reads formatted input from a stream. Returns the number of input items successfully matched and assigned, which can be fewer than provided for, or even zero in the event of an early matching failure.
        \item \textbf{printf(const char* format, ...)} $\mapsto$ \texttt{int}: Prints formatted data to stdout. Returns the number of characters transmitted, or a negative value if an error occurs.
        \item \textbf{scanf(const char* format, ...)} $\mapsto$ \texttt{int}: Reads formatted input from stdin. Returns the number of items successfully read and assigned, which may be less than the number of format specifiers.
        \item \textbf{snprintf(char* str, size\_t size, const char* format, ...)} $\mapsto$ \texttt{int}: Writes formatted output to a string of up to \texttt{size} - 1 characters, including a terminating null byte. Returns the number of characters that would have been written if \texttt{size} had been sufficiently large, not counting the terminating null byte.
        \item \textbf{sprintf(char* str, const char* format, ...)} $\mapsto$ \texttt{int}: Writes formatted data to a string. Returns the number of characters written, excluding the terminating null byte.
        \item \textbf{sscanf(const char* str, const char* format, ...)} $\mapsto$ \texttt{int}: Reads formatted input from a string. Returns the number of fields successfully converted and assigned; the return value does not include fields that were read but not assigned.
        \item \textbf{vfprintf(FILE* stream, const char* format, va\_list arg)} $\mapsto$ \texttt{int}: Writes formatted data from a variable argument list to the given output stream. Returns the number of characters written, or a negative value if an error occurs.
        \item \textbf{vfscanf(FILE* stream, const char* format, va\_list arg)} $\mapsto$ \texttt{int}: Reads formatted data from a stream into a variable argument list. Returns the number of input items successfully matched and assigned.
        \item \textbf{vprintf(const char* format, va\_list arg)} $\mapsto$ \texttt{int}: Prints formatted data from a variable argument list to stdout. Returns the number of characters transmitted, or a negative value if an error occurs.
        \item \textbf{vscanf(const char* format, va\_list arg)} $\mapsto$ \texttt{int}: Reads formatted data into a variable argument list from stdin. Returns the number of items successfully read and assigned.
        \item \textbf{vsnprintf(char* str, size\_t size, const char* format, va\_list arg)} $\mapsto$ \texttt{int}: Writes formatted data from a variable argument list to a sized buffer. Returns the number of characters that would have been written if \texttt{size} had been sufficiently large, not counting the terminating null byte.
        \item \textbf{vsprintf(char* str, const char* format, va\_list arg)} $\mapsto$ \texttt{int}: Writes formatted data from a variable argument list to a string. Returns the number of characters written, excluding the terminating null byte.
        \item \textbf{vsscanf(const char* str, const char* format, va\_list arg)} $\mapsto$ \texttt{int}: Reads formatted data from a string into a variable argument list. Returns the number of fields successfully converted and assigned.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Character input/output}
    \begin{itemize}
        \item \textbf{fgetc(FILE* stream)} $\mapsto$ \texttt{int}: Gets the next character (an unsigned char) from the specified stream and advances the position indicator for the stream. Returns the character read as an unsigned char cast to an int or EOF on end of file or error.
        \item \textbf{fgets(char* str, int n, FILE* stream)} $\mapsto$ \texttt{char*}: Reads in at most one less than \texttt{n} characters from stream and stores them into the buffer pointed to by \texttt{str}. Reading stops after an EOF or a newline. If a newline is read, it is stored into the buffer. A terminating null byte ('\textbackslash0') is stored after the last character in the buffer. Returns \texttt{str} on success, and NULL on error or when end of file occurs while no characters have been read.
        \item \textbf{fputc(int char, FILE* stream)} $\mapsto$ \texttt{int}: Writes the character \texttt{char} (an unsigned char) to the specified stream and advances the position indicator for the stream. Returns the character written as an unsigned char cast to an int or EOF on error.
        \item \textbf{fputs(const char* str, FILE* stream)} $\mapsto$ \texttt{int}: Writes a string to the specified stream up to but not including the null character. Returns a nonnegative number on success, or EOF on error.
        \item \textbf{getc(FILE* stream)} $\mapsto$ \texttt{int}: Gets the next character (an unsigned char) from the specified stream and advances the position indicator for the stream. This function may be implemented as a macro. Returns the character read as an unsigned char cast to an int or EOF on end of file or error.
        \item \textbf{getchar(void)} $\mapsto$ \texttt{int}: Gets the next character (an unsigned char) from stdin and advances the position indicator for the stream. Returns the character read as an unsigned char cast to an int or EOF on end of file or error.
        \item \textbf{gets(char* str)} $\mapsto$ \texttt{char*} (**Deprecated and dangerous**): Reads a line from stdin into the buffer pointed to by \texttt{str} until either a terminating newline or EOF, which it replaces with a null byte ('\textbackslash0'). No check for buffer overrun is performed (please use \texttt{fgets} instead). Returns \texttt{str} on success, and NULL on error or when end of file occurs while no characters have been read.
        \item \textbf{putc(int char, FILE* stream)} $\mapsto$ \texttt{int}: Writes the character \texttt{char} (an unsigned char) to the specified stream and advances the position indicator for the stream. This function may be implemented as a macro. Returns the character written as an unsigned char cast to an int or EOF on error.
        \item \textbf{putchar(int char)} $\mapsto$ \texttt{int}: Writes the character \texttt{char} (an unsigned char) to stdout and advances the position indicator for the stream. Returns the character written as an unsigned char cast to an int or EOF on error.
        \item \textbf{puts(const char* str)} $\mapsto$ \texttt{int}: Writes the string \texttt{str} and a trailing newline to stdout. Returns a nonnegative number on success, or EOF on error.
        \item \textbf{ungetc(int char, FILE* stream)} $\mapsto$ \texttt{int}: Pushes the character \texttt{char} (an unsigned char) back onto the input buffer of the specified stream. The character will be returned by the next read on that stream. Returns the character pushed back after cast to unsigned char and then to int, or EOF on error.
    \end{itemize}


    \bigbreak \noindent 
    \subsection{Direct input/output}
    \begin{itemize}
        \item \textbf{fread(void* ptr, size\_t size, size\_t nmemb, FILE* stream)} $\mapsto$ \texttt{size\_t}: Reads \texttt{nmemb} items of data, each \texttt{size} bytes long, from the stream pointed to by \texttt{stream}, storing them at the location given by \texttt{ptr}. Returns the number of items (not bytes) successfully read which may be less than \texttt{nmemb} if an error occurs or if the end of file is reached before reaching \texttt{nmemb}.
        \item \textbf{fwrite(const void* ptr, size\_t size, size\_t nmemb, FILE* stream)} $\mapsto$ \texttt{size\_t}: Writes \texttt{nmemb} items of data, each \texttt{size} bytes long, to the stream pointed to by \texttt{stream}, obtaining them from the location given by \texttt{ptr}. Returns the number of items successfully written, which may be less than \texttt{nmemb} if an error occurs.
    \end{itemize}


    \bigbreak \noindent 
    \subsection{File positioning}
    \begin{itemize}
        \item \textbf{fgetpos(FILE* stream, fpos\_t* pos)} $\mapsto$ \texttt{int}: Gets the current file position of the stream and stores it in the object pointed to by \texttt{pos}. Returns zero on success, or nonzero on error.
        \item \textbf{fseek(FILE* stream, long int offset, int whence)} $\mapsto$ \texttt{int}: Sets the file position of the stream to the given offset. The new position, measured in bytes, is obtained by adding \texttt{offset} bytes to the position specified by \texttt{whence}. If \texttt{whence} is set to \texttt{SEEK\_SET}, \texttt{SEEK\_CUR}, or \texttt{SEEK\_END}, the offset is relative to the start of the file, the current file position, or the end of the file, respectively. Returns zero on success, or nonzero on error.
        \item \textbf{fsetpos(FILE* stream, const fpos\_t* pos)} $\mapsto$ \texttt{int}: Sets the file position of the stream to the position specified by \texttt{pos}, which is a position given by a previous call to \texttt{fgetpos}. Returns zero on success, or nonzero on error.
        \item \textbf{ftell(FILE* stream)} $\mapsto$ \texttt{long int}: Returns the current file position of the stream, or -1 on an error.
        \item \textbf{rewind(FILE* stream)} $\mapsto$ \texttt{void}: Sets the file position to the beginning of the file of the given stream. Also clears the error and the end-of-file indicators for the stream.
    \end{itemize}


    \bigbreak \noindent 
    \subsection{Error-handling}
    \begin{itemize}
        \item \textbf{clearerr(FILE* stream)} $\mapsto$ \texttt{void}: Clears both the end-of-file and the error indicators for the stream. This function does not return a value.
        \item \textbf{feof(FILE* stream)} $\mapsto$ \texttt{int}: Checks the end-of-file indicator for the given stream. Returns a nonzero value if the end-of-file indicator is set for \texttt{stream}, otherwise zero.
        \item \textbf{ferror(FILE* stream)} $\mapsto$ \texttt{int}: Checks the error indicator for the given stream. Returns a nonzero value if the error indicator is set for \texttt{stream}, otherwise zero.
        \item \textbf{perror(const char* s)} $\mapsto$ \texttt{void}: Prints a descriptive error message to stderr. First, if the string \texttt{s} is not NULL and does not point to an empty string, this string is printed followed by a colon and a space. Then an error message corresponding to the current value of the global variable \texttt{errno} is printed, followed by a newline. This function does not return a value.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Macros}
    \begin{itemize}
        \item \textbf{BUFSIZ}: This macro constant expands to an integral expression with the size of the buffer used by the setbuf function.
        \item \textbf{EOF}: It is a macro definition of type int that expands into a negative integral constant expression (generally, -1).
        \item \textbf{FILENAME\_MAX}: This macro constant expands to an integral expression corresponding to the size needed for an array of char elements to hold the longest file name string allowed by the library.
        \item \textbf{FOPEN\_MAX}: This macro constant expands to an integral expression that represents the maximum number of files that can be opened simultaneously.
        \item \textbf{L\_tmpna}: This macro constant expands to an integral expression corresponding to the size needed for an array of char elements to hold the longest file name string possibly generated by tmpnam.
        \item \textbf{NULL}: This macro expands to a null pointer constant.
        \item \textbf{TMP\_MAX}: This macro expands to the minimum number of unique temporary file names that are guaranteed to be possible to generate using tmpnam.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Types}
    \begin{itemize}
        \item \textbf{FILE}	Object containing information to control a stream (type)
        \item \textbf{fpos\_t}	Object containing information to specify a position within a file (type)
        \item \textbf{size\_t}	Unsigned integral type (type)
    \end{itemize}

    \pagebreak 
    \unsect{Miscellaneous utilities: <cstdlib>}
    \bigbreak \noindent 
    \subsection{Process control}
    \begin{itemize}
        \item \textbf{abort(void)} $\mapsto$ \texttt{void}: Causes abnormal program termination without cleaning up. The program terminates as if by calling `std::terminate`, and the termination status is implementation-defined. This function does not return.
        \item \textbf{exit(int status)} $\mapsto$ \texttt{void}: Causes normal program termination with cleaning up. Performs standard cleanup for program termination (like flushing buffers) and calls the functions registered by `std::atexit`, then terminates the program with the given status. This function does not return.
        \item \textbf{quick\_exit(int status)} $\mapsto$ \texttt{void} (\textbf{C++11}): Causes quick program termination without completely cleaning up. Calls the functions registered by `std::at\_quick\_exit` and terminates the program with the given status, without calling destructors for objects of automatic, thread, or static storage duration. This function does not return.
        \item \textbf{\_Exit(int status)} $\mapsto$ \texttt{void} (\textbf{C++11}): Causes normal program termination without cleaning up, similar to `abort`. It terminates the program without calling destructors or any functions registered with `std::atexit` or `std::at\_quick\_exit`. This function does not return.
        \item \textbf{atexit(void (*func)(void))} $\mapsto$ \texttt{int}: Registers a function to be called on `std::exit()` invocation. The specified function is called when the program terminates normally. Returns zero on success, non-zero if the registration fails.
        \item \textbf{at\_quick\_exit(void (*func)(void))} $\mapsto$ \texttt{int} (\textbf{C++11}): Registers a function to be called on `std::quick\_exit` invocation. The specified function is called when the program terminates via `std::quick\_exit`. Returns zero on success, non-zero if the registration fails.
        \item \textbf{system(const char* command)} $\mapsto$ \texttt{int}: Calls the host environment's command processor (`/bin/sh` on Unix, `CMD.EXE` on Windows) with the specified command. Returns an implementation-defined value if successful, and a negative value if an error occurs or if the command processor is not available.
        \item \textbf{getenv(const char* name)} $\mapsto$ \texttt{char*}: Provides access to the list of environment variables. Returns a pointer to the value associated with the environment variable `name`, or `NULL` if the variable is not found. The returned pointer points to static data whose content should not be modified.
    \end{itemize}

    \pagebreak 
    \unsect{Posix regex API <regex.h>}
    \bigbreak \noindent 
    \nt{This is not the standard regex library}
    \begin{itemize}
        \item \textbf{regcomp(regex\_t *preg, const char *regex, int cflags)} $\mapsto$ \texttt{int}: Compiles a regular expression into a format that can be used for pattern matching. It stores the result in the object pointed to by \texttt{preg}. The \texttt{cflags} argument is used to customize the compilation process. Returns zero on success, and a non-zero error code on failure.
        \item \textbf{regexec(const regex\_t *preg, const char *string, size\_t nmatch, regmatch\_t pmatch[], int eflags)} $\mapsto$ \texttt{int}: Matches a null-terminated string against the precompiled pattern specified by \texttt{preg}. \texttt{nmatch} and \texttt{pmatch} are used to specify how many matches to find and where to store them. The \texttt{eflags} argument can be used to modify the execution behavior. Returns zero if the regular expression matches; otherwise, returns a non-zero value indicating the error or mismatch.
        \item \textbf{regerror(int errcode, const regex\_t *preg, char *errbuf, size\_t errbuf\_size)} $\mapsto$ \texttt{size\_t}: Translates an error code returned by `regcomp()` or `regexec()` into a human-readable error message. The error message is stored in `errbuf`, which is a buffer provided by the caller, with a maximum size specified by `errbuf\_size`. Returns the size of the error message (including the terminating null byte). If `errbuf\_size` is too small to hold the error message, the message is truncated but the return value still reflects the full length of the message.
        \item \textbf{regfree(regex\_t *preg)} $\mapsto$ \texttt{void}: Frees any memory that was allocated by `regcomp()` for the compiled regular expression pointed to by `preg`. After calling `regfree()`, the `regex\_t` object should not be used again until it has been reinitialized by another call to `regcomp()`.
    \end{itemize}

    \pagebreak 
    \unsect{
        Directory Input/Output <dirent.h>
    }
    \begin{itemize}
        \item \textbf{chdir(const char *path)} $\mapsto$ \texttt{int}: Changes the current working directory of the calling process to the directory specified in \texttt{path}. Returns zero on success, and -1 on failure, setting \texttt{errno} to indicate the error.
        \item \textbf{getcwd(char *buf, size\_t size)} $\mapsto$ \texttt{char*}: Copies an absolute pathname of the current working directory to the array pointed to by \texttt{buf}, which is of length \texttt{size}. If \texttt{size} is large enough, returns \texttt{buf}; if \texttt{size} is too small, NULL is returned, and \texttt{errno} is set to \texttt{ERANGE}; on other errors, NULL is returned, and \texttt{errno} is set appropriately.
        \item \textbf{opendir(const char *name)} $\mapsto$ \texttt{DIR*}: Opens a directory stream corresponding to the directory name, and returns a pointer to the directory stream. The stream is positioned at the first entry in the directory. Returns NULL if an error occurs, setting \texttt{errno} to indicate the error.
        \item \textbf{readdir(DIR *dirp)} $\mapsto$ \texttt{struct dirent*}: Reads the next directory entry from the directory stream pointed to by \texttt{dirp}. Returns a pointer to a \texttt{struct dirent} representing the next directory entry, or NULL when reaching the end of the directory stream or if an error occurs.
    \end{itemize}
    \bigbreak \noindent 
    \subsection{The DIR type}
    \bigbreak \noindent 
    The DIR type is an opaque data type that represents a directory stream. A directory stream is an ordered sequence of all the directory entries in a particular directory. Directory entries include files, subdirectories, and other types of file system objects contained in the directory.
    \bigbreak \noindent 
    You cannot see the structure of DIR directly, as it is hidden (opaque) to provide abstraction and portability across different operating systems and filesystems. This means you interact with directory streams using pointer variables of type DIR *, and you manipulate these streams through the functions provided by <dirent.h>, such as opendir(), readdir(), and closedir().
    \bigbreak \noindent 
    \subsection{dirent Structure}
    \bigbreak \noindent 
    The struct dirent structure represents an individual directory entry, which could be a file, a subdirectory, or another type of file system object. The exact contents of this structure can vary between different operating systems, but it generally includes the following members:

    \begin{itemize}
        \item \textbf{d\_ino:} The inode number of the directory entry. The inode number is a unique identifier within a filesystem.
        \item \textbf{d\_name:} A character array (string)} containing the name of the directory entry. This name is not the full path, but just the filename or directory name.
    \end{itemize}
    \bigbreak \noindent 
    \subsubsection{Example}
    \bigbreak \noindent 
    \begin{cppcode}
    DIR* d;
    struct dirent* dir;
    d = opendir("."); // Open the current directory
    
    if (d) {
        while ((dir = readdir(d)) != NULL) {
            printf("%s\n", dir->d_name); // Print the name of each directory entry
        }
        closedir(d); // Close the directory stream
    }

    return 0;

    \end{cppcode}

    \pagebreak 

    \pagebreak 
    \unsect{Type traits <type\_traits>}
    \bigbreak \noindent 
    \subsection{Primary type categories}
        \begin{itemize}
            \item \texttt{is\_void} (C++11): checks if a type is void (class template)
            \item \texttt{is\_null\_pointer} (C++14): checks if a type is \texttt{std::nullptr\_t} (class template)
            \item \texttt{is\_integral} (C++11): checks if a type is an integral type (class template)
            \item \texttt{is\_floating\_point} (C++11): checks if a type is a floating-point type (class template)
            \item \texttt{is\_array} (C++11): checks if a type is an array type (class template)
            \item \texttt{is\_enum} (C++11): checks if a type is an enumeration type (class template)
            \item \texttt{is\_union} (C++11): checks if a type is a union type (class template)
            \item \texttt{is\_class} (C++11): checks if a type is a non-union class type (class template)
            \item \texttt{is\_function} (C++11): checks if a type is a function type (class template)
            \item \texttt{is\_pointer} (C++11): checks if a type is a pointer type (class template)
            \item \texttt{is\_lvalue\_reference} (C++11): checks if a type is an lvalue reference (class template)
            \item \texttt{is\_rvalue\_reference} (C++11): checks if a type is an rvalue reference (class template)
            \item \texttt{is\_member\_object\_pointer} (C++11): checks if a type is a pointer to a non-static member object (class template)
            \item \texttt{is\_member\_function\_pointer} (C++11): checks if a type is a pointer to a non-static member function (class template)
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Composite type categories}
        \bigbreak \noindent 
        \begin{itemize}
            \item \texttt{is\_fundamental}: checks if a type is a fundamental type (class template)
            \item \texttt{is\_arithmetic}: checks if a type is an arithmetic type (class template)
            \item \texttt{is\_scalar}: checks if a type is a scalar type (class template)
            \item \texttt{is\_object}: checks if a type is an object type (class template)
            \item \texttt{is\_compound}: checks if a type is a compound type (class template)
            \item \texttt{is\_reference}: checks if a type is either an lvalue reference or rvalue reference (class template)
            \item \texttt{is\_member\_pointer}: checks if a type is a pointer to a non-static member function or object (class template)
        \end{itemize}

        \pagebreak 
        \subsection{Type properties}
        \begin{itemize}
            \item \texttt{is\_const}: checks if a type is const-qualified (class template)
            \item \texttt{is\_volatile}: checks if a type is volatile-qualified (class template)
            \item \texttt{is\_trivial}: checks if a type is trivial (class template)
            \item \texttt{is\_trivially\_copyable}: checks if a type is trivially copyable (class template)
            \item \texttt{is\_standard\_layout}: checks if a type is a standard-layout type (class template)
            \item \texttt{is\_pod} (deprecated in C++20): checks if a type is a plain-old data (POD) type (class template)
            \item \texttt{has\_unique\_object\_representations}: checks if every bit in the type's object representation contributes to its value (class template)
            \item \texttt{is\_empty}: checks if a type is a class (but not union) type and has no non-static data members (class template)
            \item \texttt{is\_polymorphic}: checks if a type is a polymorphic class type (class template)
            \item \texttt{is\_abstract}: checks if a type is an abstract class type (class template)
            \item \texttt{is\_final}: checks if a type is a final class type (class template)
            \item \texttt{is\_aggregate}: checks if a type is an aggregate type (class template)
            \item \texttt{is\_implicit\_lifetime}: checks if a type is an implicit-lifetime type (class template)
            \item \texttt{is\_signed}: checks if a type is a signed arithmetic type (class template)
            \item \texttt{is\_unsigned}: checks if a type is an unsigned arithmetic type (class template)
            \item \texttt{is\_bounded\_array}: checks if a type is an array type of known bound (class template)
            \item \texttt{is\_unbounded\_array}: checks if a type is an array type of unknown bound (class template)
            \item \texttt{is\_scoped\_enum}: checks if a type is a scoped enumeration type (class template)
        \end{itemize}

        \pagebreak 
        \subsection{Type relationships}
        \begin{itemize}
            \item \texttt{is\_same}: checks if two types are the same (class template)
            \item \texttt{is\_base\_of}: checks if a type is a base of the other type (class template)
            \item \texttt{is\_virtual\_base\_of}: checks if a type is a virtual base of the other type (class template)
            \item \texttt{is\_convertible}: checks if a type can be converted to the other type (class template)
            \item \texttt{is\_nothrow\_convertible}: checks if a type can be converted to the other type without throwing exceptions (class template)
            \item \texttt{is\_layout\_compatible}: checks if two types are layout-compatible (class template)
            \item \texttt{is\_pointer\_interconvertible\_base\_of}: checks if a type is a pointer-interconvertible (initial) base of another type (class template)
            \item \texttt{is\_invocable}: checks if a type can be invoked (as if by \texttt{std::invoke}) with the given argument types (class template)
            \item \texttt{is\_invocable\_r}: checks if a type can be invoked with the given argument types, returning a specific result type (class template)
            \item \texttt{is\_nothrow\_invocable}: checks if a type can be invoked without throwing exceptions (class template)
            \item \texttt{is\_nothrow\_invocable\_r}: checks if a type can be invoked with the given argument types, returning a specific result type without throwing exceptions (class template)
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Const-volatility specifiers}
        \bigbreak \noindent 
        \begin{itemize}
            \item \texttt{remove\_cv}: removes both const and volatile specifiers from the given type (class template)
            \item \texttt{remove\_const}: removes the const specifier from the given type (class template)
            \item \texttt{remove\_volatile}: removes the volatile specifier from the given type (class template)
            \item \texttt{add\_cv}: adds both const and volatile specifiers to the given type (class template)
            \item \texttt{add\_const}: adds the const specifier to the given type (class template)
            \item \texttt{add\_volatile}: adds the volatile specifier to the given type (class template)
        \end{itemize}

        \pagebreak 
        \subsection{References}
        \begin{itemize}
            \item \texttt{remove\_reference}: removes a reference from the given type (class template)
            \item \texttt{add\_lvalue\_reference}: adds an lvalue reference to the given type (class template)
            \item \texttt{add\_rvalue\_reference}: adds an rvalue reference to the given type (class template)
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Pointers}
        \begin{itemize}
            \item \texttt{remove\_pointer}: removes a pointer from the given type (class template)
            \item \texttt{add\_pointer}: adds a pointer to the given type (class template)
        \end{itemize}


        \bigbreak \noindent 
        \subsection{Sign modifiers}
        \begin{itemize}
            \item \texttt{make\_signed}: obtains the corresponding signed type for the given integral type (class template)
            \item \texttt{make\_unsigned}: obtains the corresponding unsigned type for the given integral type (class template)
        \end{itemize}

        \pagebreak 
        \subsection{Miscellaneous transformations}
        \bigbreak \noindent 
        \begin{itemize}
            \item \texttt{aligned\_storage} (deprecated in C++23): defines the type suitable for use as uninitialized storage for types of given size (class template)
            \item \texttt{aligned\_union} (deprecated in C++23): defines the type suitable for use as uninitialized storage for all given types (class template)
            \item \texttt{decay}: applies type transformations as when passing a function argument by value (class template)
            \item \texttt{remove\_cvref}: combines \texttt{std::remove\_cv} and \texttt{std::remove\_reference} (class template)
            \item \texttt{enable\_if}: conditionally removes a function overload or template specialization from overload resolution (class template)
            \item \texttt{conditional}: chooses one type or another based on compile-time boolean (class template)
            \item \texttt{common\_type}: determines the common type of a group of types (class template)
            \item \texttt{common\_reference} and \texttt{basic\_common\_reference}: determines the common reference type of a group of types (class template)
            \item \texttt{underlying\_type}: obtains the underlying integer type for a given enumeration type (class template)
            \item \texttt{result\_of} (removed in C++20) and \texttt{invoke\_result}: deduces the result type of invoking a callable object with a set of arguments (class template)
            \item \texttt{void\_t}: void variadic alias template (alias template)
            \item \texttt{type\_identity}: returns the type argument unchanged (class template)
            \item \texttt{unwrap\_reference} and \texttt{unwrap\_ref\_decay}: get the reference type wrapped in \texttt{std::reference\_wrapper} (class template)
        \end{itemize}

        \pagebreak 
        \subsection{Most common}
        \begin{itemize}
            \item \texttt{std::is\_integral}: Checks if a type is an integral type (e.g., \texttt{int}, \texttt{bool}).
            \item \texttt{std::is\_floating\_point}: Checks if a type is a floating-point type (e.g., \texttt{float}, \texttt{double}).
            \item \texttt{std::is\_pointer}: Checks if a type is a pointer type.
            \item \texttt{std::is\_const}: Checks if a type is \texttt{const}-qualified.
            \item \texttt{std::is\_reference}: Checks if a type is either an lvalue or rvalue reference.
            \item \texttt{std::is\_same}: Checks if two types are the same.
            \item \texttt{std::is\_class}: Checks if a type is a class (excluding union).
            \item \texttt{std::is\_array}: Checks if a type is an array type.
            \item \texttt{std::enable\_if}: Conditionally includes/excludes function overloads or template specializations based on a compile-time condition.
            \item \texttt{std::remove\_cv}: Removes \texttt{const} and \texttt{volatile} qualifiers from a type.
            \item \texttt{std::remove\_reference}: Removes lvalue or rvalue reference from a type.
            \item \texttt{std::decay}: Transforms a type similarly to how it would be passed to a function by value (removes references, \texttt{const}, etc.).
            \item \texttt{std::underlying\_type}: Retrieves the underlying type of an enumeration.
        \end{itemize}

        \pagebreak 
        \unsect{Smart pointers}
        \bigbreak \noindent 
        \subsection{Unique\_ptr}
        \bigbreak \noindent 
        \subsubsection{Constructors}
        \bigbreak \noindent 
        \begin{itemize}
            \item \textbf{std::unique\_ptr();}	Default constructor (holds nullptr).
            \item \textbf{explicit std::unique\_ptr(T* ptr);}	Takes ownership of a raw pointer.
            \item \textbf{explicit std::unique\_ptr(T* ptr, Deleter d);}	Takes ownership and uses a custom deleter.
            \item \textbf{std::unique\_ptr(std::unique\_ptr\&\& other) noexcept;}	Move constructor (transfers ownership).
            \item \textbf{explicit std::unique\_ptr(T[] ptr);}	Specialized constructor for arrays.
            \item \textbf{explicit std::unique\_ptr(T[] ptr, Deleter d);}	Specialized constructor for arrays with a custom deleter.
        \end{itemize}
        \bigbreak \noindent 
        The explicit keyword prevents implicit conversions, ensuring that std::unique\_ptr is only created in a deliberate and controlled way. This helps avoid unintended behavior, especially when working with raw pointers and preventing accidental ownership transfer.
        \bigbreak \noindent 
        \begin{cppcode}
        std::unique_ptr<int> up1 = new int(10);  // ERROR: Cannot implicitly convert
        std::unique_ptr<int> up2(new int(10));   // OK: Explicitly calling the constructor
        \end{cppcode}
        \bigbreak \noindent 
        \subsubsection{Modifer methods}
        \bigbreak \noindent 
        \begin{itemize}
            \item \textbf{pointer release()}: returns a pointer to the managed object and releases the ownership
            \item \textbf{void reset(ptr)}: replaces the managed object
            \item \textbf{void swap(other)}: swaps the managed objects
        \end{itemize}

        \bigbreak \noindent 
        \subsubsection{Observers}
        \begin{itemize}
            \item \textbf{pointer get()}: returns a pointer to the managed object
            \item \textbf{Deleter\& get\_deleter()}: returns the deleter that is used for destruction of the managed object
            \item \textbf{bool operator bool}: checks if there is an associated managed object, true if *this owns an object, false otherwise.
        \end{itemize}

        \bigbreak \noindent 
        \subsubsection{Operators}
        \bigbreak \noindent 
        We have operator bool, dereference (*), the arrow operator (->), index operator ([]), output operator (<<), and the comparison operators. Comparison operators compare the pointer not the value 

        \bigbreak \noindent 
        \subsubsection{Non member functions}
        \begin{itemize}
            \item \textbf{unique\_ptr<T> make\_unique(args, size)}: creates a unique pointer that manages a new object
            \item \textbf{unique\_ptr<T> make\_unique\_for\_overwrite(args, size)} creates a unique pointer that manages a new object
            \item \textbf{void swap(lhs,rhs)}: specializes the std::swap algorithm
        \end{itemize}

        \pagebreak 
        \subsection{shared\_ptr}
        \bigbreak \noindent 
        \subsubsection{Constructors}
        \bigbreak \noindent 
        \begin{itemize}
            \item \textbf{std::shared\_ptr();}	Default constructor (holds nullptr).
            \item \textbf{explicit std::shared\_ptr(T* ptr);}	Takes ownership of a raw pointer and enables shared ownership.
            \item \textbf{std::shared\_ptr(T* ptr, Deleter d);}	Takes ownership with a custom deleter.
            \item \textbf{std::shared\_ptr(T* ptr, Deleter d, Allocator a);}	Takes ownership with a custom deleter and allocator.
            \item \textbf{std::shared\_ptr(const std::shared\_ptr\& other);}	Copy constructor (increments reference count).
            \item \textbf{std::shared\_ptr(std::shared\_ptr\&\& other) noexcept;}	Move constructor (transfers ownership, does not increase reference count).
            \item \textbf{template<class Y> std::shared\_ptr(const std::shared\_ptr<Y>\& other);}	Copy constructor for related types (e.g., shared\_ptr<Derived> to shared\_ptr<Base>).
            \item \textbf{template<class Y> std::shared\_ptr(std::shared\_ptr<Y>\&\& other);}	Move constructor for related types.
            \item \textbf{template<class Y> explicit std::shared\_ptr(const std::weak\_ptr<Y>\& other);}	Creates a shared\_ptr from a weak\_ptr, if the resource is still available.
            \item \textbf{explicit std::shared\_ptr(std::nullptr\_t);}	Constructs a shared\_ptr that holds nullptr.
        \end{itemize}

        \bigbreak \noindent 
        \subsubsection{Modifiers}
        \begin{itemize}
            \item \textbf{void reset(ptr, deleter(optional), allocator(optional))}: replaces the managed object
            \item \textbf{void swap(other)}: swaps the managed objects
        \end{itemize}

        \bigbreak \noindent 
        \subsubsection{Observers}
        \begin{itemize}
            \item \textbf{pointer get()}: returns the stored pointer
            \item \textbf{long use\_count()}: returns the number of shared\_ptr objects referring to the same managed object
            \item \textbf{bool unique()}: checks whether the managed object is managed only by the current shared\_ptr object
            \item \textbf{operator bool:}
            \item \textbf{bool owner\_before(other):} provides owner-based ordering of shared pointers. used to compare ownership order of std::shared\_ptr (or std::weak\_ptr). It does not compare the actual pointer values but rather their control blocks (ownership metadata)
                \bigbreak \noindent 
                \begin{cppcode}
                    std::shared_ptr<int> sp1 = std::make_shared<int>(10);
                    std::shared_ptr<int> sp2 = std::make_shared<int>(20);

                    if (sp1.owner_before(sp2)) {
                        std::cout << "sp1's ownership is before sp2\n";
                    } else if (sp2.owner_before(sp1)) {
                        std::cout << "sp2's ownership is before sp1\n";
                    } else {
                        std::cout << "sp1 and sp2 have the same ownership\n";
                    }
                \end{cppcode}
            \item \textbf{bool owner\_equal(other):} provides owner-based equal comparison of shared pointers
                \bigbreak \noindent 
                Checks whether this shared\_ptr and other share ownership or are both empty. The comparison is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object
            \item \textbf{bool operator bool()}: Checks if *this stores a non-null pointer
        \end{itemize}

        \bigbreak \noindent 
        \subsubsection{Overloads}
        \bigbreak \noindent 
        We have operator bool, dereference, arrow, index operator, operator <<, and all comparision operators 
        \bigbreak \noindent 
        Note that the comparison operators do not compare the value that the pointer points to, but rather the object itself.
        \bigbreak \noindent 
        \begin{cppcode}
            shared_ptr<int> ptr1 = std::make_shared<int>(20);
            shared_ptr<int> ptr2 = std::make_shared<int>(20);

            cout << (ptr1 == ptr2) << endl; // False

            shared_ptr<int> ptr3 = std::make_shared<int>(20);
            shared_ptr<int> ptr4 = ptr3;

            cout << (ptr3 == ptr4) << endl; // True
        \end{cppcode}
        \bigbreak \noindent 
        Further note that the output stream operator (<<) outputs the value of the ptr (the address that it holds)
        \bigbreak \noindent 
        \begin{cppcode}
            shared_ptr<int> ptr1 = std::make_shared<int>(20);
            cout << ptr1; // 0x55e55983b2c0
        \end{cppcode}

        \bigbreak \noindent 
        \subsubsection{Non member functions}
        \begin{itemize}
            \item \textbf{make\_shared:} creates a shared pointer that manages a new object
            \item \textbf{make\_shared\_for\_overwrite:} creates a shared pointer that manages a new object
            \item \textbf{allocate\_shared} creates a shared pointer that manages a new object allocated using an allocator
            \item \textbf{allocate\_shared\_for\_overwrite} creates a shared pointer that manages a new object allocated using an allocator
            \item \textbf{static\_pointer\_cast} applies static\_cast, dynamic\_cast, const\_cast, or reinterpret\_cast to the stored pointer
            \item \textbf{dynamic\_pointer\_cast} applies static\_cast, dynamic\_cast, const\_cast, or reinterpret\_cast to the stored pointer
            \item \textbf{const\_pointer\_cast} applies static\_cast, dynamic\_cast, const\_cast, or reinterpret\_cast to the stored pointer
            \item \textbf{reinterpret\_pointer\_cast} applies static\_cast, dynamic\_cast, const\_cast, or reinterpret\_cast to the stored pointer
            \item \textbf{std::swap(std::shared\_ptr)}: specializes the std::swap algorithm
        \end{itemize}

        \pagebreak 
        \subsection{weak\_ptr}
        \bigbreak \noindent 
        \subsubsection{Constructors}
        \begin{itemize}
            \item \textbf{std::weak\_ptr();}	Default constructor (creates an empty weak pointer).
            \item \textbf{std::weak\_ptr(const std::weak\_ptr\& other);}	Copy constructor (creates a new weak pointer that shares the ownership control block).
            \item \textbf{std::weak\_ptr(std::weak\_ptr\&\& other) noexcept;}	Move constructor (transfers ownership of the weak reference).
            \item \textbf{template<class Y> std::weak\_ptr(const std::weak\_ptr<Y>\& other);}	Copy constructor for related types.
            \item \textbf{template<class Y> std::weak\_ptr(std::weak\_ptr<Y>\&\& other);}	Move constructor for related types.
            \item \textbf{template<class Y> std::weak\_ptr(const std::shared\_ptr<Y>\& other);}	Constructs a weak\_ptr from a shared\_ptr, sharing ownership control but not ownership of the resource.
        \end{itemize}

        \bigbreak \noindent 
        \subsubsection{Modifiers}
        \begin{itemize}
            \item \textbf{void reset()}: Releases the reference to the managed object 
            \item \textbf{void swap(other)} swaps the managed objects
        \end{itemize}

        \bigbreak \noindent 
        \subsubsection{Observers}
        \begin{itemize}
            \item \textbf{long use\_count()}: returns the number of shared\_ptr objects that manage the object
            \item \textbf{bool expired()}: checks whether the referenced object was already deleted
            \item \textbf{shared\_ptr<T> lock()}: creates a shared\_ptr that manages the referenced object
            \item \textbf{bool owner\_before(other)}: provides owner-based ordering of weak pointers
            \item \textbf{bool owner\_equal(other)}: provides owner-based equal comparison of weak pointers
        \end{itemize}
        \bigbreak \noindent 
        \textbf{Note:} No operator overloads
        \bigbreak \noindent 
        \subsubsection{Non member functions}
        \begin{itemize}
            \item \textbf{void std::swap(lhs,rhs)}: specializes the std::swap algorithm
        \end{itemize}

        \pagebreak 
        \unsect{std::bitset <bitset>}
        \bigbreak \noindent 
        \subsection{Element access}
        \begin{itemize}
            \item \textbf{std::bitset::reference operator[]:} accesses specific bit
            \item \textbf{bool all():} checks if all of the bits are set to true
            \item \textbf{bool any():} checks if any of the bits are set to true
            \item \textbf{bool none():} checks if none of the bits are set to true
            \item \textbf{size\_t count():} returns the number of bits set to true
        \end{itemize}

        \bigbreak \noindent 
        \subsection{capacity}
        \begin{itemize}
            \item \textbf{size\_t size()}: returns the number of bits that the bitset holds
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Modifiers}
        \begin{itemize}
            \item \textbf{operator\&=:} performs binary AND
            \item \textbf{operator|=:} performs binary OR
            \item \textbf{operator$^{\land}$=:} performs binary XOR
            \item \textbf{operator$\sim$:} performs binary NOT
            \item \textbf{operator<<=:} performs binary shift left
            \item \textbf{operator>>=:} performs binary shift right
            \item \textbf{operator<<:} performs binary shift left
            \item \textbf{operator>>:} performs binary shift right
            \item \textbf{*this set(pos, value=true):} sets bits to true or given value
            \item \textbf{*this reset(pos):} sets bits to false
            \item \textbf{*this flip(pos):} toggles the values of bits
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Conversions}
        \begin{itemize}
            \item \textbf{string to\_string(zero,one):} returns a string representation of the data. Zero is character to use to represent false, one character to use to represent true
            \item \textbf{unsigned long to\_ulong():} returns an unsigned long integer representation of the data
            \item \textbf{unsigned long long to\_ullong():} returns an unsigned long long integer representation of the data
        \end{itemize}

        \pagebreak 
        \unsect{std::basic\_string\_view}
        \bigbreak \noindent 
        \subsection{Element access}
        \begin{itemize}
            \item \textbf{T\& operator[pos]}: accesses the specified character
            \item \textbf{T\& at(pos)}: accesses the specified character with bounds checking
            \item \textbf{T\& front()}: accesses the first character
            \item \textbf{T\& back()}: accesses the last character
            \item \textbf{char* data()}: returns a pointer to the first character of a view
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Capacity}
        \begin{itemize}
            \item \textbf{size_t size()}: returns the number of characters
            \item \textbf{size_t length()}: returns the number of characters
            \item \textbf{size_t max\_size()}: returns the maximum number of characters
            \item \textbf{bool empty()}: checks whether the view is empty
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Modifiers}
        \begin{itemize}
            \item \textbf{void remove\_prefix(n)}: shrinks the view by moving its start forward
            \item \textbf{void remove\_suffix(n)}: shrinks the view by moving its end backward
            \item \textbf{void swap(other)}: swaps the contents
        \end{itemize}

        \bigbreak \noindent 
        \subsection{Operations}
        \begin{itemize}
            \item \textbf{size\_t copy(char* dest, count, pos=0)}: copies characters
            \item \textbf{basic\_string\_view substr(pos, count)}: returns a substring
            \item \textbf{int compare()}: compares two views
            \item \textbf{starts\_with}: checks if the string view starts with the given prefix
            \item \textbf{ends\_with}: checks if the string view ends with the given suffix
            \item \textbf{contains}: checks if the string view contains the given substring or character
            \item \textbf{find}: find characters in the view
            \item \textbf{rfind}: find the last occurrence of a substring
            \item \textbf{find\_first\_of}: find first occurrence of characters
            \item \textbf{find\_last\_of}: find last occurrence of characters
            \item \textbf{find\_first\_not\_of}: find first absence of characters
            \item \textbf{find\_last\_not\_of}: find last absence of characters
        \end{itemize}






















\end{document}
