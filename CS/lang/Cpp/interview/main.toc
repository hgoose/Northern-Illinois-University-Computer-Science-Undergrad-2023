\contentsline {section}{\numberline {1}The different interview processes}{3}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}The big tech style interview process}{3}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}The shorter interview process}{4}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}Background}{5}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Rvalue references}{5}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Universal References (T\&\& in templates)}{5}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Perfect forwarding}{6}{subsection.0.2.3}%
\contentsline {subsubsection}{\numberline {2.3.1}The Problem Without Perfect Forwarding}{6}{subsubsection.0.2.3.1}%
\contentsline {subsubsection}{\numberline {2.3.2} Perfect Forwarding with std::forward}{6}{subsubsection.0.2.3.2}%
\contentsline {subsection}{\numberline {2.4}Exception safety: four types}{7}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Resource Acquisition Is Initialization (RAII)}{8}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}The partition of memory}{9}{subsection.0.2.6}%
\contentsline {subsubsection}{\numberline {2.6.1}Text segment (code segment)}{9}{subsubsection.0.2.6.1}%
\contentsline {subsubsection}{\numberline {2.6.2}Data Segment}{10}{subsubsection.0.2.6.2}%
\contentsline {subsubsection}{\numberline {2.6.3}Stack}{10}{subsubsection.0.2.6.3}%
\contentsline {subsubsection}{\numberline {2.6.4}Heap}{11}{subsubsection.0.2.6.4}%
\contentsline {subsubsection}{\numberline {2.6.5}The free list}{11}{subsubsection.0.2.6.5}%
\contentsline {subsubsection}{\numberline {2.6.6}Memory fragmentation}{11}{subsubsection.0.2.6.6}%
\contentsline {subsubsection}{\numberline {2.6.7}A programs execution}{12}{subsubsection.0.2.6.7}%
\contentsline {subsubsection}{\numberline {2.6.8}What does it mean for memory to be "allocated"}{13}{subsubsection.0.2.6.8}%
\contentsline {subsubsection}{\numberline {2.6.9}"Static allocation"}{13}{subsubsection.0.2.6.9}%
\contentsline {subsubsection}{\numberline {2.6.10}"Automatic allocation"}{14}{subsubsection.0.2.6.10}%
\contentsline {subsubsection}{\numberline {2.6.11}"Dynamic allocation"}{15}{subsubsection.0.2.6.11}%
\contentsline {subsubsection}{\numberline {2.6.12}Stack vs heap allocation}{15}{subsubsection.0.2.6.12}%
\contentsline {subsubsection}{\numberline {2.6.13}Why new (dynamic allocation) is slow and stack allocation is fast}{15}{subsubsection.0.2.6.13}%
\contentsline {subsubsection}{\numberline {2.6.14}Does new call malloc?}{16}{subsubsection.0.2.6.14}%
\contentsline {subsubsection}{\numberline {2.6.15}Delete}{16}{subsubsection.0.2.6.15}%
\contentsline {subsubsection}{\numberline {2.6.16}How does delete know how many bytes to relinquish?}{16}{subsubsection.0.2.6.16}%
\contentsline {subsubsection}{\numberline {2.6.17}Dangling pointer, memory leak, and resource leak}{17}{subsubsection.0.2.6.17}%
\contentsline {subsection}{\numberline {2.7}New in detail}{17}{subsection.0.2.7}%
\contentsline {subsubsection}{\numberline {2.7.1}Behind the scenes}{17}{subsubsection.0.2.7.1}%
\contentsline {subsubsection}{\numberline {2.7.2}operator new}{18}{subsubsection.0.2.7.2}%
\contentsline {subsubsection}{\numberline {2.7.3}placement new}{18}{subsubsection.0.2.7.3}%
\contentsline {subsubsection}{\numberline {2.7.4}nothrow new}{18}{subsubsection.0.2.7.4}%
\contentsline {section}{\numberline {3}Categories}{19}{section.0.3}%
\contentsline {section}{\numberline {4}Auto and type deduction}{20}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Auto with const}{20}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Const with auto and references}{21}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Const with auto and pointers}{21}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}rvalue references with auto}{22}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Auto in function return types or lambda parameters}{22}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}When can auto deduce undesired types?}{22}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}What are the advantages of using auto?}{24}{subsection.0.4.7}%
\contentsline {subsubsection}{\numberline {4.7.1}Regarding local variables}{24}{subsubsection.0.4.7.1}%
