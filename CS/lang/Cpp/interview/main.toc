\contentsline {section}{\numberline {1}The different interview processes}{2}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}The big tech style interview process}{2}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}The shorter interview process}{3}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}Background}{4}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Rvalue references}{4}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Universal References (T\&\& in templates)}{4}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Perfect forwarding}{5}{subsection.0.2.3}%
\contentsline {subsubsection}{\numberline {2.3.1}The Problem Without Perfect Forwarding}{5}{subsubsection.0.2.3.1}%
\contentsline {subsubsection}{\numberline {2.3.2} Perfect Forwarding with std::forward}{5}{subsubsection.0.2.3.2}%
\contentsline {subsection}{\numberline {2.4}Exception safety: four types}{6}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Resource Acquisition Is Initialization (RAII)}{7}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}The partition of memory}{8}{subsection.0.2.6}%
\contentsline {subsubsection}{\numberline {2.6.1}Text segment (code segment)}{8}{subsubsection.0.2.6.1}%
\contentsline {subsubsection}{\numberline {2.6.2}Data Segment}{9}{subsubsection.0.2.6.2}%
\contentsline {subsubsection}{\numberline {2.6.3}Stack}{9}{subsubsection.0.2.6.3}%
\contentsline {subsubsection}{\numberline {2.6.4}Heap}{10}{subsubsection.0.2.6.4}%
\contentsline {subsubsection}{\numberline {2.6.5}The free list}{10}{subsubsection.0.2.6.5}%
\contentsline {subsubsection}{\numberline {2.6.6}Memory fragmentation}{10}{subsubsection.0.2.6.6}%
\contentsline {subsubsection}{\numberline {2.6.7}A programs execution}{11}{subsubsection.0.2.6.7}%
\contentsline {subsubsection}{\numberline {2.6.8}What does it mean for memory to be "allocated"}{12}{subsubsection.0.2.6.8}%
\contentsline {subsubsection}{\numberline {2.6.9}"Static allocation"}{12}{subsubsection.0.2.6.9}%
\contentsline {subsubsection}{\numberline {2.6.10}"Automatic allocation"}{13}{subsubsection.0.2.6.10}%
\contentsline {subsubsection}{\numberline {2.6.11}"Dynamic allocation"}{14}{subsubsection.0.2.6.11}%
\contentsline {subsubsection}{\numberline {2.6.12}Stack vs heap allocation}{14}{subsubsection.0.2.6.12}%
\contentsline {subsubsection}{\numberline {2.6.13}Why new (dynamic allocation) is slow and stack allocation is fast}{14}{subsubsection.0.2.6.13}%
\contentsline {subsubsection}{\numberline {2.6.14}Does new call malloc?}{15}{subsubsection.0.2.6.14}%
\contentsline {subsubsection}{\numberline {2.6.15}Delete}{15}{subsubsection.0.2.6.15}%
\contentsline {subsubsection}{\numberline {2.6.16}How does delete know how many bytes to relinquish?}{15}{subsubsection.0.2.6.16}%
\contentsline {subsubsection}{\numberline {2.6.17}Dangling pointer, memory leak, and resource leak}{16}{subsubsection.0.2.6.17}%
\contentsline {subsection}{\numberline {2.7}New in detail}{16}{subsection.0.2.7}%
\contentsline {subsubsection}{\numberline {2.7.1}Behind the scenes}{16}{subsubsection.0.2.7.1}%
\contentsline {subsubsection}{\numberline {2.7.2}operator new}{17}{subsubsection.0.2.7.2}%
\contentsline {subsubsection}{\numberline {2.7.3}placement new}{17}{subsubsection.0.2.7.3}%
\contentsline {subsubsection}{\numberline {2.7.4}nothrow new}{17}{subsubsection.0.2.7.4}%
\contentsline {section}{\numberline {3}Categories}{18}{section.0.3}%
\contentsline {section}{\numberline {4}Auto and type deduction}{19}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Auto with const}{19}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Const with auto and references}{20}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Const with auto and pointers}{20}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}rvalue references with auto}{21}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Auto in function return types or lambda parameters}{21}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}When can auto deduce undesired types?}{21}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}What is the type of a lambda?}{23}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}What are the advantages of using auto?}{24}{subsection.0.4.8}%
\contentsline {subsubsection}{\numberline {4.8.1}Regarding local variables}{24}{subsubsection.0.4.8.1}%
\contentsline {subsubsection}{\numberline {4.8.2}Correctness}{25}{subsubsection.0.4.8.2}%
\contentsline {subsubsection}{\numberline {4.8.3}Performance}{25}{subsubsection.0.4.8.3}%
\contentsline {subsubsection}{\numberline {4.8.4}Maintainability}{25}{subsubsection.0.4.8.4}%
\contentsline {subsubsection}{\numberline {4.8.5}Robustness}{25}{subsubsection.0.4.8.5}%
\contentsline {subsection}{\numberline {4.9}Intializer\_lists}{26}{subsection.0.4.9}%
\contentsline {subsection}{\numberline {4.10}decltype}{27}{subsection.0.4.10}%
\contentsline {subsection}{\numberline {4.11}Decltype vs auto}{27}{subsection.0.4.11}%
\contentsline {subsection}{\numberline {4.12}decltype(auto)}{28}{subsection.0.4.12}%
\contentsline {section}{\numberline {5}Keyword static and its different uses }{29}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}What does a static member variable in C++ mean?}{29}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}What does a static member function mean in C++?}{29}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}What is the static initialization order fiasco?}{30}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}How to solve the static initialization order fiasco?}{31}{subsection.0.5.4}%
\contentsline {section}{\numberline {6}Polymorphism, inheritance and virtual functions}{33}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Rules for virtual functions}{33}{subsection.0.6.1}%
