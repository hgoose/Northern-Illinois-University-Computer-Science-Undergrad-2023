\contentsline {section}{\numberline {1}The different interview processes}{4}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}The big tech style interview process}{4}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}The shorter interview process}{5}{subsection.0.1.2}%
\contentsline {section}{\numberline {2}Background}{6}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Rvalue references}{6}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Universal References (T\&\& in templates)}{6}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Perfect forwarding}{7}{subsection.0.2.3}%
\contentsline {subsubsection}{\numberline {2.3.1}The Problem Without Perfect Forwarding}{7}{subsubsection.0.2.3.1}%
\contentsline {subsubsection}{\numberline {2.3.2} Perfect Forwarding with std::forward}{7}{subsubsection.0.2.3.2}%
\contentsline {subsection}{\numberline {2.4}Exception safety: four types}{8}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Resource Acquisition Is Initialization (RAII)}{9}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}The partition of memory}{10}{subsection.0.2.6}%
\contentsline {subsubsection}{\numberline {2.6.1}Text segment (code segment)}{10}{subsubsection.0.2.6.1}%
\contentsline {subsubsection}{\numberline {2.6.2}Data Segment}{11}{subsubsection.0.2.6.2}%
\contentsline {subsubsection}{\numberline {2.6.3}Stack}{11}{subsubsection.0.2.6.3}%
\contentsline {subsubsection}{\numberline {2.6.4}Heap}{12}{subsubsection.0.2.6.4}%
\contentsline {subsubsection}{\numberline {2.6.5}The free list}{12}{subsubsection.0.2.6.5}%
\contentsline {subsubsection}{\numberline {2.6.6}Memory fragmentation}{12}{subsubsection.0.2.6.6}%
\contentsline {subsubsection}{\numberline {2.6.7}A programs execution}{13}{subsubsection.0.2.6.7}%
\contentsline {subsubsection}{\numberline {2.6.8}What does it mean for memory to be "allocated"}{14}{subsubsection.0.2.6.8}%
\contentsline {subsubsection}{\numberline {2.6.9}"Static allocation"}{14}{subsubsection.0.2.6.9}%
\contentsline {subsubsection}{\numberline {2.6.10}"Automatic allocation"}{15}{subsubsection.0.2.6.10}%
\contentsline {subsubsection}{\numberline {2.6.11}"Dynamic allocation"}{16}{subsubsection.0.2.6.11}%
\contentsline {subsubsection}{\numberline {2.6.12}Stack vs heap allocation}{16}{subsubsection.0.2.6.12}%
\contentsline {subsubsection}{\numberline {2.6.13}Why new (dynamic allocation) is slow and stack allocation is fast}{16}{subsubsection.0.2.6.13}%
\contentsline {subsubsection}{\numberline {2.6.14}Does new call malloc?}{17}{subsubsection.0.2.6.14}%
\contentsline {subsubsection}{\numberline {2.6.15}Delete}{17}{subsubsection.0.2.6.15}%
\contentsline {subsubsection}{\numberline {2.6.16}How does delete know how many bytes to relinquish?}{17}{subsubsection.0.2.6.16}%
\contentsline {subsubsection}{\numberline {2.6.17}Dangling pointer, memory leak, and resource leak}{18}{subsubsection.0.2.6.17}%
\contentsline {subsection}{\numberline {2.7}New in detail}{18}{subsection.0.2.7}%
\contentsline {subsubsection}{\numberline {2.7.1}Behind the scenes}{18}{subsubsection.0.2.7.1}%
\contentsline {subsubsection}{\numberline {2.7.2}operator new}{19}{subsubsection.0.2.7.2}%
\contentsline {subsubsection}{\numberline {2.7.3}placement new}{19}{subsubsection.0.2.7.3}%
\contentsline {subsubsection}{\numberline {2.7.4}nothrow new}{19}{subsubsection.0.2.7.4}%
\contentsline {section}{\numberline {3}Categories}{20}{section.0.3}%
\contentsline {section}{\numberline {4}Auto and type deduction}{21}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Auto with const}{21}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Const with auto and references}{22}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Const with auto and pointers}{22}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}rvalue references with auto}{23}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Auto in function return types or lambda parameters}{23}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}When can auto deduce undesired types?}{23}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}What is the type of a lambda?}{25}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}What are the advantages of using auto?}{26}{subsection.0.4.8}%
\contentsline {subsubsection}{\numberline {4.8.1}Regarding local variables}{26}{subsubsection.0.4.8.1}%
\contentsline {subsubsection}{\numberline {4.8.2}Correctness}{27}{subsubsection.0.4.8.2}%
\contentsline {subsubsection}{\numberline {4.8.3}Performance}{27}{subsubsection.0.4.8.3}%
\contentsline {subsubsection}{\numberline {4.8.4}Maintainability}{27}{subsubsection.0.4.8.4}%
\contentsline {subsubsection}{\numberline {4.8.5}Robustness}{27}{subsubsection.0.4.8.5}%
\contentsline {subsection}{\numberline {4.9}Intializer\_lists}{28}{subsection.0.4.9}%
\contentsline {subsection}{\numberline {4.10}decltype}{29}{subsection.0.4.10}%
\contentsline {subsection}{\numberline {4.11}Decltype vs auto}{29}{subsection.0.4.11}%
\contentsline {subsection}{\numberline {4.12}decltype(auto)}{30}{subsection.0.4.12}%
\contentsline {section}{\numberline {5}Keyword static and its different uses }{31}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}What does a static member variable in C++ mean?}{31}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}What does a static member function mean in C++?}{31}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}What is the static initialization order fiasco?}{32}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}How to solve the static initialization order fiasco?}{33}{subsection.0.5.4}%
\contentsline {section}{\numberline {6}Polymorphism, inheritance and virtual functions}{35}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}Rules for virtual functions}{35}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}The diamond problem and its solution}{36}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Should we always use virtual inheritance? If yes, why? If not, why not?}{37}{subsection.0.6.3}%
\contentsline {subsubsection}{\numberline {6.3.1}Issues with Type Conversions}{39}{subsubsection.0.6.3.1}%
\contentsline {subsection}{\numberline {6.4}Non public inheritance}{40}{subsection.0.6.4}%
\contentsline {subsection}{\numberline {6.5}Can we inherit from a standard container (such as std::vector)? If so what are the implications?}{40}{subsection.0.6.5}%
\contentsline {subsection}{\numberline {6.6}What is a destructor and how can we overload it?}{41}{subsection.0.6.6}%
\contentsline {section}{\numberline {7}Lambdas}{42}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}When could IILF's (Immediately invoked lambda functions) be useful.}{42}{subsection.0.7.1}%
\contentsline {subsection}{\numberline {7.2}What kind of captures are available for lambda expressions?}{42}{subsection.0.7.2}%
\contentsline {subsubsection}{\numberline {7.2.1}The following types of captures are available:}{42}{subsubsection.0.7.2.1}%
\contentsline {section}{\numberline {8}How to use the const qualifier in C++}{44}{section.0.8}%
\contentsline {subsection}{\numberline {8.1}What are the advantages of using const local variables?}{44}{subsection.0.8.1}%
\contentsline {subsection}{\numberline {8.2}What happens when a class has const member variables?}{44}{subsection.0.8.2}%
\contentsline {subsection}{\numberline {8.3}Should you take plain old data types by const reference as a function parameter?}{45}{subsection.0.8.3}%
