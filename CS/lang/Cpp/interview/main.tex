\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={C++ Daily Interview}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ Daily Interview}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{The different interview processes}
    \bigbreak \noindent 
    \subsection{The big tech style interview process}
    \bigbreak \noindent 
One of them, the more usual one nowadays is very competitive and has several rounds. It starts with an initial screening call that is often conducted by a non-technical person, a recruiter. However, I’ve heard and seen cases where even the first contacts were made by engineers so that they can see earlier whether you’d be a good fit for the team.
\bigbreak \noindent 
This first round might have been preceded by a 0th round with some takeaway exercise. The idea behind
is that if you cannot prove a certain level of expertise, they don’t want to waste their time on the
applicant. Sometimes this exercise is way too long and many of us would outright reject such homework.
If it’s more reasonable, you can complete it in an hour or two.
\bigbreak \noindent 
After the screening, there is a technical round that is usually quite broad and there is not a lot of time to
go deep on the different topics. It’s almost sure that you’ll get an easy or medium-level Leetcode-style
coding exercise. For those, you must be able to reason about algorithmic complexities and it’s also very
useful if you are more than familiar with the standard library of your language. Apart from a coding
exercise, expect more general questions about your chosen language.
\bigbreak \noindent 
By understanding your language deeper -
something this book helps with - you’ll have a better chance to reach the next and usually final round of
interviews, the so-called on-site. Even if it’s online, it might still be called on-site and it’s a series of
interviews you have to complete in one day or sometimes spanned over one day.
\bigbreak \noindent 
It typically has 3 or 4 different types of interviews.
\begin{itemize}
    \item Behavioural interviews focusing on your soft skills
    \item A system design interview where you get a quite vague task to design a system. You have to clarify what the requirements are and you have to come up with the high-level architecture and dig deeper into certain parts
    \item There are different kinds of coding interviews
        \begin{enumerate}
            \item \textbf{Coding exercises}: You won’t be able to solve coding exercises with what you learn in this book, but you’ll be able to avoid some pitfalls with a deeper understanding of the language. Daily C++ Interview helps you to achieve that understanding. In addition, you must practice on pages like Leetcode, Hackerrank, Codingame, etc
            \item \item \textbf{Debug interview}: You receive a piece of code and you have to find the bugs. Sometimes this can be called a code review interview. It’s still about finding bugs. Personally, I find it a bit deeper than a simple coding exercise. In a coding interview, you are supposed to talk about design flaws, code smells, and testability. If you know C++ well enough, if you try to answer some of the questions of Daily C++ Interview on a day-to-day basis, you’ll have a much better chance to recognize bugs, smells, flaws and pass the interview.
        \end{enumerate}
\end{itemize}

\bigbreak \noindent 
\subsection{The shorter interview process}
\bigbreak \noindent 
Certain companies try to compete for talent by shortening their interview cycles and making a decision as fast as possible. Often they promise a decision in less than 10 days. Usually, they don’t offer so competitive packages - but even that is not always true - so they try to compete on something else.
\bigbreak \noindent 
A shorter decision cycle obviously means fewer interviews. Sometimes this approach is combined with the lack of coding interviews - at least for senior engineers. The idea behind is that many engineers despise the idea of implementing those coding exercises. They find it irrelevant and even derogative to implement a linked list. Instead, they will ask questions that help evaluate how deep you understand the given programming language.

\pagebreak 
\unsect{Background}
\bigbreak \noindent 
\subsection{Rvalue references}
\bigbreak \noindent 
An rvalue reference is a reference that can only bind to rvalues (temporary values).
\bigbreak \noindent 
\begin{cppcode}
void func(int&& param) {
    std::cout << "Rvalue reference received\n";
}

int main() {
    int x = 10;
    // func(x);  // ❌ Error! x is an lvalue
    func(20);    // ✅ OK, 20 is an rvalue
}
\end{cppcode}
\bigbreak \noindent 
Rvalue references allow efficient resource transfers via std::move. They do not accept lvalues.
\bigbreak \noindent 
\subsection{Universal References (T\&\& in templates)}
\bigbreak \noindent 
A universal reference is when T\&\& appears in a template parameter and depends on type deduction.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(T&& param) {
        std::cout << "Universal reference received\n";
    }

    int main() {
        int x = 10;
        func(x);   // ✅ param is int& (lvalue reference)
        func(20);  // ✅ param is int&& (rvalue reference)
    }
\end{cppcode}
\bigbreak \noindent 
Universal references can bind to both lvalues and rvalues. Their behavior depends on type deduction. Used primarily for perfect forwarding

\bigbreak \noindent 
\subsection{Perfect forwarding}
\bigbreak \noindent 
Perfect forwarding is a technique that allows a function to pass its arguments to another function while preserving their original value category (i.e., whether they are lvalues or rvalues).
\bigbreak \noindent 
This is crucial when writing generic functions that should forward arguments efficiently, without unnecessary copies or moves.
\bigbreak \noindent 
\subsubsection{The Problem Without Perfect Forwarding}
\bigbreak \noindent 
Without perfect forwarding, lvalues and rvalues can be unintentionally converted, leading to performance issues.
\bigbreak \noindent 
\begin{cppcode}
    void func(int& x) { std::cout << "Lvalue reference\n"; }
    void func(int&& x) { std::cout << "Rvalue reference\n"; }

    template <typename T>
    void wrapper(T x) {  // Passes by value (unintended copy)
        func(x); // Always an lvalue inside wrapper
    }

    int main() {
        int a = 10;
        wrapper(a);  // Calls func(int&) (expected)
        wrapper(20); // Calls func(int&) (unexpected, should be func(int&&))
    }
\end{cppcode}
\bigbreak \noindent 
The problem is that T x always treats x as an lvalue inside wrapper, even if it was originally an rvalue. This causes an unnecessary copy and prevents func(int\&\&) from being called.
\bigbreak \noindent 
\subsubsection{ Perfect Forwarding with std::forward}
\bigbreak \noindent 
Perfect forwarding ensures that arguments retain their original value category.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void wrapper(T&& arg) { 
        func(std::forward<T>(arg));  // Perfectly forwards argument
    }
\end{cppcode}
\begin{itemize}
    \item If arg is an lvalue, T deduces as T\&, so std::forward<T>(arg) behaves like an lvalue reference.
    \item If arg is an rvalue, T deduces as T, so std::forward<T>(arg) behaves like an rvalue reference.
\end{itemize}
\bigbreak \noindent 
If you do not use std::forward in a universal reference (T\&\& in a template), the argument loses its rvalue status and is always treated as an lvalue inside the function. This can lead to incorrect function overload resolution and unnecessary copies/moves.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void wrapper(T&& arg) { 
        func(arg);  // Problem: 'arg' is always an lvalue inside wrapper
    }
\end{cppcode}
\bigbreak \noindent 
Even though arg is declared as T\&\&, it becomes an lvalue when used inside wrapper.
\bigbreak \noindent 
This means that even if you pass an rvalue, it will be treated as an lvalue.













% \bigbreak \noindent 
% Every rvalue ref is denoted by ‘\&\&’ but the converse is not true
% \begin{align*}
%     \text{rvalue reference } \implies \&\& \\
%     \&\& \not\implies \text{ rvalue reference}
% \end{align*}
% \bigbreak \noindent 
% “\&\&” in source code though may have the syntactic appearance of an rvalue reference (“\&&”), but the meaning of an lvalue reference (“\&”).

\bigbreak \noindent 
\subsection{Exception safety: four types}
\bigbreak \noindent 
Exception safety in C++ refers to the guarantees a function or piece of code provides regarding its behavior when exceptions are thrown. Exception safety ensures that objects remain in a valid state and that resources (such as memory, file handles, and locks) are properly managed even in the presence of exceptions.
\bigbreak \noindent 
Exception safety is typically categorized into four levels:
\begin{enumerate}
    \item \textbf{No Guarantee (Unsafe)}: The function provides no exception safety. If an exception is thrown, the program may enter an invalid state, leak resources, or cause undefined behavior.
        \bigbreak \noindent 
        \begin{cppcode}
            void unsafeFunction(std::vector<int>& vec, int value) {
                vec.push_back(value); // If push_back throws, `vec` may be in an inconsistent state.
                doSomething(); // May not run if push_back fails.
            }
        \end{cppcode}
    \item \textbf{Basic Guarantee}: If an exception is thrown, no resources leak, and all objects remain in a valid (but possibly modified) state.
        \bigbreak \noindent 
        \begin{cppcode}
            void basicGuarantee(std::vector<int>& vec, int value) {
                try {
                    vec.push_back(value); // If this throws, `vec` is still valid.
                } catch (...) {
                    // Exception handling ensures no resource leaks.
                }
            }
        \end{cppcode}
    \item \textbf{Strong Guarantee}: Either the function succeeds completely or has no effect (strong exception safety). This is often achieved using copy-and-swap techniques or transactions.
        \bigbreak \noindent 
        \begin{cppcode}
            void strongGuarantee(std::vector<int>& vec, int value) {
                std::vector<int> temp(vec); // Copy to temporary
                temp.push_back(value); // Modify the copy
                vec.swap(temp); // Commit the change safely
            }
        \end{cppcode}
        \bigbreak \noindent 
        If push\_back throws, vec remains unchanged.
    \item \textbf{No-Throw Guarantee (Exception Neutrality)}: The function is guaranteed not to throw exceptions. Achieved by using only non-throwing operations (noexcept)
        \bigbreak \noindent 
        \begin{cppcode}
            void noThrowFunction(std::vector<int>& vec, int value) noexcept {
                vec.push_back(value); // Assumes `push_back` does not throw
            }
        \end{cppcode}
\end{enumerate}

\bigbreak \noindent 
\subsection{Resource Acquisition Is Initialization (RAII)}
\bigbreak \noindent 
Resource Acquisition Is Initialization (RAII) is a programming technique in C++ where resource management (such as memory, file handles, or locks) is tied to the lifetime of objects. This ensures that resources are acquired in a constructor and released in a destructor, providing exception safety and preventing resource leaks.
\bigbreak \noindent 
Smart pointers are an example of this
\bigbreak \noindent 
\begin{cppcode}
    void badFunction() {
        int* ptr = new int(10);
        throw std::runtime_error("Exception!"); 
        delete ptr;  // This line is never reached, memory leak!
    }
\end{cppcode}
\bigbreak \noindent 
With smart pointers, we can guarantee RAII
\bigbreak \noindent 
\begin{cppcode}
    void goodFunction() {
        std::unique_ptr<int> ptr = std::make_unique<int>(10);
        throw std::runtime_error("Exception!"); 
        // `ptr` is destroyed automatically, no memory leak.
    }
\end{cppcode}
\bigbreak \noindent 
The name Resource Acquisition Is Initialization (RAII) comes from the idea that acquiring a resource (e.g., memory, file, mutex, etc.) should happen at the same time as object initialization—specifically, in the constructor of a class.
\begin{itemize}
    \item Resource Acquisition $\to$ The act of obtaining or allocating a resource (e.g., opening a file, allocating memory).
    \item Is Initialization $\to$ This acquisition happens during the initialization phase of an object, meaning inside its constructor.
\end{itemize}
\bigbreak \noindent 
C++ only guarantees deterministic destruction for objects with automatic (stack) storage duration. That is, objects created on the stack are automatically destroyed when they go out of scope.
\bigbreak \noindent 
However, RAII extends this guarantee to dynamically allocated resources by using smart pointers and custom RAII classes.
\bigbreak \noindent 
If resource acquisition does not happen during the initialization phase (i.e., inside the constructor in C++), several issues can arise, primarily resource leaks, partially initialized objects, and lack of exception safety.
\bigbreak \noindent 
If a class does not acquire its resource in the constructor, but instead in a separate function, the object may exist in an invalid state.
\bigbreak \noindent 
\begin{cppcode}
class ResourceManager {
    FILE* file;
public:
    ResourceManager() { file = nullptr; } // No resource acquired here 

    void openFile(const char* filename) {
        file = fopen(filename, "r");  // Resource acquired separately 
    }

    ~ResourceManager() {
        if (file) fclose(file);
    }
};

int main() {
    ResourceManager rm;
    // Forgot to call `openFile()`, now `rm` is in an invalid state 
}
\end{cppcode}
\bigbreak \noindent 
The object exists in an invalid state unless openFile() is called manually. A user of the class might forget to call openFile(), leading to runtime errors.





\pagebreak 
\unsect{Categories}
\bigbreak \noindent 
The questions in this book fall into the following categories
\begin{itemize}
    \item Auto and type deduction
    \item Keyword static and its different uses
    \item Polymorphism, inheritance, and virtual functions
    \item Lambda functions
    \item How to use const
    \item Best practices in modern c++
    \item Smart pointers
    \item References, universal references
    \item C++20
    \item Special function and the rules of how many
    \item OOP, inheritance, poylmorphism
    \item Observable behaviors
    \item The STL
    \item Misc
\end{itemize}

\pagebreak 
\unsect{Auto and type deduction}
\bigbreak \noindent 
auto type deduction is usually the same as template type deduction, but auto type deduction assumes that a braced initializer represents a std::initializer\_list, and template type deduction doesn’t hold such premises.
\bigbreak \noindent 
\begin{cppcode}
    auto x = {1, 2, 3}; // auto deduces std::initializer_list<int>
\end{cppcode}
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(T t) {
        std::cout << typeid(T).name() << "\n";
    }

    int main() {
        func({1, 2, 3}); // ❌ Error: cannot deduce T from {1, 2, 3}
    }
\end{cppcode}
\bigbreak \noindent 
However, if we explicitly specify std::initializer\_list<T>, it works
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(std::initializer_list<T> t) {
        for (T n : t) {
            std::cout << n << " ";
        }
    }

    int main() {
        func({1, 2, 3}); // ✅ Works, T = int
    }
\end{cppcode}

\bigbreak \noindent 
\subsection{Auto with const}
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
    const int x = 10;
    auto y = x;   // y is `int`, not `const int`
\end{cppcode}
\bigbreak \noindent 
We must const qualify $y$ if we require it to maintain constness
\bigbreak \noindent 
\begin{cppcode}
const auto y = x; // y is int and const
\end{cppcode}


\bigbreak \noindent 
\subsection{Const with auto and references}
\bigbreak \noindent 
Using auto\& ensures that the deduced type keeps the const qualifier when referencing a const object.
\bigbreak \noindent 
\begin{cppcode}
const int a = 42;
auto& b = a;  // `b` is `const int&`
\end{cppcode}
\bigbreak \noindent 
\begin{cppcode}
    const int x = 5;
    auto& y = x;

    y = 15; // Error
\end{cppcode}
\bigbreak \noindent 
If $x$ were not const, we could also qualify $y$ to be const, therefore not allowing modification of $x$ through $y$
\bigbreak \noindent 
\begin{cppcode}
    int x = 5;
    const auto& y = x;

    y = 15; // Error
\end{cppcode}

\bigbreak \noindent 
\subsection{Const with auto and pointers}
\bigbreak \noindent 
First, recall
\bigbreak \noindent 
\begin{cppcode}
    int x = 5;
    int y = 10;

    // Pointer is mutable, value is not
    const int* ptr = &x; 
    int const* ptr = &x; // Pointer is mutable, value is not
    //
    // // // Pointer is immutable, value is mutable
    int* const ptr = &x;
    int *const ptr = &x;

    // Pointer and value are immutable
    const int* const ptr = &x;
    const int *const ptr = &x;
    int const *const ptr = &x;
\end{cppcode}
\bigbreak \noindent 
First, we discuss mutable pointers to const values
\bigbreak \noindent 
\begin{cppcode}
    // Pointer is mutable, value is not
    const int* ptr = &x; 

    // Pointer to constant int
    auto ptr2 = ptr;
    *ptr2 = 20; // Error
    // Pointer is mutable
    ptr2 = &y;

    // Both value and pointer are immutable
    const auto ptr2 = ptr;
    *ptr2 = 20;  // Error
    ptr2 = &y // Error
\end{cppcode}
\bigbreak \noindent 
Next, constant pointers to non-const data
\bigbreak \noindent 
\begin{cppcode}
    // Pointer is immutable, value is mutable
    int* const ptr = &x;

    // Disregards const, ptr2 is non-const and value is non-const
    auto ptr2 = ptr;
    *ptr2 = 20;
    ptr2 = &y; 

    // Pointer is const, value non-const
    const auto ptr2 = ptr;
\end{cppcode}
\bigbreak \noindent 
Similarly for const pointers to const data, using auto will maintain constness for the data, but not for the pointer. Therefore, in this case, we must also qualify ptr2 with const.

\bigbreak \noindent 
\subsection{rvalue references with auto}
\bigbreak \noindent 


















\end{document}
