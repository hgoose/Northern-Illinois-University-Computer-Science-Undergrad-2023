\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={C++ Daily Interview}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ Daily Interview}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{The different interview processes}
    \bigbreak \noindent 
    \subsection{The big tech style interview process}
    \bigbreak \noindent 
One of them, the more usual one nowadays is very competitive and has several rounds. It starts with an initial screening call that is often conducted by a non-technical person, a recruiter. However, I’ve heard and seen cases where even the first contacts were made by engineers so that they can see earlier whether you’d be a good fit for the team.
\bigbreak \noindent 
This first round might have been preceded by a 0th round with some takeaway exercise. The idea behind
is that if you cannot prove a certain level of expertise, they don’t want to waste their time on the
applicant. Sometimes this exercise is way too long and many of us would outright reject such homework.
If it’s more reasonable, you can complete it in an hour or two.
\bigbreak \noindent 
After the screening, there is a technical round that is usually quite broad and there is not a lot of time to
go deep on the different topics. It’s almost sure that you’ll get an easy or medium-level Leetcode-style
coding exercise. For those, you must be able to reason about algorithmic complexities and it’s also very
useful if you are more than familiar with the standard library of your language. Apart from a coding
exercise, expect more general questions about your chosen language.
\bigbreak \noindent 
By understanding your language deeper -
something this book helps with - you’ll have a better chance to reach the next and usually final round of
interviews, the so-called on-site. Even if it’s online, it might still be called on-site and it’s a series of
interviews you have to complete in one day or sometimes spanned over one day.
\bigbreak \noindent 
It typically has 3 or 4 different types of interviews.
\begin{itemize}
    \item Behavioural interviews focusing on your soft skills
    \item A system design interview where you get a quite vague task to design a system. You have to clarify what the requirements are and you have to come up with the high-level architecture and dig deeper into certain parts
    \item There are different kinds of coding interviews
        \begin{enumerate}
            \item \textbf{Coding exercises}: You won’t be able to solve coding exercises with what you learn in this book, but you’ll be able to avoid some pitfalls with a deeper understanding of the language. Daily C++ Interview helps you to achieve that understanding. In addition, you must practice on pages like Leetcode, Hackerrank, Codingame, etc
            \item \item \textbf{Debug interview}: You receive a piece of code and you have to find the bugs. Sometimes this can be called a code review interview. It’s still about finding bugs. Personally, I find it a bit deeper than a simple coding exercise. In a coding interview, you are supposed to talk about design flaws, code smells, and testability. If you know C++ well enough, if you try to answer some of the questions of Daily C++ Interview on a day-to-day basis, you’ll have a much better chance to recognize bugs, smells, flaws and pass the interview.
        \end{enumerate}
\end{itemize}

\bigbreak \noindent 
\subsection{The shorter interview process}
\bigbreak \noindent 
Certain companies try to compete for talent by shortening their interview cycles and making a decision as fast as possible. Often they promise a decision in less than 10 days. Usually, they don’t offer so competitive packages - but even that is not always true - so they try to compete on something else.
\bigbreak \noindent 
A shorter decision cycle obviously means fewer interviews. Sometimes this approach is combined with the lack of coding interviews - at least for senior engineers. The idea behind is that many engineers despise the idea of implementing those coding exercises. They find it irrelevant and even derogative to implement a linked list. Instead, they will ask questions that help evaluate how deep you understand the given programming language.

\pagebreak 
\unsect{Background}
\bigbreak \noindent 
\subsection{Rvalue references}
\bigbreak \noindent 
An rvalue reference is a reference that can only bind to rvalues (temporary values).
\bigbreak \noindent 
\begin{cppcode}
int&& x = 50;
\end{cppcode}
\bigbreak \noindent 
Here, $z$ is an rvalue reference that binds directly to the temporary value 50. While this might seem trivial for primitive types like int, it becomes powerful when working with objects that manage resources (e.g., strings, vectors, or custom classes). By binding to an rvalue, you can extend the lifetime of the temporary object and potentially "move" its resources.
\bigbreak \noindent 
\begin{cppcode}
void func(int&& param) {
    std::cout << "Rvalue reference received\n";
}

int main() {
    int x = 10;
    // func(x);  // Error! x is an lvalue
    func(20);    //  OK, 20 is an rvalue
    
    int&& z = 30;
    func(z);
}
\end{cppcode}
\bigbreak \noindent 
Rvalue references allow efficient resource transfers via std::move. They do not accept lvalues.
\bigbreak \noindent 
\subsection{Universal References (T\&\& in templates)}
\bigbreak \noindent 
A universal reference is when T\&\& appears in a template parameter and depends on type deduction.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(T&& param) {
        std::cout << "Universal reference received\n";
    }

    int main() {
        int x = 10;
        func(x);   //  param is int& (lvalue reference)
        func(20);  //  param is int&& (rvalue reference)
    }
\end{cppcode}
\bigbreak \noindent 
Universal references can bind to both lvalues and rvalues. Their behavior depends on type deduction. Used primarily for perfect forwarding

\bigbreak \noindent 
\subsection{Perfect forwarding}
\bigbreak \noindent 
Perfect forwarding is a technique that allows a function to pass its arguments to another function while preserving their original value category (i.e., whether they are lvalues or rvalues).
\bigbreak \noindent 
This is crucial when writing generic functions that should forward arguments efficiently, without unnecessary copies or moves.
\bigbreak \noindent 
\subsubsection{The Problem Without Perfect Forwarding}
\bigbreak \noindent 
Without perfect forwarding, lvalues and rvalues can be unintentionally converted, leading to performance issues.
\bigbreak \noindent 
\begin{cppcode}
    void func(int& x) { std::cout << "Lvalue reference\n"; }
    void func(int&& x) { std::cout << "Rvalue reference\n"; }

    template <typename T>
    void wrapper(T x) {  // Passes by value (unintended copy)
        func(x); // Always an lvalue inside wrapper
    }

    int main() {
        int a = 10;
        wrapper(a);  // Calls func(int&) (expected)
        wrapper(20); // Calls func(int&) (unexpected, should be func(int&&))
    }
\end{cppcode}
\bigbreak \noindent 
The problem is that T x always treats x as an lvalue inside wrapper, even if it was originally an rvalue. This causes an unnecessary copy and prevents func(int\&\&) from being called.
\bigbreak \noindent 
\subsubsection{ Perfect Forwarding with std::forward}
\bigbreak \noindent 
Perfect forwarding ensures that arguments retain their original value category.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void wrapper(T&& arg) { 
        func(std::forward<T>(arg));  // Perfectly forwards argument
    }
\end{cppcode}
\begin{itemize}
    \item If arg is an lvalue, T deduces as T\&, so std::forward<T>(arg) behaves like an lvalue reference.
    \item If arg is an rvalue, T deduces as T, so std::forward<T>(arg) behaves like an rvalue reference.
\end{itemize}
\bigbreak \noindent 
If you do not use std::forward in a universal reference (T\&\& in a template), the argument loses its rvalue status and is always treated as an lvalue inside the function. This can lead to incorrect function overload resolution and unnecessary copies/moves.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void wrapper(T&& arg) { 
        func(arg);  // Problem: 'arg' is always an lvalue inside wrapper
    }
\end{cppcode}
\bigbreak \noindent 
Even though arg is declared as T\&\&, it becomes an lvalue when used inside wrapper.
\bigbreak \noindent 
This means that even if you pass an rvalue, it will be treated as an lvalue.













% \bigbreak \noindent 
% Every rvalue ref is denoted by ‘\&\&’ but the converse is not true
% \begin{align*}
%     \text{rvalue reference } \implies \&\& \\
%     \&\& \not\implies \text{ rvalue reference}
% \end{align*}
% \bigbreak \noindent 
% “\&\&” in source code though may have the syntactic appearance of an rvalue reference (“\&&”), but the meaning of an lvalue reference (“\&”).

\bigbreak \noindent 
\subsection{Exception safety: four types}
\bigbreak \noindent 
Exception safety in C++ refers to the guarantees a function or piece of code provides regarding its behavior when exceptions are thrown. Exception safety ensures that objects remain in a valid state and that resources (such as memory, file handles, and locks) are properly managed even in the presence of exceptions.
\bigbreak \noindent 
Exception safety is typically categorized into four levels:
\begin{enumerate}
    \item \textbf{No Guarantee (Unsafe)}: The function provides no exception safety. If an exception is thrown, the program may enter an invalid state, leak resources, or cause undefined behavior.
        \bigbreak \noindent 
        \begin{cppcode}
            void unsafeFunction(std::vector<int>& vec, int value) {
                vec.push_back(value); // If push_back throws, `vec` may be in an inconsistent state.
                doSomething(); // May not run if push_back fails.
            }
        \end{cppcode}
    \item \textbf{Basic Guarantee}: If an exception is thrown, no resources leak, and all objects remain in a valid (but possibly modified) state.
        \bigbreak \noindent 
        \begin{cppcode}
            void basicGuarantee(std::vector<int>& vec, int value) {
                try {
                    vec.push_back(value); // If this throws, `vec` is still valid.
                } catch (...) {
                    // Exception handling ensures no resource leaks.
                }
            }
        \end{cppcode}
    \item \textbf{Strong Guarantee}: Either the function succeeds completely or has no effect (strong exception safety). This is often achieved using copy-and-swap techniques or transactions.
        \bigbreak \noindent 
        \begin{cppcode}
            void strongGuarantee(std::vector<int>& vec, int value) {
                std::vector<int> temp(vec); // Copy to temporary
                temp.push_back(value); // Modify the copy
                vec.swap(temp); // Commit the change safely
            }
        \end{cppcode}
        \bigbreak \noindent 
        If push\_back throws, vec remains unchanged.
    \item \textbf{No-Throw Guarantee (Exception Neutrality)}: The function is guaranteed not to throw exceptions. Achieved by using only non-throwing operations (noexcept)
        \bigbreak \noindent 
        \begin{cppcode}
            void noThrowFunction(std::vector<int>& vec, int value) noexcept {
                vec.push_back(value); // Assumes `push_back` does not throw
            }
        \end{cppcode}
\end{enumerate}

\bigbreak \noindent 
\subsection{Resource Acquisition Is Initialization (RAII)}
\bigbreak \noindent 
Resource Acquisition Is Initialization (RAII) is a programming technique in C++ where resource management (such as memory, file handles, or locks) is tied to the lifetime of objects. This ensures that resources are acquired in a constructor and released in a destructor, providing exception safety and preventing resource leaks.
\bigbreak \noindent 
Smart pointers are an example of this
\bigbreak \noindent 
\begin{cppcode}
    void badFunction() {
        int* ptr = new int(10);
        throw std::runtime_error("Exception!"); 
        delete ptr;  // This line is never reached, memory leak!
    }
\end{cppcode}
\bigbreak \noindent 
With smart pointers, we can guarantee RAII
\bigbreak \noindent 
\begin{cppcode}
    void goodFunction() {
        std::unique_ptr<int> ptr = std::make_unique<int>(10);
        throw std::runtime_error("Exception!"); 
        // `ptr` is destroyed automatically, no memory leak.
    }
\end{cppcode}
\bigbreak \noindent 
The name Resource Acquisition Is Initialization (RAII) comes from the idea that acquiring a resource (e.g., memory, file, mutex, etc.) should happen at the same time as object initialization—specifically, in the constructor of a class.
\begin{itemize}
    \item Resource Acquisition $\to$ The act of obtaining or allocating a resource (e.g., opening a file, allocating memory).
    \item Is Initialization $\to$ This acquisition happens during the initialization phase of an object, meaning inside its constructor.
\end{itemize}
\bigbreak \noindent 
C++ only guarantees deterministic destruction for objects with automatic (stack) storage duration. That is, objects created on the stack are automatically destroyed when they go out of scope.
\bigbreak \noindent 
However, RAII extends this guarantee to dynamically allocated resources by using smart pointers and custom RAII classes.
\bigbreak \noindent 
If resource acquisition does not happen during the initialization phase (i.e., inside the constructor in C++), several issues can arise, primarily resource leaks, partially initialized objects, and lack of exception safety.
\bigbreak \noindent 
If a class does not acquire its resource in the constructor, but instead in a separate function, the object may exist in an invalid state.
\bigbreak \noindent 
\begin{cppcode}
class ResourceManager {
    FILE* file;
public:
    ResourceManager() { file = nullptr; } // No resource acquired here 

    void openFile(const char* filename) {
        file = fopen(filename, "r");  // Resource acquired separately 
    }

    ~ResourceManager() {
        if (file) fclose(file);
    }
};

int main() {
    ResourceManager rm;
    // Forgot to call `openFile()`, now `rm` is in an invalid state 
}
\end{cppcode}
\bigbreak \noindent 
The object exists in an invalid state unless openFile() is called manually. A user of the class might forget to call openFile(), leading to runtime errors.

\bigbreak \noindent 
\subsection{The partition of memory}
\bigbreak \noindent 
In C++, when a program runs, its memory is divided into distinct segments, each serving different purposes. These segments partition the memory block allocated to the program
\bigbreak \noindent 
\subsubsection{Text segment (code segment)}
\bigbreak \noindent 
This segment contains the executable code of the program. It is usually read-only to prevent accidental modification. The size of this segment is fixed once the program is loaded into memory.

\bigbreak \noindent 
\subsubsection{Data Segment}
\bigbreak \noindent 
Stores global and static variables.
\begin{itemize}
    \item \textbf{Initialized Data Segment:} Stores global/static variables with explicit initial values.
    \item \textbf{Uninitialized Data Segment (BSS - Block Started by Symbol):} Stores global/static variables initialized to zero (default).
\end{itemize}

\bigbreak \noindent 
\subsubsection{Stack}
\bigbreak \noindent 
Used for function calls, local variables, and return addresses. Each function call pushes a new frame onto the stack, which is popped when the function returns. The stack grows downward (toward lower memory addresses).
\bigbreak \noindent 
It has a fixed size, set by the operating system or runtime environment.
\bigbreak \noindent 
Stack Overflow happens if it exceeds its allocated space (e.g., excessive recursion).
\bigbreak \noindent 
On linux the default stack size is typically 8mb, on windows it is typically 1mb.
\bigbreak \noindent 
Note that the \textit{call stack} is essentially the stack in the context of program execution. However, the term "call stack" specifically refers to how the stack is used to manage function calls, while "stack" is a more general term for the data structure or memory region itself. Let me clarify the relationship between the two:
\bigbreak \noindent 
The call stack is a region of memory that operates as a Last-In-First-Out (LIFO) data structure. It is used to keep track of function calls, their parameters, local variables, and control flow. Each time a function is called, a new stack frame (or activation record) is created and pushed onto the call stack. When the function returns, its stack frame is popped off the stack.
\bigbreak \noindent 
The last function called is the first one to return, which aligns with the LIFO principle.
\bigbreak \noindent 
A special register (e.g., esp on x86 or rsp on x86-64) keeps track of the current top of the stack. It is adjusted as data is pushed onto or popped off the stack.
\bigbreak \noindent 
Another register (e.g., ebp on x86 or rbp on x86-64) is often used to reference the base of the current stack frame, making it easier to access local variables and function parameters.
\bigbreak \noindent 
When a function is called, the following happens:
\begin{itemize}
    \item The return address (where the program should continue after the function returns) is pushed onto the stack.
    \item The function's parameters are pushed onto the stack.
    \item The stack pointer is adjusted to allocate space for local variables.
\end{itemize}
\bigbreak \noindent 
The function uses its stack frame to store local variables and intermediate results.
\bigbreak \noindent 
The frame pointer (if used) helps navigate the stack frame.
\bigbreak \noindent 
When the function finishes, its stack frame is popped off the stack:
\begin{itemize}
    \item The stack pointer is restored to its previous position.
    \item The return address is used to jump back to the caller.
\end{itemize}
\bigbreak \noindent 
The size of a stack frame in C++ (or any other programming language) depends on several factors, including:
\begin{itemize}
    \item The size of local variables declared in the function.
    \item The size of function parameters passed to the function.
    \item The size of the return address (typically the size of a memory pointer, e.g., 4 bytes on 32-bit systems or 8 bytes on 64-bit systems).
    \item The size of saved registers (if any) that need to be preserved across function calls.
    \item Alignment requirements (e.g., the stack frame might be padded to align data to specific boundaries for performance reasons).
\end{itemize}


\bigbreak \noindent 
\subsubsection{Heap}
\bigbreak \noindent 
Used for dynamic memory allocation (new, malloc). The program can allocate and free memory at runtime.
\bigbreak \noindent 
The heap grows upward (toward higher memory addresses). Memory leaks occur if allocated memory is not freed properly.
\bigbreak \noindent 
Unlike the stack, the heap does not have a fixed size limit, but it is constrained by system memory.

\bigbreak \noindent 
\subsubsection{The free list}
\bigbreak \noindent 
In C++, particularly in dynamic memory management, the free list is a data structure used to track free (unused) memory blocks in the heap. It is commonly implemented as a linked list of memory blocks that have been allocated and later freed but are available for reuse.
\bigbreak \noindent 
When a program requests memory (e.g., new or malloc), the allocator checks the free list first to find a suitable block.
\bigbreak \noindent 
If a sufficiently large free block is found, it is removed from the free list and returned to the caller.
\bigbreak \noindent 
If no suitable block is found, a new block is allocated from the heap.
\bigbreak \noindent 
When memory is freed (delete or free), the deallocated block is added to the free list.

\bigbreak \noindent 
\subsubsection{Memory fragmentation}
\bigbreak \noindent 
Memory fragmentation refers to inefficient memory allocation where free memory is divided into small, non-contiguous blocks, making it difficult to allocate large contiguous blocks even if there is enough total free memory. It occurs primarily in dynamic memory management when memory is allocated and freed in an unpredictable manner.

\bigbreak \noindent 
\subsubsection{A programs execution}
\bigbreak \noindent 
When a program is executed, the operating system (OS) finds a suitable slot in memory to load the program and manages its memory layout.
\bigbreak \noindent 
The OS reserves a contiguous block of memory for the program's execution. This includes space for the text segment (code), data segment (globals/statics), stack, and heap.
\bigbreak \noindent 
The OS determines a base address and loads the program's executable code into that location.
\bigbreak \noindent 
Once the program is loaded the text segment is placed first and has a fixed size.
\bigbreak \noindent 
The data segment follows, holding global/static variables.
\bigbreak \noindent 
The stack starts from a high memory address and grows downward as functions call each other.
\bigbreak \noindent 
The heap starts from a low memory address (above the data segment) and grows upward when dynamic allocations (new, malloc) occur.
\bigbreak \noindent 
The OS does not preallocate a fixed size for the heap or stack but instead reserves an initial size for the stack and heap and expands or shrinks them dynamically based on need (within system constraints).
\bigbreak \noindent 
If the stack grows too much (e.g., deep recursion) or the heap expands too far, they may collide, causing a crash (segmentation fault).
\bigbreak \noindent 
Stack size is often limited by the OS (default is a few MB), but heap size depends on system RAM
\bigbreak \noindent 
If the stack needs more space, the OS allocates additional pages unless it hits the stack limit (causing a stack overflow).
\bigbreak \noindent 
 If the heap needs more memory (malloc or new), the OS extends it using sbrk() or memory mapping (mmap).
 \bigbreak \noindent 
 \fig{1}{./figures/1.png}
 \bigbreak \noindent 
 The free space (or gap between the stack and heap) in a program's memory layout represents unallocated virtual memory that can be used by either the stack or heap as the program runs.
 \bigbreak \noindent 
 It acts as a buffer zone between the stack (growing downward) and the heap (growing upward).

 \bigbreak \noindent 
 \subsubsection{What does it mean for memory to be "allocated"}
 \bigbreak \noindent 
 When memory is "allocated," it means that a specific portion of the computer's memory space has been set aside and reserved for a particular program or data to use, essentially giving that program exclusive access to that memory area to store information during its execution; this is done by the operating system based on the program's needs

 \bigbreak \noindent 
 \subsubsection{"Static allocation"}
 \bigbreak \noindent 
 In C++ (and programming in general), statically allocated refers to memory that is allocated at compile time and remains fixed in size and location for the entire duration of the program's execution. This is in contrast to dynamic allocation, where memory is allocated and deallocated at runtime.
 \bigbreak \noindent 
 Static allocation means that the memory for a variable or object is reserved when the program is compiled, and it persists for the entire lifetime of the program.
 \bigbreak \noindent 
 The memory is allocated in one of the following regions
 \begin{enumerate}
     \item \textbf{Global/Static Memory:} For global variables and static variables.
 \end{enumerate}
 \bigbreak \noindent 
 \textbf{Characteristics of Static Allocation}
 \bigbreak \noindent 
 \begin{itemize}
     \item \textbf{Fixed Size:} The size of the memory block is known at compile time and cannot change during runtime.
     \item \textbf{Lifetime:} The memory exists for the entire duration of the program (for global/static variables) or for the duration of the function call (for local variables).
     \item \textbf{Efficiency:} Statically allocated memory is fast to allocate and access because it is managed by the compiler and does not require runtime overhead (e.g., no need for new/delete or malloc/free).
     \item \textbf{Scope:} The visibility of the variable depends on where it is declared:
         \begin{itemize}
             \item Global variables are accessible throughout the program.
             \item Static variables inside a function are accessible only within that function but retain their value between calls.
         \end{itemize}
 \end{itemize}

 \bigbreak \noindent 
 \subsubsection{"Automatic allocation"}
 \bigbreak \noindent 
 Automatic allocation refers to memory that is allocated automatically for local variables when a function is called and deallocated automatically when the function exits.
 \bigbreak \noindent 
 This memory is allocated on the stack, which is a region of memory managed by the compiler and the runtime environment.
 \bigbreak \noindent 
 The term "automatic" comes from the fact that the allocation and deallocation are handled automatically by the system, without requiring explicit intervention from the programmer (e.g., no need for new/delete or malloc/free).
 \begin{itemize}
     \item \textbf{Lifetime:} The memory is allocated when a function is called and deallocated when the function returns.
     \item \textbf{Scope:} The variables are only accessible within the block (e.g., function or {} block) where they are declared.
     \item \textbf{Speed:} Allocation and deallocation are very fast because the stack is a simple LIFO (Last-In-First-Out) data structure.
 \end{itemize}
 \bigbreak \noindent 
 \textbf{Does the Compiler Assign Memory Locations at Compile Time?} Yes and no. Here’s the distinction:
 \bigbreak \noindent 
 The size of the stack frame (e.g., how much memory is needed for local variables and parameters) is determined at compile time. The layout of the stack frame (e.g., the order of variables and their offsets within the frame) is also determined at compile time.
 \bigbreak \noindent 
 The actual memory addresses on the stack are assigned at runtime when the function is called.
 \bigbreak \noindent 
 The stack pointer (a CPU register, e.g., esp on x86 or rsp on x86-64) keeps track of the current top of the stack and is adjusted dynamically as functions are called and return.
 \bigbreak \noindent 
 While stack memory is used for local variables, the actual allocation happens at runtime, not compile time.
 \bigbreak \noindent 
 When a function is called, the necessary stack space is allocated for its local variables.
 \bigbreak \noindent 
 The values of these variables are stored on the stack as the function executes.
 \bigbreak \noindent 
 When the function returns, the stack space is deallocated, effectively destroying the local variables.

 \bigbreak \noindent 
 \subsubsection{"Dynamic allocation"}
 \bigbreak \noindent 
 Dynamic memory allocation refers to memory that is explicitly allocated and deallocated at runtime by the programmer using new, new[], malloc(), or similar functions. This memory is managed on the heap, which has a more flexible lifespan than stack memory.

 \bigbreak \noindent 
 \subsubsection{Stack vs heap allocation}
 \bigbreak \noindent 
 Stack memory is allocated at runtime, but it is not explicitly controlled by the programmer. Instead, the compiler and runtime manage it automatically.
 \bigbreak \noindent 
 Unlike heap memory, stack allocation is deterministic (it follows a Last In, First Out order) and does not require explicit deallocation.
 \bigbreak \noindent 
 Heap memory, on the other hand, allows arbitrary allocation and deallocation at any time, making it truly "dynamic."

 \bigbreak \noindent 
 \subsubsection{Why new (dynamic allocation) is slow and stack allocation is fast}
 \bigbreak \noindent 
 The new operator in C++ is considered slow compared to stack allocation for several reasons
 \bigbreak \noindent 
 new allocates memory from the heap, which is managed dynamically by the operating system. Heap memory is not contiguous like the stack, so the allocator needs to search for a large enough free block of memory. This requires bookkeeping (maintaining free lists, fragmentation handling, etc.), which adds computational overhead.
 \bigbreak \noindent 
 If the heap does not have enough free space, new might call malloc(), which, in turn, may invoke sbrk() or mmap() at the OS level.
 \bigbreak \noindent 
    System calls (context switches to the kernel) are expensive compared to simple pointer arithmetic used in stack allocation.
    \bigbreak \noindent 
    Stack memory is pre-allocated at program startup. Allocation is just moving the stack pointer (simple arithmetic, e.g., esp -= size). No system calls or bookkeeping are required.
    \bigbreak \noindent 
    Deallocation is implicit—when a function returns, all its local variables are freed automatically.
    \bigbreak \noindent 
    Most systems use a downward-growing stack, meaning the stack grows from higher memory addresses to lower ones.
    \bigbreak \noindent 
    The Stack Pointer (SP or ESP/RSP in x86/x86-64) keeps track of the top of the stack.
    \bigbreak \noindent 
    Pushing data decrements the stack pointer (moves it to a lower address).
    \bigbreak \noindent 
    Popping data increments the stack pointer (moves it to a higher address).
    \bigbreak \noindent 
    Yes, the stack pointer (SP, ESP in x86, RSP in x86-64) is used to keep track of where to allocate and deallocate memory on the stack.
    \bigbreak \noindent 
    \subsubsection{Does new call malloc?}
    \bigbreak \noindent 
    in most standard C++ implementations, new eventually calls malloc() (or an equivalent memory allocation function), but with additional functionality.
    \bigbreak \noindent 
    When you write:
    \begin{cppcode}
    int* ptr = new int(10);
    \end{cppcode}
    \bigbreak \noindent 
    The following steps happen
    \begin{enumerate}
        \item operator new(size\_t) is called, which internally calls malloc(size).
        \item If malloc() succeeds, operator new() returns the allocated memory.
        \item The constructor is called (for non-POD types).
        \item A pointer to the object is returned.
    \end{enumerate}
    \bigbreak \noindent 
    For example, the default operator new() might look like this:
    \bigbreak \noindent 
    \begin{cppcode}
        void* operator new(std::size_t size) {
            void* ptr = std::malloc(size);  // Calls malloc internally
            if (!ptr) throw std::bad_alloc();  // Handle allocation failure
            return ptr;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Similarly, new[] calls malloc() but also stores extra metadata for array size.

    \bigbreak \noindent 
    \subsubsection{Delete}
    \bigbreak \noindent 
    In C++, when you use delete on a dynamically allocated object, it performs two main actions:
    \begin{itemize}
        \item Calls the object's destructor (if it has one).
        \item Frees the allocated memory using operator delete (which typically calls free under the hood but is not required to).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{How does delete know how many bytes to relinquish?}
    \bigbreak \noindent 
    The heap allocator (e.g., malloc internally in operator new) tracks allocations. This means when delete is called, the heap manager looks up the size using metadata stored alongside the allocated block.

    \bigbreak \noindent 
    \subsubsection{Dangling pointer, memory leak, and resource leak}
    \begin{itemize}
        \item \textbf{Dangling pointer}: A dangling pointer is a pointer that continues to reference a memory location that has been deallocated or freed. Accessing such a pointer can lead to undefined behavior, crashes, or security vulnerabilities.
        \item \textbf{Memory leak}: A memory leak occurs when dynamically allocated memory is not properly deallocated, causing unreachable memory to remain allocated until the program terminates. This can lead to increased memory consumption over time.
        \item \textbf{Resource leak}: A resource leak occurs when a program fails to release system resources such as file handles, network sockets, or database connections, leading to exhaustion of available system resources.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{New in detail}
    \bigbreak \noindent 
    When you use new to allocate memory for an object, the following happens:
    \begin{enumerate}
        \item \textbf{Memory allocation:} operator new(size\_t) is called to allocate memory from the heap.
        \item \textbf{Object construction:} The constructor of the object is called in the allocated memory.
        \item \textbf{Returns a pointer:} A pointer to the newly created object is returned
    \end{enumerate}
    \bigbreak \noindent 
    If memory allocation fails (e.g., due to insufficient memory), new throws a std::bad\_alloc exception (unless you're using the nothrow version of new).

    \bigbreak \noindent 
    \subsubsection{Behind the scenes}
    \bigbreak \noindent 
    Suppose we have a struct
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x{},y{};
        }
    \end{cppcode}
    \bigbreak \noindent 
    The following
    \bigbreak \noindent 
    \begin{cppcode}
        point* p = new point();
    \end{cppcode}
    \bigbreak \noindent 
    Is roughly equivalent to
    \bigbreak \noindent 
    \begin{cppcode}
        void* memory = operator new(sizeof(point));
        point* ptr = static_cast<point*>(memory);
        ptr = new (memory) point(); // or point{}
    \end{cppcode}
    \bigbreak \noindent 
    The first line This line allocates raw memory for an object of type point using the global operator new. This only allocates memory but does not construct the object.
    \bigbreak \noindent 
    The second line casts the raw memory to a pointer of type point*. However, the object is still not constructed at this point.
    \bigbreak \noindent 
    This line uses placement new to construct an object of type point in the already allocated memory. The placement new syntax is new (memory) point(), where memory is the pointer to the pre-allocated memory.
    \bigbreak \noindent 
    \subsubsection{operator new}
    \bigbreak \noindent 
    operator new is a low-level memory allocation function that allocates raw memory but does not invoke the constructor of an object. The syntax
    \bigbreak \noindent 
    \begin{cppcode}
    void* name = operator new(size)
    \end{cppcode}
    \bigbreak \noindent 
    performs the following steps
    \begin{enumerate}
        \item It calls the global operator new function, which allocates \textit{size} bytes of memory from the free store (heap).
        \item The returned pointer (memory) is of type void* because operator new does not know the actual type of the object to be constructed.
        \item The allocated memory is not yet initialized (i.e., no constructor is called )
    \end{enumerate}

    \bigbreak \noindent 
    \subsubsection{placement new}
    \bigbreak \noindent 
    Placement new is a special form of the new operator that constructs an object in a pre-allocated memory block. Instead of allocating memory from the heap, it initializes an object at a specific memory location.
    \bigbreak \noindent 
    \begin{cppcode}
        T* name = new (location) Obj()
    \end{cppcode}
    \bigbreak \noindent 
    Does not allocate new memory—it reuses the given memory.

    \bigbreak \noindent 
    \subsubsection{nothrow new}
    \bigbreak \noindent 
    In C++, the new operator throws an exception (std::bad\_alloc) if it fails to allocate memory. However, you can use std::nothrow to make new return nullptr instead of throwing an exception when memory allocation fails.
    \bigbreak \noindent 
    \begin{cppcode}
        int* ptr = new (std::nothrow) int[1000000000]; // Try to allocate a large array

        if (!ptr) {
            std::cout << "Memory allocation failed!\n";
        } else {
            std::cout << "Memory allocation successful!\n";
            delete[] ptr;
        }
    \end{cppcode}

\pagebreak 
\unsect{Categories}
\bigbreak \noindent 
The questions in this book fall into the following categories
\begin{itemize}
    \item Auto and type deduction
    \item Keyword static and its different uses
    \item Polymorphism, inheritance, and virtual functions
    \item Lambda functions
    \item How to use const
    \item Best practices in modern c++
    \item Smart pointers
    \item References, universal references
    \item C++20
    \item Special function and the rules of how many
    \item OOP, inheritance, poylmorphism
    \item Observable behaviors
    \item The STL
    \item Misc
\end{itemize}

\pagebreak 
\unsect{Auto and type deduction}
\bigbreak \noindent 
auto type deduction is usually the same as template type deduction, but auto type deduction assumes that a braced initializer represents a std::initializer\_list, and template type deduction doesn’t hold such premises.
\bigbreak \noindent 
\begin{cppcode}
    auto x = {1, 2, 3}; // auto deduces std::initializer_list<int>
\end{cppcode}
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(T t) {
        std::cout << typeid(T).name() << "\n";
    }

    int main() {
        func({1, 2, 3}); // ❌ Error: cannot deduce T from {1, 2, 3}
    }
\end{cppcode}
\bigbreak \noindent 
However, if we explicitly specify std::initializer\_list<T>, it works
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(std::initializer_list<T> t) {
        for (T n : t) {
            std::cout << n << " ";
        }
    }

    int main() {
        func({1, 2, 3}); // ✅ Works, T = int
    }
\end{cppcode}

\bigbreak \noindent 
\subsection{Auto with const}
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
    const int x = 10;
    auto y = x;   // y is `int`, not `const int`
\end{cppcode}
\bigbreak \noindent 
We must const qualify $y$ if we require it to maintain constness
\bigbreak \noindent 
\begin{cppcode}
const auto y = x; // y is int and const
\end{cppcode}


\bigbreak \noindent 
\subsection{Const with auto and references}
\bigbreak \noindent 
Using auto\& ensures that the deduced type keeps the const qualifier when referencing a const object.
\bigbreak \noindent 
\begin{cppcode}
const int a = 42;
auto& b = a;  // `b` is `const int&`
\end{cppcode}
\bigbreak \noindent 
\begin{cppcode}
    const int x = 5;
    auto& y = x;

    y = 15; // Error
\end{cppcode}
\bigbreak \noindent 
If $x$ were not const, we could also qualify $y$ to be const, therefore not allowing modification of $x$ through $y$
\bigbreak \noindent 
\begin{cppcode}
    int x = 5;
    const auto& y = x;

    y = 15; // Error
\end{cppcode}
\bigbreak \noindent 
So we see, auto cannot implicitly give us references, we must use auto\&

\bigbreak \noindent 
\subsection{Const with auto and pointers}
\bigbreak \noindent 
First, recall
\bigbreak \noindent 
\begin{cppcode}
    int x = 5;
    int y = 10;

    // Pointer is mutable, value is not
    const int* ptr = &x; 
    int const* ptr = &x; // Pointer is mutable, value is not
    //
    // // // Pointer is immutable, value is mutable
    int* const ptr = &x;
    int *const ptr = &x;

    // Pointer and value are immutable
    const int* const ptr = &x;
    const int *const ptr = &x;
    int const *const ptr = &x;
\end{cppcode}
\bigbreak \noindent 
First, we discuss mutable pointers to const values
\bigbreak \noindent 
\begin{cppcode}
    // Pointer is mutable, value is not
    const int* ptr = &x; 

    // Pointer to constant int
    auto ptr2 = ptr;
    *ptr2 = 20; // Error
    // Pointer is mutable
    ptr2 = &y;

    // Both value and pointer are immutable
    const auto ptr2 = ptr;
    *ptr2 = 20;  // Error
    ptr2 = &y // Error
\end{cppcode}
\bigbreak \noindent 
Next, constant pointers to non-const data
\bigbreak \noindent 
\begin{cppcode}
    // Pointer is immutable, value is mutable
    int* const ptr = &x;

    // Disregards const, ptr2 is non-const and value is non-const
    auto ptr2 = ptr;
    *ptr2 = 20;
    ptr2 = &y; 

    // Pointer is const, value non-const
    const auto ptr2 = ptr;
\end{cppcode}
\bigbreak \noindent 
Similarly for const pointers to const data, using auto will maintain constness for the data, but not for the pointer. Therefore, in this case, we must also qualify ptr2 with const.

\bigbreak \noindent 
\subsection{rvalue references with auto}
\bigbreak \noindent 
\begin{cppcode}
    int x = 50;
    auto&& y = x; // y is int&
    auto&& z = 50; // z is int&&
\end{cppcode}

\bigbreak \noindent 
\subsection{Auto in function return types or lambda parameters}
\bigbreak \noindent 
auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.

\bigbreak \noindent 
\subsection{When can auto deduce undesired types?}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    std::vector<bool> foo() {
        // ...
    }

    void bar(bool b) {
        // ...
    }

    auto someBit = foo()[2]; // this is some pointer to a temp object

    std::vector<bool> bits{ true, false, false, true };
    bar(bits[2]); // Undefined behaviour
\end{cppcode}
\bigbreak \noindent 
std::vector<bool> is a specialized version of std::vector that is optimized for space efficiency. Instead of storing each bool as a full byte, it typically stores each bool as a single bit.
\bigbreak \noindent 
This specialization means that std::vector<bool> does not behave exactly like other std::vector types. Specifically, accessing elements does not return a reference to a bool but rather a proxy object (of type std::vector<bool>::reference) that simulates a reference to a single bit.
\bigbreak \noindent 
When you access an element of a std::vector<bool> using operator[], it returns a temporary proxy object (std::vector<bool>::reference) that represents the bit at that position.
\bigbreak \noindent 
This proxy object can be implicitly converted to a bool, but it is not a direct reference to a bool in the vector.
\bigbreak \noindent 
Temporary objects (like the proxy object returned by foo()[2]) are destroyed at the end of the full expression in which they are created. This means that if you try to use the temporary object after the expression, you will be accessing a destroyed object, leading to undefined behavior.
\bigbreak \noindent 
\textbf{Note:} A proxy object is an intermediate object that stands in for another object. In the case of std::vector<bool>, accessing an element (e.g., foo()[2]) returns a proxy object of type std::vector<bool>::reference. This proxy object is not a direct reference to a bool but rather a lightweight object that provides access to a single bit in the underlying storage of the std::vector<bool>.
\bigbreak \noindent 
So what's happening here?
\begin{enumerate}
    \item foo() returns a temporary std::vector<bool>.
    \item foo()[2] creates a temporary proxy object (std::vector<bool>::reference) that refers to the bit at index 2 in the temporary vector.
    \item The temporary proxy object is assigned to $x$.
\end{enumerate}
However, the problem arises because The temporary std::vector<bool> returned by foo() is destroyed at the end of the full expression.
\bigbreak \noindent 
The proxy object (std::vector<bool>::reference) depends on the temporary vector for its existence. Once the vector is destroyed, the proxy object becomes invalid because it no longer has a valid vector to refer to.
\bigbreak \noindent 
The language rules specify that temporaries are destroyed at the end of the full expression unless they are bound to a const reference (which extends their lifetime to the lifetime of the reference).
\bigbreak \noindent 
Proxy objects like std::vector<bool>::reference are not regular objects but rather lightweight intermediaries. They are not designed to outlive the container they depend on.
\bigbreak \noindent 
To avoid the problem of the proxy object becoming invalid, you need to ensure that the std::vector<bool> outlives the proxy object. Here are two ways to do this:
\bigbreak \noindent 
1. Store the vector in a named variable
\bigbreak \noindent 
\begin{cppcode}
auto bits = foo(); // Store the vector in a named variable
auto x = bits[2];  // Access the bit from the persistent vector
\end{cppcode}
\bigbreak \noindent 
 Extract the value immediately, If you only need the value of the bit and not the proxy object, you can extract the value immediately:
 \bigbreak \noindent 
 \begin{cppcode}
 bool x = foo()[2]; // Extract the value of the bit
 \end{cppcode}
 \bigbreak \noindent 
 Here, x is a bool (not a proxy object), so it does not depend on the temporary vector.
 \bigbreak \noindent 
 In such situations, it’s better either not to use auto at all, or use the idiom that Meyers (effective modern c++) calls the the explicitly typed initializer idiom.
 \begin{cppcode}
     auto x = static_cast<bool>(bits[2])
 \end{cppcode}
 \bigbreak \noindent 
 The idiom can also come in handy when you deal with proxy types.

 \bigbreak \noindent 
 \subsection{What is the type of a lambda?}
 \bigbreak \noindent 
 Consider the code
 \bigbreak \noindent 
 \begin{cppcode}
     auto f = []() { return 12; }; // Type is class(lambda)
 \end{cppcode}
 \bigbreak \noindent 
 then the type of $f$ is a lambda closure type. The compiler generates a unique unnamed class to represent the lambda expression.
 \bigbreak \noindent 
 It is a unique unnamed structure that overloads the function call operator. Every instance of a lambda introduces a new type.
 \bigbreak \noindent 
 When a lambda captures variables, it still generates a unique compiler-defined class, but with data members corresponding to the captured variables.
 \bigbreak \noindent 
 In the special case of a non-capturing lambda, the structure in addition has an implicit conversion to a function pointer.
 \bigbreak \noindent 
 \begin{cppcode}
     auto f = []() ->int {
        return 12;
    };
    int (*g)();
    g=f; // OK

    auto f = [&]() ->int {
        return 12;
    };
    int (*g)();
    g=f; // ERROR
 \end{cppcode}





 \bigbreak \noindent 
 \subsection{What are the advantages of using auto?}
 \bigbreak \noindent 
 auto variables must be initialized and as such, they are generally immune to type mismatches that can lead to portability or efficiency problems. auto can also make refactoring easier, and it typically requires less typing than explicitly specified types.
 \bigbreak \noindent 
 auto variables mainly can improve correctness, performance, maintainability, and robustness. It is also more convenient to type, but that’s its least important advantage.
 \bigbreak \noindent 
 Consider declaring local variables auto x = type\{ expr \}; when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, and
 \bigbreak \noindent 
 it guarantees the variable will be initialized, in addition, it won’t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use ( ) instead of \{ \}.
 \bigbreak \noindent 
 \subsubsection{Regarding local variables}
 \bigbreak \noindent 
 Regarding local variables, if you use the auto x = expr; way of declaration, there are many advantages.
 \begin{itemize}
     \item It’s guaranteed that your variable will be initialized. If you forgot, you’ll get an error from the compiler.
     \item There are no temporary objects, implicit conversion, so it is more efficient.
     \item Using auto guarantees that you will use the correct type.
     \item In the case of maintenance, refactoring, there is no need to update the type.
     \item It is the simplest way to portably spell the implementationspecific type of arithmetic operations on built-in types. Those types might vary from platform to platform, and it also ensures that you cannot accidentally get lossy narrowing conversions.
     \item You can omit difficult to spell types, such as lambdas, iterators, etc.
 \end{itemize}

 \bigbreak \noindent 
 \subsubsection{Correctness}
 \bigbreak \noindent 
 auto ensures that variables have the exact type returned by expressions, preventing unintended type conversions.
 \bigbreak \noindent 
 \begin{cppcode}
 auto x = someFunction(); // Exact type of the return value
 \end{cppcode}
 \bigbreak \noindent 
 Complex template or iterator types are assigned correctly
 \bigbreak \noindent 
 \begin{cppcode}
     std::unordered_map<std::string, int> myMap;
     auto it = myMap.begin(); // Correct type without manually specifying
 \end{cppcode}

 \bigbreak \noindent 
 \subsubsection{Performance}
 \bigbreak \noindent 
 When used with references (auto\&), auto can prevent unnecessary copies.
 \bigbreak \noindent 
 \begin{cppcode}
     std::vector<int> vec = {1, 2, 3};
     for (auto& v : vec) { // Avoids copying
         v *= 2;
     }
 \end{cppcode}
 \bigbreak \noindent 
 And, 
 \bigbreak \noindent 
 \textbf{More Efficient Type Deduction:} Instead of relying on implicit conversions, auto allows for direct initialization with the optimal type.

 \bigbreak \noindent 
 \subsubsection{Maintainability}
 \bigbreak \noindent 
 If the return type of a function changes, auto ensures code doesn't need manual updates.
 \bigbreak \noindent 
 \begin{cppcode}
 auto result = computeValue(); // No need to change type if computeValue() changes
 \end{cppcode}
 \bigbreak \noindent 
 \subsubsection{Robustness}
 \bigbreak \noindent 
 \begin{itemize}
     \item \textbf{Ensures Type Safety in Loops:} Avoids iterator mismatches.
         \bigbreak \noindent 
         \begin{cppcode}
             std::vector<std::string> words = {"hello", "world"};
             for (auto it = words.begin(); it != words.end(); ++it) {
                 std::cout << *it << "\n";
             }
         \end{cppcode}
         \item \textbf{Encourages Strong Typing with auto\&\&:} Useful in templates for perfect forwarding.
             \bigbreak \noindent 
             \begin{cppcode}
                 template <typename T>
                 void wrapper(T&& arg) {
                     process(std::forward<T>(arg)); // Maintains the original type (lvalue/rvalue)
                 }
             \end{cppcode}
 \end{itemize}

 \bigbreak \noindent 
 \subsection{Intializer\_lists}
 \bigbreak \noindent 
 Consider
 \bigbreak \noindent 
 \begin{cppcode}
 auto myCollection = {1,2,3};
 \end{cppcode}
 \bigbreak \noindent 
 The type is std::initializer\_list<int>. The int part is probably straightforward, and about std::initializer\_list, well you just have to know that with auto type deduction, if you use braces, you have two options
 \bigbreak \noindent 
 If you put nothing between the curly braces, you’ll get a compilation error as the compiler is unable to deduce ‘std::initializer\_list<auto>’ from ‘<brace-enclosed initializer list>()’. So you don’t get an empty container, but a compilation error instead.
 \bigbreak \noindent 
 If you have at least one element between the braces, the type will be std::initializer\_list.
 \bigbreak \noindent 
 If you wonder what this type is, you should know that it is a lightweight proxy object providing access to an array of objects of type const T. It is automatically constructed when:
 \bigbreak \noindent 
 \begin{itemize}
     \item a braced-init-list is used to list-initialize an object, where the corresponding constructor accepts a std::initializer\_list parameter
     \item a braced-init-list is used on the right side of an assignment or as a function call argument, and the corresponding assignment operator/function accepts a std::initializer\_list parameter
     \item a braced-init-list is bound to auto, including in a ranged for loop
 \end{itemize}
 \bigbreak \noindent 
 Initializer lists may be implemented with a pair of pointers or with a pointer and a length. Copying a std::initializer\_list is considered a shallow copy as it doesn’t copy the underlying objects.

 \bigbreak \noindent 
 \subsection{decltype}
 \bigbreak \noindent 
 \subsection{Decltype vs auto}
 \bigbreak \noindent 
 decltype deduces the exact type of an expression, including references and const qualifiers. It does not evaluate the expression, only inspects its type. If you pass a variable name without parentheses, it gives the declared type. If you pass an expression, the result depends on how the expression is formed.
 \bigbreak \noindent 
 \begin{cppcode}
 int x = 20;
 const int& y=x;
 decltype(y) z = x; // Const int&
 \end{cppcode}
 \bigbreak \noindent 
 When decltype is applied to an expression inside parentheses, it deduces the type as a reference if the expression is an lvalue.
 \bigbreak \noindent 
 \begin{cppcode}
 int x = 20;
 decltype(x) y; // Int
 decltype((x)) y = x; // int&

 const int x = 10;
 decltype(x) y = x; // const int
 decltype((x)) z = x; // const int&

 decltype(10) k; // int
 decltype((10)) r; // int
 \end{cppcode}

 \bigbreak \noindent 
 auto does not preserve references unless explicitly specified. It removes const qualifiers unless the initializer is explicitly const.
 



 \bigbreak \noindent 
 Consider
 \bigbreak \noindent 
 \begin{cppcode}
     struct A {
         double x;
     }

     // a is a pointer to an A that is const
     const A* a;

     decltype(a->x) y // y is a double
     decltype((a->x)) y = z // z is a const double& to y
 \end{cppcode}
 \bigbreak \noindent 
 When decltype is used without parentheses, it gives the declared type
 \bigbreak \noindent 
 \begin{cppcode}
     decltype(a->x) y;  // y is of type double
 \end{cppcode}
 \bigbreak \noindent 
 When decltype is applied to a parenthesized expression, it deduces the expression's type with reference qualifiers:
 \bigbreak \noindent 
 \begin{cppcode}
    decltype((a->x)) z = y; // const double& 
    const decltype(a->x)& z = y; // Equivalent
 \end{cppcode}
 \bigbreak \noindent 
 Thus, z is a double\&, but since $A$ is a pointer to a constant objects, (a->x) is a reference to a constant

 \bigbreak \noindent 
 \subsection{decltype(auto)}
 \bigbreak \noindent 
 The decltype(auto) idiom was introduced in C++14. Like auto, it deduces a type from its initializer, but it performs the type deduction using the decltype rules.
 \bigbreak \noindent 
 in generic code, you have to be able to perfectly
forward a return type without knowing whether you are dealing
with a reference or a value. decltype(auto) gives you that ability:
\bigbreak \noindent 
\begin{cppcode}
template<class Fun, class... Args>
decltype(auto) foo(Fun fun, Args&&... args) {
    return fun(std::forward(args)...);
}
\end{cppcode}
\bigbreak \noindent 
If you wanted to achieve the same thing simply with auto, you
would have to declare different overloads for the same example
function above, one with the return type auto always deducing to
a pure value, and one with auto\& always deducing to a reference
type.

\pagebreak 
\unsect{Keyword static and its different uses }
\bigbreak \noindent 
\subsection{What does a static member variable in C++ mean?}
\bigbreak \noindent 
A member variable that is declared static is allocated storage in the static storage area, only once during the program lifetime. Given that there is only one single copy of the variable for all objects, it’s also called a class member.
\bigbreak \noindent 
When we declare a static member in the header file, we’re telling
the compiler about the existence of a static member variable,
but we do not actually define it (it’s pretty much like a forward
declaration in that sense). Because static member variables are not
part of class instances (they are treated similarly to global variables,
and get initialized when the program starts), you must explicitly
define the static member outside of the class, in the global scope.
\bigbreak \noindent 
\begin{cppcode}
class A {
    static MyType s_var;
};
MyType A::s_var = value;
\end{cppcode}
\bigbreak \noindent 
Though there are a couple of exceptions. First, when the static member is a const integral type (which includes char and bool) or a const enum, the static member can be initialized inside the class definition:
\bigbreak \noindent 
\begin{cppcode}
class A {
    static const int s_var{42};
};
\end{cppcode}
\bigbreak \noindent 
If the member is not const, you either have to initialize it out-of-line,
or you have to use the inline keyword
\bigbreak \noindent 
static constexpr members can be initialized inside the class definition starting from C++17 (no out-of-line initialization required)
\bigbreak \noindent 
It’s been already mentioned but it’s worth emphasizing that static
member variables are created when the program starts and destroyed when the program ends and as such static members exist
even if no objects of the class have been instantiated.


\bigbreak \noindent 
\subsection{What does a static member function mean in C++?}
\bigbreak \noindent 
static member functions can be used to work with static member
variables in the class or to perform operations that do not require an
instance of the class. Yet the actions performed in a static member
function should conceptually, semantically be strongly related to
the class. Some key points about static member functions.
\begin{itemize}
    \item static member functions don’t have the this pointer
    \item static member functions cannot be virtual
    \item static member functions cannot access non-static members
    \item The const and volatile qualifiers aren’t available for static member functions
\end{itemize}
\bigbreak \noindent 
In practice, a static member functions mean that you can call
such functions without having the class instantiated (you can also call it on an instance).
\bigbreak \noindent 
\begin{cppcode}
    struct S {
        static void print() {}
    };

    S::print();
    S s;
    s.print();
\end{cppcode}
\bigbreak \noindent 
As this pointer always holds the memory address of the current object and to call a static member you don’t need an object at all, it cannot have a this pointer.
\bigbreak \noindent 
A virtual member is something that doesn’t relate directly to any class, only to an instance. A “virtual function” is (by definition) a function that is dynamically linked, i.e. the right implementaion is chosen at runtime depending on the dynamic type of a given object. Hence, if there is no object, there cannot be a virtual call.
\bigbreak \noindent 
Accessing a non-static member function requires that the object has been constructed but for static calls, we don’t pass any instantiation of the class. It’s not even guaranteed that any instance has been constructed.
\bigbreak \noindent 
Once again, the const and the const volatile keywords modify whether and how an object can be modified or not. As there is no object
\bigbreak \noindent 
\subsection{What is the static initialization order fiasco?}
\bigbreak \noindent 
The static initialization order fiasco is a subtle aspect of C++ that
many don’t know about, don’t consider or misunderstand. It’s hard
to detect as the error often occurs before main() would be invoked.
\bigbreak \noindent 
Static or global variables in one translation unit are always initialized according to their definition order. On the other hand, there is
no strict order for which translation unit is initialized first.
\bigbreak \noindent 
Let’s suppose that you have a translation unit A with a static
variable sA, which depends on static variable sB from translation
unit B in order to get initialized. You have 50\% chance to fail. This
is the static initialization order fiasco.
\bigbreak \noindent 
\begin{cppcode}
// File1.cpp
#include <string>
std::string name = "Julia";

// File2.cpp
#include <string>
extern std::string message = "Hello, " + name;

int main() {cout << message;}
// g++ -o bin file2.cpp file1.cpp
// ./bin "Hello, "

// g++ -o bin file1.cpp file2.cpp
// ./bin "Hello, Julia"
\end{cppcode}

\bigbreak \noindent 
\subsection{How to solve the static initialization order fiasco?}
\bigbreak \noindent 
Probably the simplest solution is to replace the variable in file1.cpp with a function. Observe
\bigbreak \noindent 
\begin{cppcode}
// file1.cpp
#include <string>
std::string foo() {
    return std::string("Julia");
}

// file2.cpp
#include <string>
extern std::string foo();
std::string message = "Hello, " + foo();

int main() {cout << message;}
// g++ -o bin file2.cpp file1.cpp
// ./bin "Hello, Julia"

// g++ -o bin file1.cpp file2.cpp
// ./bin "Hello, Julia"
\end{cppcode}

\bigbreak \noindent 
Starting from C++20, the static initialization order fiasco can be solved with the use of constinit. In this case, the static variable will be initialized at compile-time, before any linking.

\bigbreak \noindent 
\begin{cppcode}
    // File1.cpp
    #include <string>
    constinit std::string name = "Julia";

    // File2.cpp
    #include <string>
    extern std::string message = "Hello, " + name;

    int main() {cout << message;}
    // g++ -o bin file2.cpp file1.cpp
    // ./bin "Hello, Julia"

    // g++ -o bin file1.cpp file2.cpp
    // ./bin "Hello, Julia"
\end{cppcode}

\pagebreak 
\unsect{Polymorphism, inheritance and virtual functions}
\bigbreak \noindent 
\subsection{Rules for virtual functions}
\bigbreak \noindent 
\begin{itemize}
    \item They are always member functions
    \item They cannot be static
    \item They can be a friend of another class
    \item C++ does not contain virtual constructors but can have a virtual destructor
\end{itemize}
\bigbreak \noindent 
In fact, if you want to allow other classes to inherit from a given class, you should always make the destructor virtual, otherwise, you can easily have undefined behaviour
\bigbreak \noindent 
if you are using inheritance and intend to delete derived objects through a base class pointer, you should always make the base class destructor virtual, even if there are no other virtual functions.
\bigbreak \noindent 
If the base class destructor is not virtual and you delete a derived object through a base class pointer, only the base class destructor will be called, leading to undefined behavior (UB) due to a memory leak.
\bigbreak \noindent 
When you declare print() as virtual in the base class, it ensures that the function call is dynamically dispatched.
\bigbreak \noindent 
Even though derived::print() is private, it is still part of the vtable, and the lookup mechanism allows it to be called when accessed through a base class pointer
\bigbreak \noindent 
Since b->print(); is being called via a base* pointer, the compiler only checks whether base::print() is accessible from the calling scope (which it is, because it's public).
\bigbreak \noindent 
The actual function executed (derived::print()) is resolved at runtime, at which point access specifiers do not matter.
\bigbreak \noindent 
Thus, the following would not work
\bigbreak \noindent 
\begin{cppcode}
    struct base {
        private:
        virtual void print() const {cout << "Base" << endl;}
    };

    struct derived : base{
        private:
        void print() const override {cout << "Derived" << endl;}
    };
    base* b = new derived{};
    b->print(); // Print is a private member of base
\end{cppcode}
\bigbreak \noindent 
Notice that both print methods are now private
\bigbreak \noindent 




 

































\end{document}
