\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={C++ Daily Interview}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{C++ Daily Interview}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{The different interview processes}
    \bigbreak \noindent 
    \subsection{The big tech style interview process}
    \bigbreak \noindent 
One of them, the more usual one nowadays is very competitive and has several rounds. It starts with an initial screening call that is often conducted by a non-technical person, a recruiter. However, I’ve heard and seen cases where even the first contacts were made by engineers so that they can see earlier whether you’d be a good fit for the team.
\bigbreak \noindent 
This first round might have been preceded by a 0th round with some takeaway exercise. The idea behind
is that if you cannot prove a certain level of expertise, they don’t want to waste their time on the
applicant. Sometimes this exercise is way too long and many of us would outright reject such homework.
If it’s more reasonable, you can complete it in an hour or two.
\bigbreak \noindent 
After the screening, there is a technical round that is usually quite broad and there is not a lot of time to
go deep on the different topics. It’s almost sure that you’ll get an easy or medium-level Leetcode-style
coding exercise. For those, you must be able to reason about algorithmic complexities and it’s also very
useful if you are more than familiar with the standard library of your language. Apart from a coding
exercise, expect more general questions about your chosen language.
\bigbreak \noindent 
By understanding your language deeper -
something this book helps with - you’ll have a better chance to reach the next and usually final round of
interviews, the so-called on-site. Even if it’s online, it might still be called on-site and it’s a series of
interviews you have to complete in one day or sometimes spanned over one day.
\bigbreak \noindent 
It typically has 3 or 4 different types of interviews.
\begin{itemize}
    \item Behavioural interviews focusing on your soft skills
    \item A system design interview where you get a quite vague task to design a system. You have to clarify what the requirements are and you have to come up with the high-level architecture and dig deeper into certain parts
    \item There are different kinds of coding interviews
        \begin{enumerate}
            \item \textbf{Coding exercises}: You won’t be able to solve coding exercises with what you learn in this book, but you’ll be able to avoid some pitfalls with a deeper understanding of the language. Daily C++ Interview helps you to achieve that understanding. In addition, you must practice on pages like Leetcode, Hackerrank, Codingame, etc
            \item \item \textbf{Debug interview}: You receive a piece of code and you have to find the bugs. Sometimes this can be called a code review interview. It’s still about finding bugs. Personally, I find it a bit deeper than a simple coding exercise. In a coding interview, you are supposed to talk about design flaws, code smells, and testability. If you know C++ well enough, if you try to answer some of the questions of Daily C++ Interview on a day-to-day basis, you’ll have a much better chance to recognize bugs, smells, flaws and pass the interview.
        \end{enumerate}
\end{itemize}

\bigbreak \noindent 
\subsection{The shorter interview process}
\bigbreak \noindent 
Certain companies try to compete for talent by shortening their interview cycles and making a decision as fast as possible. Often they promise a decision in less than 10 days. Usually, they don’t offer so competitive packages - but even that is not always true - so they try to compete on something else.
\bigbreak \noindent 
A shorter decision cycle obviously means fewer interviews. Sometimes this approach is combined with the lack of coding interviews - at least for senior engineers. The idea behind is that many engineers despise the idea of implementing those coding exercises. They find it irrelevant and even derogative to implement a linked list. Instead, they will ask questions that help evaluate how deep you understand the given programming language.

\pagebreak 
\unsect{Background}
\bigbreak \noindent 
\subsection{Rvalue references}
\bigbreak \noindent 
An rvalue reference is a reference that can only bind to rvalues (temporary values).
\bigbreak \noindent 
\begin{cppcode}
int&& x = 50;
\end{cppcode}
\bigbreak \noindent 
Here, $z$ is an rvalue reference that binds directly to the temporary value 50. While this might seem trivial for primitive types like int, it becomes powerful when working with objects that manage resources (e.g., strings, vectors, or custom classes). By binding to an rvalue, you can extend the lifetime of the temporary object and potentially "move" its resources.
\bigbreak \noindent 
\begin{cppcode}
void func(int&& param) {
    std::cout << "Rvalue reference received\n";
}

int main() {
    int x = 10;
    // func(x);  // Error! x is an lvalue
    func(20);    //  OK, 20 is an rvalue
    
    int&& z = 30;
    func(z);
}
\end{cppcode}
\bigbreak \noindent 
Rvalue references allow efficient resource transfers via std::move. They do not accept lvalues.
\bigbreak \noindent 
\subsection{Universal References (T\&\& in templates)}
\bigbreak \noindent 
A universal reference is when T\&\& appears in a template parameter and depends on type deduction.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(T&& param) {
        std::cout << "Universal reference received\n";
    }

    int main() {
        int x = 10;
        func(x);   //  param is int& (lvalue reference)
        func(20);  //  param is int&& (rvalue reference)
    }
\end{cppcode}
\bigbreak \noindent 
Universal references can bind to both lvalues and rvalues. Their behavior depends on type deduction. Used primarily for perfect forwarding

\bigbreak \noindent 
\subsection{Perfect forwarding}
\bigbreak \noindent 
Perfect forwarding is a technique that allows a function to pass its arguments to another function while preserving their original value category (i.e., whether they are lvalues or rvalues).
\bigbreak \noindent 
This is crucial when writing generic functions that should forward arguments efficiently, without unnecessary copies or moves.
\bigbreak \noindent 
\subsubsection{The Problem Without Perfect Forwarding}
\bigbreak \noindent 
Without perfect forwarding, lvalues and rvalues can be unintentionally converted, leading to performance issues.
\bigbreak \noindent 
\begin{cppcode}
    void func(int& x) { std::cout << "Lvalue reference\n"; }
    void func(int&& x) { std::cout << "Rvalue reference\n"; }

    template <typename T>
    void wrapper(T x) {  // Passes by value (unintended copy)
        func(x); // Always an lvalue inside wrapper
    }

    int main() {
        int a = 10;
        wrapper(a);  // Calls func(int&) (expected)
        wrapper(20); // Calls func(int&) (unexpected, should be func(int&&))
    }
\end{cppcode}
\bigbreak \noindent 
The problem is that T x always treats x as an lvalue inside wrapper, even if it was originally an rvalue. This causes an unnecessary copy and prevents func(int\&\&) from being called.
\bigbreak \noindent 
\subsubsection{ Perfect Forwarding with std::forward}
\bigbreak \noindent 
Perfect forwarding ensures that arguments retain their original value category.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void wrapper(T&& arg) { 
        func(std::forward<T>(arg));  // Perfectly forwards argument
    }
\end{cppcode}
\begin{itemize}
    \item If arg is an lvalue, T deduces as T\&, so std::forward<T>(arg) behaves like an lvalue reference.
    \item If arg is an rvalue, T deduces as T, so std::forward<T>(arg) behaves like an rvalue reference.
\end{itemize}
\bigbreak \noindent 
If you do not use std::forward in a universal reference (T\&\& in a template), the argument loses its rvalue status and is always treated as an lvalue inside the function. This can lead to incorrect function overload resolution and unnecessary copies/moves.
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void wrapper(T&& arg) { 
        func(arg);  // Problem: 'arg' is always an lvalue inside wrapper
    }
\end{cppcode}
\bigbreak \noindent 
Even though arg is declared as T\&\&, it becomes an lvalue when used inside wrapper.
\bigbreak \noindent 
This means that even if you pass an rvalue, it will be treated as an lvalue.













% \bigbreak \noindent 
% Every rvalue ref is denoted by ‘\&\&’ but the converse is not true
% \begin{align*}
%     \text{rvalue reference } \implies \&\& \\
%     \&\& \not\implies \text{ rvalue reference}
% \end{align*}
% \bigbreak \noindent 
% “\&\&” in source code though may have the syntactic appearance of an rvalue reference (“\&&”), but the meaning of an lvalue reference (“\&”).

\bigbreak \noindent 
\subsection{Exception safety: four types}
\bigbreak \noindent 
Exception safety in C++ refers to the guarantees a function or piece of code provides regarding its behavior when exceptions are thrown. Exception safety ensures that objects remain in a valid state and that resources (such as memory, file handles, and locks) are properly managed even in the presence of exceptions.
\bigbreak \noindent 
Exception safety is typically categorized into four levels:
\begin{enumerate}
    \item \textbf{No Guarantee (Unsafe)}: The function provides no exception safety. If an exception is thrown, the program may enter an invalid state, leak resources, or cause undefined behavior.
        \bigbreak \noindent 
        \begin{cppcode}
            void unsafeFunction(std::vector<int>& vec, int value) {
                vec.push_back(value); // If push_back throws, `vec` may be in an inconsistent state.
                doSomething(); // May not run if push_back fails.
            }
        \end{cppcode}
    \item \textbf{Basic Guarantee}: If an exception is thrown, no resources leak, and all objects remain in a valid (but possibly modified) state.
        \bigbreak \noindent 
        \begin{cppcode}
            void basicGuarantee(std::vector<int>& vec, int value) {
                try {
                    vec.push_back(value); // If this throws, `vec` is still valid.
                } catch (...) {
                    // Exception handling ensures no resource leaks.
                }
            }
        \end{cppcode}
    \item \textbf{Strong Guarantee}: Either the function succeeds completely or has no effect (strong exception safety). This is often achieved using copy-and-swap techniques or transactions.
        \bigbreak \noindent 
        \begin{cppcode}
            void strongGuarantee(std::vector<int>& vec, int value) {
                std::vector<int> temp(vec); // Copy to temporary
                temp.push_back(value); // Modify the copy
                vec.swap(temp); // Commit the change safely
            }
        \end{cppcode}
        \bigbreak \noindent 
        If push\_back throws, vec remains unchanged.
    \item \textbf{No-Throw Guarantee (Exception Neutrality)}: The function is guaranteed not to throw exceptions. Achieved by using only non-throwing operations (noexcept)
        \bigbreak \noindent 
        \begin{cppcode}
            void noThrowFunction(std::vector<int>& vec, int value) noexcept {
                vec.push_back(value); // Assumes `push_back` does not throw
            }
        \end{cppcode}
\end{enumerate}

\bigbreak \noindent 
\subsection{Resource Acquisition Is Initialization (RAII)}
\bigbreak \noindent 
Resource Acquisition Is Initialization (RAII) is a programming technique in C++ where resource management (such as memory, file handles, or locks) is tied to the lifetime of objects. This ensures that resources are acquired in a constructor and released in a destructor, providing exception safety and preventing resource leaks.
\bigbreak \noindent 
Smart pointers are an example of this
\bigbreak \noindent 
\begin{cppcode}
    void badFunction() {
        int* ptr = new int(10);
        throw std::runtime_error("Exception!"); 
        delete ptr;  // This line is never reached, memory leak!
    }
\end{cppcode}
\bigbreak \noindent 
With smart pointers, we can guarantee RAII
\bigbreak \noindent 
\begin{cppcode}
    void goodFunction() {
        std::unique_ptr<int> ptr = std::make_unique<int>(10);
        throw std::runtime_error("Exception!"); 
        // `ptr` is destroyed automatically, no memory leak.
    }
\end{cppcode}
\bigbreak \noindent 
The name Resource Acquisition Is Initialization (RAII) comes from the idea that acquiring a resource (e.g., memory, file, mutex, etc.) should happen at the same time as object initialization—specifically, in the constructor of a class.
\begin{itemize}
    \item Resource Acquisition $\to$ The act of obtaining or allocating a resource (e.g., opening a file, allocating memory).
    \item Is Initialization $\to$ This acquisition happens during the initialization phase of an object, meaning inside its constructor.
\end{itemize}
\bigbreak \noindent 
C++ only guarantees deterministic destruction for objects with automatic (stack) storage duration. That is, objects created on the stack are automatically destroyed when they go out of scope.
\bigbreak \noindent 
However, RAII extends this guarantee to dynamically allocated resources by using smart pointers and custom RAII classes.
\bigbreak \noindent 
If resource acquisition does not happen during the initialization phase (i.e., inside the constructor in C++), several issues can arise, primarily resource leaks, partially initialized objects, and lack of exception safety.
\bigbreak \noindent 
If a class does not acquire its resource in the constructor, but instead in a separate function, the object may exist in an invalid state.
\bigbreak \noindent 
\begin{cppcode}
class ResourceManager {
    FILE* file;
public:
    ResourceManager() { file = nullptr; } // No resource acquired here 

    void openFile(const char* filename) {
        file = fopen(filename, "r");  // Resource acquired separately 
    }

    ~ResourceManager() {
        if (file) fclose(file);
    }
};

int main() {
    ResourceManager rm;
    // Forgot to call `openFile()`, now `rm` is in an invalid state 
}
\end{cppcode}
\bigbreak \noindent 
The object exists in an invalid state unless openFile() is called manually. A user of the class might forget to call openFile(), leading to runtime errors.

\bigbreak \noindent 
\subsection{The partition of memory}
\bigbreak \noindent 
In C++, when a program runs, its memory is divided into distinct segments, each serving different purposes. These segments partition the memory block allocated to the program
\bigbreak \noindent 
\subsubsection{Text segment (code segment)}
\bigbreak \noindent 
This segment contains the executable code of the program. It is usually read-only to prevent accidental modification. The size of this segment is fixed once the program is loaded into memory.

\bigbreak \noindent 
\subsubsection{Data Segment}
\bigbreak \noindent 
Stores global and static variables.
\begin{itemize}
    \item \textbf{Initialized Data Segment:} Stores global/static variables with explicit initial values.
    \item \textbf{Uninitialized Data Segment (BSS - Block Started by Symbol):} Stores global/static variables initialized to zero (default).
\end{itemize}

\bigbreak \noindent 
\subsubsection{Stack}
\bigbreak \noindent 
Used for function calls, local variables, and return addresses. Each function call pushes a new frame onto the stack, which is popped when the function returns. The stack grows downward (toward lower memory addresses).
\bigbreak \noindent 
It has a fixed size, set by the operating system or runtime environment.
\bigbreak \noindent 
Stack Overflow happens if it exceeds its allocated space (e.g., excessive recursion).
\bigbreak \noindent 
On linux the default stack size is typically 8mb, on windows it is typically 1mb.
\bigbreak \noindent 
Note that the \textit{call stack} is essentially the stack in the context of program execution. However, the term "call stack" specifically refers to how the stack is used to manage function calls, while "stack" is a more general term for the data structure or memory region itself. Let me clarify the relationship between the two:
\bigbreak \noindent 
The call stack is a region of memory that operates as a Last-In-First-Out (LIFO) data structure. It is used to keep track of function calls, their parameters, local variables, and control flow. Each time a function is called, a new stack frame (or activation record) is created and pushed onto the call stack. When the function returns, its stack frame is popped off the stack.
\bigbreak \noindent 
The last function called is the first one to return, which aligns with the LIFO principle.
\bigbreak \noindent 
A special register (e.g., esp on x86 or rsp on x86-64) keeps track of the current top of the stack. It is adjusted as data is pushed onto or popped off the stack.
\bigbreak \noindent 
Another register (e.g., ebp on x86 or rbp on x86-64) is often used to reference the base of the current stack frame, making it easier to access local variables and function parameters.
\bigbreak \noindent 
When a function is called, the following happens:
\begin{itemize}
    \item The return address (where the program should continue after the function returns) is pushed onto the stack.
    \item The function's parameters are pushed onto the stack.
    \item The stack pointer is adjusted to allocate space for local variables.
\end{itemize}
\bigbreak \noindent 
The function uses its stack frame to store local variables and intermediate results.
\bigbreak \noindent 
The frame pointer (if used) helps navigate the stack frame.
\bigbreak \noindent 
When the function finishes, its stack frame is popped off the stack:
\begin{itemize}
    \item The stack pointer is restored to its previous position.
    \item The return address is used to jump back to the caller.
\end{itemize}
\bigbreak \noindent 
The size of a stack frame in C++ (or any other programming language) depends on several factors, including:
\begin{itemize}
    \item The size of local variables declared in the function.
    \item The size of function parameters passed to the function.
    \item The size of the return address (typically the size of a memory pointer, e.g., 4 bytes on 32-bit systems or 8 bytes on 64-bit systems).
    \item The size of saved registers (if any) that need to be preserved across function calls.
    \item Alignment requirements (e.g., the stack frame might be padded to align data to specific boundaries for performance reasons).
\end{itemize}


\bigbreak \noindent 
\subsubsection{Heap}
\bigbreak \noindent 
Used for dynamic memory allocation (new, malloc). The program can allocate and free memory at runtime.
\bigbreak \noindent 
The heap grows upward (toward higher memory addresses). Memory leaks occur if allocated memory is not freed properly.
\bigbreak \noindent 
Unlike the stack, the heap does not have a fixed size limit, but it is constrained by system memory.

\bigbreak \noindent 
\subsubsection{The free list}
\bigbreak \noindent 
In C++, particularly in dynamic memory management, the free list is a data structure used to track free (unused) memory blocks in the heap. It is commonly implemented as a linked list of memory blocks that have been allocated and later freed but are available for reuse.
\bigbreak \noindent 
When a program requests memory (e.g., new or malloc), the allocator checks the free list first to find a suitable block.
\bigbreak \noindent 
If a sufficiently large free block is found, it is removed from the free list and returned to the caller.
\bigbreak \noindent 
If no suitable block is found, a new block is allocated from the heap.
\bigbreak \noindent 
When memory is freed (delete or free), the deallocated block is added to the free list.

\bigbreak \noindent 
\subsubsection{Memory fragmentation}
\bigbreak \noindent 
Memory fragmentation refers to inefficient memory allocation where free memory is divided into small, non-contiguous blocks, making it difficult to allocate large contiguous blocks even if there is enough total free memory. It occurs primarily in dynamic memory management when memory is allocated and freed in an unpredictable manner.

\bigbreak \noindent 
\subsubsection{A programs execution}
\bigbreak \noindent 
When a program is executed, the operating system (OS) finds a suitable slot in memory to load the program and manages its memory layout.
\bigbreak \noindent 
The OS reserves a contiguous block of memory for the program's execution. This includes space for the text segment (code), data segment (globals/statics), stack, and heap.
\bigbreak \noindent 
The OS determines a base address and loads the program's executable code into that location.
\bigbreak \noindent 
Once the program is loaded the text segment is placed first and has a fixed size.
\bigbreak \noindent 
The data segment follows, holding global/static variables.
\bigbreak \noindent 
The stack starts from a high memory address and grows downward as functions call each other.
\bigbreak \noindent 
The heap starts from a low memory address (above the data segment) and grows upward when dynamic allocations (new, malloc) occur.
\bigbreak \noindent 
The OS does not preallocate a fixed size for the heap or stack but instead reserves an initial size for the stack and heap and expands or shrinks them dynamically based on need (within system constraints).
\bigbreak \noindent 
If the stack grows too much (e.g., deep recursion) or the heap expands too far, they may collide, causing a crash (segmentation fault).
\bigbreak \noindent 
Stack size is often limited by the OS (default is a few MB), but heap size depends on system RAM
\bigbreak \noindent 
If the stack needs more space, the OS allocates additional pages unless it hits the stack limit (causing a stack overflow).
\bigbreak \noindent 
 If the heap needs more memory (malloc or new), the OS extends it using sbrk() or memory mapping (mmap).
 \bigbreak \noindent 
 \fig{1}{./figures/1.png}
 \bigbreak \noindent 
 The free space (or gap between the stack and heap) in a program's memory layout represents unallocated virtual memory that can be used by either the stack or heap as the program runs.
 \bigbreak \noindent 
 It acts as a buffer zone between the stack (growing downward) and the heap (growing upward).

 \bigbreak \noindent 
 \subsubsection{What does it mean for memory to be "allocated"}
 \bigbreak \noindent 
 When memory is "allocated," it means that a specific portion of the computer's memory space has been set aside and reserved for a particular program or data to use, essentially giving that program exclusive access to that memory area to store information during its execution; this is done by the operating system based on the program's needs

 \bigbreak \noindent 
 \subsubsection{"Static allocation"}
 \bigbreak \noindent 
 In C++ (and programming in general), statically allocated refers to memory that is allocated at compile time and remains fixed in size and location for the entire duration of the program's execution. This is in contrast to dynamic allocation, where memory is allocated and deallocated at runtime.
 \bigbreak \noindent 
 Static allocation means that the memory for a variable or object is reserved when the program is compiled, and it persists for the entire lifetime of the program.
 \bigbreak \noindent 
 The memory is allocated in one of the following regions
 \begin{enumerate}
     \item \textbf{Global/Static Memory:} For global variables and static variables.
 \end{enumerate}
 \bigbreak \noindent 
 \textbf{Characteristics of Static Allocation}
 \bigbreak \noindent 
 \begin{itemize}
     \item \textbf{Fixed Size:} The size of the memory block is known at compile time and cannot change during runtime.
     \item \textbf{Lifetime:} The memory exists for the entire duration of the program (for global/static variables) or for the duration of the function call (for local variables).
     \item \textbf{Efficiency:} Statically allocated memory is fast to allocate and access because it is managed by the compiler and does not require runtime overhead (e.g., no need for new/delete or malloc/free).
     \item \textbf{Scope:} The visibility of the variable depends on where it is declared:
         \begin{itemize}
             \item Global variables are accessible throughout the program.
             \item Static variables inside a function are accessible only within that function but retain their value between calls.
         \end{itemize}
 \end{itemize}

 \bigbreak \noindent 
 \subsubsection{"Automatic allocation"}
 \bigbreak \noindent 
 Automatic allocation refers to memory that is allocated automatically for local variables when a function is called and deallocated automatically when the function exits.
 \bigbreak \noindent 
 This memory is allocated on the stack, which is a region of memory managed by the compiler and the runtime environment.
 \bigbreak \noindent 
 The term "automatic" comes from the fact that the allocation and deallocation are handled automatically by the system, without requiring explicit intervention from the programmer (e.g., no need for new/delete or malloc/free).
 \begin{itemize}
     \item \textbf{Lifetime:} The memory is allocated when a function is called and deallocated when the function returns.
     \item \textbf{Scope:} The variables are only accessible within the block (e.g., function or {} block) where they are declared.
     \item \textbf{Speed:} Allocation and deallocation are very fast because the stack is a simple LIFO (Last-In-First-Out) data structure.
 \end{itemize}
 \bigbreak \noindent 
 \textbf{Does the Compiler Assign Memory Locations at Compile Time?} Yes and no. Here’s the distinction:
 \bigbreak \noindent 
 The size of the stack frame (e.g., how much memory is needed for local variables and parameters) is determined at compile time. The layout of the stack frame (e.g., the order of variables and their offsets within the frame) is also determined at compile time.
 \bigbreak \noindent 
 The actual memory addresses on the stack are assigned at runtime when the function is called.
 \bigbreak \noindent 
 The stack pointer (a CPU register, e.g., esp on x86 or rsp on x86-64) keeps track of the current top of the stack and is adjusted dynamically as functions are called and return.
 \bigbreak \noindent 
 While stack memory is used for local variables, the actual allocation happens at runtime, not compile time.
 \bigbreak \noindent 
 When a function is called, the necessary stack space is allocated for its local variables.
 \bigbreak \noindent 
 The values of these variables are stored on the stack as the function executes.
 \bigbreak \noindent 
 When the function returns, the stack space is deallocated, effectively destroying the local variables.

 \bigbreak \noindent 
 \subsubsection{"Dynamic allocation"}
 \bigbreak \noindent 
 Dynamic memory allocation refers to memory that is explicitly allocated and deallocated at runtime by the programmer using new, new[], malloc(), or similar functions. This memory is managed on the heap, which has a more flexible lifespan than stack memory.

 \bigbreak \noindent 
 \subsubsection{Stack vs heap allocation}
 \bigbreak \noindent 
 Stack memory is allocated at runtime, but it is not explicitly controlled by the programmer. Instead, the compiler and runtime manage it automatically.
 \bigbreak \noindent 
 Unlike heap memory, stack allocation is deterministic (it follows a Last In, First Out order) and does not require explicit deallocation.
 \bigbreak \noindent 
 Heap memory, on the other hand, allows arbitrary allocation and deallocation at any time, making it truly "dynamic."

 \bigbreak \noindent 
 \subsubsection{Why new (dynamic allocation) is slow and stack allocation is fast}
 \bigbreak \noindent 
 The new operator in C++ is considered slow compared to stack allocation for several reasons
 \bigbreak \noindent 
 new allocates memory from the heap, which is managed dynamically by the operating system. Heap memory is not contiguous like the stack, so the allocator needs to search for a large enough free block of memory. This requires bookkeeping (maintaining free lists, fragmentation handling, etc.), which adds computational overhead.
 \bigbreak \noindent 
 If the heap does not have enough free space, new might call malloc(), which, in turn, may invoke sbrk() or mmap() at the OS level.
 \bigbreak \noindent 
    System calls (context switches to the kernel) are expensive compared to simple pointer arithmetic used in stack allocation.
    \bigbreak \noindent 
    Stack memory is pre-allocated at program startup. Allocation is just moving the stack pointer (simple arithmetic, e.g., esp -= size). No system calls or bookkeeping are required.
    \bigbreak \noindent 
    Deallocation is implicit—when a function returns, all its local variables are freed automatically.
    \bigbreak \noindent 
    Most systems use a downward-growing stack, meaning the stack grows from higher memory addresses to lower ones.
    \bigbreak \noindent 
    The Stack Pointer (SP or ESP/RSP in x86/x86-64) keeps track of the top of the stack.
    \bigbreak \noindent 
    Pushing data decrements the stack pointer (moves it to a lower address).
    \bigbreak \noindent 
    Popping data increments the stack pointer (moves it to a higher address).
    \bigbreak \noindent 
    Yes, the stack pointer (SP, ESP in x86, RSP in x86-64) is used to keep track of where to allocate and deallocate memory on the stack.
    \bigbreak \noindent 
    \subsubsection{Does new call malloc?}
    \bigbreak \noindent 
    in most standard C++ implementations, new eventually calls malloc() (or an equivalent memory allocation function), but with additional functionality.
    \bigbreak \noindent 
    When you write:
    \begin{cppcode}
    int* ptr = new int(10);
    \end{cppcode}
    \bigbreak \noindent 
    The following steps happen
    \begin{enumerate}
        \item operator new(size\_t) is called, which internally calls malloc(size).
        \item If malloc() succeeds, operator new() returns the allocated memory.
        \item The constructor is called (for non-POD types).
        \item A pointer to the object is returned.
    \end{enumerate}
    \bigbreak \noindent 
    For example, the default operator new() might look like this:
    \bigbreak \noindent 
    \begin{cppcode}
        void* operator new(std::size_t size) {
            void* ptr = std::malloc(size);  // Calls malloc internally
            if (!ptr) throw std::bad_alloc();  // Handle allocation failure
            return ptr;
        }
    \end{cppcode}
    \bigbreak \noindent 
    Similarly, new[] calls malloc() but also stores extra metadata for array size.

    \bigbreak \noindent 
    \subsubsection{Delete}
    \bigbreak \noindent 
    In C++, when you use delete on a dynamically allocated object, it performs two main actions:
    \begin{itemize}
        \item Calls the object's destructor (if it has one).
        \item Frees the allocated memory using operator delete (which typically calls free under the hood but is not required to).
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{How does delete know how many bytes to relinquish?}
    \bigbreak \noindent 
    The heap allocator (e.g., malloc internally in operator new) tracks allocations. This means when delete is called, the heap manager looks up the size using metadata stored alongside the allocated block.

    \bigbreak \noindent 
    \subsubsection{Dangling pointer, memory leak, and resource leak}
    \begin{itemize}
        \item \textbf{Dangling pointer}: A dangling pointer is a pointer that continues to reference a memory location that has been deallocated or freed. Accessing such a pointer can lead to undefined behavior, crashes, or security vulnerabilities.
        \item \textbf{Memory leak}: A memory leak occurs when dynamically allocated memory is not properly deallocated, causing unreachable memory to remain allocated until the program terminates. This can lead to increased memory consumption over time.
        \item \textbf{Resource leak}: A resource leak occurs when a program fails to release system resources such as file handles, network sockets, or database connections, leading to exhaustion of available system resources.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{New in detail}
    \bigbreak \noindent 
    When you use new to allocate memory for an object, the following happens:
    \begin{enumerate}
        \item \textbf{Memory allocation:} operator new(size\_t) is called to allocate memory from the heap.
        \item \textbf{Object construction:} The constructor of the object is called in the allocated memory.
        \item \textbf{Returns a pointer:} A pointer to the newly created object is returned
    \end{enumerate}
    \bigbreak \noindent 
    If memory allocation fails (e.g., due to insufficient memory), new throws a std::bad\_alloc exception (unless you're using the nothrow version of new).

    \bigbreak \noindent 
    \subsubsection{Behind the scenes}
    \bigbreak \noindent 
    Suppose we have a struct
    \bigbreak \noindent 
    \begin{cppcode}
        struct point {
            int x{},y{};
        }
    \end{cppcode}
    \bigbreak \noindent 
    The following
    \bigbreak \noindent 
    \begin{cppcode}
        point* p = new point();
    \end{cppcode}
    \bigbreak \noindent 
    Is roughly equivalent to
    \bigbreak \noindent 
    \begin{cppcode}
        void* memory = operator new(sizeof(point));
        point* ptr = static_cast<point*>(memory);
        ptr = new (memory) point(); // or point{}
    \end{cppcode}
    \bigbreak \noindent 
    The first line This line allocates raw memory for an object of type point using the global operator new. This only allocates memory but does not construct the object.
    \bigbreak \noindent 
    The second line casts the raw memory to a pointer of type point*. However, the object is still not constructed at this point.
    \bigbreak \noindent 
    This line uses placement new to construct an object of type point in the already allocated memory. The placement new syntax is new (memory) point(), where memory is the pointer to the pre-allocated memory.
    \bigbreak \noindent 
    \subsubsection{operator new}
    \bigbreak \noindent 
    operator new is a low-level memory allocation function that allocates raw memory but does not invoke the constructor of an object. The syntax
    \bigbreak \noindent 
    \begin{cppcode}
    void* name = operator new(size)
    \end{cppcode}
    \bigbreak \noindent 
    performs the following steps
    \begin{enumerate}
        \item It calls the global operator new function, which allocates \textit{size} bytes of memory from the free store (heap).
        \item The returned pointer (memory) is of type void* because operator new does not know the actual type of the object to be constructed.
        \item The allocated memory is not yet initialized (i.e., no constructor is called )
    \end{enumerate}

    \bigbreak \noindent 
    \subsubsection{placement new}
    \bigbreak \noindent 
    Placement new is a special form of the new operator that constructs an object in a pre-allocated memory block. Instead of allocating memory from the heap, it initializes an object at a specific memory location.
    \bigbreak \noindent 
    \begin{cppcode}
        T* name = new (location) Obj()
    \end{cppcode}
    \bigbreak \noindent 
    Does not allocate new memory—it reuses the given memory.

    \bigbreak \noindent 
    \subsubsection{nothrow new}
    \bigbreak \noindent 
    In C++, the new operator throws an exception (std::bad\_alloc) if it fails to allocate memory. However, you can use std::nothrow to make new return nullptr instead of throwing an exception when memory allocation fails.
    \bigbreak \noindent 
    \begin{cppcode}
        int* ptr = new (std::nothrow) int[1000000000]; // Try to allocate a large array

        if (!ptr) {
            std::cout << "Memory allocation failed!\n";
        } else {
            std::cout << "Memory allocation successful!\n";
            delete[] ptr;
        }
    \end{cppcode}

\pagebreak 
\unsect{Categories}
\bigbreak \noindent 
The questions in this book fall into the following categories
\begin{itemize}
    \item Auto and type deduction
    \item Keyword static and its different uses
    \item Polymorphism, inheritance, and virtual functions
    \item Lambda functions
    \item How to use const
    \item Best practices in modern c++
    \item Smart pointers
    \item References, universal references
    \item C++20
    \item Special function and the rules of how many
    \item OOP, inheritance, poylmorphism
    \item Observable behaviors
    \item The STL
    \item Misc
\end{itemize}

\pagebreak 
\unsect{Auto and type deduction}
\bigbreak \noindent 
auto type deduction is usually the same as template type deduction, but auto type deduction assumes that a braced initializer represents a std::initializer\_list, and template type deduction doesn’t hold such premises.
\bigbreak \noindent 
\begin{cppcode}
    auto x = {1, 2, 3}; // auto deduces std::initializer_list<int>
\end{cppcode}
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(T t) {
        std::cout << typeid(T).name() << "\n";
    }

    int main() {
        func({1, 2, 3}); // ❌ Error: cannot deduce T from {1, 2, 3}
    }
\end{cppcode}
\bigbreak \noindent 
However, if we explicitly specify std::initializer\_list<T>, it works
\bigbreak \noindent 
\begin{cppcode}
    template <typename T>
    void func(std::initializer_list<T> t) {
        for (T n : t) {
            std::cout << n << " ";
        }
    }

    int main() {
        func({1, 2, 3}); // ✅ Works, T = int
    }
\end{cppcode}

\bigbreak \noindent 
\subsection{Auto with const}
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
    const int x = 10;
    auto y = x;   // y is `int`, not `const int`
\end{cppcode}
\bigbreak \noindent 
We must const qualify $y$ if we require it to maintain constness
\bigbreak \noindent 
\begin{cppcode}
const auto y = x; // y is int and const
\end{cppcode}


\bigbreak \noindent 
\subsection{Const with auto and references}
\bigbreak \noindent 
Using auto\& ensures that the deduced type keeps the const qualifier when referencing a const object.
\bigbreak \noindent 
\begin{cppcode}
const int a = 42;
auto& b = a;  // `b` is `const int&`
\end{cppcode}
\bigbreak \noindent 
\begin{cppcode}
    const int x = 5;
    auto& y = x;

    y = 15; // Error
\end{cppcode}
\bigbreak \noindent 
If $x$ were not const, we could also qualify $y$ to be const, therefore not allowing modification of $x$ through $y$
\bigbreak \noindent 
\begin{cppcode}
    int x = 5;
    const auto& y = x;

    y = 15; // Error
\end{cppcode}
\bigbreak \noindent 
So we see, auto cannot implicitly give us references, we must use auto\&

\bigbreak \noindent 
\subsection{Const with auto and pointers}
\bigbreak \noindent 
First, recall
\bigbreak \noindent 
\begin{cppcode}
    int x = 5;
    int y = 10;

    // Pointer is mutable, value is not
    const int* ptr = &x; 
    int const* ptr = &x; // Pointer is mutable, value is not
    //
    // // // Pointer is immutable, value is mutable
    int* const ptr = &x;
    int *const ptr = &x;

    // Pointer and value are immutable
    const int* const ptr = &x;
    const int *const ptr = &x;
    int const *const ptr = &x;
\end{cppcode}
\bigbreak \noindent 
First, we discuss mutable pointers to const values
\bigbreak \noindent 
\begin{cppcode}
    // Pointer is mutable, value is not
    const int* ptr = &x; 

    // Pointer to constant int
    auto ptr2 = ptr;
    *ptr2 = 20; // Error
    // Pointer is mutable
    ptr2 = &y;

    // Both value and pointer are immutable
    const auto ptr2 = ptr;
    *ptr2 = 20;  // Error
    ptr2 = &y // Error
\end{cppcode}
\bigbreak \noindent 
Next, constant pointers to non-const data
\bigbreak \noindent 
\begin{cppcode}
    // Pointer is immutable, value is mutable
    int* const ptr = &x;

    // Disregards const, ptr2 is non-const and value is non-const
    auto ptr2 = ptr;
    *ptr2 = 20;
    ptr2 = &y; 

    // Pointer is const, value non-const
    const auto ptr2 = ptr;
\end{cppcode}
\bigbreak \noindent 
Similarly for const pointers to const data, using auto will maintain constness for the data, but not for the pointer. Therefore, in this case, we must also qualify ptr2 with const.

\bigbreak \noindent 
\subsection{rvalue references with auto}
\bigbreak \noindent 
\begin{cppcode}
    int x = 50;
    auto&& y = x; // y is int&
    auto&& z = 50; // z is int&&
\end{cppcode}

\bigbreak \noindent 
\subsection{Auto in function return types or lambda parameters}
\bigbreak \noindent 
auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.

\bigbreak \noindent 
\subsection{When can auto deduce undesired types?}
\bigbreak \noindent 
Consider the code
\bigbreak \noindent 
\begin{cppcode}
    std::vector<bool> foo() {
        // ...
    }

    void bar(bool b) {
        // ...
    }

    auto someBit = foo()[2]; // this is some pointer to a temp object

    std::vector<bool> bits{ true, false, false, true };
    bar(bits[2]); // Undefined behaviour
\end{cppcode}
\bigbreak \noindent 
std::vector<bool> is a specialized version of std::vector that is optimized for space efficiency. Instead of storing each bool as a full byte, it typically stores each bool as a single bit.
\bigbreak \noindent 
This specialization means that std::vector<bool> does not behave exactly like other std::vector types. Specifically, accessing elements does not return a reference to a bool but rather a proxy object (of type std::vector<bool>::reference) that simulates a reference to a single bit.
\bigbreak \noindent 
When you access an element of a std::vector<bool> using operator[], it returns a temporary proxy object (std::vector<bool>::reference) that represents the bit at that position.
\bigbreak \noindent 
This proxy object can be implicitly converted to a bool, but it is not a direct reference to a bool in the vector.
\bigbreak \noindent 
Temporary objects (like the proxy object returned by foo()[2]) are destroyed at the end of the full expression in which they are created. This means that if you try to use the temporary object after the expression, you will be accessing a destroyed object, leading to undefined behavior.
\bigbreak \noindent 
\textbf{Note:} A proxy object is an intermediate object that stands in for another object. In the case of std::vector<bool>, accessing an element (e.g., foo()[2]) returns a proxy object of type std::vector<bool>::reference. This proxy object is not a direct reference to a bool but rather a lightweight object that provides access to a single bit in the underlying storage of the std::vector<bool>.
\bigbreak \noindent 
So what's happening here?
\begin{enumerate}
    \item foo() returns a temporary std::vector<bool>.
    \item foo()[2] creates a temporary proxy object (std::vector<bool>::reference) that refers to the bit at index 2 in the temporary vector.
    \item The temporary proxy object is assigned to $x$.
\end{enumerate}
However, the problem arises because The temporary std::vector<bool> returned by foo() is destroyed at the end of the full expression.
\bigbreak \noindent 
The proxy object (std::vector<bool>::reference) depends on the temporary vector for its existence. Once the vector is destroyed, the proxy object becomes invalid because it no longer has a valid vector to refer to.
\bigbreak \noindent 
The language rules specify that temporaries are destroyed at the end of the full expression unless they are bound to a const reference (which extends their lifetime to the lifetime of the reference).
\bigbreak \noindent 
Proxy objects like std::vector<bool>::reference are not regular objects but rather lightweight intermediaries. They are not designed to outlive the container they depend on.
\bigbreak \noindent 
To avoid the problem of the proxy object becoming invalid, you need to ensure that the std::vector<bool> outlives the proxy object. Here are two ways to do this:
\bigbreak \noindent 
1. Store the vector in a named variable
\bigbreak \noindent 
\begin{cppcode}
auto bits = foo(); // Store the vector in a named variable
auto x = bits[2];  // Access the bit from the persistent vector
\end{cppcode}
\bigbreak \noindent 
 Extract the value immediately, If you only need the value of the bit and not the proxy object, you can extract the value immediately:
 \bigbreak \noindent 
 \begin{cppcode}
 bool x = foo()[2]; // Extract the value of the bit
 \end{cppcode}
 \bigbreak \noindent 
 Here, x is a bool (not a proxy object), so it does not depend on the temporary vector.
 \bigbreak \noindent 
 In such situations, it’s better either not to use auto at all, or use the idiom that Meyers (effective modern c++) calls the the explicitly typed initializer idiom.
 \begin{cppcode}
     auto x = static_cast<bool>(bits[2])
 \end{cppcode}
 \bigbreak \noindent 
 The idiom can also come in handy when you deal with proxy types.

 \bigbreak \noindent 
 \subsection{What is the type of a lambda?}
 \bigbreak \noindent 
 Consider the code
 \bigbreak \noindent 
 \begin{cppcode}
     auto f = []() { return 12; }; // Type is class(lambda)
 \end{cppcode}
 \bigbreak \noindent 
 then the type of $f$ is a lambda closure type. The compiler generates a unique unnamed class to represent the lambda expression.
 \bigbreak \noindent 
 It is a unique unnamed structure that overloads the function call operator. Every instance of a lambda introduces a new type.
 \bigbreak \noindent 
 When a lambda captures variables, it still generates a unique compiler-defined class, but with data members corresponding to the captured variables.
 \bigbreak \noindent 
 In the special case of a non-capturing lambda, the structure in addition has an implicit conversion to a function pointer.
 \bigbreak \noindent 
 \begin{cppcode}
     auto f = []() ->int {
        return 12;
    };
    int (*g)();
    g=f; // OK

    auto f = [&]() ->int {
        return 12;
    };
    int (*g)();
    g=f; // ERROR
 \end{cppcode}





 \bigbreak \noindent 
 \subsection{What are the advantages of using auto?}
 \bigbreak \noindent 
 auto variables must be initialized and as such, they are generally immune to type mismatches that can lead to portability or efficiency problems. auto can also make refactoring easier, and it typically requires less typing than explicitly specified types.
 \bigbreak \noindent 
 auto variables mainly can improve correctness, performance, maintainability, and robustness. It is also more convenient to type, but that’s its least important advantage.
 \bigbreak \noindent 
 Consider declaring local variables auto x = type\{ expr \}; when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, and
 \bigbreak \noindent 
 it guarantees the variable will be initialized, in addition, it won’t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use ( ) instead of \{ \}.
 \bigbreak \noindent 
 \subsubsection{Regarding local variables}
 \bigbreak \noindent 
 Regarding local variables, if you use the auto x = expr; way of declaration, there are many advantages.
 \begin{itemize}
     \item It’s guaranteed that your variable will be initialized. If you forgot, you’ll get an error from the compiler.
     \item There are no temporary objects, implicit conversion, so it is more efficient.
     \item Using auto guarantees that you will use the correct type.
     \item In the case of maintenance, refactoring, there is no need to update the type.
     \item It is the simplest way to portably spell the implementationspecific type of arithmetic operations on built-in types. Those types might vary from platform to platform, and it also ensures that you cannot accidentally get lossy narrowing conversions.
     \item You can omit difficult to spell types, such as lambdas, iterators, etc.
 \end{itemize}

 \bigbreak \noindent 
 \subsubsection{Correctness}
 \bigbreak \noindent 
 auto ensures that variables have the exact type returned by expressions, preventing unintended type conversions.
 \bigbreak \noindent 
 \begin{cppcode}
 auto x = someFunction(); // Exact type of the return value
 \end{cppcode}
 \bigbreak \noindent 
 Complex template or iterator types are assigned correctly
 \bigbreak \noindent 
 \begin{cppcode}
     std::unordered_map<std::string, int> myMap;
     auto it = myMap.begin(); // Correct type without manually specifying
 \end{cppcode}

 \bigbreak \noindent 
 \subsubsection{Performance}
 \bigbreak \noindent 
 When used with references (auto\&), auto can prevent unnecessary copies.
 \bigbreak \noindent 
 \begin{cppcode}
     std::vector<int> vec = {1, 2, 3};
     for (auto& v : vec) { // Avoids copying
         v *= 2;
     }
 \end{cppcode}
 \bigbreak \noindent 
 And, 
 \bigbreak \noindent 
 \textbf{More Efficient Type Deduction:} Instead of relying on implicit conversions, auto allows for direct initialization with the optimal type.

 \bigbreak \noindent 
 \subsubsection{Maintainability}
 \bigbreak \noindent 
 If the return type of a function changes, auto ensures code doesn't need manual updates.
 \bigbreak \noindent 
 \begin{cppcode}
 auto result = computeValue(); // No need to change type if computeValue() changes
 \end{cppcode}
 \bigbreak \noindent 
 \subsubsection{Robustness}
 \bigbreak \noindent 
 \begin{itemize}
     \item \textbf{Ensures Type Safety in Loops:} Avoids iterator mismatches.
         \bigbreak \noindent 
         \begin{cppcode}
             std::vector<std::string> words = {"hello", "world"};
             for (auto it = words.begin(); it != words.end(); ++it) {
                 std::cout << *it << "\n";
             }
         \end{cppcode}
         \item \textbf{Encourages Strong Typing with auto\&\&:} Useful in templates for perfect forwarding.
             \bigbreak \noindent 
             \begin{cppcode}
                 template <typename T>
                 void wrapper(T&& arg) {
                     process(std::forward<T>(arg)); // Maintains the original type (lvalue/rvalue)
                 }
             \end{cppcode}
 \end{itemize}

 \bigbreak \noindent 
 \subsection{Intializer\_lists}
 \bigbreak \noindent 
 Consider
 \bigbreak \noindent 
 \begin{cppcode}
 auto myCollection = {1,2,3};
 \end{cppcode}
 \bigbreak \noindent 
 The type is std::initializer\_list<int>. The int part is probably straightforward, and about std::initializer\_list, well you just have to know that with auto type deduction, if you use braces, you have two options
 \bigbreak \noindent 
 If you put nothing between the curly braces, you’ll get a compilation error as the compiler is unable to deduce ‘std::initializer\_list<auto>’ from ‘<brace-enclosed initializer list>()’. So you don’t get an empty container, but a compilation error instead.
 \bigbreak \noindent 
 If you have at least one element between the braces, the type will be std::initializer\_list.
 \bigbreak \noindent 
 If you wonder what this type is, you should know that it is a lightweight proxy object providing access to an array of objects of type const T. It is automatically constructed when:
 \bigbreak \noindent 
 \begin{itemize}
     \item a braced-init-list is used to list-initialize an object, where the corresponding constructor accepts a std::initializer\_list parameter
     \item a braced-init-list is used on the right side of an assignment or as a function call argument, and the corresponding assignment operator/function accepts a std::initializer\_list parameter
     \item a braced-init-list is bound to auto, including in a ranged for loop
 \end{itemize}
 \bigbreak \noindent 
 Initializer lists may be implemented with a pair of pointers or with a pointer and a length. Copying a std::initializer\_list is considered a shallow copy as it doesn’t copy the underlying objects.

 \bigbreak \noindent 
 \subsection{decltype}
 \bigbreak \noindent 
 \subsection{Decltype vs auto}
 \bigbreak \noindent 
 decltype deduces the exact type of an expression, including references and const qualifiers. It does not evaluate the expression, only inspects its type. If you pass a variable name without parentheses, it gives the declared type. If you pass an expression, the result depends on how the expression is formed.
 \bigbreak \noindent 
 \begin{cppcode}
 int x = 20;
 const int& y=x;
 decltype(y) z = x; // Const int&
 \end{cppcode}
 \bigbreak \noindent 
 When decltype is applied to an expression inside parentheses, it deduces the type as a reference if the expression is an lvalue.
 \bigbreak \noindent 
 \begin{cppcode}
 int x = 20;
 decltype(x) y; // Int
 decltype((x)) y = x; // int&

 const int x = 10;
 decltype(x) y = x; // const int
 decltype((x)) z = x; // const int&

 decltype(10) k; // int
 decltype((10)) r; // int
 \end{cppcode}

 \bigbreak \noindent 
 auto does not preserve references unless explicitly specified. It removes const qualifiers unless the initializer is explicitly const.
 



 \bigbreak \noindent 
 Consider
 \bigbreak \noindent 
 \begin{cppcode}
     struct A {
         double x;
     }

     // a is a pointer to an A that is const
     const A* a;

     decltype(a->x) y // y is a double
     decltype((a->x)) y = z // z is a const double& to y
 \end{cppcode}
 \bigbreak \noindent 
 When decltype is used without parentheses, it gives the declared type
 \bigbreak \noindent 
 \begin{cppcode}
     decltype(a->x) y;  // y is of type double
 \end{cppcode}
 \bigbreak \noindent 
 When decltype is applied to a parenthesized expression, it deduces the expression's type with reference qualifiers:
 \bigbreak \noindent 
 \begin{cppcode}
    decltype((a->x)) z = y; // const double& 
    const decltype(a->x)& z = y; // Equivalent
 \end{cppcode}
 \bigbreak \noindent 
 Thus, z is a double\&, but since $A$ is a pointer to a constant objects, (a->x) is a reference to a constant

 \bigbreak \noindent 
 \subsection{decltype(auto)}
 \bigbreak \noindent 
 The decltype(auto) idiom was introduced in C++14. Like auto, it deduces a type from its initializer, but it performs the type deduction using the decltype rules.
 \bigbreak \noindent 
 in generic code, you have to be able to perfectly
forward a return type without knowing whether you are dealing
with a reference or a value. decltype(auto) gives you that ability:
\bigbreak \noindent 
\begin{cppcode}
template<class Fun, class... Args>
decltype(auto) foo(Fun fun, Args&&... args) {
    return fun(std::forward(args)...);
}
\end{cppcode}
\bigbreak \noindent 
If you wanted to achieve the same thing simply with auto, you
would have to declare different overloads for the same example
function above, one with the return type auto always deducing to
a pure value, and one with auto\& always deducing to a reference
type.

\pagebreak 
\unsect{Keyword static and its different uses }
\bigbreak \noindent 
\subsection{What does a static member variable in C++ mean?}
\bigbreak \noindent 
A member variable that is declared static is allocated storage in the static storage area, only once during the program lifetime. Given that there is only one single copy of the variable for all objects, it’s also called a class member.
\bigbreak \noindent 
When we declare a static member in the header file, we’re telling
the compiler about the existence of a static member variable,
but we do not actually define it (it’s pretty much like a forward
declaration in that sense). Because static member variables are not
part of class instances (they are treated similarly to global variables,
and get initialized when the program starts), you must explicitly
define the static member outside of the class, in the global scope.
\bigbreak \noindent 
\begin{cppcode}
class A {
    static MyType s_var;
};
MyType A::s_var = value;
\end{cppcode}
\bigbreak \noindent 
Though there are a couple of exceptions. First, when the static member is a const integral type (which includes char and bool) or a const enum, the static member can be initialized inside the class definition:
\bigbreak \noindent 
\begin{cppcode}
class A {
    static const int s_var{42};
};
\end{cppcode}
\bigbreak \noindent 
If the member is not const, you either have to initialize it out-of-line,
or you have to use the inline keyword
\bigbreak \noindent 
static constexpr members can be initialized inside the class definition starting from C++17 (no out-of-line initialization required)
\bigbreak \noindent 
It’s been already mentioned but it’s worth emphasizing that static
member variables are created when the program starts and destroyed when the program ends and as such static members exist
even if no objects of the class have been instantiated.


\bigbreak \noindent 
\subsection{What does a static member function mean in C++?}
\bigbreak \noindent 
static member functions can be used to work with static member
variables in the class or to perform operations that do not require an
instance of the class. Yet the actions performed in a static member
function should conceptually, semantically be strongly related to
the class. Some key points about static member functions.
\begin{itemize}
    \item static member functions don’t have the this pointer
    \item static member functions cannot be virtual
    \item static member functions cannot access non-static members
    \item The const and volatile qualifiers aren’t available for static member functions
\end{itemize}
\bigbreak \noindent 
In practice, a static member functions mean that you can call
such functions without having the class instantiated (you can also call it on an instance).
\bigbreak \noindent 
\begin{cppcode}
    struct S {
        static void print() {}
    };

    S::print();
    S s;
    s.print();
\end{cppcode}
\bigbreak \noindent 
As this pointer always holds the memory address of the current object and to call a static member you don’t need an object at all, it cannot have a this pointer.
\bigbreak \noindent 
A virtual member is something that doesn’t relate directly to any class, only to an instance. A “virtual function” is (by definition) a function that is dynamically linked, i.e. the right implementaion is chosen at runtime depending on the dynamic type of a given object. Hence, if there is no object, there cannot be a virtual call.
\bigbreak \noindent 
Accessing a non-static member function requires that the object has been constructed but for static calls, we don’t pass any instantiation of the class. It’s not even guaranteed that any instance has been constructed.
\bigbreak \noindent 
Once again, the const and the const volatile keywords modify whether and how an object can be modified or not. As there is no object
\bigbreak \noindent 
\subsection{What is the static initialization order fiasco?}
\bigbreak \noindent 
The static initialization order fiasco is a subtle aspect of C++ that
many don’t know about, don’t consider or misunderstand. It’s hard
to detect as the error often occurs before main() would be invoked.
\bigbreak \noindent 
Static or global variables in one translation unit are always initialized according to their definition order. On the other hand, there is
no strict order for which translation unit is initialized first.
\bigbreak \noindent 
Let’s suppose that you have a translation unit A with a static
variable sA, which depends on static variable sB from translation
unit B in order to get initialized. You have 50\% chance to fail. This
is the static initialization order fiasco.
\bigbreak \noindent 
\begin{cppcode}
// File1.cpp
#include <string>
std::string name = "Julia";

// File2.cpp
#include <string>
extern std::string message = "Hello, " + name;

int main() {cout << message;}
// g++ -o bin file2.cpp file1.cpp
// ./bin "Hello, "

// g++ -o bin file1.cpp file2.cpp
// ./bin "Hello, Julia"
\end{cppcode}

\bigbreak \noindent 
\subsection{How to solve the static initialization order fiasco?}
\bigbreak \noindent 
Probably the simplest solution is to replace the variable in file1.cpp with a function. Observe
\bigbreak \noindent 
\begin{cppcode}
// file1.cpp
#include <string>
std::string foo() {
    return std::string("Julia");
}

// file2.cpp
#include <string>
extern std::string foo();
std::string message = "Hello, " + foo();

int main() {cout << message;}
// g++ -o bin file2.cpp file1.cpp
// ./bin "Hello, Julia"

// g++ -o bin file1.cpp file2.cpp
// ./bin "Hello, Julia"
\end{cppcode}

\bigbreak \noindent 
Starting from C++20, the static initialization order fiasco can be solved with the use of constinit. In this case, the static variable will be initialized at compile-time, before any linking.

\bigbreak \noindent 
\begin{cppcode}
    // File1.cpp
    #include <string>
    constinit std::string name = "Julia";

    // File2.cpp
    #include <string>
    extern std::string message = "Hello, " + name;

    int main() {cout << message;}
    // g++ -o bin file2.cpp file1.cpp
    // ./bin "Hello, Julia"

    // g++ -o bin file1.cpp file2.cpp
    // ./bin "Hello, Julia"
\end{cppcode}

\pagebreak 
\unsect{Polymorphism, inheritance and virtual functions}
\bigbreak \noindent 
\subsection{Rules for virtual functions}
\bigbreak \noindent 
\begin{itemize}
    \item They are always member functions
    \item They cannot be static
    \item They can be a friend of another class
    \item C++ does not contain virtual constructors but can have a virtual destructor
\end{itemize}
\bigbreak \noindent 
In fact, if you want to allow other classes to inherit from a given class, you should always make the destructor virtual, otherwise, you can easily have undefined behaviour
\bigbreak \noindent 
if you are using inheritance and intend to delete derived objects through a base class pointer, you should always make the base class destructor virtual, even if there are no other virtual functions.
\bigbreak \noindent 
If the base class destructor is not virtual and you delete a derived object through a base class pointer, only the base class destructor will be called, leading to undefined behavior (UB) due to a memory leak.
\bigbreak \noindent 
When you declare print() as virtual in the base class, it ensures that the function call is dynamically dispatched.
\bigbreak \noindent 
Even though derived::print() is private, it is still part of the vtable, and the lookup mechanism allows it to be called when accessed through a base class pointer
\bigbreak \noindent 
Since b->print(); is being called via a base* pointer, the compiler only checks whether base::print() is accessible from the calling scope (which it is, because it's public).
\bigbreak \noindent 
The actual function executed (derived::print()) is resolved at runtime, at which point access specifiers do not matter.
\bigbreak \noindent 
Thus, the following would not work
\bigbreak \noindent 
\begin{cppcode}
    struct base {
        private:
        virtual void print() const {cout << "Base" << endl;}
    };

    struct derived : base{
        private:
        void print() const override {cout << "Derived" << endl;}
    };
    base* b = new derived{};
    b->print(); // Print is a private member of base
\end{cppcode}
\bigbreak \noindent 
Notice that both print methods are now private
\bigbreak \noindent 

\subsection{The diamond problem and its solution}
\bigbreak \noindent 
The diamond problem in C++ occurs in multiple inheritance when a class inherits from two base classes that both derive from a common ancestor, leading to duplicate instances of the ancestor and ambiguity in member access. It is resolved using virtual inheritance, ensuring only one shared instance of the common base class exists.
\bigbreak \noindent 
Virtual inheritance is a C++ technique that ensures only one copy of
a base class’s member variables is inherited by grandchild derived
classes. Without virtual inheritance, if two classes B and C inherit
from class A, and class D inherits from both B and C, then D will
contain two copies of A’s member variables: one via B, and one via
C. These will be accessible independently, using scope resolution
\bigbreak \noindent 
Instead, if classes B and C inherit virtually from class A, then
objects of class D will contain only one set of the member variables
from class A.
\bigbreak \noindent 
In practice, virtual base classes are most suitable when the classes
that derive from the virtual base, and especially the virtual base
itself, are pure abstract classes. This means the classes above the
“join class” (the one at the bottom) have very little if any data.
\bigbreak \noindent 
Consider the following class hierarchy to represent the diamond
problem, though not with pure abstracts.
\bigbreak \noindent 
\begin{cppcode}
    struct Person {
        virtual ~Person() = default;
        virtual void speak() {}
    };
    struct Student: Person {
        virtual void learn() {}
    };

    struct Worker: Person {
        virtual void work() {}
    }; // A teaching assistant is both a worker and a student
    struct TeachingAssistant: Student, Worker {};

    int main() {
        TeachingAssistant aTeachingAssistant;
        aTeachingAssistant.Student::speak();
        // or
        aTeachingAssistant.Worker::speak();

        // And we can also do
        Person& p = static_cast<Student&>(aTeachingAssistant);
        p.speak();
    }
\end{cppcode}
\bigbreak \noindent 
a call to aTeachingAssistant.speak() is ambiguous because there are two Person (indirect) base classes in
TeachingAssistant, so any TeachingAssistant object has two different Person base class subobjects. So an attempt to directly bind
a reference to the Person subobject of a TeachingAssistant object
would fail, since the binding is inherently ambiguous:
\bigbreak \noindent 
To disambiguate, one would have to explicitly convert
aTeachingAssistant to either base class subobject:
\bigbreak \noindent 
If we introduce virtual to our inheritance as such, our problems disappear.
\bigbreak \noindent 
\begin{cppcode}
    struct Person {
        virtual ~Person() = default;
        virtual void speak() {}
    };
    struct Student: virtual Person {
        virtual void learn() {}
    };

    struct Worker: virtual Person {
        virtual void work() {}
    }; // A teaching assistant is both a worker and a student
    struct TeachingAssistant: Student, Worker {};

    TeachingAssistant aTeachingAssistant;
    aTeachingAssistant.speak();

    Person* p = new TeachingAssistant{};
    p->speak();
\end{cppcode}
\bigbreak \noindent 
The Person portion of TeachingAssistant::Worker is now the same
Person instance as the one used by TeachingAssistant::Student,
which is to say that a TeachingAssistant has only one,
shared, Person instance in its representation and so a call
to TeachingAssistant::speak is unambiguous. Additionally,
a direct cast from TeachingAssistant to Person is also
unambiguous, now that there exists only one Person instance
which TeachingAssistant could be converted to.
\bigbreak \noindent 
This can be done through vtable pointers. Without going into
details, the object size increases by two pointers, but there is only
one Person object behind and no ambiguity.
\bigbreak \noindent 
You must use the virtual keyword in the middle level of the
diamond. Using it at the bottom doesn’t help.
\bigbreak \noindent 
\begin{cppcode}
    cout << sizeof(TeachingAssistant); // 16 (two pointers)
\end{cppcode}

\bigbreak \noindent 
\subsection{Should we always use virtual inheritance? If yes, why? If not, why not?}
\bigbreak \noindent 
The answer is definitely no, we shouldn’t use virtual inheritance
all the time. According to an idiomatic answer, one of the key
C++ characteristics is that you should only pay for what you use.
And if you don’t need to solve the problems addressed by virtual
inheritance, you should rather not pay for it.
\bigbreak \noindent 
Virtual inheritance is almost never needed. It addresses the diamond inheritance problem that we saw just yesterday. It can only
happen if you have multiple inheritance, and in case you can avoid
it, you don’t have the problem to solve. In fact, many languages
don’t even have this feature
\bigbreak \noindent 
Virtual inheritance causes troubles with object initialization and
copying. Since it is the “most derived” class that is responsible
for these operations, it has to be familiar with all the intimate
details of the structure of base classes. Due to this, a more complex
dependency appears between the classes, which complicates the
project structure
\bigbreak \noindent 
Troubles with type conversions may also be a source of bugs
\bigbreak \noindent 
In virtual inheritance, the most derived class is responsible for initializing the virtual base class. This creates tight coupling between the most derived class and all the base classes. The most derived class must be aware of every virtual base class and explicitly initialize them. If not handled properly, virtual base classes may be default-initialized, leading to unintended behaviors or even undefined behavior in some cases.
\bigbreak \noindent 
\begin{cppcode}
    class A {
        public:
        int x;
        A(int val) : x(val) {}
    };

    class B : virtual public A {
        public:
        B() : A(0) {}  // A(0) does nothing because A is virtual
    };

    class C : virtual public A {
        public:
        C() : A(0) {}  // A(0) does nothing because A is virtual
    };

    class D : public B, public C {
        public:
        D() : A(42) {}  // Only the most derived class initializes A
    };

    int main() {
        D d;
        std::cout << d.x << std::endl;  // Correctly prints 42
    }
\end{cppcode}
\bigbreak \noindent 
The initialization order is as follows
\bigbreak \noindent 
When D d; is executed:
\begin{enumerate}
    \item Virtual base A is constructed first (via D's constructor).
    \item B is constructed (but does not initialize A).
    \item C is constructed (but does not initialize A).
    \item Finally, D's constructor runs.
\end{enumerate}
\bigbreak \noindent 
Since A is virtually inherited, it is not initialized by B or C at all. The most derived class (D) is responsible for initializing A. If B and C were allowed to initialize A, there would be ambiguity
\bigbreak \noindent 
\textbf{Note:} If you try to instantiate a derived class that doesn’t explicitly initialize the virtual base \footnote{When we talk about a "virtual base class", we are referring to the base class that is inherited using virtual}, it may lead to default initialization or even compilation errors if the base has no default constructor.
\bigbreak \noindent 
\begin{cppcode}
class D : public B, public C {
public:
    D() {}  // Error: constructor for D must explicitly initialize the base class A
};
\end{cppcode}
\bigbreak \noindent 
\begin{itemize}
    \item Virtual inheritance breaks the hierarchical structure of the class relationships because it forces the most derived class to handle the construction of the virtual base.
    \item This means that a base class (e.g., B or C in the example above) cannot assume that the virtual base (A) has been properly initialized.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Issues with Type Conversions}
\bigbreak \noindent 
\begin{cppcode}
class A {
public:
    virtual void foo() {}
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};

int main() {
    D d;
    A* a = &d;  // Works fine
    B* b = &d;  // Works fine
    C* c = &d;  // Works fine

    B* b2 = dynamic_cast<B*>(a);  // Requires dynamic_cast due to virtual base
    C* c2 = dynamic_cast<C*>(b);  // Also requires dynamic_cast

    return 0;
}
\end{cppcode}
\bigbreak \noindent 
Here, since A is virtually inherited, converting from A* to B* or C* requires a runtime check (dynamic\_cast) instead of a simple implicit cast.
\bigbreak \noindent 
This increases runtime overhead and makes it harder to predict the behavior of type conversions.

\bigbreak \noindent 
\subsection{Non public inheritance}
\bigbreak \noindent 
Consider the following code
\bigbreak \noindent 
\begin{cppcode}
class A { };
class B : private A { };

A* b = new B(); // Error: Cannot convert B to its private base class A 
\end{cppcode}
\bigbreak \noindent 
In C++, when you privately inherit from a base class, it means that the "is-a" relationship is hidden from the outside. Although class B is implemented in terms of class A, that relationship is not exposed to the outside world. Therefore, a pointer conversion from B* to A* is disallowed outside of B.
\bigbreak \noindent 
With public inheritance, B would be recognized as a subtype of A and the conversion would be allowed:
\bigbreak \noindent 
But with private inheritance, you're effectively saying that the inheritance is an implementation detail, not a part of B's public interface. That's why you get the error "Cannot cast B to its private base class A".
\bigbreak \noindent 
Note that the same thing is true for protected inheritance
\bigbreak \noindent 
In C++, public inheritance is used to express an "is-a" relationship. That is, if class B publicly inherits from class A, then every B object can be used wherever an A is expected—because a B is a kind of A.
\bigbreak \noindent 
On the other hand, when you use non-public (private or protected) inheritance, you're not promising that B can be used as an A to the outside world. Instead, you're saying that B is implemented in terms of A, and you're using A's implementation internally without exposing its interface as part of B's public contract. This hides the base class interface from users of B.
\bigbreak \noindent 
Because of this hidden relationship, non-public inheritance can sometimes be seen as analogous to a "has-a" relationship. In a "has-a" relationship (or composition), a class contains another class as a member and uses it to implement part of its behavior, but it doesn't expose that member's interface as its own. Similarly, with private inheritance, B contains the functionality of A (via inheritance) but does not allow implicit conversion to A* or access to A's public members from outside of B.

\bigbreak \noindent 
\subsection{Can we inherit from a standard container (such as std::vector)? If so what are the implications?}
\bigbreak \noindent 
The standard containers declare their constructors as public and
non-final, so yes it is possible to inherit from them. In fact, it’s
a well-known and used technique to benefit from strongly typed
containers
\bigbreak \noindent 
the lack of a virtual destructor might lead to undefined
behaviour and a memory leak. Both can be serious issues, but the
undefined behaviour is worse because it can not just lead to crashes
but even to difficult to detect memory corruption eventually leading to strange application behaviour.
\bigbreak \noindent 
But the lack of virtual destructor doesn’t lead to undefined behaviour and memory leak by default, you have to use your derived
class in such a way.
\bigbreak \noindent 
If you delete an object through a pointer to a base class that has
a non-virtual destructor, you have to face the consequences of
undefined behaviour. Plus if the derived object introduces new
member variables, you’ll also have some nice memory leak. But
again, that’s the smaller problem.

\bigbreak \noindent 
\subsection{What is a destructor and how can we overload it?}
\bigbreak \noindent 
A destructor is a special member function of a class. It has the same name as the class and it is also prefixed with a tilde symbol. If available, it is executed automatically whenever an object goes out of scope
\bigbreak \noindent 
A destructor has no parameters, it cannot be const, volatile or static and just like constructors, it has no return type.
\bigbreak \noindent 
By default, it is generated by the compiler, but you have to pay
attention as the rule of 5 applies. If any of the other 4 special
functions is implemented manually, the destructor will not be
generated
\bigbreak \noindent 
As a quick reminder, the special functions besides the
destructor are
\begin{itemize}
    \item copy constructor
    \item copy assignment operator
    \item move constructor
    \item move assignment operator
\end{itemize}
\bigbreak \noindent 
A destructor is needed if the class acquires resources that have to
be released. Remember, you should write RAII class, meaning that
resources are acquired on construction and released on destruction.
This can be things like releasing connections, closing file handles,
saving transactions, etc
\bigbreak \noindent 
As said a destructor has no parameter, it cannot be const, volatile
or static, and there can be only one destructor. Hence it cannot be
overloaded.


\pagebreak 
\unsect{Lambdas}
\bigbreak \noindent 
\subsection{When could IILF's (Immediately invoked lambda functions) be useful.}
\bigbreak \noindent 
Consider the following example
\bigbreak \noindent 
\begin{cppcode}
    const std::string S = [caseA, caseB, caseC]() -> std::string {
        if (caseA) {
            return std::string("A string")
        } else if (caseB) {
            return std::string("B string")
        } else if (caseC) {
            return std::string("C string")
        } else {
            ...
        }
    }
\end{cppcode}
\bigbreak \noindent 
In this way, we could perform complex initializations beyond the limitations of the conditional operator.

\bigbreak \noindent 
\subsection{What kind of captures are available for lambda expressions?}
\bigbreak \noindent 
The capture is a comma-separated list of zero or more captures, optionally beginning with the capture-default. The capture list defines the outside variables that are accessible from within the lambda function body.
\bigbreak \noindent 
The only capture defaults are:
\begin{itemize}
    \item \& (implicitly capture the used automatic variables by reference) and
    \item = (implicitly capture the used automatic variables by copy).
\end{itemize}
\bigbreak \noindent 
The current object (*this) can be implicitly captured if either of the capture defaults is present. If implicitly captured, it is always captured by reference, even if the capture default is =. However since C++20 the implicit capture of *this with the capture default = is deprecated.
\bigbreak \noindent 
\subsubsection{The following types of captures are available:}
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{By-copy capture }:
        \bigbreak \noindent 
        \begin{cppcode}
        int num;
        auto l = [num](){};
        \end{cppcode}
    \item \textbf{By-copy capture that is a pack expansion }:
        \bigbreak \noindent 
        \begin{cppcode}
            template <typename Args>
            void f(Args... args) {
                auto l = [args...] {
                    return g(args...);
                };
                l();
            }
        \end{cppcode}
    \item \textbf{by-reference capture}:
        \bigbreak \noindent 
        \begin{cppcode}
            nt num=42;
            auto l = [&num](){};
        \end{cppcode}
    \item \textbf{by-reference capture that is a pack expansion }:
        \bigbreak \noindent 
        \begin{cppcode}
            template <typename Args>
            void f(Args... args) {
                auto l = [&args...] { return g(args...);};
                l();
            }
        \end{cppcode}
    \item \textbf{by-copy capture of the current object}:
        \bigbreak \noindent 
        \begin{cppcode}
            auto l = [*this](){};
        \end{cppcode}
    \item \textbf{by-reference capture of the current object}:
        \bigbreak \noindent 
        \begin{cppcode}
        auto l = [this](){};
        \end{cppcode}
    \item \textbf{by-copy capture with an initializer}
        \bigbreak \noindent 
        \begin{cppcode}
        auto l = [num=5](){};
        \end{cppcode}
    \item \textbf{by-reference capture with an initializer}:
        \bigbreak \noindent 
        \begin{cppcode}
            int num=42;
            auto l = [&num2=num](){};
        \end{cppcode}
\end{itemize}


\pagebreak 
\unsect{How to use the const qualifier in C++}
\bigbreak \noindent 
\subsection{What are the advantages of using const local variables?}
\bigbreak \noindent 
By declaring a local variable const you mark it immutable. It should
never change its value. If you still try to modify it later on, you’ll
get a compilation error. For global variables, this is rather useful.
Otherwise, you have no idea who might modify their values. Of
course, we should avoid using global variables, do you remember
the static initialization order fiasco?
\bigbreak \noindent 
Moreover, declaring variables as const also helps the compiler to
perform some optimizations. Unless you explicitly mark a variable
const, the compiler will not know (at least not for sure) that the
given variable should not be changed. Again this is something that
we should use whenever it is possible.

\bigbreak \noindent 
\subsection{What happens when a class has const member variables?}
\bigbreak \noindent 
classes with const members are not assignable. When we have class or struct with const member variables, the copy assignment operator is implicitly deleted
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        const int x = 12;
        A(int x) : x(x) { cout << "Constructed A object with x = " << x << endl; } 

    };
    A a1(50);
    A a2(20);
    a1 = a2; // Error: Copy assignment implicitly deleted
\end{cppcode}
\bigbreak \noindent 
Although we can still use the copy constructor just fine.
\bigbreak \noindent 
If you think about it, it makes perfect sense. A variable is something you cannot change after initialization. And when you want
to assign a new value to an object, thus to its members, it’s not
possible anymore.
\bigbreak \noindent 
As such it also makes it impossible to use move semantics, for the
same reason.
\bigbreak \noindent 
From the error messages, you can see that the corresponding special
functions, such as the assignment operator or the move assignment
operator were deleted. Which means we have to implement them
by hand. Don’t forget about the rule of 5. If we implement one,
we have to implement all the 5
\bigbreak \noindent 
Let’s take the assignment operator as an example. What should we
do with it?
\bigbreak \noindent 
Do we skip assigning to the const members? Not so great, either we
depend on that value somewhere, or we should not store the value.
\bigbreak \noindent 
If we really want to implement it, we must use const\_cast as a
workaround. As you cannot cast the constness away from values,
you have to turn the member values into temporary non-const
pointers.
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        const int x = 12;
        A(int x) : x(x) { cout << "Constructed A object with x = " << x << endl; } 

        A& operator=(const A& other) {
            int* tmp = const_cast<int*>(&x);
            *tmp = other.x;
            return *this;
        }
    };
    A a1(50);
    A a2(20);
    a1 = a2; // Error: Copy assignment implicitly deleted
\end{cppcode}
\bigbreak \noindent 
Recall that const cast can introduce UB. We’ve just had a look at the copy assignment and it wouldn’t work
without risking undefined behaviour.
\bigbreak \noindent 
It’s not worth it!

\bigbreak \noindent 
\subsection{Should you take plain old data types by const reference as a function parameter?}
\bigbreak \noindent 
They should not be passed as const references or pointers. It’s
inefficient. These data types can be accessed with one memory
read if passed by value. On the other hand, if you pass them by
reference/pointer, first the address of the variable will be read and
then by dereferencing it, the value. That’s 2 memory reads instead
of one.
\bigbreak \noindent 
We shall not take fundamental data types by const\&.
\bigbreak \noindent 
But should we take them simply by const? As always, it depends. If we don’t plan to modify their value, yes we should. For better readability, for the compiler and for the future.
\bigbreak \noindent 
\begin{cppcode}
    void f(const int x) { }
    // More efficient than 
    void f(const int& x) {}
\end{cppcode}
\bigbreak \noindent 
For a simple type like an int, passing by value (i.e. using "void f(int x)") is generally as efficient—or even slightly more efficient—than passing by reference. This is because:
\bigbreak \noindent 
\begin{itemize}
    \item \textbf{Small Data Type:} An int is typically a small, built-in type that fits into a register, so copying it has negligible cost.
    \item \textbf{Reference Overhead:} Passing by reference usually involves an extra level of indirection (a pointer under the hood), which isn’t necessary for such a small type.
    \item \textbf{Compiler Optimizations:} Modern compilers are very good at optimizing simple value copies, making any potential overhead even less noticeable.
\end{itemize}
That said, the difference in performance for an int is extremely minor. For larger, more complex types, or when you need to modify the original variable, passing by reference may be more appropriate.

\pagebreak 
\unsect{Best practices in modern C++}
\bigbreak \noindent 
\subsection{What are explicit constructors and what are their advantages?}
\bigbreak \noindent 
The explicit specifier specifies that a constructor cannot be used for implicit conversions.
\bigbreak \noindent 
If not used, the compiler is allowed to make one implicit conversion
to resolve the parameters to a function. The compiler can use
constructors callable with a single parameter to convert from one
type to another in order to get the right type for a parameter.
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        int x{}, y{};

        A(int x) : x(x) {}

        void f(A a) {}
    };
    A a(5);
    a.f(20); // Ok, compiler will use the constructor to implicitly convert
    A a2 = 10; // Also ok
\end{cppcode}
\bigbreak \noindent 
But if we make the constructor explicit,
\bigbreak \noindent 
\begin{cppcode}
    struct A {
        int x{}, y{};

        explicit A(int x) : x(x) {}

        void f(A a) {}
    };
    A a = 5; // No vaiable conversion
    a.f(20); // No vaiable conversion
\end{cppcode}

\bigbreak \noindent 
\subsection{What are user-defined literals?}
\bigbreak \noindent 
User-defined literals allow integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.
\bigbreak \noindent 
User-defined literals can be used with integer, floating-point, character and string types
\bigbreak \noindent 

\bigbreak \noindent 
\subsection{Why should we use nullptr instead of NULL or 0?}
\bigbreak \noindent 
The literal 0 is an int, not a pointer. If the compiler is looking at
a 0 where only a pointer can be used, it will interpret 0 as a null
pointer, but that’s only an implicit conversion, a second option if
\bigbreak \noindent 
you prefer. The same is true for NULL, though implementations are
allowed to give NULL an integral type other than int, such as long,
which is uncommon
\bigbreak \noindent 
This has the following implication. In case you have a function with
three overloads, including integral types and pointers, you might
get some surprises:
\bigbreak \noindent 
\begin{cppcode}
void f(int) { cout << "called int fn"; }
void f(void*) { cout << "called void* fn"; }
f(0); // calls int fn
f(nullptr) // calls void* fn
f(NULL); // Ambiguous, does not compile
\end{cppcode}
\bigbreak \noindent 
On the other hand, nullptr doesn’t have an integral type. It’s type
is std::nullptr\_t. It is a distinct type that is not itself a pointer
type or a pointer to member type. At the same time, it implicitly
converts to all raw pointer types, and that’s what makes nullptr
act as if it were a pointer of all types.

\bigbreak \noindent 
\subsection{What advantages does alias have over typedef?}
\bigbreak \noindent 
In case of function pointers, they are more readable:
\bigbreak \noindent 
\begin{cppcode}
    typedef void (*MyFunctionPointer)(int, int);
    using MyFunctionPointerAlias = void(*)(int, int);
\end{cppcode}
\bigbreak \noindent 
Another advantage is that typedefs don’t support templatization,
but alias declarations do

\bigbreak \noindent 
\subsection{Should you explicitly delete unused/unsupported special functions or declare them as private?}
\bigbreak \noindent 
You might not want a class to be copied or moved, so you
want to keep related special functions unreachable for the caller.
One option is to declare them as private or protected and the other
is that you explicitly delete them.
\bigbreak \noindent 
Before C++11 there was no other option than declaring the unneeded special functions private and not implementing them.
\bigbreak \noindent 
Since C++11 you can simply mark them deleted by declaring them as = delete;
\bigbreak \noindent 
The C++11 way is a better approach because
\begin{enumerate}
    \item it’s more explicit than having the functions in the private section which might only be a mistake
    \item in case you try to make a copy, you’ll already get an error at compilation time
\end{enumerate}
\bigbreak \noindent 
Deleted functions should be declared as public, not private. It’s not a
mandate by the compiler, but some compilers might only complain
that you call a private function, not that it’s deleted.

\bigbreak \noindent 
\subsection{ What is a trivial class in C++?}
\bigbreak \noindent 
When a class or struct in C++ has only compiler-provided or
explicitly defaulted special member functions, then it is a trivial
type. It occupies a contiguous memory area. It can have members
with different access specifiers. In C++, the compiler is free to
choose how to order members in this situation. Therefore, you can
memcpy such objects but you cannot reliably consume them from a
C program. A trivial type T can be copied into an array of char or
unsigned char and safely copied back into a T variable. Note that
because of alignment requirements, there might be padding bytes
between type members.
\bigbreak \noindent 
Trivial types have a trivial default constructor, trivial copy and
move constructors, trivial copy and move assignment operators and
a trivial destructor. In each case, trivial means the constructor/operator/destructor is not user-provided and belongs to a class that
has
\begin{enumerate}
    \item no virtual functions or virtual base classes,
    \item no base classes with a corresponding non-trivial constructor/- operator/destructor
    \item no data members of class type with a corresponding nontrivial constructor/operator/destructor
\end{enumerate}
\bigbreak \noindent 
Whether a class is trivial or not, you can verify with the std::is\_trivial trait class. It checks whether the class is trivially copyable
(std::is\_trivially\_copyable) and is trivially default constructible
std::is\_trivially\_default\_constructible.

\pagebreak 
\unsect{Smart pointers}
\bigbreak \noindent 
\subsection{RAII}
\bigbreak \noindent 
RAII is the bread and butter idiom of C++. It says that anything that
exists in a system only in limited supply must be acquired before
we start using it.
\bigbreak \noindent 
By such resources, we mean things like
\begin{itemize}
    \item allocated heap memory,
    \item execution thread,
    \item open sockets,
    \item files,
    \item locked mutex,
    \item disk space,
    \item or database connections.
\end{itemize}
\bigbreak \noindent 
On the other hand, resources that are not acquired before using
them, are not part of RAII, such as 
\begin{itemize}
    \item CPU cores and time,
    \item cache capacity,
    \item network bandwidth,
    \item electric power consumption
    \item or even stack memory.
\end{itemize}
\bigbreak \noindent 
In practical terms, an RAII class acquires all the resources
upon construction and releases everything on destruction time.
You shouldn’t have to call methods such as init()/open()
or destroy/close.
\bigbreak \noindent 
In the standard library std::string, std::vector or std::thread
are such RAII classes.
\bigbreak \noindent 
On the other hand, if you consider raw pointers, they don’t share
the RAII concept. When a pointer goes out of scope, it doesn’t get
destroyed automatically, you have to delete it before it’s lost and
creates a memory leak. On the other hand, the smart pointers of
the standard library (std::unique\_ptr, std::shared\_ptr) provide
such a wrapper.
\bigbreak \noindent 
\begin{cppcode}
    SomeLimitedResource* resource = new SomeLimitedResource();
    resouce->doIt(); // oops, it throws an exception...

    delete resource; // this never gets called, so we have a leak
\end{cppcode}
\bigbreak \noindent 
Applying RAII by smart pointers, it should be ok:
\bigbreak \noindent 
\begin{cppcode}
    std::unique_ptr<SomeLimitedResource> resource =
    std::make_unique<SomeLimitedResource>();

    // even if it throws an exception, the resource gets released
    resouce->doIt();
\end{cppcode}

\bigbreak \noindent 
\begin{cppcode}
// RAII struct
struct A{
    int* p;
    A(int* p) : p(p) { }

    void ex() {
        throw std::exception();
    }

    ~A() {
        delete p;
    }
};
A a(new int(10));
a.ex(); // Ok! destructor will be called
\end{cppcode}

\bigbreak \noindent 
\subsection{When should we use unique pointers?}
\bigbreak \noindent 
If you need a smart pointer, by default, you should reach for
std::unique\_ptr. It is a small, fast, move-only smart pointer for
managing resources with exclusive-ownership semantics.
\bigbreak \noindent 
They have the same size as a raw pointer, and for most operations,
they require the same amount of instructions.
\bigbreak \noindent 
As mentioned, it’s for exclusive ownership. Whatever it points to,
it also owns it. std::unique\_ptr is a move only type, copying is
not allowed, there can be only one owner. There is no reference
counting, this makes it smaller and faster than the std::shared\_-
ptr.
\bigbreak \noindent 
By default, resource destruction takes place via delete, but custom
deleters can be specified. Stateful deleters and function pointers
as deleters increase the size of std::unique\_ptr objects. Resource
destruction happens as soon as the pointer goes out of scope.
\bigbreak \noindent 
\begin{cppcode}
    std::unique_ptr<T> ptr (new T());
    // or;
    T* t = new T();
    std::unique_ptr<T> ptr2 (t);
\end{cppcode}
\bigbreak \noindent 
C++14 introduced std::make\_unique to ease the creation:
\bigbreak \noindent 
\begin{cppcode}
std::unique_ptr<T> ptr = std::make_unique<T>();
\end{cppcode}
\bigbreak \noindent 
The new way of pointer creation is safer, because before you could
accidentally pass in a raw pointer twice to a new unique pointer
like this:
\bigbreak \noindent 
\begin{cppcode}
T* t = new T();
std::unique_ptr<T> ptr (t);
std::unique_ptr<T> ptr2 (t);
\end{cppcode}
\bigbreak \noindent 
A common use for std::unique\_ptr is as a factory function return
type for objects in a hierarchy. In case it turns out that a shared
pointer would be a better fit, the conversion is really easy:
\bigbreak \noindent 
\begin{cppcode}
std::unique_ptr<T> unique = std::make_unique<T>();
std::shared_ptr<T> shared = std::move(unique);
\end{cppcode}

\bigbreak \noindent 
\subsection{What are the reasons to use shared pointers?}
\bigbreak \noindent 
Shared pointers brought C++ developers the advantages of two
worlds. It offers automatic cleanup (a.k.a. garbage collection) that
is applicable to all types with a destructor and it is predictable, not
like Garbage Collectors in other languages.
\bigbreak \noindent 
Compared to std::unique\_ptr or to a raw pointer, std::shared\_-
ptr objects are typically twice as big because they don’t just contain
a raw pointer, but they also contain another raw pointer to a
dynamically allocated memory area where the reference counting
happens.
\bigbreak \noindent 
By default, destruction happens via delete, but just like for
std::unique\_ptr, custom deleters can be passed. It’s worth noting
that the type of the deleter has no effect on the type of the
std::shared\_ptr.
\bigbreak \noindent 
Resource destruction happens as soon as the pointer goes out of
scope.
\bigbreak \noindent 
It’s available since C++11 and there are two ways to initalize a
shared pointer:
\bigbreak \noindent 
\begin{cppcode}
std::shared_ptr<T> ptr (new T());
std::shared_ptr<T> ptr2 = std::make_shared<T>();
\end{cppcode}
\bigbreak \noindent 
The second way of pointer creation - via std::make\_shared is safer,
because before you could accidentally pass in a raw pointer twice
and the cost of the dynamic allocation for the reference count
memory is avoided.
\bigbreak \noindent 
Avoid creating std::shared\_ptrs from variables of raw pointer
type as it’s difficult to maintain, difficult to understand when the
pointed object would be destroyed.
\bigbreak \noindent 
Use std::shared\_ptr for shared-ownership resource management.

\bigbreak \noindent 
\subsection{When to use a weak pointer?}
\bigbreak \noindent 
A weak pointer - std::weak\_ptr is a smart pointer that doesn’t
affect the object’s reference count and as such what it points to
might have been already destroyed.
\bigbreak \noindent 
std::weak\_ptr is created from a shared\_ptr and in case the pointed
at object gets destroyed, the weak pointer expires.
\bigbreak \noindent 
\begin{cppcode}
    shared_ptr<int> sp = std::make_shared<int>(10);
    weak_ptr<int> wp(sp);

    sp = nullptr;
    if (wp.expired()) {
        cout << "wp exired" << endl;
    }
\end{cppcode}
\bigbreak \noindent 
In case you want to use it, you can either call lock() on it that either
returns a std::shared\_ptr or nullptr in case the pointer is expired,
or you can directly pass a weak ptr to shared\_ptr constructor.
\bigbreak \noindent 
\begin{cppcode}
std::shared_ptr<T> sp = wp.lock();
std::shared_ptr<T> sp2(wp);
\end{cppcode}
\bigbreak \noindent 
It can be useful for cyclic ownerships, to break the cycle
\bigbreak \noindent 
it can also be useful for caching and for the observer pattern.
\bigbreak \noindent 
\subsection{What are the advantages of std::make\_shared and std::make\_unique compared to the new operator?}
\bigbreak \noindent 
Let’s start with a reminder. While std::make\_shared was added to
the STL in C++11, std::make\_unique was only added in C++14.
\bigbreak \noindent 
Compared to the direct use of new, make functions eliminate source
code duplication, improve exception safety, and std::make\_shared
generates code that’s smaller and faster.
\bigbreak \noindent 
When you use new, if during construction there is an exception
thrown, in some circumstances, there might be a resource leak,
when the pointer has not yet been “processed” by the make function.
\bigbreak \noindent 
std::make\_shared is also faster than simply using new as it allocates
memory only once to hold the object and the control block for reference counting. Whereas when you use new it uses two allocations.
\bigbreak \noindent 
Sadly, the mentioned make functions cannot be used if you want to
specify custom deleters. At least, they are not often used.

\bigbreak \noindent 
\subsection{Should you use smart pointers over raw pointers all the time?}
\bigbreak \noindent 
No, raw pointers are, although considered dangerous in many cases, still have their place.
\bigbreak \noindent 
std::unique\_ptr transfers and std::shared\_ptr shares ownership.
\bigbreak \noindent 
In case a function has nothing to do with ownership, there should
be no need for it to take pointer parameters by a smart pointer.
Taking smart pointers in such cases will only make its API more
restrictive and the run-time cost higher.
\bigbreak \noindent 
 If you don’t want to share or transfer ownership, just use a raw pointer.

 \pagebreak 
 \unsect{References, universal references, a bit of a mixture}
 \bigbreak \noindent 
 \subsection{ What does std::move move?}
 \bigbreak \noindent 
 std::move doesn’t move anything. At runtime, it does nothing at all. It doesn’t even generate a single byte of executable code.
 \bigbreak \noindent 
 std::move is in fact just a tool to cast whatever its input is to an rvalue reference.
 \bigbreak \noindent 
 It returns an rvalue reference and that is a candidate for a move operation. Applying std::move to an object tells the compiler that the object is eligible to be moved from. That’s why std::move has the name it does have: to make it easy to designate objects that may be moved from.
 \bigbreak \noindent 
 It’s worth noting that moving from a const variable is not possible as the move constructor and the move assignment can change the object from where the move is performed. Yet if you try to move from a const object, the compiler will say nothing. No compiler warning not to say error. Move requests on const objects are silently transformed into copy operations.

 \bigbreak \noindent 
 \subsection{What does std::forward forward?}
 \bigbreak \noindent 
 Just like std::move doesn’t move anything, std::forward doesn’t forward anything either. Similarly, it does nothing at all at runtime. It doesn’t even generate a single byte of executable code.
 \bigbreak \noindent 
 std::forward is also a cast, just like std::move. But how it is used?
 \bigbreak \noindent 
 The most common scenario for std::forward is a function template that takes a universal reference parameter that is to be passed to another function:
 \bigbreak \noindent 
 It is also called perfect forwarding. It has two overloads.
 \bigbreak \noindent 
 One forwards lvalues as lvalues and rvalues as rvalues, while the
 other is a conditional cast. It forwards rvalues as rvalues and
 prohibits forwarding of rvalues as lvalues. Attempting to forward
 an rvalue as an lvalue, is a compile-time error.

 \bigbreak \noindent 
 \subsection{What is the difference between universal and rvalue references?}
 \bigbreak \noindent 
 If a function template parameter has type T\&\& for a deduced type T, or if an object is declared using auto\&\&, the parameter or object is a universal reference.
 \bigbreak \noindent 
 \begin{cppcode}
     template<typename T>
     void f(T&& param);

     // universal reference
     auto&& v2 = v; // universal reference
 \end{cppcode}
 \bigbreak \noindent 
 But what is a universal reference, you might ask. Universal references correspond to rvalue references if they’re initialized with rvalues. They correspond to lvalue references if they’re initialized with lvalues. They are either this or that depending on what is passed in.
 \bigbreak \noindent 
 If the form of the type declaration isn’t precisely type\&\&, or if type deduction does not occur - there is no auto used - we have an rvalue reference.
 \bigbreak \noindent 
 \begin{cppcode}
     void f(MyClass&& param); // rvalue reference

     MyClass&& var1 = MyClass(); // rvalue reference

     template<typename T>
     void f(std::vector<T>&& param); // rvalue reference
 \end{cppcode}
 \bigbreak \noindent 
 The takeaway is that by knowing the differences between rvalue
and universal references, you can read source code more accurately.
Is this an rvalue type that can be bound only to rvalues or is this
a universal reference that can be bound to either rvalue or lvalue
references?

\bigbreak \noindent 
\subsection{What is reference collapsing?}
\bigbreak \noindent 
Reference collapsing can happen in four different scenarios:
\begin{itemize}
    \item template instantiation
    \item auto type generation
    \item creation and use of typedefs and alias declarations
    \item using decltype
\end{itemize}
\bigbreak \noindent 
You are not allowed to declare a reference to a reference, but
compilers may produce them in the above-listed contexts. When
compilers generate references to references, reference collapsing
dictates what happens next
\bigbreak \noindent 
There are two kinds of references (lvalue and rvalue), so there are
four possible reference-reference combinations:
\begin{itemize}
    \item lvalue to lvalue
    \item lvalue to rvalue
    \item rvalue to lvalue
    \item rvalue to rvalue
\end{itemize}
\bigbreak \noindent 
If a reference to a reference arises in one of the four listed contexts,
the references collapse to one single reference according to this rule:
\bigbreak \noindent 
\begin{quote}
    If either reference is an lvalue reference, the result is an lvalue reference. Otherwise (i.e., if both are rvalue references) the result is an rvalue reference.
\end{quote}
\bigbreak \noindent 
Universal references are considered as rvalue references in contexts
where type deduction distinguishes lvalues from rvalues and where
reference collapsing occurs.

\bigbreak \noindent 
\subsection{When constexpr functions are evaluated?}
\bigbreak \noindent 
constexpr functions might be evaluated at compile-time, but it’s
not guaranteed. They can be executed both at runtime and at
compile time. It often depends on the compiler version and the
optimisation level.
\bigbreak \noindent 
If the value of a constexpr function is requested during compile
time with constexpr variable, then it will be executed at compile
time: constexpr auto foo = bar(42) where bar is a constexpr
function.
\bigbreak \noindent 
Also, if a constexpr function is executed in the context of a C-array
initialization or static assertion, it will be evaluated at compile time.
\bigbreak \noindent 
In case a constant is needed, but you provide only a runtime
function, the compiler will let you know.
\bigbreak \noindent 
It’s not a good idea to make all functions constexpr as most
computations are best done at run time. At the same time, it’s
worth noting that constexpr functions will be always threadsafe
and inlined.

\bigbreak \noindent 
\subsection{When should you declare your functions as noexcept?}
\bigbreak \noindent 
You should definitely put noexcept on every function written
completely in C or in any other language without exceptions. The
C++ Standard Library does that implicitly for all functions in the C
Standard Library.
\bigbreak \noindent 
Otherwise, you should use noexcept for functions that don’t throw
an exception, or if it throws, then you don’t mind letting the
program crash
\bigbreak \noindent 
Here is a small code sample to show how to use it
\bigbreak \noindent 
\begin{cppcode}
void func1() noexcept; // does not throw
void func2() noexcept(true); // does not throw
void func3() throw(); // does not throw
void func4() noexcept(false); // may throw
\end{cppcode}
\bigbreak \noindent 
But what does it mean that a function doesn’t throw an exception?
It means it cannot use any other function that throws, it is declared
as noexcept itself and it doesn’t use dynamic\_cast to a reference
type.
\bigbreak \noindent 
The six generated special functions are implicitly noexcept functions.
\bigbreak \noindent 
If an exception is thrown in spite of noexcept specifier being
present, std::terminate is called.
\bigbreak \noindent 
So you can use noexcept when it’s better to crash than actually
handling an exception, as the Core Guidelines also indicates
\bigbreak \noindent 
Using noexcept can give hints both for the compiler to perform
certain optimizations and for the developers as well that they don’t
have to handle possible exceptions.


\pagebreak 
\unsect{C++20}
\bigbreak \noindent 
\subsection{What are concepts}
\bigbreak \noindent 
Concepts are an extension to templates. They are compile-time
predicates that you can use to express a generic algorithm’s expectations on its template arguments.
\bigbreak \noindent 
Concepts allow you to formally document constraints on templates
and have the compiler enforce them. As a bonus, you can also take
advantage of that enforcement to improve the compile time of your
program via concept-based overloading
\bigbreak \noindent 
The main uses of concepts are:
\begin{itemize}
    \item Introducing type-checking to template programming
    \item Simplified compiler diagnostics for failed template instantiations
    \item Selecting function template overloads and class template specializations based on type properties
    \item Constraining automatic type deduction
\end{itemize}

\bigbreak \noindent 
Here is how you can define concepts
\bigbreak \noindent 
\begin{cppcode}
    template<typename T>
    concept integral = std::is_integral<T>::value;

    auto add(integral auto a, integral auto b) {
        return a+b;
    }
\end{cppcode}
\bigbreak \noindent 
What are the advantages of concepts?
\begin{itemize}
    \item Requirements for templates are part of the interface.
    \item The overloading of functions or specialisation of class templates can be based on concepts.
    \item We get improved error messages because the compiler compares the requirements of the template parameter with the actual template arguments
    \item You can use predefined concepts or define your own.
    \item The usage of auto and concepts is unified. Instead of auto, you can use the conceptName auto syntax.
    \item If a function declaration uses a concept, it automatically becomes a function template. Writing function templates is, therefore, as easy as writing a function.
\end{itemize}

\bigbreak \noindent 
\subsubsection{Constrained Template Parameter List}
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
concept integral = std::is_integral_v<T>;

template <integral T>
void foo(T t) {
    // ...
}
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Requires Clause (Pre-Declaration)}
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
requires SomeConcept<T>
void foo(T t) {
    // ...
}
\end{cppcode}

\bigbreak \noindent 
\subsubsection{ Abbreviated Function Template Syntax}
\bigbreak \noindent 
\begin{cppcode}
void foo(SomeConcept auto t) {
    // ...
}
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Trailing Requires Clause}
\bigbreak \noindent 
\begin{cppcode}
template <typename T>
void foo(T t) requires SomeConcept<T> {
    // ...
}
\end{cppcode}

\bigbreak \noindent 
\subsection{What are the available standard attributes in C++?}
\bigbreak \noindent 
A simple one looks like this: [[attribute]]. But it can have
parameters ([[deprecated("because")]]) or a namespace
([[gnu::unused]]) or both.

\bigbreak \noindent 
The first ones were introduced by C++11:
\begin{itemize}
    \item \relax [[noreturn]] indicates that a function does not return. It doesn’t mean that it returns a void, but that it doesn’t return. It can mean that it always throws an exception. Maybe different ones based on their input.
    \item  \relax [[carries\_dependency]] indicates that a dependency chain in release-consume std::memory\_order propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.
\end{itemize}

\bigbreak \noindent 
Then C++14 added another type of attribute with two versions:
\begin{itemize}
    \item \relax [[deprecated]] and [[deprecated(reason)]] indicate that the usage of that entity is discouraged. A reason can be specified as a parameter.
\end{itemize}
\bigbreak \noindent 
C++17 fastened up and added three more.
\begin{itemize}
    \item \relax [[fallthrough]] indicates in a switch-case that a break or return is missing on purpose. The fall through from one case label to another is intentional
    \item \relax [[nodiscard]] indicates that the return value of a function should not be discarded - in other words, it must be saved into a variable - otherwise, you’ll get a compiler warning
    \item \relax [[maybe\_unused]] suppresses compiler warnings on unused entities, if any. For example, you’ll not get a compiler warning for an unused variable if it was declared with the [[maybe\_unused]] variable.
\end{itemize}

\bigbreak \noindent 
C++20 added another 4 attributes:
\begin{itemize}
    \item \relax [[nodiscard("reason")]] it’s the same as [[nodiscard]] but with a reason specified.
    \item \relax [[likely]] indicates to the compiler that a switch-case or an if-else branch is likely to be executed more frequently than the others and as such it lets the compiler optimize for that evaluation path.
    \item \relax [[unlikely]] has the same concept as [[likely]], but in this case, such labelled paths are less likely to be executed than the others.
    \item \relax [[no\_unique\_address]] indicates that this data member need not have an address distinct from all other non-static data members of its class.
\end{itemize}

\bigbreak \noindent 
\subsection{What is 3-way comparison?}
\bigbreak \noindent 
The three-way comparison operator is also known as the starship operator and it looks like this: lhs <=> rhs.
\bigbreak \noindent 
With C++20, you can simply =default the spaceship operator and it will generate all the six constexpr and noexcept operators for you and they perform lexicographical comparison.

\bigbreak \noindent 
\subsection{What are modules and what advantages do they bring?}
\bigbreak \noindent 
#include statements are basically textual
inclusions. The preprocessor macro replaces the #include statement
with the content of the file to be included.
\bigbreak \noindent 
Hence a simple hello world program can grow from around 100
bytes up to 13,000. Simply because of the inclusion of <iostream>
\bigbreak \noindent 
All the header headers will be copied, even if you only want to use
one small function.
\bigbreak \noindent 
Modules, introduced by C++20, finally bring a solution. Importing
a module is basically free, unlike for inclusion, the order of imports
doesn’t matter.
\bigbreak \noindent 
With modules, you can easily structure your libraries and with
export qualifiers you can easily decide what you want to expose
and what not.
\bigbreak \noindent 
\begin{cppcode}
// math.cppm
export module math;

export int square(int n){
    return n*n;
}

// main.cpp
import math;
int main(){
    square(42);
}
\end{cppcode}

\pagebreak 
\unsect{Special function and the rules of how many?}
\bigbreak \noindent 
\subsection{Explain the rule of three}
\bigbreak \noindent 
If a class requires a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly requires all three.
\bigbreak \noindent 
When you return or pass an object by value, you manipulate a container, etc., these member functions will be called. If they are not user-defined, they are generated by the compiler (since C++98)
\bigbreak \noindent 
Since C++98 the compiler tries to generate
\begin{itemize}
    \item a default constructor (T()), that calls the default constructor of each class member and base class
    \item a copy constructor (T(const T\& other)), that calls a copy constructor on each member and base class
    \item a copy assignment operator (T\& operator=(const T\& other)), that calls a copy assignment operator on each class member and base class
    \item the destructor ($\sim$T()), which calls the destructor of each class member and base class. Note that this default-generated destructor is never virtual (unless it is for a class inheriting from one that has a virtual destructor).
\end{itemize}
\bigbreak \noindent 
In case you have a class holding on a raw or smart pointer,
a file descriptor, database connection, or other types managing
resources, there is a fair chance that the generated functions would
be incorrect and you should implement them by hand.
\bigbreak \noindent 
And here comes the rule of three, if you implement by hand
either the copy constructor, the copy assignment operator or the
destructor, the compiler will not generate those that you didn’t
write. So if you need to write any of these three, the assumption
is that you’ll need the rest as well
\bigbreak \noindent 
\subsection{Explain the rule of five}
\bigbreak \noindent 
 The rule of five was introduced by C++11. It’s about move semantics that was introduced by C++11. So if you
implement by hand any of the following special functions, then
none of the others will be generated. You have to take care of
implementing all of them:
\begin{itemize}
    \item a copy constructor: T(const T\&)
    \item a copy assignment: operator=(const T\&)
    \item a move constructor: T(X\&\&)
    \item a move assignment: operator=(T\&\&)
    \item a destructor: $\sim$T()
\end{itemize}

\bigbreak \noindent 
\subsection{Explain the rule of zero}
\bigbreak \noindent 
If all the members have all their special functions, you’re done, you don’t need to define any, zero.
\bigbreak \noindent 
\begin{cppcode}
class MyClass {
public:
    // ... no default operations declared
    private:
    std::string name;
    std::map<int, int> rep;
};

MyClass mc; // default constructor
MyClass mc2 {nm}; // copy constructor
\end{cppcode}
\bigbreak \noindent 
As both std::map and std::string have all the special functions, none
is needed in MyClass
\bigbreak \noindent 
The idea is that a class needs to declare any of the special functions,
then it should deal exclusively with ownership and other classes
shouldn’t declare these special functions.
\bigbreak \noindent 
So keep in mind, that if you need any of the special functions,
implement all of them, but try not to need them in the first place.

\bigbreak \noindent 
\subsection{What advantages does having a default constructor have?}
\bigbreak \noindent 

We could say that a default constructor gives us the possibility of
simple object creation, but it’s not so much the case.
\bigbreak \noindent 
It’s true that it’s simple to create an object without passing any
parameters, but it’s only useful if the created object is fully usable. If
it still has to be initialized, then the simple creation is worth nothing
and in fact, it’s even misleading and harmful.
\bigbreak \noindent 
On the other hand, many features of the standard library require
having a default constructor.
\bigbreak \noindent 
Think about std::vector, when you create a vector of 10 elements
(std::vector<T> ts(10);), 10 default constructed T objects will be
added to the new vector.
\bigbreak \noindent 
It’s worth noting that having a default constructor doesn’t mean
that you should define it. Whenever possible, let the compiler
generate it. So for example, if a default constructor only default
initializes data members, then you are better off using in-class member initializers instead and let the compiler generate the default
constructor.
\bigbreak \noindent 
So whenever possible, you should have a default constructor, because it lets you use more language and standard library features,
but also make sure that a default constructor leaves a fully usable
object behind


\pagebreak 
\unsect{Object oriented design, inheritance, polymorphism}
\bigbreak \noindent 
\subsection{Distinguish between shallow copy and deep copy}
\bigbreak \noindent 
A shallow copy does memory dumping bit-by-bit from one object
to another, in other words, it copies all of the member field values.
A deep copy is a field by field copy from one object to another.
\bigbreak \noindent 
The big difference is that a shallow copy may not do what you
want for members that are not storing values, but pointers to values.
In other words, for members pointing to dynamically allocated
memory. A shallow copy of those means that no new memory will
be allocated and in fact, if you modify such a member through one
object, the changes will be visible from all the copies.
\bigbreak \noindent 
The default copy constructor and assignment operator make shallow copies. In case, a class has a reference or pointer members, there
is a fair chance that you have written the copy constructor yourself
and you should also write the assignment operator.

\bigbreak \noindent 
\subsection{What does dynamic dispatch mean?}
\bigbreak \noindent 
Dynamic dispatch is the process of selecting
which implementation of a polymorphic operation (method or
function) to call at run time. It is commonly employed in, and
considered a prime characteristic of, object-oriented programming
(OOP) languages and systems
\bigbreak \noindent 
Dynamic dispatch contrasts with static dispatch, in which the
implementation of a polymorphic operation is selected at compile
time. The purpose of dynamic dispatch is to defer the selection of an
appropriate implementation until the run time type of a parameter
(or multiple parameters) is known.

\bigbreak \noindent 
\subsection{What is an abstract class in C++?}
\bigbreak \noindent 
An abstract class in C++ is a class with at least one pure virtual
function. A pure virtual is a function that has no implementation
in that given class. Such classes cannot be instantiated
\bigbreak \noindent 
Any class that is meant to be instantiated and inherits from an
abstract one, it must implement all the pure virtual - in other words,
abstract - functions. Though non-leaf classes inheriting from an
abstract class that are only used as base classes of other classes,
they don’t have to implement the pure virtual functions: Though we cannot instantiate an abstract class, we can have
pointers or references to it:
\bigbreak \noindent 
A class is abstract if it has at least one pure virtual function. So
an abstract class can have non-virtual or just non-pure virtual
functions. It can even have a constructor and some members.

\bigbreak \noindent 
\subsection{Is it possible to have polymorphic behaviour without the cost of virtual functions?}
\bigbreak \noindent 
The short answer is yes.

\pagebreak 
\unsect{Observable behaviours}
\bigbreak \noindent 
\subsection{What is observable behaviour of code?}
\bigbreak \noindent 
The term observable behavior, according to the standard, means the following:
\begin{itemize}
    \item Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.
    \item At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.
    \item The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is implementation-defined.
\end{itemize}
\bigbreak \noindent 
The “as-if rule” is strongly related, in short, any code transformation is allowed that does not change the observable behavior of the
program.
\bigbreak \noindent 
The C++ standard precisely defines the observable behavior of
every C++ program that does not fall into one of the following
classes
\begin{itemize}
    \item ill-formed
    \item ill-formed, no diagnostic required
    \item implementation-defined behaviour
    \item unspecified behaviour
    \item undefined behaviour
\end{itemize}
\bigbreak \noindent 
\subsection{What are the characteristics of an ill-formed C++ program?}
\bigbreak \noindent 
We saw above that the C++ standard defines the behaviour
of C++ programs. In case the program is not well-formed, the
behaviour falls into one of the five other cases. One of them is “illformed” and another is “ill-formed, no diagnostic required”
\bigbreak \noindent 
\subsubsection{ill-formed}
\bigbreak \noindent 
In this case, the program has syntax errors and/or diagnosable
semantic errors. The compiler will tell you about them. The violated
rules are written in the standard with either shall, shall not or
ill-formed.

\bigbreak \noindent 
\subsubsection{ill-formed, no diagnostic required}
\bigbreak \noindent 
Under this category, there will be no compiler errors. The program
doesn’t have syntactic errors, only semantic ones, but in general,
they are not diagnosable by the compiler.
\bigbreak \noindent 
These semantic errors are either detectable at link time, or if the
program is executed, it results in undefined behaviour.
\bigbreak \noindent 
Such problems are violations against the One Definition Rule which
says that only one definition of any variable, function, class type,
enumeration type, concept (since C++20) or template is allowed in
any one translation unit. There might be multiple declarations, but
only one definition.

\bigbreak \noindent 
\subsection{What is unspecified behaviour?}
\bigbreak \noindent 
The behaviour of a program is said to be unspecified when the
standard does not specify what should happen or it specifies multiple options. The exact behaviour depends on the implementation
and may not be completely determined upon examination of the
program’s source code.
\bigbreak \noindent 
Even with the implementation, the compiler doesn’t have to document how it resolves such situations.
\bigbreak \noindent 
This means that different result sets can be completely valid depending on which implementation you are using.
\bigbreak \noindent 
But whatever will happen it’s guaranteed that the effects of the
unspecified code are strictly limited to the commands affected. It’s
not the case for undefined behaviour when the compiler is free to
remove complete execution branches
\bigbreak \noindent 
Consider
\bigbreak \noindent 
\begin{cppcode}
int x, y;

cout << &x > &y;
\end{cppcode}
\bigbreak \noindent 
In other words, if you take two local variables and for any reason,
you want to compare their memory addresses, it’s completely
unspecified whose address will be higher. There is no right or good
answer, it depends on the implementation, but it doesn’t have to
document it.
\bigbreak \noindent 
\subsection{What is implementation-defined behaviour?}
\bigbreak \noindent 
In many ways, implementation-defined behaviour is similar to
unspecified behaviour. First of all, the standard doesn’t impose on
how the concerned item should be implemented. That will depend
on the compiler
\bigbreak \noindent 
It’s also true that the effects of implementation-defined behaviour
are limited to the very commands in question. So no full execution
branches can be removed, like in the case of undefined behaviour.
\bigbreak \noindent 
What differs between unspecified and implementation-defined behaviour is that the implementation must document what is a valid
result set.
\bigbreak \noindent 
In C++, sizeof(int) and the size of integer types, in general, is
implementation specified. And even the size of a byte

\bigbreak \noindent 
\subsection{What is undefined behaviour in C++?}
\bigbreak \noindent 
Among unspecified, implementation-defined and undefined behaviour, this latter one is the most dangerous.
\bigbreak \noindent 
When you implement a program invoking some behaviour that is
undefined, it basically means that there are no requirements on
the behaviour of your whole program. The possible effects are not
limited to the calls whose behaviour are unspecified, the compiler
can do anything so your software can:
\begin{itemize}
    \item crash with seemingly no reasons
    \item return logically impossible results
    \item have non-deterministic behaviour
\end{itemize}
\bigbreak \noindent 
In fact, the compiler can remove whole execution paths. Let’s
say you have a big function with one line invoking undefined
behaviour. It’s possible that the whole function will be removed
from the compiled code.
\bigbreak \noindent 
When you have undefined behaviour in your code, you break
the rules of the language and it won’t be detected until runtime.
Turning on as many compiler warnings as possible usually helps a
lot in removing undefined behaviour.
\bigbreak \noindent 
Some examples of undefined behaviour:
\begin{itemize}
    \item Accessing uninitialized variables
    \item Accessing objects after the lifetime ended
    \item Deleting objects through base class pointers without a virtual destructor
\end{itemize}
\bigbreak \noindent 
\subsection{What are the reasons behind undefined behaviour’s existence?}
\bigbreak \noindent 
First of all, we have to remark that the concept of undefined
behaviour was not introduced by C++. It was already there in C.
\bigbreak \noindent 
And what is C after all? It’s just a high-level assembler that had to
work on completely different platforms and architectures.
\bigbreak \noindent 
From the language designer’s point of view, undefined behaviour
is a way to cope with significant differences between compilers
and between platforms. Some even refer to that epoch as chaotic.
Different compilers treated the language differently and to be fairly
backwards-compatible, a lot of details (like layout, endianness)
were not defined or specified.
\bigbreak \noindent 
This gave compiler writers a lot of flexibility and they could and
still can get really creative with this freedom. They can use it
to simplify, to shorten, to speed up the compiled code without
violating any rules.

\bigbreak \noindent 
\subsection{What approaches to take to avoid undefined behaviour?}
\bigbreak \noindent 
You can listen to your compiler! Turn on whatever warnings you can (-Wall, -Wextra, -Wpedantic) and treat them as errors. They will catch a lot of undefined behaviour.
\bigbreak \noindent 
Use a sanitizer, both g++ and clang offer some
\bigbreak \noindent 
Practice contractual programming. If you want to use elements of the standard library (you should), check the contract
it proposes, in other words, read their documentation, read
what kind of input they expect.

\bigbreak \noindent 
\subsection{What doesn't cause iterator invalidation? }
\bigbreak \noindent 
insert iterators (e.g. std::back\_insert\_iterator)
are guaranteed to remain valid as long as all insertions are
performed through this iterator and no other independent
iterator-invalidating event occurs. They will even remain valid if a
container has to be reallocated as it grows (notably a std::vector).
\bigbreak \noindent 
Also, read-only methods never invalidate iterators or references.
Methods that modify the contents of a container may invalidate
iterators and/or references

\pagebreak 
\unsect{The Standard Template Library}
\bigbreak \noindent 
\subsection{What is the STL?}
\bigbreak \noindent 
STL stands for the Standard Template Library, but there is no such
library as the STL. It is part of the C++ standard library.
\bigbreak \noindent 
It’s a set of template classes and functions to provide solutions for
common problems. The elements of the STL can be divided into 4
categories:
\begin{enumerate}
    \item algorithms, e.g.: std::find, std::copy
    \item containers, e.g.: std::vector<T>, std::list<T>
    \item function objects, e.g.: std::greater<T>, std::logical_and<T>
    \item iterators, e.g.: std::iterator, std::back_inserter
\end{enumerate}
\bigbreak \noindent 
The STL was created by Alexander Stepanov, who already had the
idea of a generic data processing library in the 1970s, but there was
no language support to implement his dream.
\bigbreak \noindent 
In the 80s, he made his first attempts in ADA, but that language
never got widely adopted outside the defence industry.
\bigbreak \noindent 
A former colleague convinced him to present the idea to the C++
Committee that he did in November 1993. Then things happened
fast. In March 1994, Stepanov submitted the formal proposal which
was accepted in just a mere 4 months. In August, HP - the employer
of Stepanov - published the first implementation of the STL.

\bigbreak \noindent 
\subsection{What are the advantages of algorithms over raw loops?}
\bigbreak \noindent 
First, what are raw loops?
\bigbreak \noindent 
“A raw loop is any loop inside a function where the function serves
a purpose larger than the algorithm. implemented by the loop.” -
Sean Parent
\bigbreak \noindent 
Why should you prefer using std algorithms
instead of such raw loops?
\begin{itemize}
    \item \textbf{Algorithms are virtually bug-free}: If you have to write something a thousand times, there is a fair chance that you’ll make some mistakes once in a while. It’s OK, we all make mistakes. On the other hand, if you use functions that were written before and used a million times, you won’t face any bugs
    \item \textbf{Algorithms have a better performance (Usually)}:
\end{itemize}
\bigbreak \noindent 
Algorithms are most of the time better than plain old for loops.
\bigbreak \noindent 
They are less error-prone than loops as they were already written
and tested - a lot. Unless you are going for the last drops of
performance, algorithms will provide be good enough for you and
actually more performant than simple loops

\bigbreak \noindent 
\subsection{Do algorithms validate ranges?}
\bigbreak \noindent 
No, It's undefined behaviour. You might have seemingly correct
results, like the combination of the two containers, you might get
a timeout or a nice core dump. You have to always double-check that what you pass in is valid and
respect the contracts imposed by the given algorithm.

\bigbreak \noindent 
\subsection{Can you combine containers of different sizes?}
\bigbreak \noindent 
No, it's UB, So you always have to make sure that the second input range,
defined only by its starting point is always at least as long as the
first one.











\end{document}
