\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Advanced algorithms}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Advanced algorithms}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Linked lists}
    \bigbreak \noindent 
    \subsection{Floyd's cycle finding algorithm (Hare-Tortoise algorithm)}
    \bigbreak \noindent 
    Floyd’s cycle finding algorithm or Hare-Tortoise algorithm is a pointer algorithm that uses only two pointers, moving through the sequence at different speeds. This algorithm is used to find a loop in a linked list. It uses two pointers one moving twice as fast as the other one. The faster one is called the fast pointer and the other one is called the slow pointer.
    \bigbreak \noindent 
    While traversing the linked list one of these things will occur-
    \begin{itemize}
        \item The Fast pointer may reach the end (NULL) which shows that there is no loop in the linked list.
        \item The Fast pointer again catches the slow pointer at some time therefore a loop exists in the linked list.
    \end{itemize}
    \bigbreak \noindent 
    \begin{cppcode}
        bool hasCycle(ListNode *head) {
            if (!head) return false;
            ListNode* slow = head, *fast = head;

            while (fast && slow && slow->next && fast->next && fast->next->next) {
                slow = slow->next;
                fast = fast->next->next;
                if (slow == fast) return true;
            }
            return false;
        }
    \end{cppcode}
    \bigbreak \noindent 
    \subsubsection{Location of where the cycle begins}
    \bigbreak \noindent 
    Floyd’s algorithm (also known as the "tortoise and hare" algorithm) not only detects a cycle in a linked list but can also identify the exact node where the cycle begins. 
    \bigbreak \noindent 
    If there is a cycle, the fast pointer will eventually "lap" the slow pointer, meaning they will meet at some node inside the cycle. If no cycle exists, the fast pointer will reach the end of the list (i.e., a null reference).
    \bigbreak \noindent 
    Once a meeting point is found, reset the slow pointer to the head of the list while keeping the fast pointer at the meeting point. Now move both pointers one step at a time. 
    \bigbreak \noindent 
    The point at which the two pointers meet again is the start of the cycle.
    \bigbreak \noindent 
    \begin{cppcode}
        ListNode* floyd(ListNode* head) {
            ListNode* slow = head, *fast = head;

            while (fast) {
                slow = slow->next;

                if (fast->next && fast->next->next) {
                    fast=fast->next->next;
                    if (slow == fast) break;
                }
                else fast=nullptr;

            } 
            if (!fast) return nullptr;

            slow = head;
            while (slow != fast) {
                slow=slow->next;
                fast=fast->next;
            }

            return slow;
        }

        int main(int argc, const char** argv) {

            ListNode* head = new ListNode(1);
            head->next = new ListNode(2);
            ListNode* cycle_begin = head->next;
            head->next->next = new ListNode(3);
            head->next->next->next = new ListNode(4);
            head->next->next->next->next = cycle_begin;

            ListNode* f = floyd(head);
            if (f) cout << f->val;
            else cout << "No cycle";
        }
    \end{cppcode}

    \bigbreak \noindent 
    \subsubsection{Proof of Floyd's algorithm}
    \bigbreak \noindent 
    Let
    \begin{align*}
        L &= \text{ Distance from head to the beginning of the cycle}\\
        C &= \text{ Length of the cycle} \\
        K &= \text{ Distance from start of cycle to meeting point}
    .\end{align*}
    \bigbreak \noindent 
    Once the slow pointers meet, the slow pointer has moved $L + K$ times, whereas the fast pointer has moved $L + K +nC$, where $n$ is the number of completed cycles. Since the fast pointer moves twice as fast, we have
    \begin{align*}
        2(L + K) &= L + K + nC
    .\end{align*}
    Solving for $L$, we get
    \begin{align*}
        L &= nC - K
    .\end{align*}
    Reset the slow pointer to the head of the list, move both pointers at the same rate (rate of the slow pointer) $L$ times. The slow pointer will be at the start of the cycle, the fast pointer (which started $K$ nodes into the cycle) will have moved 
    \begin{align*}
        (L + K) \mod C
    .\end{align*}
    But, $L = nC - K$. Thus,
    \begin{align*}
        (L + K) \mod C = (nC - K + K) \mod C = nC \mod C = 0
    .\end{align*}
    Thus, the fast pointer will also be at the start of the cycle, since it is zero nodes into the cycle. \endpf

    \bigbreak \noindent 
    \subsubsection{Practical example, find duplicate}
    \bigbreak \noindent 
    Given an array of integers nums containing $n + 1$ integers where each integer is in the range $[1, n]$ inclusive.
    \bigbreak \noindent 
    There is only one repeated number in nums, return this repeated number.
    \bigbreak \noindent 
    You must solve the problem without modifying the array nums and using only constant extra space.

    \bigbreak \noindent 
    \begin{cppcode}
        int findDuplicate(vector<int>& nums) {
            int slow = 0, fast = 0;
            do {
                slow = nums[slow];
                fast = nums[nums[fast]];
            } while (slow != fast);

            slow = 0;
            do {
                slow = nums[slow];
                fast = nums[fast];
            } while (slow != fast);
            return slow;
        }
    \end{cppcode}









    \pagebreak 
    \unsect{Range queries}
    \bigbreak \noindent 
    In a range query, our task is to calculate a value based on a subarray of an array. Typical range queries are
    \begin{itemize}
        \item $sumq(a,b)$: calculate the sum of values in range $[a,b]$
        \item $minq(a,b)$: find the minimum value in range $[a,b]$
        \item $maxq(a,b)$: find the maximum value in range $[a,b]$
    \end{itemize}
    \bigbreak \noindent 
    A simple way to process range queries is to use a loop that goes through all array values in the range.
    \bigbreak \noindent 
    This works in $O(n)$ time, where $n$ is the size of the array. Thus, we can process $q$ queries in $O(nq)$ time using the function. However, if both $n$ and $q$ are large, this approach is slow. Fortunately, it turns out that there are ways to process range queries much more efficiently.

    \bigbreak \noindent 
    \subsection{Static array queries}
    \bigbreak \noindent 
    We first focus on a situation where the array is static, i.e., the array values are never updated between the queries. In this case, it suffices to construct a static data structure that tells us the answer for any possible query.
    \bigbreak \noindent 
    \subsubsection{Sum queries}
    \bigbreak \noindent 
    We can easily process sum queries on a static array by constructing a prefix sum array. Each value in the prefix sum array equals the sum of values in the original array up to that position. That is, the value at position $k$ is $\text{sum}_{q}(0,k) $
    \bigbreak \noindent 
    we can calculate any value of $\text{sum}_{q}(a,b)$ in $O(1)$ time as follows:
    \begin{align*}
        \text{sum}_{q}(a,b) = \text{sum}_{q}(0,b) - \text{sum}_{q}(0,a-1)
    .\end{align*}
    We define $\text{sum}_{q}(0,-1) = 0$, so that the formula holds when $a=0$

    \bigbreak \noindent 
    \subsubsection{Minimum and maximum queries: Sparse tables}
    \bigbreak \noindent 
    Minimum queries are more difficult to process than sum queries. Still, there is a quite simple $O(n \lg n)$ time preprocessing method after which we can answer any minimum query in $O(1)$ time
    \bigbreak \noindent 
    Note that since minimum and maximum queries can be processed similarly, we can focus on minimum queries.
    \bigbreak \noindent 
    The idea is to precalculate all values of $\text{min}_{q}(a,b)$ where $b - a +1$ (the length of the range) is a power of two. For example, for the array
    \bigbreak \noindent 
    \begin{center}
        A := [1,3,4,8,6,1,4,2]
    \end{center}
    \bigbreak \noindent 
    The following values are calculated
    \bigbreak \noindent 
    \begin{align*}
        \begin{array}{ccc}
            a &b &\text{min}_{q}(a,b) \\
            \hline
            0 &0 &1\\
            1 &1 &3\\
            2 &2 &4\\
            3 &3 &8\\
            4 &4 &6\\
            5 &5 &1\\
            6 &6 &4\\
            7 &7 &2 
        \end{array}
        \quad
        \begin{array}{ccc}
            a &b &\text{min}_{q}(a,b)\\
            \hline
            0 &1 &1\\
            1 &2 &3\\
            2 &3 &4\\
            3 &4 &6\\
            4 &5 &1\\
            5 &6 &1\\
            6 &7 &2
        \end{array}
        \quad
        \begin{array}{ccc}
            a &b &\text{min}_{q}(a,b) \\
            \hline
            0 &3 &1\\
            1 &4 &3\\
            2 &5 &1\\
            3 &6 &1\\
            4 &7 &1\\
            0 &7 &1
        \end{array}
    .\end{align*}
    \bigbreak \noindent 
    The number of precalculated values is $O(n\lg n)$, because there are $O(\lg n)$ range lengths that are powers of two. The values can be calculated efficiently using the recursive formula
    \begin{align*}
        \text{min}_{q}(a,b) = \text{min}(\text{min}_{q}(a, a+w-1), \text{min}_{q}(a+w,b))
    \end{align*}
    where $b-a+1$ is a power of two and $w = \frac{b-a+1}{2} $, calculating all those values takes $O(n\lg n)$ time.
    \bigbreak \noindent 
    After this, any value of $\text{min}_{q}(a,b)$ can be calculated in $O(1)$ time as a minimum of two precalculated values. Let $k$ be the largest power of two that does not exceed $b - a+1$. We can calculate the value of minq(a,b) using the formula
    \begin{align*}
        \text{min}_{q}(a,b) = \text{min}(\text{min}_{q}9a,a+k-1, \text{min}_{q}(b-k+1,b))
    .\end{align*}
    In the above formula, the range $[a,b]$ is represented as the union of the ranges $[a,a+ k -1]$ and $[b - k +1,b]$, both of length $k$
    \bigbreak \noindent 
    Note that we have the min for both these ranges, since
    \begin{align*}
        a+k-1-a+1 &= k, \\
        b-(b-k+1)+1 &= k
    \end{align*}
    and $k$ is a power of two. Also, we have that
    \begin{align*}
        k \leq L
    \end{align*}
    where $L = (b-a+1)$, it follows then that
    \begin{align*}
        L < 2k
    .\end{align*}
    So, 
    \begin{align*}
        k \leq L < 2k
    .\end{align*}
    Thus, for our split $A[a,a+k-1]$ and $A[b-k+1,b]$, both segments have length $k$, so the sum of the number of elements in both segments is $2k$. If segment one starts at $a$, and segment two ends at $b$, and the total is $2k$, then the union must capture the original subarray $A[a,b]$, since $ L < 2k $.
    \bigbreak \noindent 
    The structure that we store the preprocessed work in is called a \textbf{sparse table}.
    \bigbreak \noindent 
    We create a matrix table $st[i][j]$ such that 
    \begin{itemize}
        \item $i$ represents the starting index in the array
        \item $j$ represents the interval length as a power of $2$. That is, the interval covers $2^{j}$ elements
    \end{itemize}
    The idea is that $st[i][j]$ stores the minimum value in the subarray from index $i$ to index $i+2^{j} -1$. If the ending index is $k$, then 
    \begin{align*}
        2^{j} = k-i+1 \implies k = 2^{j} + i -1 = i +2^{j} -1
    .\end{align*}
    For every $i$ in the range $0$ to $n-1$, 
    \begin{align*}
        st[i][0] = A[i]
    .\end{align*}
    This corresponds to an interval of length 1 ($2^{0}$).
    \bigbreak \noindent 
    For every $j$ from $1$ up to $ $

    \pagebreak 
    \begin{cppcode}
        void buildSparseTable(const vector<int>& v, vector<vector<int>>& st, vector<int>& log) {
            int n = v.size();
            int K = floor(log2(n)) + 1;

            // Resize and initialize the sparse table.
            st.assign(n, vector<int>(K));

            // Compute log values for each i.
            log.resize(n + 1);
            log[1] = 0;
            for (int i = 2; i <= n; i++) {
                log[i] = log[i / 2] + 1;
            }

            // Initialize st[i][0] = v[i].
            for (int i = 0; i < n; i++) {
                st[i][0] = v[i];
            }

            // Build sparse table: combine intervals.
            for (int j = 1; j < K; j++) {
                for (int i = 0; i + (1 << j) <= n; i++) {
                    st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
                }
            }
        }

        int query(int L, int R, const vector<vector<int>>& st, const vector<int>& log) {
            int len = R - L + 1;
            int j = log[len];
            return std::min(st[L][j], st[R - (1 << j) + 1][j]);
        }
    \end{cppcode}
    \bigbreak \noindent 


    



    \pagebreak \bigbreak \noindent 
    \subsection{Difference arrays}
    \bigbreak \noindent 
    Difference arrays are a useful technique in data structures and algorithms that allow for efficient range updates on an array.
    \bigbreak \noindent 
    A difference array is derived from an original array. It stores the difference between consecutive elements. For an array $A$ of size $n$, the difference array $D$ is defined as:
    \begin{align*}
        D[0] &= A[0] \\
        D[i] &= A[i] - A[i-1]  \quad \text{ for} i \in \{1,2,...n-1\}
    \end{align*}
    \bigbreak \noindent 
    The key idea is that if you want to add a constant value $x$ to a range from index $l$ to $r$ in $A$, you can update the difference array $D$ as follows
    \begin{align*}
        D[l] &+= x \\
        D[r+1] &-= x \quad \text{ if $r+1$ in bounds}
    \end{align*}
    After processing all such range updates, you can reconstruct the final array by computing the prefix sum of $D$
    \begin{align*}
        A[0] &= D[0] \\
        A[i] &= A[i-1] + D[i] \quad \text{ for } i\in \{1,2,...,n-1\} 
    \end{align*}
    \bigbreak \noindent 
    Range updates that would normally take $O(n)$ time each can be done in $O(1)$ time
    \bigbreak \noindent 
    Consider an example
    \begin{align*}
        A = [1,2,3,4,5]
    \end{align*}
    Thus,
    \begin{align*}
        D = [1,1,1,1,1]
    \end{align*}
    \bigbreak \noindent 
    With query $Q(1,3,3)$, of form $Q(l_{i}, r_{j}, v)$. Thus, $Q(1,3,3)  = A[i]+=3$ for $i\in \{1,2,3\}$
    \bigbreak \noindent 
    Applying $D[l] = D[1] +=3$, $D[r+1]  = D[4]-=3$, we get
    \begin{align*}
        D = [1,4,1,1,-2]
    \end{align*}
    Then we reconstruct $A$ using prefix sums $A[i] = A[i-1] + D[i]$, and we get
    \begin{align*}
        A = [1,5,6,7,5] 
    \end{align*}
    \bigbreak \noindent 
    if $r$ is the last index in the original array, then $r+1$ will be out of bounds. In that case, you simply omit the subtraction step because there's no element beyond the last index. This naturally means that the update applies to all elements from $l$ to the end of the array. Consider the query $Q(1,4,3)$ on the array $A = [1,2,3,4,5]$. The difference array is 
    \begin{align*}
        D = [1,4,1,1,1]
    \end{align*}
    Notice that since $D[r+1] = D[5]$ is out of bounds, we only need to do $D[l] = D[1]+=3$. The final array is 
    \begin{align*}
        A[1,5,6,7,8]
    \end{align*}

    \bigbreak \noindent 
    \subsubsection{Why it works}
    \bigbreak \noindent 
    Let's first consider the property between the difference array $D$ and the array $A$
    \begin{align*}
        D[0] &= A[0] \\
        D[i] &= A[i] - A[i-1]
    \end{align*}
    Thus,
    \begin{align*}
        A[i] &= D[i] + A[i-1]
    \end{align*}
    Suppose we have the array $A[a,b,c,d,e]$, and we want to add $k$ to $A[i]$, for $i \in \{1,2,3\} $, we have
    \begin{align*}
        A[a,b+k, c+k, d+k, e]
    \end{align*}
    Then, 
    \begin{align*}
    &D[a, b+k-a, b+k-c-k, d+k-c-k, e-d-k] \\
    &=[a, b-a+k, b-c, d-c, e-k]
    \end{align*}
    We see the only changes to $D$ are $D[l]$, and $D[r+1]$

    \begin{align*}
        1 + 2 + 3 + \cdots
    \end{align*}






    \pagebreak 
    \unsect{Intervals}
    \bigbreak \noindent 
    Interval problems are a class of problems in data structures and algorithms that deal with ranges or segments, typically represented by start and end points. These problems often require determining relationships between intervals—such as overlapping, containment, or disjointness—and finding optimal ways to select, merge, or query these intervals.
    \bigbreak \noindent 
    Common problem types are
    \begin{itemize}
        \item \textbf{Interval Scheduling:} Select the maximum number of non-overlapping intervals from a given set. A classic example is scheduling meetings in a conference room.
        \item \textbf{Interval Partitioning:} Assign intervals to different resources (like classrooms or machines) such that no overlapping intervals share the same resource, while minimizing the total number of resources used.
        \item \textbf{Merging Intervals:} Combine overlapping intervals into a single continuous interval. This is often required in scenarios like consolidating time ranges or segments.
        \item \textbf{Interval Intersection/Union:} Find the common overlapping parts (intersection) of intervals or the total span covered by intervals (union).
    \end{itemize}
    \bigbreak \noindent 
    Data structures and techniques that are relevant are
    \begin{itemize}
        \item \textbf{Greedy Algorithms:} For many interval scheduling problems, a greedy approach (such as selecting the interval that ends earliest) leads to an optimal solution.
        \item \textbf{Sorting:} Many interval problems begin with sorting the intervals based on start or end times to simplify subsequent processing.
        \item \textbf{Interval Trees:} These are balanced trees designed to hold intervals and allow efficient querying, such as finding all intervals that overlap with a given query interval.
        \item \textbf{Segment Trees:} Useful for range queries and updates, segment trees can efficiently manage intervals when dealing with aggregated data like sums or minima/maxima over a range.
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Merge intervals}
    \bigbreak \noindent 
    The merge intervals problem is a problem that takes overlapping intervals, and merges the ones that overlap. For example,
    \begin{align*}
        [1,3], [2,6], [8,10], [15,18] \to [1,6], [8,10], [15,18]
    \end{align*}
    We note that intervals with common endpoints are considered to be overlapping. For example, $[1,4], [4,5]$ would be merged into $[1,5]$
    \bigbreak \noindent 
    \begin{cppcode}
        class Solution {
            public:
            vector<vector<int>> merge(vector<vector<int>>& intervals) {
                std::sort(intervals.begin(), intervals.end());

                vector<vector<int>> m;
                int curr_start = intervals[0][0];
                int curr_end = intervals[0][1];

                for (int i=1; i<(int)intervals.size(); ++i) {
                    int next_left = intervals[i][0], next_right = intervals[i][1];

                if (next_left >= curr_start && next_left <= curr_end) {
                    curr_end = std::max(curr_end, next_right);
                } else {
                    m.push_back({curr_start,curr_end});
                    curr_start = next_left, curr_end = next_right;
                }
            }
            m.push_back({curr_start, curr_end});
            return m;
        }
    };

    // [[1,3],[2,6],[8,10],[15,18]] -> [[1,6],[8,10],[15,18]]
\end{cppcode}
\bigbreak \noindent 
Time complexity is $O(n\lg n)$, space complexity is $O(n)$

\pagebreak 
\subsection{Line sweep (sweep line)}
\bigbreak \noindent 
Line Sweep (or Sweep Line) is an algorithmic technique where we sweep an imaginary line (x or y axis) and solve various problem.
\bigbreak \noindent 
\subsubsection{Merge intervals with line sweep}
\bigbreak \noindent 
\begin{cppcode}
    class Solution {
        public:
        vector<vector<int>> merge(vector<vector<int>>& intervals) {
            map<int, int> line;
            for (const auto& e : intervals) {
                ++line[e[0]];
                --line[e[1]];
            }

            int count=0, start=0;
            vector<vector<int>> res;
            for (auto& [key, value] : line) {
                if (count==0) {
                    start = value;
                }
                count+=value;

                if (count == 0) {
                    res.push_back({start, value});
                }
            }
            return res;
        }
    };
\end{cppcode}
\bigbreak \noindent 
For every interval [start, end] in the input:
\begin{itemize}
    ++line[e[0]]; increments the count at the start point.
    --line[e[1]]; decrements the count at the end point.
\end{itemize}
\bigbreak \noindent 
This records "events" along the number line: a positive event when an interval begins and a negative event when an interval ends. The map keeps these events in sorted order by key (the coordinate).
\begin{itemize}
    \item \textbf{count:} Tracks how many intervals are currently active as we sweep through the line.
    \item \textbf{ans:} Will store the resulting merged intervals.
    \item \textbf{start:} Used to mark the beginning of a new merged interval.
\end{itemize}
\bigbreak \noindent 
The for loop goes through each key-value pair in the map line in ascending order of the coordinate (since map is sorted by keys).
\bigbreak \noindent 
When count is 0 before processing an event, this indicates that no interval is active at that moment. The code then sets start to the current coordinate (i.first), which will be the beginning of a new merged interval.
\bigbreak \noindent 
count += i.second; adjusts the active interval count based on the event at that coordinate.
\bigbreak \noindent 
A positive count means one or more intervals are active, while a count returning to 0 means all intervals that started have now ended.
\bigbreak \noindent 
When count becomes 0, it indicates that a merged interval has ended at the current coordinate.
\bigbreak \noindent 
The code then pushes the interval [start, i.first] into ans.



    \pagebreak 
    \unsect{Bitwise operations (and tricks)}
    \subsection{Bitwise power of two}
    \bigbreak \noindent 
    To check if a positive integer $n$ is a power of two. That is, $n = 2^{x}$ for some $x\in\mathbb{N}$, we check
    \bigbreak \noindent 
    \begin{cppcode}
        if (n & n-1 == 0) {
            // n is a power of two
        }
    \end{cppcode}
    \bigbreak \noindent 
    If $n$ is a power of two, it can be written as $2^{k}$ . Its binary form will have a single '1' followed by $k$ zeros
    \bigbreak \noindent 
    When you subtract 1 from a power of two, the binary representation becomes a sequence of $k$ ones.
    \bigbreak \noindent 
    Consider $1000 - 0001$. We can convert $0001$ to its twos complement representation, and change the subtraction to addition. $0001$ in its two complement representation is $1110$. Thus, we have
    \begin{align*}
        \begin{array}{ccccc} &1&0&0&0 \\ -&0&0&0&1 \\ \hline \end{array} = \begin{array}{ccccc} 1 & 0 & & & \\ & 1 & 0 & 0 & 0 \\ +&1&1&1&1 \\ \hline &0&1&1&1 \end{array}
    \end{align*}
    \bigbreak \noindent 
    The operation $n\&(n-1)$ compares each bit of $n$ and $n-1$. Since $n$ has a single '1' in a position where $n-1$ has a '0' (and vice versa for all lower bits), none of the corresponding bits are '1' at the same time. Therefore, the result is 0.
    \bigbreak \noindent 
    If $n $ is not a power of two, its binary representation will have more than one '1'. Subtracting 1 will not clear all the '1' bits when you perform the AND operation, so the result will be non-zero.
    \bigbreak \noindent 
    If $n =0$, $n \& (n-1)$ will be zero, but $0$ is not a power of two, so we require $n >0$.

    \subsection{Bitwise parity check}
    \bigbreak \noindent 
    We can check the parity of a number by observing if the rightmost bit is set. If the rightmost bit is one, then the number is odd, if its zero, then the number is even.
    \bigbreak \noindent 
    \begin{cppcode}
        bool parity(int n) {
            // Equivalent result: return n % 2
            return n & 1;
        }
    \end{cppcode}
    \bigbreak \noindent 
    As an example, consider $4\ \&\ 1$... That is, $0100\ \&\ 0001$, we see
    \begin{align*}
        \begin{array}{ccccc}
           &0&1&0&0 \\
           &0&0&0&1 \\
           \hline
            \& & 0 &0&0&0
        \end{array}
    .\end{align*}
    And for $4\ \& \ 1 = 0101\ \& \ 0001$, we have
    \begin{align*}
        \begin{array}{ccccc}
           & 0&1&0&1 \\
           &0&0&0&1 \\
           \hline 
            \& & 0 & 0 & 0& 1
        \end{array}
    .\end{align*}

    \bigbreak \noindent 
    \subsection{Bitwise divide and multiply by two}
    \bigbreak \noindent 
    For this we can use left and right shifts (by one). To multiply a number by 2, we shift left by one. For a divide by two, we shift right by one
    \bigbreak \noindent 
    \begin{cppcode}
    int x = 50
    cout << (x << 1) << endl; // 100
    cout << (x >> 1) << endl; // 25
    \end{cppcode}

    \pagebreak 
    \unsect{Math related things}
    \bigbreak \noindent 
    \subsection{Floors and Ceils}
    \bigbreak \noindent 
    \subsubsection{Defining the notation}
    \bigbreak \noindent 
    We have
    \begin{align*}
        \lfloor x \rfloor &= \text{Max}\{n:\ n\in \mathbb{Z},\ n \leq x \} \\
        \lceil x \rceil  &= \text{Min}\{n:\ n \in \mathbb{Z},\ n \geq x\}
    .\end{align*}
    \bigbreak \noindent 
    \subsubsection{Equating ceils and floors}
    \bigbreak \noindent 
    We two integers $a,b$, we have the property
    \begin{align*}
        \left\lceil \frac{a}{b} \right\rceil = \left\lfloor \frac{a+b-1}{b} \right\rfloor
    .\end{align*}
    \bigbreak \noindent 
    We have that
    \begin{align*}
        a = bq + r \quad 0 \leq r < b
    .\end{align*}
    where $q$ is the integer quotient $q = \right\lfloor \frac{a}{b} \right\rfloor$ and $r$ is the remainder
    \bigbreak \noindent 
    The ceil $ \left\lceil \frac{a}{b} \right\rceil $ is therefore
    \begin{align*}
        \left\lceil \frac{a}{b} \right\rceil = \begin{cases}
            q & \text{ if } r=0 \\
            q +1 & \text{ if } r>0
        \end{cases}
    .\end{align*}
    To ensure that we round up when there is a nonzero remainder, we add $b-1$ to $a$, this yields
    \begin{align*}
        a + b-1 = bq + r + b-1 = b(q+1) + (r-1)
    .\end{align*}
    So, if $r = 0$, we have that
    \begin{align*}
    \left\lfloor a+b-1 \right\rfloor &= \left\lfloor b(q+1) - 1 \right\rfloor \\
\implies \left\lfloor \frac{a+b-1}{b} \right\rfloor &= \left\lfloor  q+1 -\frac{1}{b}\right\rfloor \\
                                                     &= \left\lfloor  q + \frac{b-1}{b} \right\rfloor
    .\end{align*}
    Since $\frac{b-1}{b} < 1$, so
    \begin{align*}
        \left\lfloor \frac{a+b-1}{b} \right\rfloor &= q
    .\end{align*}
    \bigbreak \noindent 
    When $r > 0$, we have
    \begin{align*}
        \left\lfloor a+b-1 \right\rfloor &= \left\lfloor  b(q+1) + (r-1) \right\rfloor \\
        \implies \left\lfloor \frac{a+b-1}{b} \right\rfloor &= \left\lfloor q+1 + \frac{r-1}{b}  \right\rfloor
    .\end{align*}
    and since $0 < r < b$, $ \frac{r-1}{b} < 1 $, so
    \begin{align*}
        \left\lfloor \frac{a+b-1}{b} \right\rfloor &= q + 1
    .\end{align*}
    \bigbreak \noindent 
    So, we can use this property in algorithms to replace a call to a ceil function, and instead use integer division. Consider the following example, suppose we need to compute
    \begin{align*}
       \left\lceil \frac{n}{2} \right\rceil
    .\end{align*}
    Then, we have
    \begin{align*}
       \left\lceil \frac{n}{2} \right\rceil  = \left\lfloor \frac{n+2-1}{2} \right\rfloor = \left\lfloor \frac{n+1}{2} \right\rfloor
    .\end{align*}
    \bigbreak \noindent 
    \begin{cppcode}
    int n = 15 
    cout << ceil((double)n/2) << endl;
    cout << (n+1)/2 << endl; // Equivalent
    \end{cppcode}

    \bigbreak \noindent 
    \subsection{Another useful property}
    \bigbreak \noindent 
    For an integer $n$, we have that
    \begin{align*}
        \left\lfloor \frac{n}{2} \right\rfloor + \left\lceil \frac{n}{2} \right\rceil = n
    .\end{align*}
    \bigbreak \noindent 
    If $n$ even, then $n = 2k$ for some integer $k$, then
    \begin{align*}
        \left\lfloor \frac{n}{2} \right\rfloor + \left\lceil \frac{n}{2} \right\rceil &= \left\lfloor \frac{2k}{2} \right\rfloor + \left\lceil \frac{2k}{2} \right\rceil \\
        &= \left\lfloor k \right\rfloor + \left\lceil k \right\rceil = 2k = n
    .\end{align*}
    If $n$ is odd, then $ n = 2k+1$ for some integer $k$, and 
    \begin{align*}
        \left\lfloor \frac{n}{2} \right\rfloor + \left\lceil \frac{n}{2} \right\rceil &= \left\lfloor \frac{2k+1}{2} \right\rfloor + \left\lceil \frac{2k+1}{2} \right\rceil \\
                                                                                      &= \left\lfloor k + \frac{1}{2} \right\rfloor + \left\lceil k + \frac{1}{2} \right\rceil = k + (k+1) = 2k + 1  =n
    .\end{align*}
    Thus, 
    \begin{align*}
        \left\lceil \frac{n}{2} \right\rceil = n - \left\lfloor \frac{n}{2} \right\rfloor
    .\end{align*}
    \bigbreak \noindent 
    \begin{cppcode}
    int n = 25;
    cout << (ceil((double)n/2)) << endl;
    cout << (n - n/2) << endl; // Equivalent
    \end{cppcode}


    \pagebreak 
    \subsection{Counting}
    \bigbreak \noindent 
    \subsubsection{Counting number of subarrays}
    \bigbreak \noindent 
    Let $A = [a_{1}, a_{2}, a_{3},...,a_{n}] $, suppose we want to count the total number of possible contiguous subarrays. For example, if  $A = [1,2,3,4]$, then define $\omega$ to be the set of all subarrays. We have
    \begin{align*}
        \omega = \{[1],[2],[3],[4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], [1,2,3,4]\}
    .\end{align*}
    Thus, $\abs{\omega} = 10$. In general, we have that
    \begin{align*}
        \abs{\omega} = \sum_{i=1}^{n} (n-i+1) = \sum_{i=1}^{n} i = \frac{n(n+1)}{2}
    .\end{align*}
    If we include $\varnothing$ to be a valid subarray, then $\abs{\omega} = \frac{n(n+1)}{2} + 1$
    \bigbreak \noindent 
    For each subarray size $i$, starting from $1$ to $n$, we consider the number of starting points, but we must be able to include $i$ elements. Thus, the last element that can be a starting point for a subarray of size $i$ is at index $ n - i + 1$. Thus, there are $n-i+1$ valid subarrays of size $i$

    \bigbreak \noindent 
    \subsubsection{Counting number of subarrays with length a power of two}
    \bigbreak \noindent 
    Consider an array $A = [a_{1}, a_{2}, a_{3},...,a_{n}]$, let $\phi[i,j]$ be a subarray of $A$ with $ 0 \leq i \leq j \leq n$, suppose we want to count the number of subarrays such that the length $j-i + 1$ is a power of two.
    \bigbreak \noindent 
    So, for $ L = j-i+1$, we require that $L = 2^{\ell}$, for $\ell \in \mathbb{Z}^{+}$. We have that $2^{\ell}$ must satisfy
    \begin{align*}
        2^{\ell} \leq n \implies \ell \leq \lg n
    .\end{align*}
    So, by the logic in the previous subsection, we have that 
    \begin{align*}
    \left\lvert \omega \right\rvert     = \sum_{\ell = 0}^{\left\lfloor \lg n \right\rfloor} n - 2^{\ell} +1 = \Theta(n\lg n)
    .\end{align*}
    And, the number of subarrays with length a power of two is $O(\lg n)$, or more precisely $\Theta(\lg n) $.



\pagebreak 
\unsect{Math algorithms}
\bigbreak \noindent 
\subsection{Euclidean GCD Algorithm}
\bigbreak \noindent 
The GCD of two integers $a$ and $b$ (with $a \leq b$) is the largest integer that divides both $a$ and $b$. The Euclidean algorithm is based on the principle that
\begin{align*}
    \text{gcd}(a,b) = \text{gcd}(b, a\ \text{mod } b)
.\end{align*}
\bigbreak \noindent 
This means that the GCD of two numbers doesn't change if the larger number is replaced by its remainder when divided by the smaller number. You keep repeating this until the remainder is 0, and the GCD will be the last non-zero remainder
\bigbreak \noindent 
\begin{cppcode}
    int gcd(int a, int b)  {
        if (!b) return a;

        return gcd(b, a%b);
    }
    // An iterative approach
    int gcd(int a, int b ) {
        if (b < a) {
            b = std::exchange(a,b);
        }
        while (b != 0) {
            a = std::exchange(b, a % b);
        }
        return a;
    }
\end{cppcode}
\bigbreak \noindent 
\subsubsection{GCD of some integer collection}
\bigbreak \noindent 
We can apply the above algorithm to find the GCD of a collection of elements
\bigbreak \noindent 
\begin{cppcode}
    int gcd_set(const vector<int>& v) {
        if (v.empty()) return 0;
        int result = v[0];
        for (int i=1; i<(int)v.size(); ++i) {
            result = gcd(result, v[i]);
            // Return early
            if (result == 1) return result;
        }
        return result;
    }
\end{cppcode}

\bigbreak \noindent 
\subsection{Fibonacci numbers in constant time}
\bigbreak \noindent 
The formula for the $n$th Fibonacci number $F(n)$ can be derived using Binet's formula, which expresses the Fibonacci sequence in terms of powers of the golden ratio.
\begin{align*}
    F(n) = \frac{\phi^{n} - \psi^{n}}{\sqrt{5}}
.\end{align*}
Where $\phi$ is the golden ration $\frac{1+\sqrt{5}}{2} \approx 1.618 $, and $\psi$ is the conjugate of the golden ration $\psi = \frac{1- \sqrt{5}}{2} \approx -0.618 $

\bigbreak \noindent 
\subsection{Sterlings factorial approximation}
\bigbreak \noindent 
Stirling's Approximation provides an approximation for factorials, particularly useful for large values of $n$. The formula is:
\begin{align*}
    n! \approx  \sqrt{2\pi n}\left(\frac{n}{e}\right)^{n}
.\end{align*}

\bigbreak \noindent 
\subsection{square roots}
\bigbreak \noindent 
Given a non-negative integer $x$, return the square root of $x$ rounded down to the nearest integer. The returned integer should be non-negative as well.
\bigbreak \noindent 
\textbf{Note:} You must not use any built-in exponent function or operator.
\bigbreak \noindent 
\subsubsection{Naive $O(\sqrt{n})$}
\bigbreak \noindent 
\begin{cppcode}
    typedef long long dword; 
    class Solution {
        public:
        int mySqrt(int x) {
            dword last{};
            for (dword i=0; i<=x; ++i) {
                if (i*i == x) return i;
                else if (i*i > x) return last;
                last = i;
            }
            return 0;
        }
    };
\end{cppcode}
\bigbreak \noindent 
For each number $i \in [0,x]$, we simply check either the square of $i$ is precisely $x$, or $i^{2}> x$, in which case we return the value of $i$ before the current iteration.
\bigbreak \noindent 
This algorithm runs in $O(\sqrt{n})$ time because the for loop runs at most $\sqrt{x}$ times.
\bigbreak \noindent 
Note that we start $i$ at one and go up to including $x$ specifically to handle the case where $x=1$. If $x=0$, the for loop never runs and the default initialized dword gets returned (which is correct)
\bigbreak \noindent 
\subsubsection{$O(\lg(n))$ binary search approach}
\bigbreak \noindent 
\begin{cppcode}
    typedef long long dword;
    class Solution {
        public:
        int mySqrt(int x) {
            dword start{}, end = x, mid, res;
            while (start <= end) {
                mid = (start + end) / 2;

                if (mid * mid > x) {
                    end = mid-1;
                } else if (mid * mid < x) {
                    start = mid + 1;
                    res = mid;
                } else {
                    return mid;
                }
            }
            return res;
        }
    };
\end{cppcode}

\pagebreak 
\subsection{Fast exponentiation ($O(\lg(n))$)}
\bigbreak \noindent 
To perform exponentiation faster than $O(n)$, use Exponentiation by Squaring, which runs in $O(logn)$ time.
\bigbreak \noindent 
This method efficiently computes $a^{b}$ using the following rules:
\begin{enumerate}
    \item If $b$ is even
        \begin{align*}
            a^{b} = \left(a^{\frac{b}{2}}\right)^{2} = \left(a^{2}\right)^{\frac{b}{2}}
        \end{align*}
    \item If $b$ is odd
        \begin{align*}
            a^{b} = a \cdot a^{b-1}
        \end{align*}
\end{enumerate}
\bigbreak \noindent 
\begin{cppcode}
    long long fastExponentation(long long a, long long b) {
        long long result = 1;
        while (b > 0) {
            if (b % 2 == 1) {
            result *= a;
        } 
        a*=a;
        b/=2;
    }
    return result;
}
\end{cppcode}

\bigbreak \noindent 
\subsubsection{Recursive}
\bigbreak \noindent 
\begin{cppcode}
    class Solution {
        public:
        double r_fe(double& x, long long& n, double& res) {
            if (n <= 0) return res;

            if (n%2 == 1) {
            res*=x;
            --n;
        }
        n/=2;
        x*=x;

        return r_fe(x,n,res);
    }

    double myPow(double x, long long n) {
        double res{1.0};
        if (n < 0) {
            n = -n;
            return 1 / r_fe(x,n,res);
        }
        return r_fe(x,n,res);
    }
};
\end{cppcode}

\pagebreak 
\subsection{Fast modular exponentiation}
\bigbreak \noindent 
Fast modular exponentiation, also known as binary exponentiation or exponentiation by squaring, is an algorithm used to efficiently compute $a^{b} \mod m $ without directly calculating $a^{b}$ (which can be very large)
\bigbreak \noindent 
It works similar to the \textit{fast exponentiation} algorithm above, but takes mods along the way.
\bigbreak \noindent 
\begin{cppcode}
    #define ll long long
    ll modExp(ll a, ll b, ll mod) {
        ll result = 1;
        a %= mod;
        while (b > 0) {
            if (b & 1)
            result = (result * a) % mod;
            a = (a * a) % mod;
            b >>= 1;
        }
        return result;
    }
\end{cppcode}


\pagebreak 
\unsect{Number Theory}
\bigbreak \noindent 

\subsection{Getting prime factors of a number}
\bigbreak \noindent 
\begin{cppcode}
    vector<int> prime_factors(int n) {
        vector<int> factors;
        for (int i=2; i<=sqrt(n); ++i) {
            if (n % i == 0) {
            while (n%i == 0) {
            factors.push_back(i);
            n/=i;
        }
    }
}
// If n was originally prime, it has no prime factors other than 1 and itself.
if (n >= 2) factors.push_back(n);
return factors;
}


int main(int argc, const char** argv) {
    vector<int> res = prime_factors(16);
    cout << res[0];
    for (int i=1; i<(int)res.size();++i) cout << "*" << res[i]; 

    return EXIT_SUCCESS;
}
\end{cppcode}
\bigbreak \noindent 
The algorithm works by testing every possible factor starting at 2 and moving upward. When it finds a number $i$ that divides $n$, it repeatedly divides $n$ by $i$ until $i$ no longer divides it. Because it starts with the smallest numbers (which are prime), any composite number would already have been broken down into its prime components. In other words, if a composite factor divides $n$, one of its smaller prime factors would have divided $n$ first and removed that component. Thus, only prime factors remain to be printed.






\end{document}
