\contentsline {section}{\numberline {1}The C++ Language}{18}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Key Features}{18}{subsection.0.1.1}%
\contentsline {section}{\numberline {2}The Compiler}{20}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}Preprocessing}{20}{subsection.0.2.1}%
\contentsline {subsection}{\numberline {2.2}Lexical Analysis}{20}{subsection.0.2.2}%
\contentsline {subsection}{\numberline {2.3}Syntax Analysis}{20}{subsection.0.2.3}%
\contentsline {subsection}{\numberline {2.4}Semantic Analysis}{20}{subsection.0.2.4}%
\contentsline {subsection}{\numberline {2.5}Intermediate Code Generation}{20}{subsection.0.2.5}%
\contentsline {subsection}{\numberline {2.6}Code Optimization}{21}{subsection.0.2.6}%
\contentsline {subsection}{\numberline {2.7}Code Generation}{21}{subsection.0.2.7}%
\contentsline {subsection}{\numberline {2.8}Assembling}{21}{subsection.0.2.8}%
\contentsline {subsection}{\numberline {2.9}Linking}{21}{subsection.0.2.9}%
\contentsline {subsection}{\numberline {2.10}Complier Options}{21}{subsection.0.2.10}%
\contentsline {subsection}{\numberline {2.11}Header Files}{22}{subsection.0.2.11}%
\contentsline {section}{\numberline {3}Preliminaries: A Quick Tour of C++ Fundamentals}{23}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Boilerplate}{23}{subsection.0.3.1}%
\contentsline {subsection}{\numberline {3.2}The main function}{23}{subsection.0.3.2}%
\contentsline {subsection}{\numberline {3.3}Comments}{23}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Data Types, Modifiers, Qualifiers, Inference}{25}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}Primitive Type Ranges and Size}{26}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}Creating strings without the STL}{27}{subsection.0.3.6}%
\contentsline {subsection}{\numberline {3.7}Retrieve size}{28}{subsection.0.3.7}%
\contentsline {subsection}{\numberline {3.8}Retrieve type}{28}{subsection.0.3.8}%
\contentsline {subsection}{\numberline {3.9}Exponential Notation}{29}{subsection.0.3.9}%
\contentsline {subsection}{\numberline {3.10}Type Conversion}{29}{subsection.0.3.10}%
\contentsline {subsection}{\numberline {3.11}Integer Division}{30}{subsection.0.3.11}%
\contentsline {subsection}{\numberline {3.12}Overflow/Underflow}{30}{subsection.0.3.12}%
\contentsline {subsection}{\numberline {3.13}Type Casting}{30}{subsection.0.3.13}%
\contentsline {subsection}{\numberline {3.14}C-style Casts}{31}{subsection.0.3.14}%
\contentsline {subsection}{\numberline {3.15}The Using Directive}{32}{subsection.0.3.15}%
\contentsline {subsection}{\numberline {3.16}Variable Declaration}{33}{subsection.0.3.16}%
\contentsline {subsection}{\numberline {3.17}Multiple Declaration}{33}{subsection.0.3.17}%
\contentsline {subsection}{\numberline {3.18}Initialization}{33}{subsection.0.3.18}%
\contentsline {subsection}{\numberline {3.19}Multiple Initialization}{33}{subsection.0.3.19}%
\contentsline {subsection}{\numberline {3.20}Direct Initialization}{34}{subsection.0.3.20}%
\contentsline {subsection}{\numberline {3.21}List Initialization}{34}{subsection.0.3.21}%
\contentsline {subsection}{\numberline {3.22}Copy Initialization}{34}{subsection.0.3.22}%
\contentsline {subsection}{\numberline {3.23}Assignment}{34}{subsection.0.3.23}%
\contentsline {subsection}{\numberline {3.24}Multiple Assignment}{35}{subsection.0.3.24}%
\contentsline {section}{\numberline {4}Symbols}{36}{section.0.4}%
\contentsline {subsection}{\numberline {4.1}Parentheses}{36}{subsection.0.4.1}%
\contentsline {subsection}{\numberline {4.2}Brackets}{36}{subsection.0.4.2}%
\contentsline {subsection}{\numberline {4.3}Braces}{36}{subsection.0.4.3}%
\contentsline {subsection}{\numberline {4.4}Angle Brackets}{36}{subsection.0.4.4}%
\contentsline {subsection}{\numberline {4.5}Semi Colon}{36}{subsection.0.4.5}%
\contentsline {subsection}{\numberline {4.6}Colon}{36}{subsection.0.4.6}%
\contentsline {subsection}{\numberline {4.7}Comma}{37}{subsection.0.4.7}%
\contentsline {subsection}{\numberline {4.8}Ellipsis}{37}{subsection.0.4.8}%
\contentsline {subsection}{\numberline {4.9}Hash}{37}{subsection.0.4.9}%
\contentsline {section}{\numberline {5}Preprocessor Directives}{38}{section.0.5}%
\contentsline {subsection}{\numberline {5.1}\#include}{38}{subsection.0.5.1}%
\contentsline {subsection}{\numberline {5.2}\#define}{38}{subsection.0.5.2}%
\contentsline {subsection}{\numberline {5.3}\#undef}{38}{subsection.0.5.3}%
\contentsline {subsection}{\numberline {5.4}\#ifdef, \#ifndef, \#else, \#elif, \#endif}{38}{subsection.0.5.4}%
\contentsline {subsection}{\numberline {5.5}\#if}{39}{subsection.0.5.5}%
\contentsline {subsection}{\numberline {5.6}\#pragma}{39}{subsection.0.5.6}%
\contentsline {subsection}{\numberline {5.7}\#error}{39}{subsection.0.5.7}%
\contentsline {subsection}{\numberline {5.8}\#line}{39}{subsection.0.5.8}%
\contentsline {section}{\numberline {6}Input/Output}{40}{section.0.6}%
\contentsline {subsection}{\numberline {6.1}iostream}{40}{subsection.0.6.1}%
\contentsline {subsection}{\numberline {6.2}Output}{40}{subsection.0.6.2}%
\contentsline {subsection}{\numberline {6.3}Input}{40}{subsection.0.6.3}%
\contentsline {subsection}{\numberline {6.4}IO Manipulators}{42}{subsection.0.6.4}%
\contentsline {subsection}{\numberline {6.5}std::setiosflags}{44}{subsection.0.6.5}%
\contentsline {subsection}{\numberline {6.6}Escape Sequences}{44}{subsection.0.6.6}%
\contentsline {subsection}{\numberline {6.7}User Input With Strings}{45}{subsection.0.6.7}%
\contentsline {subsection}{\numberline {6.8}User input with characters}{46}{subsection.0.6.8}%
\contentsline {subsection}{\numberline {6.9}Mixing cin and cin.get}{46}{subsection.0.6.9}%
\contentsline {subsection}{\numberline {6.10}Ingnore the rest of the line}{47}{subsection.0.6.10}%
\contentsline {subsubsection}{\numberline {6.10.1}Numeric limits}{47}{subsubsection.0.6.10.1}%
\contentsline {subsubsection}{\numberline {6.10.2}streamsize}{47}{subsubsection.0.6.10.2}%
\contentsline {subsubsection}{\numberline {6.10.3}max}{48}{subsubsection.0.6.10.3}%
\contentsline {section}{\numberline {7}Redirecting file to program (./program < file)}{49}{section.0.7}%
\contentsline {subsection}{\numberline {7.1}Passing cin to a function}{49}{subsection.0.7.1}%
\contentsline {section}{\numberline {8}Operators}{51}{section.0.8}%
\contentsline {subsection}{\numberline {8.1}Arithmetic Operators}{51}{subsection.0.8.1}%
\contentsline {subsection}{\numberline {8.2}Relational Operators}{51}{subsection.0.8.2}%
\contentsline {subsection}{\numberline {8.3}Logical Operators}{51}{subsection.0.8.3}%
\contentsline {subsection}{\numberline {8.4}Bitwise Operators}{51}{subsection.0.8.4}%
\contentsline {subsection}{\numberline {8.5}Assignment Operators}{51}{subsection.0.8.5}%
\contentsline {subsection}{\numberline {8.6}Increment and Decrement Operators}{51}{subsection.0.8.6}%
\contentsline {subsection}{\numberline {8.7}Pointers and References}{51}{subsection.0.8.7}%
\contentsline {subsection}{\numberline {8.8}Scope Resolution Operator}{51}{subsection.0.8.8}%
\contentsline {section}{\numberline {9}Random Numbers}{53}{section.0.9}%
\contentsline {section}{\numberline {10}Conditionals (Decision Structure)}{54}{section.0.10}%
\contentsline {subsection}{\numberline {10.1}Decision Structure Flowchart}{55}{subsection.0.10.1}%
\contentsline {subsection}{\numberline {10.2}The Conditional Operator (Ternary)}{55}{subsection.0.10.2}%
\contentsline {subsection}{\numberline {10.3}Switch}{56}{subsection.0.10.3}%
\contentsline {section}{\numberline {11}The While Loop}{58}{section.0.11}%
\contentsline {section}{\numberline {12}The Do-While Loop}{59}{section.0.12}%
\contentsline {section}{\numberline {13}The for loop}{60}{section.0.13}%
\contentsline {section}{\numberline {14}Using Files for Data Storage}{61}{section.0.14}%
\contentsline {subsection}{\numberline {14.1}File Access Methods}{61}{subsection.0.14.1}%
\contentsline {subsection}{\numberline {14.2}Setting up a program for file input/output}{61}{subsection.0.14.2}%
\contentsline {subsection}{\numberline {14.3}File Stream Objects}{61}{subsection.0.14.3}%
\contentsline {subsection}{\numberline {14.4}Creating a file object and opening a file}{62}{subsection.0.14.4}%
\contentsline {subsection}{\numberline {14.5}Closing a file}{63}{subsection.0.14.5}%
\contentsline {subsection}{\numberline {14.6}Reading from a file with an unknown number of lines}{64}{subsection.0.14.6}%
\contentsline {subsection}{\numberline {14.7}Testing for file open errors}{64}{subsection.0.14.7}%
\contentsline {section}{\numberline {15}rvalues and lvalues}{65}{section.0.15}%
\contentsline {subsection}{\numberline {15.1}rvalue (right value):}{65}{subsection.0.15.1}%
\contentsline {subsection}{\numberline {15.2}lvalue}{65}{subsection.0.15.2}%
\contentsline {section}{\numberline {16}Breaking and Continuing a loop}{66}{section.0.16}%
\contentsline {section}{\numberline {17}Functions}{67}{section.0.17}%
\contentsline {subsection}{\numberline {17.1}Function prototypes (function declarations)}{67}{subsection.0.17.1}%
\contentsline {subsection}{\numberline {17.2}Static locals}{68}{subsection.0.17.2}%
\contentsline {subsection}{\numberline {17.3}PREREQ - Reference variables}{68}{subsection.0.17.3}%
\contentsline {subsection}{\numberline {17.4}Using reference variables as parameters}{69}{subsection.0.17.4}%
\contentsline {subsection}{\numberline {17.5}Overloading Functions}{70}{subsection.0.17.5}%
\contentsline {subsection}{\numberline {17.6}The exit() function}{70}{subsection.0.17.6}%
\contentsline {subsection}{\numberline {17.7}Stubs and Drivers}{71}{subsection.0.17.7}%
\contentsline {section}{\numberline {18}Arrays and Vectors}{72}{section.0.18}%
\contentsline {subsection}{\numberline {18.1}Arrays}{72}{subsection.0.18.1}%
\contentsline {subsection}{\numberline {18.2}Partial array initialization}{72}{subsection.0.18.2}%
\contentsline {subsection}{\numberline {18.3}Implicit array sizing}{72}{subsection.0.18.3}%
\contentsline {subsection}{\numberline {18.4}Bound violation}{72}{subsection.0.18.4}%
\contentsline {subsection}{\numberline {18.5}The range based for loop}{73}{subsection.0.18.5}%
\contentsline {subsection}{\numberline {18.6}Modifying an array with a range-based for loop}{73}{subsection.0.18.6}%
\contentsline {subsection}{\numberline {18.7}Thou shall not assign}{73}{subsection.0.18.7}%
\contentsline {subsection}{\numberline {18.8}Getting the size of an array}{74}{subsection.0.18.8}%
\contentsline {subsection}{\numberline {18.9}Arrays as function arguments}{74}{subsection.0.18.9}%
\contentsline {subsection}{\numberline {18.10}2D array (matrix)}{76}{subsection.0.18.10}%
\contentsline {subsection}{\numberline {18.11}Passing a matrix to a function}{77}{subsection.0.18.11}%
\contentsline {subsection}{\numberline {18.12}The STL Vector}{78}{subsection.0.18.12}%
\contentsline {subsection}{\numberline {18.13}Defining a vector}{78}{subsection.0.18.13}%
\contentsline {subsection}{\numberline {18.14}Get index position of elements}{78}{subsection.0.18.14}%
\contentsline {subsection}{\numberline {18.15}Adding to a vector}{79}{subsection.0.18.15}%
\contentsline {subsection}{\numberline {18.16}Getting the size of a vector}{79}{subsection.0.18.16}%
\contentsline {subsection}{\numberline {18.17}Removing last element of a vector}{79}{subsection.0.18.17}%
\contentsline {subsection}{\numberline {18.18}Removing elements of a vector }{79}{subsection.0.18.18}%
\contentsline {subsection}{\numberline {18.19}Clearing a vector}{80}{subsection.0.18.19}%
\contentsline {subsection}{\numberline {18.20}Detecting an Empty vector}{80}{subsection.0.18.20}%
\contentsline {subsection}{\numberline {18.21}Resizing a vector}{80}{subsection.0.18.21}%
\contentsline {subsection}{\numberline {18.22}Swapping Vectors}{80}{subsection.0.18.22}%
\contentsline {section}{\numberline {19}Searching and Sorting Arrays}{81}{section.0.19}%
\contentsline {subsection}{\numberline {19.1}The linear search}{81}{subsection.0.19.1}%
\contentsline {subsection}{\numberline {19.2}The binary search}{82}{subsection.0.19.2}%
\contentsline {subsection}{\numberline {19.3}Bubble Sort}{83}{subsection.0.19.3}%
\contentsline {subsection}{\numberline {19.4}Selection Sort}{83}{subsection.0.19.4}%
\contentsline {section}{\numberline {20}Pointers}{86}{section.0.20}%
\contentsline {subsection}{\numberline {20.1}Nullptr}{86}{subsection.0.20.1}%
\contentsline {subsection}{\numberline {20.2}Arrays as pointers}{87}{subsection.0.20.2}%
\contentsline {subsection}{\numberline {20.3}Pointers as Function Parameters}{88}{subsection.0.20.3}%
\contentsline {subsection}{\numberline {20.4}Pointers to constants}{88}{subsection.0.20.4}%
\contentsline {subsection}{\numberline {20.5}Constant Pointers}{89}{subsection.0.20.5}%
\contentsline {subsection}{\numberline {20.6}Both pointer to constant and constant pointer}{89}{subsection.0.20.6}%
\contentsline {subsection}{\numberline {20.7}Prereq - Static vs Dynamic memory allocation}{89}{subsection.0.20.7}%
\contentsline {subsection}{\numberline {20.8}Dynamic Memory Allocation}{90}{subsection.0.20.8}%
\contentsline {subsection}{\numberline {20.9}When to use DMA}{91}{subsection.0.20.9}%
\contentsline {subsection}{\numberline {20.10}Returning pointers from a function}{91}{subsection.0.20.10}%
\contentsline {subsection}{\numberline {20.11}Smart Pointers}{92}{subsection.0.20.11}%
\contentsline {section}{\numberline {21}Characters, C-Strings and more about the string class}{94}{section.0.21}%
\contentsline {subsection}{\numberline {21.1}Character Testing}{94}{subsection.0.21.1}%
\contentsline {subsection}{\numberline {21.2}Character case conversion}{94}{subsection.0.21.2}%
\contentsline {subsection}{\numberline {21.3}C Strings }{94}{subsection.0.21.3}%
\contentsline {subsection}{\numberline {21.4}C-Strings stored in arrays}{95}{subsection.0.21.4}%
\contentsline {subsection}{\numberline {21.5}The Strlen function}{95}{subsection.0.21.5}%
\contentsline {subsection}{\numberline {21.6}The strcat Function}{96}{subsection.0.21.6}%
\contentsline {subsection}{\numberline {21.7}The Strcopy function}{96}{subsection.0.21.7}%
\contentsline {subsection}{\numberline {21.8}The strncat and strncpy functions}{97}{subsection.0.21.8}%
\contentsline {subsection}{\numberline {21.9}The strstr function}{97}{subsection.0.21.9}%
\contentsline {subsection}{\numberline {21.10}The strcmp function}{98}{subsection.0.21.10}%
\contentsline {subsection}{\numberline {21.11}String/Numeric Conversion Functions}{98}{subsection.0.21.11}%
\contentsline {subsection}{\numberline {21.12}More on the C++ string (string object)}{99}{subsection.0.21.12}%
\contentsline {subsection}{\numberline {21.13}C++ String definitions}{99}{subsection.0.21.13}%
\contentsline {subsection}{\numberline {21.14}C++ string supported operators}{99}{subsection.0.21.14}%
\contentsline {section}{\numberline {22}Type Punning}{100}{section.0.22}%
\contentsline {section}{\numberline {23}Structures}{102}{section.0.23}%
\contentsline {subsection}{\numberline {23.1}Abstraction}{102}{subsection.0.23.1}%
\contentsline {subsection}{\numberline {23.2}Abstract data types}{102}{subsection.0.23.2}%
\contentsline {subsection}{\numberline {23.3}Structures}{102}{subsection.0.23.3}%
\contentsline {subsection}{\numberline {23.4}Accessing structure members}{103}{subsection.0.23.4}%
\contentsline {subsection}{\numberline {23.5}Initializing a structure (Initialization list)}{103}{subsection.0.23.5}%
\contentsline {subsection}{\numberline {23.6}Arrays of structures}{104}{subsection.0.23.6}%
\contentsline {subsection}{\numberline {23.7}Initializing a structure array}{104}{subsection.0.23.7}%
\contentsline {subsection}{\numberline {23.8}Nested Structures}{105}{subsection.0.23.8}%
\contentsline {subsection}{\numberline {23.9}Structures as function arguments}{105}{subsection.0.23.9}%
\contentsline {subsection}{\numberline {23.10}Constant reference parameters}{106}{subsection.0.23.10}%
\contentsline {subsection}{\numberline {23.11}Returning a structure from a function}{106}{subsection.0.23.11}%
\contentsline {subsection}{\numberline {23.12}Pointers to structures}{107}{subsection.0.23.12}%
\contentsline {subsection}{\numberline {23.13}Dynamically allocating a structure}{107}{subsection.0.23.13}%
\contentsline {section}{\numberline {24}Enumerated data types}{108}{section.0.24}%
\contentsline {subsection}{\numberline {24.1}General Syntax}{108}{subsection.0.24.1}%
\contentsline {subsection}{\numberline {24.2}Example}{108}{subsection.0.24.2}%
\contentsline {subsection}{\numberline {24.3}Basic Concepts}{108}{subsection.0.24.3}%
\contentsline {subsection}{\numberline {24.4}Assigning an integer to an enumerator}{109}{subsection.0.24.4}%
\contentsline {subsection}{\numberline {24.5}Assigning an enumerator to an int variable}{109}{subsection.0.24.5}%
\contentsline {subsection}{\numberline {24.6}Using math operators to change the value of an enum variable}{109}{subsection.0.24.6}%
\contentsline {subsection}{\numberline {24.7}Specifying values in enumerators}{110}{subsection.0.24.7}%
\contentsline {subsection}{\numberline {24.8}Changing the type}{110}{subsection.0.24.8}%
\contentsline {subsection}{\numberline {24.9}Quick instantiation}{110}{subsection.0.24.9}%
\contentsline {subsection}{\numberline {24.10}Strongly typed enums}{111}{subsection.0.24.10}%
\contentsline {section}{\numberline {25}Unions}{112}{section.0.25}%
\contentsline {subsection}{\numberline {25.1}Propertys}{112}{subsection.0.25.1}%
\contentsline {subsection}{\numberline {25.2}Example}{112}{subsection.0.25.2}%
\contentsline {subsubsection}{\numberline {25.2.1}Assigning Values}{112}{subsubsection.0.25.2.1}%
\contentsline {subsubsection}{\numberline {25.2.2}Accessing Values}{112}{subsubsection.0.25.2.2}%
\contentsline {subsection}{\numberline {25.3}Use Cases}{113}{subsection.0.25.3}%
\contentsline {subsection}{\numberline {25.4}Important Points}{113}{subsection.0.25.4}%
\contentsline {subsection}{\numberline {25.5}Type punning with unions}{113}{subsection.0.25.5}%
\contentsline {section}{\numberline {26}String streams}{115}{section.0.26}%
\contentsline {subsection}{\numberline {26.1}Using istringstream}{115}{subsection.0.26.1}%
\contentsline {subsection}{\numberline {26.2}Using ostringstream}{115}{subsection.0.26.2}%
\contentsline {section}{\numberline {27}Advanced file operations}{117}{section.0.27}%
\contentsline {section}{\numberline {28}C++ Lambdas}{118}{section.0.28}%
\contentsline {subsection}{\numberline {28.1}Options for capturing}{118}{subsection.0.28.1}%
\contentsline {subsection}{\numberline {28.2}Why auto as lambda type}{120}{subsection.0.28.2}%
\contentsline {section}{\numberline {29}Fancy case syntax}{121}{section.0.29}%
\contentsline {section}{\numberline {30}Static globals}{121}{section.0.30}%
\contentsline {section}{\numberline {31}Classes (OOP Principles in C++)}{122}{section.0.31}%
\contentsline {subsection}{\numberline {31.1}Private and Public (access specifiers)}{122}{subsection.0.31.1}%
\contentsline {subsection}{\numberline {31.2}Protected}{123}{subsection.0.31.2}%
\contentsline {subsection}{\numberline {31.3}Constant member functions}{123}{subsection.0.31.3}%
\contentsline {subsection}{\numberline {31.4}The mutable keyword}{123}{subsection.0.31.4}%
\contentsline {subsection}{\numberline {31.5}The friend keyword for member functions}{124}{subsection.0.31.5}%
\contentsline {subsection}{\numberline {31.6}The friend keyword for classes}{124}{subsection.0.31.6}%
\contentsline {subsubsection}{\numberline {31.6.1}Example}{124}{subsubsection.0.31.6.1}%
\contentsline {subsection}{\numberline {31.7}Member function prototypes and definitions}{125}{subsection.0.31.7}%
\contentsline {subsection}{\numberline {31.8}Default Constructors}{126}{subsection.0.31.8}%
\contentsline {subsection}{\numberline {31.9}Parameterized Constructor}{126}{subsection.0.31.9}%
\contentsline {subsection}{\numberline {31.10}Copy Constructor}{126}{subsection.0.31.10}%
\contentsline {subsubsection}{\numberline {31.10.1}What invokes the copy constructor?}{127}{subsubsection.0.31.10.1}%
\contentsline {subsubsection}{\numberline {31.10.2}Assignment operator instead of copy constructor}{128}{subsubsection.0.31.10.2}%
\contentsline {subsubsection}{\numberline {31.10.3}Forcing the copy constructor with initialization lists}{128}{subsubsection.0.31.10.3}%
\contentsline {subsection}{\numberline {31.11}Constructor Overloading}{129}{subsection.0.31.11}%
\contentsline {subsection}{\numberline {31.12}Initialization Lists}{130}{subsection.0.31.12}%
\contentsline {subsection}{\numberline {31.13}Delegating Constructors}{130}{subsection.0.31.13}%
\contentsline {subsection}{\numberline {31.14}Explicit Constructors}{130}{subsection.0.31.14}%
\contentsline {subsection}{\numberline {31.15}Destructors}{132}{subsection.0.31.15}%
\contentsline {subsection}{\numberline {31.16}Default destructors}{132}{subsection.0.31.16}%
\contentsline {subsection}{\numberline {31.17}Accessors and Mutators}{132}{subsection.0.31.17}%
\contentsline {subsection}{\numberline {31.18}The "this" pointer}{134}{subsection.0.31.18}%
\contentsline {subsubsection}{\numberline {31.18.1}Returning this}{135}{subsubsection.0.31.18.1}%
\contentsline {subsubsection}{\numberline {31.18.2}Returning *this}{135}{subsubsection.0.31.18.2}%
\contentsline {subsection}{\numberline {31.19}Static Member Variables}{135}{subsection.0.31.19}%
\contentsline {subsubsection}{\numberline {31.19.1}Initialization}{135}{subsubsection.0.31.19.1}%
\contentsline {subsubsection}{\numberline {31.19.2}Access}{135}{subsubsection.0.31.19.2}%
\contentsline {subsubsection}{\numberline {31.19.3}Example}{135}{subsubsection.0.31.19.3}%
\contentsline {subsubsection}{\numberline {31.19.4}Static constant member variables}{136}{subsubsection.0.31.19.4}%
\contentsline {subsubsection}{\numberline {31.19.5}The 'inline' keyword}{136}{subsubsection.0.31.19.5}%
\contentsline {subsection}{\numberline {31.20}Static member function}{136}{subsection.0.31.20}%
\contentsline {subsubsection}{\numberline {31.20.1}Access}{136}{subsubsection.0.31.20.1}%
\contentsline {subsubsection}{\numberline {31.20.2}Restrictions}{136}{subsubsection.0.31.20.2}%
\contentsline {subsubsection}{\numberline {31.20.3}Example}{137}{subsubsection.0.31.20.3}%
\contentsline {subsubsection}{\numberline {31.20.4}Pragmatic Example}{138}{subsubsection.0.31.20.4}%
\contentsline {subsection}{\numberline {31.21}Memberwise assignment}{138}{subsection.0.31.21}%
\contentsline {subsection}{\numberline {31.22}Aggregation}{138}{subsection.0.31.22}%
\contentsline {subsection}{\numberline {31.23}Constant Objects}{138}{subsection.0.31.23}%
\contentsline {section}{\numberline {32}Operator Overloading}{139}{section.0.32}%
\contentsline {subsection}{\numberline {32.1}Overloading arithmetic operators}{139}{subsection.0.32.1}%
\contentsline {subsection}{\numberline {32.2}Overloading Stream Operators}{140}{subsection.0.32.2}%
\contentsline {subsection}{\numberline {32.3}Overloading Asssignment operator}{141}{subsection.0.32.3}%
\contentsline {subsection}{\numberline {32.4}Overloading Prefix}{141}{subsection.0.32.4}%
\contentsline {subsection}{\numberline {32.5}Overloading Postfix}{141}{subsection.0.32.5}%
\contentsline {subsection}{\numberline {32.6}Overloading Relational Operators}{142}{subsection.0.32.6}%
\contentsline {subsection}{\numberline {32.7}Overloading subscript operator}{142}{subsection.0.32.7}%
\contentsline {subsection}{\numberline {32.8}Overloading function call operator}{143}{subsection.0.32.8}%
\contentsline {subsection}{\numberline {32.9}Overloading dereference operator}{144}{subsection.0.32.9}%
\contentsline {subsection}{\numberline {32.10}Overloading arrow operator}{145}{subsection.0.32.10}%
\contentsline {subsection}{\numberline {32.11}Object Conversion}{146}{subsection.0.32.11}%
\contentsline {subsection}{\numberline {32.12}Aspects of an Operator That Cannot Be Changed by Operator Overloading}{146}{subsection.0.32.12}%
\contentsline {section}{\numberline {33}Class Inheritance}{147}{section.0.33}%
\contentsline {subsection}{\numberline {33.1}Access Specifiers}{148}{subsection.0.33.1}%
\contentsline {subsection}{\numberline {33.2}Constructors and Destructors}{149}{subsection.0.33.2}%
\contentsline {subsection}{\numberline {33.3}Virtual functions and the override keyword}{150}{subsection.0.33.3}%
\contentsline {subsection}{\numberline {33.4}Virtual Destructors}{150}{subsection.0.33.4}%
\contentsline {subsection}{\numberline {33.5}Polymorphism}{151}{subsection.0.33.5}%
\contentsline {subsection}{\numberline {33.6}Base class pointer to child class object}{152}{subsection.0.33.6}%
\contentsline {subsection}{\numberline {33.7}The Final keyword}{153}{subsection.0.33.7}%
\contentsline {section}{\numberline {34}Interface-Based Programming}{154}{section.0.34}%
\contentsline {subsection}{\numberline {34.1}Pure Abstract Classes in C++}{154}{subsection.0.34.1}%
\contentsline {subsection}{\numberline {34.2}Implementing Interfaces in C++}{154}{subsection.0.34.2}%
\contentsline {subsection}{\numberline {34.3}More on the concept of pure virtual functions}{155}{subsection.0.34.3}%
\contentsline {section}{\numberline {35}Separate files (Classes)}{156}{section.0.35}%
\contentsline {subsection}{\numberline {35.1}Class declaration in Header Files}{156}{subsection.0.35.1}%
\contentsline {subsection}{\numberline {35.2}Class Definition in Source Files}{156}{subsection.0.35.2}%
\contentsline {section}{\numberline {36}Rvalue references and move semantics}{157}{section.0.36}%
\contentsline {subsection}{\numberline {36.1}Rvalue references}{157}{subsection.0.36.1}%
\contentsline {subsection}{\numberline {36.2}Exception to binding references to literals}{157}{subsection.0.36.2}%
\contentsline {subsection}{\numberline {36.3}Creating a move constructor and std::move()}{159}{subsection.0.36.3}%
\contentsline {subsection}{\numberline {36.4}Move Operations and noexcept}{159}{subsection.0.36.4}%
\contentsline {subsection}{\numberline {36.5}More on std::move}{161}{subsection.0.36.5}%
\contentsline {subsubsection}{\numberline {36.5.1}Syntax}{161}{subsubsection.0.36.5.1}%
\contentsline {subsubsection}{\numberline {36.5.2}Move assignment operator}{161}{subsubsection.0.36.5.2}%
\contentsline {section}{\numberline {37}Iterators}{162}{section.0.37}%
\contentsline {subsection}{\numberline {37.1}Type of Iterators}{162}{subsection.0.37.1}%
\contentsline {subsection}{\numberline {37.2}Container Iterators}{163}{subsection.0.37.2}%
\contentsline {subsection}{\numberline {37.3}What about C-Array}{163}{subsection.0.37.3}%
\contentsline {subsection}{\numberline {37.4}Contiguous vs Non-Contiguous Memory}{164}{subsection.0.37.4}%
\contentsline {section}{\numberline {38}Other Containers}{165}{section.0.38}%
\contentsline {subsection}{\numberline {38.1}Allocation of containers}{165}{subsection.0.38.1}%
\contentsline {subsection}{\numberline {38.2}The std::array<T,n> <array>}{167}{subsection.0.38.2}%
\contentsline {subsection}{\numberline {38.3}The std::list <list>}{167}{subsection.0.38.3}%
\contentsline {subsection}{\numberline {38.4}Sets set<T, comp> <set>}{167}{subsection.0.38.4}%
\contentsline {subsection}{\numberline {38.5}Maps map<T,T, comp> <map>}{167}{subsection.0.38.5}%
\contentsline {section}{\numberline {39}Variadic Functions in C++ (Ellipsis)}{168}{section.0.39}%
\contentsline {section}{\numberline {40}std::function<type(args)> <functional>}{169}{section.0.40}%
\contentsline {section}{\numberline {41}Initializer List as function parameters}{170}{section.0.41}%
\contentsline {section}{\numberline {42}Functions as parameters}{171}{section.0.42}%
\contentsline {subsection}{\numberline {42.1}Function Pointers:}{171}{subsection.0.42.1}%
\contentsline {subsection}{\numberline {42.2}Regular function pointers}{172}{subsection.0.42.2}%
\contentsline {section}{\numberline {43}Typedefs}{173}{section.0.43}%
\contentsline {subsection}{\numberline {43.1}Basic Typedefs}{173}{subsection.0.43.1}%
\contentsline {subsubsection}{\numberline {43.1.1}Example}{173}{subsubsection.0.43.1.1}%
\contentsline {subsection}{\numberline {43.2}Applications of typedef in C++}{173}{subsection.0.43.2}%
\contentsline {subsection}{\numberline {43.3}Using typedef with arrays}{173}{subsection.0.43.3}%
\contentsline {subsubsection}{\numberline {43.3.1}Example}{173}{subsubsection.0.43.3.1}%
\contentsline {subsection}{\numberline {43.4}Using typedef with pointers}{174}{subsection.0.43.4}%
\contentsline {subsubsection}{\numberline {43.4.1}Example:}{174}{subsubsection.0.43.4.1}%
\contentsline {subsection}{\numberline {43.5}Using typedef with function pointers}{174}{subsection.0.43.5}%
\contentsline {subsubsection}{\numberline {43.5.1}Example}{174}{subsubsection.0.43.5.1}%
\contentsline {section}{\numberline {44}Buffers in C++}{175}{section.0.44}%
\contentsline {subsection}{\numberline {44.1}Types of buffers}{175}{subsection.0.44.1}%
\contentsline {subsubsection}{\numberline {44.1.1}Stack-based buffers}{175}{subsubsection.0.44.1.1}%
\contentsline {subsubsection}{\numberline {44.1.2}Heap-based Buffers}{175}{subsubsection.0.44.1.2}%
\contentsline {subsubsection}{\numberline {44.1.3}Standard Library Containers}{175}{subsubsection.0.44.1.3}%
\contentsline {subsection}{\numberline {44.2}Usage in IO Operations}{176}{subsection.0.44.2}%
\contentsline {subsection}{\numberline {44.3}Buffer Overflow}{176}{subsection.0.44.3}%
\contentsline {subsection}{\numberline {44.4}Buffer operations}{176}{subsection.0.44.4}%
\contentsline {section}{\numberline {45}The Stack, Heap, Code Segment (Text Segment), and Data Segment (static memory)}{177}{section.0.45}%
\contentsline {subsection}{\numberline {45.1}The Stack}{177}{subsection.0.45.1}%
\contentsline {subsubsection}{\numberline {45.1.1}The Call Stack}{177}{subsubsection.0.45.1.1}%
\contentsline {subsection}{\numberline {45.2}How Many Stacks are There Per Program?}{177}{subsection.0.45.2}%
\contentsline {subsection}{\numberline {45.3}Stack Memory Management}{178}{subsection.0.45.3}%
\contentsline {subsection}{\numberline {45.4}Stack Overflow}{178}{subsection.0.45.4}%
\contentsline {subsection}{\numberline {45.5}What Lives on The Stack?}{178}{subsection.0.45.5}%
\contentsline {subsection}{\numberline {45.6}The Heap}{180}{subsection.0.45.6}%
\contentsline {subsubsection}{\numberline {45.6.1}Characteristics of the Heap}{180}{subsubsection.0.45.6.1}%
\contentsline {subsubsection}{\numberline {45.6.2}Usage}{180}{subsubsection.0.45.6.2}%
\contentsline {subsubsection}{\numberline {45.6.3}Heap Allocatinos in Function Bodys}{181}{subsubsection.0.45.6.3}%
\contentsline {subsection}{\numberline {45.7}The Code Segment (Text Segment)}{181}{subsection.0.45.7}%
\contentsline {subsection}{\numberline {45.8}The Data Segment}{181}{subsection.0.45.8}%
\contentsline {subsubsection}{\numberline {45.8.1}Initialized Data Segment}{181}{subsubsection.0.45.8.1}%
\contentsline {subsubsection}{\numberline {45.8.2}Uninitialized Data Segment}{181}{subsubsection.0.45.8.2}%
\contentsline {section}{\numberline {46}More on Dynamic Memory Allocation}{182}{section.0.46}%
\contentsline {subsection}{\numberline {46.1}Before we Begin: Memory Leaks}{182}{subsection.0.46.1}%
\contentsline {subsubsection}{\numberline {46.1.1}How Memory Leaks Occur}{182}{subsubsection.0.46.1.1}%
\contentsline {subsection}{\numberline {46.2}Malloc}{182}{subsection.0.46.2}%
\contentsline {subsubsection}{\numberline {46.2.1}Signature}{182}{subsubsection.0.46.2.1}%
\contentsline {subsubsection}{\numberline {46.2.2}Example}{183}{subsubsection.0.46.2.2}%
\contentsline {subsubsection}{\numberline {46.2.3}Characteristics}{183}{subsubsection.0.46.2.3}%
\contentsline {subsubsection}{\numberline {46.2.4}Considerations}{183}{subsubsection.0.46.2.4}%
\contentsline {subsection}{\numberline {46.3}Calloc}{184}{subsection.0.46.3}%
\contentsline {subsubsection}{\numberline {46.3.1}Signature}{184}{subsubsection.0.46.3.1}%
\contentsline {subsubsection}{\numberline {46.3.2}Example}{184}{subsubsection.0.46.3.2}%
\contentsline {subsubsection}{\numberline {46.3.3}Differences from malloc}{184}{subsubsection.0.46.3.3}%
\contentsline {subsection}{\numberline {46.4}Realloc}{184}{subsection.0.46.4}%
\contentsline {subsubsection}{\numberline {46.4.1}Signature}{185}{subsubsection.0.46.4.1}%
\contentsline {subsubsection}{\numberline {46.4.2}Example}{185}{subsubsection.0.46.4.2}%
\contentsline {subsection}{\numberline {46.5}Free}{185}{subsection.0.46.5}%
\contentsline {subsubsection}{\numberline {46.5.1}Signature}{185}{subsubsection.0.46.5.1}%
\contentsline {subsection}{\numberline {46.6}New}{186}{subsection.0.46.6}%
\contentsline {subsubsection}{\numberline {46.6.1}Syntax}{186}{subsubsection.0.46.6.1}%
\contentsline {subsubsection}{\numberline {46.6.2}Array allocation}{186}{subsubsection.0.46.6.2}%
\contentsline {subsubsection}{\numberline {46.6.3}Custom Constructor Parameters}{186}{subsubsection.0.46.6.3}%
\contentsline {subsubsection}{\numberline {46.6.4}Exception Handling (std::nothrow)}{186}{subsubsection.0.46.6.4}%
\contentsline {subsubsection}{\numberline {46.6.5}Placement New}{187}{subsubsection.0.46.6.5}%
\contentsline {subsection}{\numberline {46.7}Delete}{187}{subsection.0.46.7}%
\contentsline {subsubsection}{\numberline {46.7.1}Syntax}{187}{subsubsection.0.46.7.1}%
\contentsline {subsection}{\numberline {46.8}Dangling Pointers}{188}{subsection.0.46.8}%
\contentsline {subsection}{\numberline {46.9}Overloading new and delete}{189}{subsection.0.46.9}%
\contentsline {subsubsection}{\numberline {46.9.1}Why static?}{189}{subsubsection.0.46.9.1}%
\contentsline {subsubsection}{\numberline {46.9.2}The size\_t parameter in the new overload}{190}{subsubsection.0.46.9.2}%
\contentsline {subsection}{\numberline {46.10}Getting the size of dynamically allocated memory?}{190}{subsection.0.46.10}%
\contentsline {subsection}{\numberline {46.11}Mixing Memory Management Mechanism}{190}{subsection.0.46.11}%
\contentsline {subsubsection}{\numberline {46.11.1}Why Mixing Them is Bad}{190}{subsubsection.0.46.11.1}%
\contentsline {subsection}{\numberline {46.12}Should you be using malloc, calloc, realloc, or free in C++?}{191}{subsection.0.46.12}%
\contentsline {subsubsection}{\numberline {46.12.1}Constructor and Destructor Calls}{191}{subsubsection.0.46.12.1}%
\contentsline {subsubsection}{\numberline {46.12.2}Type Safety}{191}{subsubsection.0.46.12.2}%
\contentsline {subsubsection}{\numberline {46.12.3}Exception Handling}{191}{subsubsection.0.46.12.3}%
\contentsline {section}{\numberline {47}Other Casting Operators}{192}{section.0.47}%
\contentsline {subsection}{\numberline {47.1}dynamic\_cast}{192}{subsection.0.47.1}%
\contentsline {subsubsection}{\numberline {47.1.1}Purpose}{192}{subsubsection.0.47.1.1}%
\contentsline {subsubsection}{\numberline {47.1.2}Syntax}{192}{subsubsection.0.47.1.2}%
\contentsline {subsubsection}{\numberline {47.1.3}Requirements}{192}{subsubsection.0.47.1.3}%
\contentsline {subsubsection}{\numberline {47.1.4}Example}{192}{subsubsection.0.47.1.4}%
\contentsline {subsection}{\numberline {47.2}const\_cast}{193}{subsection.0.47.2}%
\contentsline {subsubsection}{\numberline {47.2.1}Removing const}{193}{subsubsection.0.47.2.1}%
\contentsline {subsubsection}{\numberline {47.2.2}Adding const}{193}{subsubsection.0.47.2.2}%
\contentsline {subsubsection}{\numberline {47.2.3}Use cases}{193}{subsubsection.0.47.2.3}%
\contentsline {subsubsection}{\numberline {47.2.4}Important Points}{194}{subsubsection.0.47.2.4}%
\contentsline {subsubsection}{\numberline {47.2.5}Example}{194}{subsubsection.0.47.2.5}%
\contentsline {subsubsection}{\numberline {47.2.6}When is it unsafe to use}{194}{subsubsection.0.47.2.6}%
\contentsline {subsubsection}{\numberline {47.2.7}The volatile keyword}{194}{subsubsection.0.47.2.7}%
\contentsline {subsubsection}{\numberline {47.2.8}Purpose}{195}{subsubsection.0.47.2.8}%
\contentsline {subsection}{\numberline {47.3}reinterpret\_cast}{195}{subsection.0.47.3}%
\contentsline {subsubsection}{\numberline {47.3.1}Key Characteristics}{195}{subsubsection.0.47.3.1}%
\contentsline {subsubsection}{\numberline {47.3.2}Syntax}{195}{subsubsection.0.47.3.2}%
\contentsline {subsubsection}{\numberline {47.3.3}Example}{195}{subsubsection.0.47.3.3}%
\contentsline {subsubsection}{\numberline {47.3.4}Considerations}{196}{subsubsection.0.47.3.4}%
\contentsline {section}{\numberline {48}Namespaces}{197}{section.0.48}%
\contentsline {subsection}{\numberline {48.1}Syntax}{197}{subsection.0.48.1}%
\contentsline {subsection}{\numberline {48.2}Using Namespaces}{197}{subsection.0.48.2}%
\contentsline {subsection}{\numberline {48.3}Nested Namespaces}{197}{subsection.0.48.3}%
\contentsline {subsection}{\numberline {48.4}Anonymous Namespaces}{198}{subsection.0.48.4}%
\contentsline {section}{\numberline {49}Exceptions}{199}{section.0.49}%
\contentsline {subsection}{\numberline {49.1}Concepts}{199}{subsection.0.49.1}%
\contentsline {subsection}{\numberline {49.2}Syntax}{199}{subsection.0.49.2}%
\contentsline {subsection}{\numberline {49.3}Example}{200}{subsection.0.49.3}%
\contentsline {subsection}{\numberline {49.4}Why does catch take a const reference?}{200}{subsection.0.49.4}%
\contentsline {subsubsection}{\numberline {49.4.1}Safety and Efficiency}{200}{subsubsection.0.49.4.1}%
\contentsline {subsubsection}{\numberline {49.4.2}Const Correctness}{200}{subsubsection.0.49.4.2}%
\contentsline {subsection}{\numberline {49.5}Catching any exception}{201}{subsection.0.49.5}%
\contentsline {subsection}{\numberline {49.6}cerr (standard error)}{201}{subsection.0.49.6}%
\contentsline {subsubsection}{\numberline {49.6.1}Unbuffered Output}{201}{subsubsection.0.49.6.1}%
\contentsline {subsection}{\numberline {49.7}The what() function}{201}{subsection.0.49.7}%
\contentsline {subsubsection}{\numberline {49.7.1}Signature}{201}{subsubsection.0.49.7.1}%
\contentsline {subsection}{\numberline {49.8}What can we throw/catch?}{201}{subsection.0.49.8}%
\contentsline {subsection}{\numberline {49.9}noexcept in function signatures}{202}{subsection.0.49.9}%
\contentsline {subsection}{\numberline {49.10}Syntax and Usage}{202}{subsection.0.49.10}%
\contentsline {subsection}{\numberline {49.11}Benefits}{202}{subsection.0.49.11}%
\contentsline {subsection}{\numberline {49.12}OOP Approach to exceptions (Custom exception class)}{203}{subsection.0.49.12}%
\contentsline {subsection}{\numberline {49.13}Unwinding the stack}{204}{subsection.0.49.13}%
\contentsline {subsection}{\numberline {49.14}More on 'new'}{204}{subsection.0.49.14}%
\contentsline {subsubsection}{\numberline {49.14.1}Handling bad\_alloc}{204}{subsubsection.0.49.14.1}%
\contentsline {subsubsection}{\numberline {49.14.2}nothrow}{204}{subsubsection.0.49.14.2}%
\contentsline {section}{\numberline {50}Templates}{205}{section.0.50}%
\contentsline {subsection}{\numberline {50.1}Function Templates}{205}{subsection.0.50.1}%
\contentsline {subsubsection}{\numberline {50.1.1}Syntax}{205}{subsubsection.0.50.1.1}%
\contentsline {subsubsection}{\numberline {50.1.2}Example}{205}{subsubsection.0.50.1.2}%
\contentsline {subsection}{\numberline {50.2}Class Templates}{206}{subsection.0.50.2}%
\contentsline {subsubsection}{\numberline {50.2.1}Example}{206}{subsubsection.0.50.2.1}%
\contentsline {subsection}{\numberline {50.3}Function Template Specialization}{207}{subsection.0.50.3}%
\contentsline {subsection}{\numberline {50.4}Class/Struct Template Specialization}{207}{subsection.0.50.4}%
\contentsline {subsection}{\numberline {50.5}Template Parameters}{207}{subsection.0.50.5}%
\contentsline {subsection}{\numberline {50.6}Trailing return type}{208}{subsection.0.50.6}%
\contentsline {subsubsection}{\numberline {50.6.1}Syntax}{208}{subsubsection.0.50.6.1}%
\contentsline {subsubsection}{\numberline {50.6.2}Example}{208}{subsubsection.0.50.6.2}%
\contentsline {subsection}{\numberline {50.7}decltype}{208}{subsection.0.50.7}%
\contentsline {subsubsection}{\numberline {50.7.1}Syntax}{208}{subsubsection.0.50.7.1}%
\contentsline {subsubsection}{\numberline {50.7.2}Example}{208}{subsubsection.0.50.7.2}%
\contentsline {subsection}{\numberline {50.8}Template functions with mixed types (Trailing return type)}{209}{subsection.0.50.8}%
\contentsline {subsection}{\numberline {50.9}Template functions with mixed types (Deduced return type)}{210}{subsection.0.50.9}%
\contentsline {subsection}{\numberline {50.10}The use of 'static' in template programming}{210}{subsection.0.50.10}%
\contentsline {subsubsection}{\numberline {50.10.1}Declaring and Defining Static Members in a Template Class}{210}{subsubsection.0.50.10.1}%
\contentsline {subsubsection}{\numberline {50.10.2}Key points}{211}{subsubsection.0.50.10.2}%
\contentsline {subsection}{\numberline {50.11}Non-Type Template Parameters}{211}{subsection.0.50.11}%
\contentsline {subsubsection}{\numberline {50.11.1}Array sizes}{211}{subsubsection.0.50.11.1}%
\contentsline {subsubsection}{\numberline {50.11.2}Compile-Time Calculations}{212}{subsubsection.0.50.11.2}%
\contentsline {section}{\numberline {51}Elementary compile time computations}{213}{section.0.51}%
\contentsline {section}{\numberline {52}Linkage}{214}{section.0.52}%
\contentsline {subsection}{\numberline {52.1}Basics}{214}{subsection.0.52.1}%
\contentsline {subsection}{\numberline {52.2}Declaration vs. Definition}{214}{subsection.0.52.2}%
\contentsline {subsubsection}{\numberline {52.2.1}Variables}{214}{subsubsection.0.52.2.1}%
\contentsline {subsection}{\numberline {52.3}Forward Declaring}{215}{subsection.0.52.3}%
\contentsline {subsubsection}{\numberline {52.3.1}Example}{215}{subsubsection.0.52.3.1}%
\contentsline {subsubsection}{\numberline {52.3.2}Usage Frequency}{215}{subsubsection.0.52.3.2}%
\contentsline {subsection}{\numberline {52.4}Translation Units}{216}{subsection.0.52.4}%
\contentsline {subsection}{\numberline {52.5}Linkage}{216}{subsection.0.52.5}%
\contentsline {subsection}{\numberline {52.6}External Linkage}{216}{subsection.0.52.6}%
\contentsline {subsubsection}{\numberline {52.6.1}Usage}{217}{subsubsection.0.52.6.1}%
\contentsline {subsection}{\numberline {52.7}Internal Linkage}{217}{subsection.0.52.7}%
\contentsline {subsubsection}{\numberline {52.7.1}Example}{218}{subsubsection.0.52.7.1}%
\contentsline {section}{\numberline {53}Extra Information}{219}{section.0.53}%
\contentsline {subsection}{\numberline {53.1}constexpr}{219}{subsection.0.53.1}%
\contentsline {subsection}{\numberline {53.2}consteval}{219}{subsection.0.53.2}%
\contentsline {subsection}{\numberline {53.3}constinit}{219}{subsection.0.53.3}%
\contentsline {subsection}{\numberline {53.4}More on 'inline'}{219}{subsection.0.53.4}%
\contentsline {subsection}{\numberline {53.5}Measuring the speed of C++ programs}{219}{subsection.0.53.5}%
