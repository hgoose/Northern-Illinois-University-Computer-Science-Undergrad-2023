\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Java programming}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Java programming}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{User Input (scanner)}
    \bigbreak \noindent 
    The Scanner class is used to get user input, and it is found in the \textbf{java.util} package.
    \bigbreak \noindent 
    \begin{javacode}
        import java.util.Scanner;  // Import the Scanner class

        class Main {
            public static void main(String[] args) {
                Scanner myObj = new Scanner(System.in);  // Create a Scanner object
                System.out.println("Enter username");

                String userName = myObj.nextLine();  // Read user input
                System.out.println("Username is: " + userName);  // Output user input
            }
        }
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Input Types}
    \begin{itemize}
        \item \textbf{nextBoolean()}	Reads a boolean value from the user
        \item \textbf{nextByte()}	Reads a byte value from the user
        \item \textbf{nextDouble()}	Reads a double value from the user
        \item \textbf{nextFloat()}	Reads a float value from the user
        \item \textbf{nextInt()}	Reads a int value from the user
        \item \textbf{nextLine()}	Reads a String value from the user
        \item \textbf{nextLong()}	Reads a long value from the user
        \item \textbf{nextShort()}	Reads a short value from the user
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Checks}
    \begin{itemize}
        \item \textbf{hasNextBoolean()}	
        \item \textbf{hasNextByte()}
        \item \textbf{hasNextDouble()}
        \item \textbf{hasNextFloat()}	
        \item \textbf{hasNextInt()}	
        \item \textbf{hasNextLine()}	
        \item \textbf{hasNextLong()}
        \item \textbf{hasNextShort()}	
    \end{itemize}

    \pagebreak 
    \unsect{Arrays}
    \bigbreak \noindent 
    \subsection{Important methods}
    \bigbreak \noindent 
    These static methods are found in \texttt{java.util.Arrays}
    \bigbreak \noindent 
    \begin{itemize}
        \item \textbf{Arrays.fill()}: Fills all elements of the specified array with the specified value.
        \item \textbf{Arrays.equals()}: Returns a Boolean true value if both arrays are of the same type and all of the elements within the arrays are equal to each other. 
        \item \textbf{Arrays.copyOf()}: Copies the specified array, truncating or padding with default values if necessary so the copy has the specified length.
        \item \textbf{Arrays.copyOfRange()}: Copies the specified range from the index1 element up to, but not including, the index2 element of the specified array into a new array
        \item \textbf{Arrays.sort()}
        \item \textbf{Arrays.binarySearch}
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Sorting}
    \bigbreak \noindent 
    \subsection{The Comparable Interface}
    \bigbreak \noindent 
    In Java, the \texttt{Comparable<T>} interface (in java.lang) lets a class define its natural ordering by implementing a single method:
    \bigbreak \noindent 
    \begin{javacode}
    public interface Comparable<T> {
        int compareTo(T other);
    }
    \end{javacode}
    \bigbreak \noindent 
    Enables objects to be sorted (e.g. by Collections.sort() or Arrays.sort()), or used in sorted collections (e.g. TreeSet, TreeMap).
    \bigbreak \noindent 
    \textbf{Contract}:
    \begin{itemize}
        \item \textbf{this.compareTo(other) < 0} means this precedes other
        \item \textbf{== 0} means they’re considered equal in ordering
        \item \textbf{> 0} means this follows other
    \end{itemize}

    \pagebreak \bigbreak \noindent 
    \begin{javacode}
        import java.util.Scanner;
        import java.util.Collections;
        import java.util.ArrayList;
        import java.util.List;

        public class t1 implements Comparable<t1> {
            public int x,y;

            public t1(int x, int y) { this.x = x; this.y = y; }

            @Override
            // Ascending
            public int compareTo(t1 other) {
                if (this.x == other.x) return 0; 
                else if (this.x > other.x) return 1;
                else return -1;
            }

            @Override
            // Descending
            public int compareTo(t1 other) {
                if (this.x == other.x) return 0; 
                else if (this.x > other.x) return -1;
                else return 1;
            }

            public static void main(String[] args) {
                ArrayList<t1> arr = new ArrayList<>(List.of(new t1(4,2), new t1(2,6), new t1(1,8), new t1(9,18), new t1(5,0)));

                Collections.sort(arr);

                for (t1 item : arr) {
                    System.out.println("(" + item.x + "," + item.y + ")");
                }
            }
        }
    \end{javacode}

    \pagebreak 
    \subsection{Comparator}
    \bigbreak \noindent 
    The Comparator<T> interface (in java.util) defines a custom ordering for objects—even if the class itself doesn’t implement Comparable. It has one primary method
    \bigbreak \noindent 
    \begin{javacode}
        public interface Comparator<T> {
            /**
            * Compares its two arguments for order.
            *
            * @param o1 the first object to be compared.
            * @param o2 the second object to be compared.
            * @return a negative integer if o1 <  o2,
            *         zero                if o1 == o2,
            *         a positive integer if o1 >  o2.
            */
            int compare(T o1, T o2);

        }
    \end{javacode}
    \bigbreak \noindent 
    We can use it to define an ordering for objects without implementing the Comparable interface
    \bigbreak \noindent 
    \begin{javacode}
        import java.util.Collections;
        import java.util.Comparator;
        import java.util.ArrayList;
        import java.util.List;

        public class t1 {
            public int x, y;

            public t1(int x, int y) {
                this.x = x;
                this.y = y;
            }

            public static void main(String[] args) {
                List<t1> arr = new ArrayList<>(List.of( new t1(4,2), new t1(2,6), new t1(1,8), new t1(9,18), new t1(5,0)));

                // 1) Create a Comparator that compares by x:
                Comparator<t1> byX = new Comparator<>() {
                    @Override
                    public int compare(t1 a, t1 b) {
                        // Integer.compare handles a.x < b.x, ==, >
                        return Integer.compare(a.x, b.x);
                    }
                };

                // 2) Sort using that Comparator:
                Collections.sort(arr, byX);

                // 3) Print out:
                for (t1 item : arr) {
                    System.out.println("(" + item.x + "," + item.y + ")");
                }
            }
        }
    \end{javacode}

    \pagebreak 
    \unsect{Classes and Objects: A deeper look}
    \bigbreak \noindent 
    \subsection{Default and No Argument Constructors}
    \bigbreak \noindent 
    Every class must have at least one constructor. If you do not
    provide any in a class’s declaration, the compiler creates a
    default constructor that takes no arguments when it’s invoked.
    The default constructor initializes the instance variables to the
    initial values specified in their declarations or to their default
    values (zero for primitive numeric types, false for
    boolean values and null for references)
    \bigbreak \noindent 
    Recall that if your class declares constructors, the compiler
    will not create a default constructor. In this case, you must
    declare a no-argument constructor if default initialization is
    required.

    \bigbreak \noindent 
    \subsection{Enum types}
    \bigbreak \noindent 
    Like classes, all enum types are reference types. An enum type is declared with an enum declaration, which is a comma-separated list of enum constants.
    \bigbreak \noindent 
    The declaration may optionally include other components of traditional classes, such as constructors, fields and methods
    \bigbreak \noindent 
    \begin{itemize}
        \item enum constants are implicitly final.
        \item enum constants are implicitly static.
        \item Any attempt to create an object of an enum type with operator new results in a compilation error.
    \end{itemize}
    \bigbreak \noindent 
    The enum constants can be used anywhere constants can be used, such as in the case labels of switch statements and to control enhanced for statements.
    \bigbreak \noindent 
    \begin{javacode}
        public enum e {
            // First, declare constants
            a(1,2),
            b(2,3),
            c(3,4);

            // The fields of those constants
            private final int x,y;

            // Constructor
            e(int x, int y) {
                this.x = x;
                this.y = y;
            }

            // Optional sets and gets

            // So we can run the program to see no errors
            public static void main(String[] args)  {

            }
        }
    \end{javacode}
    \bigbreak \noindent 
    For every enum, the compiler generates the static method values that returns an array of the enum’s constants.
    \bigbreak \noindent 
    When an enum constant is converted to a String, the constant’s identifier is used as the String representation.
    \bigbreak \noindent 
    \begin{javacode}
        public enum e{
            a,b,c;

            public static void main(String[] args) {
                e E = a;

                for (e item : E.values()) {
                    System.out.println(item);
                }
                // a
                // b
                // c
            }
        }
    \end{javacode}
    \bigbreak \noindent 
    \begin{javacode}
        import java.util.EnumSet;

        public enum e{
            a,b,c,d;

            public static void main(String[] args) {
                e E = a;

                EnumSet<e> es = EnumSet.range(e.a, e.d);

                for (e item : es) System.out.print(item + " ");
                // a b c d
            }
        }
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Static import}
    \bigbreak \noindent 
    Imports all static members of a class (which is known as static import on demand)
    \bigbreak \noindent 
    The following syntax imports a particular static member
    \bigbreak \noindent 
    \begin{javacode}
    import static packageName.ClassName.staticMemberName;
    \end{javacode}

    \pagebreak 
    \unsect{Validating and Converting data types}
    \bigbreak \noindent 
    \subsection{String to integer}
    In Java, you can validate and convert a string to an integer safely using either Integer.parseInt() or Integer.valueOf(), but you should handle exceptions in case the string isn’t a valid integer.
    \bigbreak \noindent 
    \begin{javacode}
        String input = "123";
        int number;

        try {
            number = Integer.parseInt(input);
            System.out.println("Valid integer: " + number);
        } catch (NumberFormatException e) {
            System.out.println("Invalid input: not a valid integer.");
        }
    \end{javacode}

    \pagebreak 
    \unsect{Java regex}
    \subsection{Includes}
    \bigbreak \noindent 
    \begin{javacode}
    import java.util.regex.*;
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Create a pattern}
    \bigbreak \noindent 
    \begin{javacode}
        Pattern pattern = Pattern.compile(string pattern);
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Create a matcher}
    \bigbreak \noindent 
    \begin{javacode}
    Matcher matcher = pattern.matcher(string source);
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Yes / no match test}
    \bigbreak \noindent 
    \begin{javacode}
    boolean found = matcher.matches(); // returns true if entire string matches
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Matcher methods}
    \begin{itemize}
        \item \textbf{boolean matches()}: Checks if the entire input matches the pattern
        \item \textbf{boolean find()}:	Looks for the next occurrence of the pattern
        \item \textbf{String group()}:	Returns the text matched by the last find() (default to zero)
        \item \textbf{String group(int number)}: Returns specific capture (zero is full match)	
        \item \textbf{int start() / end()}:	Returns the start/end indices of the match
        \item \textbf{int start(int groupNumber) / end(int groupNumber)}:	Returns the start/end indices of the match
        \item \textbf{string replaceAll(String)}: Replaces all matches with a given string
        \item \textbf{string replaceFirst(String)}: Replaces first match only
    \end{itemize}

    \bigbreak \noindent 
    \subsubsection{replaceAll}
    \bigbreak \noindent 
    This method replaces every substring that matches the regex with a replacement string. We can also use back references as arguments.
    \bigbreak \noindent 
    \begin{javacode}
        String old = "abcfooxyz";
        // Replace string with captured "foo"
        System.out.println(Pattern.compile("\\w*(foo)\\w*").matcher(old).replaceAll("$1"));
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Getting captures}
    \bigbreak \noindent 
    We use .find() and .group()
    \bigbreak \noindent 
    \begin{javacode}
        Pattern pattern = Pattern.compile("(\\w+)@(\\w+)\\.(\\w+)");
        Matcher matcher = pattern.matcher("a@b.com and c@d.org");

        while (matcher.find()) {
            System.out.println("Full: " + matcher.group(0));
            System.out.println("User: " + matcher.group(1));
            System.out.println("Domain: " + matcher.group(2));
            System.out.println("TLD: " + matcher.group(3));
            System.out.println();
        }
    \end{javacode}

    \bigbreak \noindent 
    \subsection{Flags}
    \begin{itemize}
        \item \textbf{Pattern.CASE\_INSENSITIVE}:	Makes matching ignore case
        \item \textbf{Pattern.MULTILINE}:	Makes $\land$ and \$ match line boundaries
        \item \textbf{Pattern.DOTALL}:	Makes . match newline \textbackslash n as well
        \item \textbf{Pattern.UNICODE\_CASE}:	Enables Unicode-aware case folding
    \end{itemize}

    \bigbreak \noindent 
    \subsection{Shortcut}
    \bigbreak \noindent 
    You don’t always need Pattern and Matcher:
    \bigbreak \noindent 
    \begin{javacode}
    System.out.println("abc123".matches("\\w+\\d+")); // true
    \end{javacode}



\end{document}
