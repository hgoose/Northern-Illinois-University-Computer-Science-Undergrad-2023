\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Data Visualization}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Data Visualization}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Web programming: Html, css, and JS}
    \subsection{HTML and CSS}
    \begin{itemize}
        \item \textbf{SVGS with html}: An SVG (Scalable Vector Graphics) file is an XML-based image format used to display vector graphics. Unlike PNG or JPG images, SVGs scale infinitely without losing quality.        
            \bigbreak \noindent 
            Key properties:
            \begin{itemize}
                \item Resolution-independent
                \item Small file size for simple graphics
                \item Fully stylable with CSS
                \item Scriptable with JavaScript
                \item Ideal for icons, diagrams, charts, and UI graphics
            \end{itemize}
        \item \textbf{Embedding SVG directly into HTML (inline SVG)}: This is the most powerful and flexible method.
            \bigbreak \noindent 
            \begin{htmlcode}
                <svg width="200" height="100" viewBox="0 0 200 100">
                    <rect x="10" y="10" width="180" height="80" fill="steelblue" />
                    <circle cx="100" cy="50" r="30" fill="orange" />
                </svg>
            \end{htmlcode}
            \bigbreak \noindent 
            \begin{itemize}
                \item <svg> defines the canvas
                \item width / height define display size
                \item viewBox defines the internal coordinate system
                \item Shapes (rect, circle, line, path) are drawn inside
            \end{itemize}
            \begin{itemize}
                \item Fully stylable with CSS
                \item Can be animated
                \item JavaScript access to elements
                \item Best for interactive graphics
            \end{itemize}
        \item \textbf{SVG elements}: 
            \begin{center}
                \begin{tabularx}{\textwidth}{@{}XX@{}}
                    \toprule
                    \textbf{Element} &	\textbf{Purpose} \\
                    \midrule
                    <rect>	& Rectangle\\[2ex]
                    <circle>&	Circle\\[2ex]
                    <ellipse>	&Ellipse\\[2ex]
                    <line>	&Line\\[2ex]
                    <polyline>	&Connected lines\\[2ex]
                    <polygon>	&Closed shape\\[2ex]
                    <path>	&Complex shapes\\[2ex]
                    <text>	&Text\\[2ex]
                    \bottomrule
                \end{tabularx}
            \end{center}
        \item \textbf{Rect}:
            \begin{itemize}
                \item \textbf{x}:  x-coordinate (top-left)
                \item \textbf{y}:  y-coordinate (top-left)
                \item \textbf{width}:  rectangle width
                \item \textbf{height}:  rectangle height
                \item \textbf{rx}:  x-axis corner radius (rounded corners)
                \item \textbf{ry}:  y-axis corner radius
                \item \textbf{fill}
                \item \textbf{stroke}
                \item \textbf{stroke-width}
                \item \textbf{opacity}
            \end{itemize}
        \item \textbf{Circle}
            \begin{itemize}
                \item \textbf{cx}  center x-coordinate
                \item \textbf{cy}  center y-coordinate
                \item \textbf{r}  radius
                \item \textbf{fill}
                \item \textbf{stroke}
                \item \textbf{stroke-width}
            \end{itemize}
        \item \textbf{Ellipse}
            \begin{itemize}
                \item \textbf{cx}  center x-coordinate
                \item \textbf{cy}  center y-coordinate
                \item \textbf{rx}  x-radius
                \item \textbf{ry}  y-radius
                \item \textbf{fill}
                \item \textbf{stroke}
                \item \textbf{stroke-width}
            \end{itemize}
        \item \textbf{Line}
            \begin{itemize}
                \item \textbf{x1, y1}:  start point
                \item \textbf{x2, y2}:  end point
                \item \textbf{stroke}: (required)
                \item \textbf{stroke-width}:
                \item \textbf{stroke-linecap} (butt, round, square)
                \item \textbf{stroke-dasharray}:
            \end{itemize}
        \item \textbf{Polyline}
            \begin{itemize}
                \item \textbf{points}:  list of coordinate pairs "x1,y1 x2,y2 x3,y3 ..."
                \item \textbf{fill}: (usually none)
                \item \textbf{stroke:}
                \item \textbf{stroke-width:}
                \item \textbf{stroke-linejoin}:
            \end{itemize}
        \item \textbf{Polygon}
            \begin{itemize}
                \item \textbf{points}:  list of coordinate pairs "x1,y1 x2,y2 x3,y3 ..."
                \item \textbf{fill}:
                \item \textbf{stroke}:
                \item \textbf{stroke-width}:
                \item \textbf{fill-rule}: (nonzero, evenodd)
            \end{itemize}
        \item \textbf{Text}
            \begin{itemize}
                \item \textbf{x}:
                \item \textbf{y}:
                \item \textbf{dx}:
                \item \textbf{dy}:
                \item \textbf{text-anchor}: (start, middle, end)
                \item \textbf{font-family}:
                \item \textbf{font-size:}
                \item \textbf{font-weight:}
                \item \textbf{letter-spacing}:
                \item \textbf{fill}:
                \item \textbf{stroke}:
                \item \textbf{opacity}:
            \end{itemize}
        \item \textbf{SVG viewbox}: 
            \bigbreak \noindent 
            \begin{htmlcode}
                <svg viewBox="0 0 200 100">
            \end{htmlcode}
            \bigbreak \noindent 
            Means:
            \begin{itemize}
                \item Coordinate system starts at (0, 0)
                \item Width = 200 units
                \item Height = 100 units
            \end{itemize}
            This allows scaling without distortion.
        \item \textbf{CSS for <svg>}: 
            \begin{itemize}
                \item fill
                \item fill-opacity
                \item fill-rule
                \item stroke
                \item stroke-width
                \item stroke-opacity
                \item stroke-linecap
                \item stroke-linejoin
                \item stroke-dasharray
                \item stroke-dashoffset
                \item stroke-miterlimit
                \item color
                \item opacity
                \item x
                \item y
                \item cx
                \item cy
                \item r
                \item rx
                \item ry
                \item width
                \item height
                \item transform
                \item transform-origin
                \item transform-box
                \item font-family
                \item font-size
                \item font-style
                \item font-weight
                \item letter-spacing
                \item word-spacing
                \item text-anchor
                \item dominant-baseline
                \item alignment-baseline
                \item direction
                \item writing-mode
                \item display
                \item visibility
                \item overflow
                \item clip-path
                \item mask
                \item filter
                \item cursor
                \item pointer-events
                \item animation
                \item animation-name
                \item animation-duration
                \item animation-delay
                \item animation-iteration-count
                \item animation-timing-function
                \item transition
                \item transition-property
                \item transition-duration
            \end{itemize}
        \item \textbf{Paths}: The <path> element is the most powerful and flexible shape in SVG. Unlike <rect> or <circle>, a path can describe:
            \begin{itemize}
                \item Straight lines
                \item Curves
                \item Arcs
                \item Complex shapes
                \item Icons, symbols, letters
                \item Entire illustrations
            \end{itemize}
            It works by following a series of drawing commands stored in the $d$ attribute. The $d$ string is a mini drawing language, it reads left to right.
            \begin{itemize}
                \item \textbf{Move to (M)}: Moves the “pen” without drawing.
                    \bigbreak \noindent 
                    \begin{center}
                        M x y
                    \end{center}
                    Moves to $(x,y)$
                \item \textbf{Line to (L)}: Draws a straight line.
                    \bigbreak \noindent 
                    \begin{center}
                        L x y
                    \end{center}
                    Draws a line from the current point to $(x,y)$
                \item \textbf{Close path (Z): Closes the shape by connecting back to the start.}
                    \bigbreak \noindent 
                    \begin{center}
                        Z
                    \end{center}
                \item \textbf{Quadratic Curve (Q)}: (cx, cy) = control point (x, y) = end point
                    \bigbreak \noindent 
                    \begin{center}
                        Q cx cy x y
                    \end{center}
                    The control point:
                    \begin{itemize}
                        \item pulls the curve
                        \item bends its direction
                        \item determines how steep or shallow the curve is
                    \end{itemize}
                    The curve only passes through:
                    \begin{itemize}
                        \item The start point
                        \item The end point
                    \end{itemize}

                \item \textbf{Cubic Bézier (C)}: 
                    \bigbreak \noindent 
                    \begin{center}
                        C x1 y1, x2  y2, x y
                    \end{center}
                    Two control points, more control.
                \item \textbf{Arc Command (Rounded Shapes) (A)}: 
                    \bigbreak \noindent 
                    \begin{center}
                        A rx ry x-axis-rotation large-arc sweep x y
                    \end{center}
            \end{itemize}
            Note the difference between lowercase and uppercase control characters
            \begin{itemize}
                \item \textbf{Uppercase}:	Absolute position
                \item \textbf{Lowercase}:	Relative movement
            \end{itemize}
        \item \textbf{Triangle with path}: 
            \bigbreak \noindent 
            \begin{htmlcode}
                <path d="M 50 10 L 30 80 L 70 80 Z" />
            \end{htmlcode}
        \item \textbf{Fill and stroke}: 
            \bigbreak \noindent 
            \begin{htmlcode}
                <path d="M 50 10 L 30 80 L 70 80 Z" 
                stroke="black"
                stroke-width="6"
                fill="red"
                />
            \end{htmlcode}
        \item \textbf{Grouping}: The <g> element is used to group multiple SVG elements together so that transformations, styles, or attributes can be applied to them collectively.
            \bigbreak \noindent 
            \begin{htmlcode}
                <svg width="200" height="200">
                    <g>
                        <!-- SVG elements go here -->
                    </g>
                </svg>
            \end{htmlcode}
            \bigbreak \noindent 
            Instead of transforming each element individually, you apply the transformation once to the group.
            \bigbreak \noindent 
            \begin{htmlcode}
                <g transform="translate(50, 50)">
                    <circle cx="0" cy="0" r="20" />
                    <rect x="30" y="-10" width="40" height="20" />
                </g>
            \end{htmlcode}
            \bigbreak \noindent 
            Both shapes move together. You can apply styles such as fill, stroke, opacity, etc., to all child elements.
            \bigbreak \noindent 
            \begin{htmlcode}
                <g fill="blue" stroke="black" stroke-width="2">
                    <circle cx="50" cy="50" r="20" />
                    <rect x="90" y="30" width="40" height="40" />
                </g>
            \end{htmlcode}
            \bigbreak \noindent 
            Events applied to a <g> affect all child elements.
            \bigbreak \noindent 
            \begin{htmlcode}
                <g onclick="alert('Clicked group!')">
                    <circle cx="50" cy="50" r="20" />
                    <rect x="80" y="40" width="30" height="30" />
                </g>
            \end{htmlcode}
    \end{itemize}

    \pagebreak 
    \subsection{Observable}
    \begin{itemize}
        \item \textbf{Window}: Global variables can be defined with the global window object
            \bigbreak \noindent 
            \begin{jscode}
            window.data = ...
            \end{jscode}
            \bigbreak \noindent 
            Then, this property can be accessed in other cells.
        \item \textbf{Blocks}: In observable, multi-line javascript cells must be placed in a curly brace block
        \item \textbf{HTML templating}: Observable provides an html tag for writing HTML declaratively:
            \bigbreak \noindent 
            \begin{jscode}
            html`<h1>Hello</h1>`
            \end{jscode}
            \begin{itemize}
                \item Returns a live DOM node, not a string.
                \item HTML is parsed immediately.
                \item Values inside \$\{...\} are safely interpolated.
            \end{itemize}
            In a multi statement (curly brace block), this node must be returned to be rendered.
            \bigbreak \noindent 
            To make a table dynamically with templating, 
            \bigbreak \noindent 
            \begin{jscode}
html`
  <table>
    <thead>
      <tr>
        <th>Year</th>
        <th>Weekday</th>
      </tr>
    </thead>
    <tbody>
      ${data.map(d => html`
        <tr>
          <td>${d.Year}</td>
          <td>${d.Weekday}</td>
        </tr>
      `)}
    </tbody>
  </table>
            \end{jscode}
            \bigbreak \noindent 
            Notice that html must be placed inside ticks.
    \end{itemize}

    \pagebreak 
    \subsection{JS}
    \begin{itemize}
        \item \textbf{Var, let, and const}:  
            \begin{itemize}
                \item \textbf{Var}: Function-scoped, not block-scoped. Ignores \{\} blocks such as if, for, and while. Hoisted to the top of the function. Initialized as \textbf{undefined}. Can be reassigned ,can be redeclared
                \item \textbf{Let}: Block-scoped, exists only inside \{\} where it is defined. Hoisted, but not initialized. Exists in the Temporal Dead Zone (TDZ) until declared. Can be reassigned ,cannot be redeclared in the same scope
                    \bigbreak \noindent 
                    \begin{jscode}
                        let x = 3;
                        x = 4;     // OK
                        let x = 5; // Error
                    \end{jscode}
                \item \textbf{Const}: Block-scoped, same as let. Hoisted but in the TDZ. Must be initialized at declaration
                    \bigbreak \noindent 
                    \begin{jscode}
                    const z  = 10; // Good
                    const y;       // Error
                    \end{jscode}
                    \bigbreak \noindent 
                    Cannot be reassigned. Const prevents reassignment, not mutation.
            \end{itemize}
                \item \textbf{Immutable types}: These cannot be changed after creation. Any “modification” creates a new value. Primitive Types are all immutable 
                    \begin{itemize}
                        \item number	
                        \item string
                        \item boolean
                        \item null	
                        \item undefined	
                        \item symbol
                        \item bigint
                    \end{itemize}
                    \bigbreak \noindent 
                    \begin{jscode}
                        let s = "hello";
                        s[0] = "H";   // No effect
                        console.log(s); // "hello"
                    \end{jscode}
                \item \textbf{Mutable types}:  These are objects and collections, whose contents can change without changing the reference.
                    \begin{itemize}
                        \item Object	
                        \item Array	
                        \item Function	
                        \item Date	
                        \item Map / Set
                    \end{itemize}
                \item \textbf{Pass by value and pass by reference}: JavaScript does not technically have pass-by-reference.
                    \begin{itemize}
                        \item Primitive values are passed by value
                        \item Objects are passed by value of their reference
                    \end{itemize}
                    All primitives are passed by value. 
                    \bigbreak \noindent 
                    Objects are somewhat passed by reference, technically by value of reference. The reference (memory address) is copied, not the object itself.
                    \bigbreak \noindent 
                    \begin{jscode}
                        function modify(obj) {
                            obj.x = 10;
                        }

                        const data = { x: 1 };
                        modify(data);

                        console.log(data.x); // 10
                    \end{jscode}
                    \begin{itemize}
                        \item data holds a reference to the object
                        \item That reference is copied into obj
                        \item Both point to the same object
                        \item Mutating the object affects both
                    \end{itemize}
                \item \textbf{Objects}: Key value pairs
                    \bigbreak \noindent 
                    \begin{jscode}
                        var obj = {x: 2, y: 4}; obj.x = 3; obj.y = 5;
                    \end{jscode}
                    \bigbreak \noindent 
                    Prototypes for instance functions. We can access properties via dot notation or [] notation. Objects may also contain functions
                    \bigbreak \noindent 
                    \begin{jscode}
                        var student = {firstName: "John",
                            lastName: "Smith",
                            fullName: function() { return this.firstName + " " + this.lastName; }};
                        student.fullName()
                    \end{jscode}
                    \bigbreak \noindent 
                    \textbf{Note:} Dot-notation only works with certain identifiers, bracket notation works with more identifiers, like if the key was a string.
                \item \textbf{JSON}: Data interchange format, subset of JS. Uses nested objects and arrays. Data only, no functions.
                \item \textbf{Functional programming in JS}
                \item \textbf{Unary plus operator}: The unary plus (+) operator precedes its operand and evaluates to its operand but attempts to convert it into a number, if it isn't already.
                \item \textbf{Map, filter, and reduce}: 
                    \begin{itemize}
                        \item \textbf{Map}: map transforms each element of an array using a callback function and returns a new array of the same length. It is a pure transformation; the original array is not modified.
                            \bigbreak \noindent 
                            \begin{jscode}
                            arr.map((element, index, array) => newElement) -> Array
                            \end{jscode}
                        \item \textbf{Filter}: filter selects a subset of elements based on a predicate function and returns a new array containing only those elements for which the predicate evaluates to true.
                            \bigbreak \noindent 
                            \begin{jscode}
                            arr.filter((element, index, array) => boolean) -> Array
                            \end{jscode}
                        \item \textbf{Reduce}: reduce aggregates an array into a single value by repeatedly combining elements using an accumulator function. It is the most general of the three operations.
                            \bigbreak \noindent 
                            \begin{jscode}
                                arr.reduce((accumulator, element, index, array) => newAccumulator, initialValue) -> any
                            \end{jscode}
                    \end{itemize}
                \item \textbf{forEach}: forEach executes a provided callback function once for each element of an array. It is intended for side effects, not for producing values.
                    \bigbreak \noindent 
                    \begin{jscode}
                    arr.forEach((element, index, array) => void) -> void
                    \end{jscode}
                \item \textbf{Object manipulation}
                    \begin{itemize}
                        \item \textbf{Deleting properties}: We use the delete operator
                            \bigbreak \noindent 
                            \begin{jscode}
                            delete person.age;
                            \end{jscode}
                    \end{itemize}

        \item \textbf{Creating html elements manually with JS (SVGs)}:
            \begin{itemize}
                \item \textbf{document.createElementNS}: We use create element to create new elements, to create a new svg element,
                    \bigbreak \noindent 
                    \begin{jscode}
                    const new_element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    \end{jscode}
                \item \textbf{setAttribute}: We can set attributes on our element with setAttribute
                    \bigbreak \noindent 
                    \begin{jscode}
                    new_element.setAttribute(name: string, value);
                    \end{jscode}
                \item \textbf{appendChild}: We use append child to append child to a root node in our document tree
                    \bigbreak \noindent 
                    \begin{jscode}
                        root_element.appendChild(new_element);
                    \end{jscode}
                \item \textbf{createTextNode(value)}: Creates a plain text node
                    \bigbreak \noindent 
                    \begin{jscode}
                    root_element.appendChild(document.createTextNode("Hello world"));
                    \end{jscode}
            \end{itemize}
        \item \textbf{General JS to create HTML dynamically}: 
            \begin{itemize}
                \item \textbf{document.createElement(tagName)}: Creates a new DOM element but does not place it in the document.
                    \bigbreak \noindent 
                    \begin{jscode}
                    const div = document.createElement("div");
                    \end{jscode}
                \item \textbf{document.createTextNode(text)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                        const text = document.createTextNode("Hello world");
                        div.appendChild(text);
                    \end{jscode}
                \item \textbf{element.textContent}: Assigns or retrieves text content (preferred in most cases).
                    \bigbreak \noindent 
                    \begin{jscode}
                    div.textContent = "Hello world";
                    \end{jscode}
                \item \textbf{div.setAttribute("class", "container")}:
                    \bigbreak \noindent 
                    \begin{jscode}
                    div.setAttribute("class", "container");
                    \end{jscode}
                \item \textbf{getAttribute(name)}:
                \item \textbf{removeAttribute(name)}:
                \item \textbf{hasAttribute(name)}: 
                \item \textbf{parent.appendChild(child)}: Appends as the last child.
                    \bigbreak \noindent 
                    \begin{jscode}
                    document.body.appendChild(div);
                    \end{jscode}
                \item \textbf{parent.insertBefore(newNode, referenceNode)}: Inserts at a specific position.
                    \bigbreak \noindent 
                    \begin{jscode}
                    parent.insertBefore(div, parent.firstChild);
                    \end{jscode}
                \item \textbf{element.append(...)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                    document.body.append(div);
                    \end{jscode}
                \item \textbf{element.prepend(...):}
                \item \textbf{element.before(...):}
                \item \textbf{element.after(...)}:
                \item \textbf{element.innerHTML}: Parses an HTML string and replaces the element’s contents.
                    \bigbreak \noindent 
                    \begin{jscode}
                        div.innerHTML = "<strong>Hello</strong>";
                    \end{jscode}
                \item \textbf{document.getElementById(id)}:
                \item \textbf{document.querySelector(cssSelector)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                        const container = document.querySelector(".container");
                        container.append(div);
                    \end{jscode}
                \item \textbf{document.querySelectorAll(cssSelector)}:
                \item \textbf{element.cloneNode(deep)}: Copies an element.
                    \bigbreak \noindent 
                    \begin{jscode}
                    const copy = div.cloneNode(true);
                    \end{jscode}
                \item \textbf{element.addEventListener(type, handler)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                    button.addEventListener("click", handleClick);
                    \end{jscode}
            \end{itemize}
        \item \textbf{Direct property assignment (often cleaner and safer):}
            \bigbreak \noindent 
            \begin{jscode}
                div.id = "main";
                div.className = "container";
            \end{jscode}
        \item \textbf{Element properties}: 
            \begin{itemize}
                \item \textbf{id}: Unique element identifier
                \item \textbf{className}: Space-separated CSS classes
                \item \textbf{classList}: Token-based class API (add, remove, toggle)
                \item \textbf{tagName}: Uppercase tag name (read-only)
                \item \textbf{nodeName}: Same as tagName for elements
                \item \textbf{nodeType}: Numeric node type (1 = Element)
                \item \textbf{style}: Inline style object
                \item \textbf{hidden}: Shortcut for display: none
            \end{itemize}


    \end{itemize}






















    
\end{document}
