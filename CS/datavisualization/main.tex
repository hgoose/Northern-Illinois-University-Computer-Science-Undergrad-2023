\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Data Visualization}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Data Visualization}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \pagebreak 
    \unsect{Web programming: Html, css, and JS}
    \subsection{HTML and CSS}
    \begin{itemize}
        \item \textbf{SVGS with html}: An SVG (Scalable Vector Graphics) file is an XML-based image format used to display vector graphics. Unlike PNG or JPG images, SVGs scale infinitely without losing quality.        
            \bigbreak \noindent 
            Key properties:
            \begin{itemize}
                \item Resolution-independent
                \item Small file size for simple graphics
                \item Fully stylable with CSS
                \item Scriptable with JavaScript
                \item Ideal for icons, diagrams, charts, and UI graphics
            \end{itemize}
        \item \textbf{Embedding SVG directly into HTML (inline SVG)}: This is the most powerful and flexible method.
            \bigbreak \noindent 
            \begin{htmlcode}
                <svg width="200" height="100" viewBox="0 0 200 100">
                    <rect x="10" y="10" width="180" height="80" fill="steelblue" />
                    <circle cx="100" cy="50" r="30" fill="orange" />
                </svg>
            \end{htmlcode}
            \bigbreak \noindent 
            \begin{itemize}
                \item <svg> defines the canvas
                \item width / height define display size
                \item viewBox defines the internal coordinate system
                \item Shapes (rect, circle, line, path) are drawn inside
            \end{itemize}
            \begin{itemize}
                \item Fully stylable with CSS
                \item Can be animated
                \item JavaScript access to elements
                \item Best for interactive graphics
            \end{itemize}
        \item \textbf{SVG elements}: 
            \begin{center}
                \begin{tabularx}{\textwidth}{@{}XX@{}}
                    \toprule
                    \textbf{Element} &	\textbf{Purpose} \\
                    \midrule
                    <rect>	& Rectangle\\[2ex]
                    <circle>&	Circle\\[2ex]
                    <ellipse>	&Ellipse\\[2ex]
                    <line>	&Line\\[2ex]
                    <polyline>	&Connected lines\\[2ex]
                    <polygon>	&Closed shape\\[2ex]
                    <path>	&Complex shapes\\[2ex]
                    <text>	&Text\\[2ex]
                    \bottomrule
                \end{tabularx}
            \end{center}
        \item \textbf{Rect}:
            \begin{itemize}
                \item \textbf{x}:  x-coordinate (top-left)
                \item \textbf{y}:  y-coordinate (top-left)
                \item \textbf{width}:  rectangle width
                \item \textbf{height}:  rectangle height
                \item \textbf{rx}:  x-axis corner radius (rounded corners)
                \item \textbf{ry}:  y-axis corner radius
                \item \textbf{fill}
                \item \textbf{stroke}
                \item \textbf{stroke-width}
                \item \textbf{opacity}
            \end{itemize}
        \item \textbf{Circle}
            \begin{itemize}
                \item \textbf{cx}  center x-coordinate
                \item \textbf{cy}  center y-coordinate
                \item \textbf{r}  radius
                \item \textbf{fill}
                \item \textbf{stroke}
                \item \textbf{stroke-width}
            \end{itemize}
        \item \textbf{Ellipse}
            \begin{itemize}
                \item \textbf{cx}  center x-coordinate
                \item \textbf{cy}  center y-coordinate
                \item \textbf{rx}  x-radius
                \item \textbf{ry}  y-radius
                \item \textbf{fill}
                \item \textbf{stroke}
                \item \textbf{stroke-width}
            \end{itemize}
        \item \textbf{Line}
            \begin{itemize}
                \item \textbf{x1, y1}:  start point
                \item \textbf{x2, y2}:  end point
                \item \textbf{stroke}: (required)
                \item \textbf{stroke-width}:
                \item \textbf{stroke-linecap} (butt, round, square)
                \item \textbf{stroke-dasharray}:
            \end{itemize}
        \item \textbf{Polyline}
            \begin{itemize}
                \item \textbf{points}:  list of coordinate pairs "x1,y1 x2,y2 x3,y3 ..."
                \item \textbf{fill}: (usually none)
                \item \textbf{stroke:}
                \item \textbf{stroke-width:}
                \item \textbf{stroke-linejoin}:
            \end{itemize}
        \item \textbf{Polygon}
            \begin{itemize}
                \item \textbf{points}:  list of coordinate pairs "x1,y1 x2,y2 x3,y3 ..."
                \item \textbf{fill}:
                \item \textbf{stroke}:
                \item \textbf{stroke-width}:
                \item \textbf{fill-rule}: (nonzero, evenodd)
            \end{itemize}
        \item \textbf{Text}
            \begin{itemize}
                \item \textbf{x}:
                \item \textbf{y}:
                \item \textbf{dx}:
                \item \textbf{dy}:
                \item \textbf{text-anchor}: (start, middle, end)
                \item \textbf{font-family}:
                \item \textbf{font-size:}
                \item \textbf{font-weight:}
                \item \textbf{letter-spacing}:
                \item \textbf{fill}:
                \item \textbf{stroke}:
                \item \textbf{opacity}:
            \end{itemize}
        \item \textbf{SVG viewbox}: 
            \bigbreak \noindent 
            \begin{htmlcode}
                <svg viewBox="0 0 200 100">
            \end{htmlcode}
            \bigbreak \noindent 
            Means:
            \begin{itemize}
                \item Coordinate system starts at (0, 0)
                \item Width = 200 units
                \item Height = 100 units
            \end{itemize}
            This allows scaling without distortion.
        \item \textbf{CSS for <svg>}: 
            \begin{itemize}
                \item fill
                \item fill-opacity
                \item fill-rule
                \item stroke
                \item stroke-width
                \item stroke-opacity
                \item stroke-linecap
                \item stroke-linejoin
                \item stroke-dasharray
                \item stroke-dashoffset
                \item stroke-miterlimit
                \item color
                \item opacity
                \item x
                \item y
                \item cx
                \item cy
                \item r
                \item rx
                \item ry
                \item width
                \item height
                \item transform
                \item transform-origin
                \item transform-box
                \item font-family
                \item font-size
                \item font-style
                \item font-weight
                \item letter-spacing
                \item word-spacing
                \item text-anchor
                \item dominant-baseline
                \item alignment-baseline
                \item direction
                \item writing-mode
                \item display
                \item visibility
                \item overflow
                \item clip-path
                \item mask
                \item filter
                \item cursor
                \item pointer-events
                \item animation
                \item animation-name
                \item animation-duration
                \item animation-delay
                \item animation-iteration-count
                \item animation-timing-function
                \item transition
                \item transition-property
                \item transition-duration
            \end{itemize}
        \item \textbf{Paths}: The <path> element is the most powerful and flexible shape in SVG. Unlike <rect> or <circle>, a path can describe:
            \begin{itemize}
                \item Straight lines
                \item Curves
                \item Arcs
                \item Complex shapes
                \item Icons, symbols, letters
                \item Entire illustrations
            \end{itemize}
            It works by following a series of drawing commands stored in the $d$ attribute. The $d$ string is a mini drawing language, it reads left to right.
            \begin{itemize}
                \item \textbf{Move to (M)}: Moves the “pen” without drawing.
                    \bigbreak \noindent 
                    \begin{center}
                        M x y
                    \end{center}
                    Moves to $(x,y)$
                \item \textbf{Line to (L)}: Draws a straight line.
                    \bigbreak \noindent 
                    \begin{center}
                        L x y
                    \end{center}
                    Draws a line from the current point to $(x,y)$
                \item \textbf{Close path (Z): Closes the shape by connecting back to the start.}
                    \bigbreak \noindent 
                    \begin{center}
                        Z
                    \end{center}
                \item \textbf{Quadratic Curve (Q)}: (cx, cy) = control point (x, y) = end point
                    \bigbreak \noindent 
                    \begin{center}
                        Q cx cy x y
                    \end{center}
                    The control point:
                    \begin{itemize}
                        \item pulls the curve
                        \item bends its direction
                        \item determines how steep or shallow the curve is
                    \end{itemize}
                    The curve only passes through:
                    \begin{itemize}
                        \item The start point
                        \item The end point
                    \end{itemize}

                \item \textbf{Cubic Bézier (C)}: 
                    \bigbreak \noindent 
                    \begin{center}
                        C x1 y1, x2  y2, x y
                    \end{center}
                    Two control points, more control.
                \item \textbf{Arc Command (Rounded Shapes) (A)}: 
                    \bigbreak \noindent 
                    \begin{center}
                        A rx ry x-axis-rotation large-arc sweep x y
                    \end{center}
            \end{itemize}
            Note the difference between lowercase and uppercase control characters
            \begin{itemize}
                \item \textbf{Uppercase}:	Absolute position
                \item \textbf{Lowercase}:	Relative movement
            \end{itemize}
        \item \textbf{Triangle with path}: 
            \bigbreak \noindent 
            \begin{htmlcode}
                <path d="M 50 10 L 30 80 L 70 80 Z" />
            \end{htmlcode}
        \item \textbf{Fill and stroke}: 
            \bigbreak \noindent 
            \begin{htmlcode}
                <path d="M 50 10 L 30 80 L 70 80 Z" 
                stroke="black"
                stroke-width="6"
                fill="red"
                />
            \end{htmlcode}
        \item \textbf{Grouping}: The <g> element is used to group multiple SVG elements together so that transformations, styles, or attributes can be applied to them collectively.
            \bigbreak \noindent 
            \begin{htmlcode}
                <svg width="200" height="200">
                    <g>
                        <!-- SVG elements go here -->
                    </g>
                </svg>
            \end{htmlcode}
            \bigbreak \noindent 
            Instead of transforming each element individually, you apply the transformation once to the group.
            \bigbreak \noindent 
            \begin{htmlcode}
                <g transform="translate(50, 50)">
                    <circle cx="0" cy="0" r="20" />
                    <rect x="30" y="-10" width="40" height="20" />
                </g>
            \end{htmlcode}
            \bigbreak \noindent 
            Both shapes move together. You can apply styles such as fill, stroke, opacity, etc., to all child elements.
            \bigbreak \noindent 
            \begin{htmlcode}
                <g fill="blue" stroke="black" stroke-width="2">
                    <circle cx="50" cy="50" r="20" />
                    <rect x="90" y="30" width="40" height="40" />
                </g>
            \end{htmlcode}
            \bigbreak \noindent 
            Events applied to a <g> affect all child elements.
            \bigbreak \noindent 
            \begin{htmlcode}
                <g onclick="alert('Clicked group!')">
                    <circle cx="50" cy="50" r="20" />
                    <rect x="80" y="40" width="30" height="30" />
                </g>
            \end{htmlcode}
    \end{itemize}

    \pagebreak 
    \subsection{Observable}
    \begin{itemize}
        \item \textbf{Window}: Global variables can be defined with the global window object
            \bigbreak \noindent 
            \begin{jscode}
            window.data = ...
            \end{jscode}
            \bigbreak \noindent 
            Then, this property can be accessed in other cells.
        \item \textbf{Blocks}: In observable, multi-line javascript cells must be placed in a curly brace block
        \item \textbf{HTML templating}: Observable provides an html tag for writing HTML declaratively:
            \bigbreak \noindent 
            \begin{jscode}
            html`<h1>Hello</h1>`
            \end{jscode}
            \begin{itemize}
                \item Returns a live DOM node, not a string.
                \item HTML is parsed immediately.
                \item Values inside \$\{...\} are safely interpolated.
            \end{itemize}
            In a multi statement (curly brace block), this node must be returned to be rendered.
            \bigbreak \noindent 
            To make a table dynamically with templating, 
            \bigbreak \noindent 
            \begin{jscode}
html`
  <table>
    <thead>
      <tr>
        <th>Year</th>
        <th>Weekday</th>
      </tr>
    </thead>
    <tbody>
      ${data.map(d => html`
        <tr>
          <td>${d.Year}</td>
          <td>${d.Weekday}</td>
        </tr>
      `)}
    </tbody>
  </table>
            \end{jscode}
            \bigbreak \noindent 
            Notice that html must be placed inside ticks.
    \end{itemize}

    \pagebreak 
    \subsection{JS}
    \begin{itemize}
        \item \textbf{Var, let, and const}:  
            \begin{itemize}
                \item \textbf{Var}: Function-scoped, not block-scoped. Ignores \{\} blocks such as if, for, and while. Hoisted to the top of the function. Initialized as \textbf{undefined}. Can be reassigned ,can be redeclared
                \item \textbf{Let}: Block-scoped, exists only inside \{\} where it is defined. Hoisted, but not initialized. Exists in the Temporal Dead Zone (TDZ) until declared. Can be reassigned ,cannot be redeclared in the same scope
                    \bigbreak \noindent 
                    \begin{jscode}
                        let x = 3;
                        x = 4;     // OK
                        let x = 5; // Error
                    \end{jscode}
                \item \textbf{Const}: Block-scoped, same as let. Hoisted but in the TDZ. Must be initialized at declaration
                    \bigbreak \noindent 
                    \begin{jscode}
                    const z  = 10; // Good
                    const y;       // Error
                    \end{jscode}
                    \bigbreak \noindent 
                    Cannot be reassigned. Const prevents reassignment, not mutation.
            \end{itemize}
                \item \textbf{Immutable types}: These cannot be changed after creation. Any “modification” creates a new value. Primitive Types are all immutable 
                    \begin{itemize}
                        \item number	
                        \item string
                        \item boolean
                        \item null	
                        \item undefined	
                        \item symbol
                        \item bigint
                    \end{itemize}
                    \bigbreak \noindent 
                    \begin{jscode}
                        let s = "hello";
                        s[0] = "H";   // No effect
                        console.log(s); // "hello"
                    \end{jscode}
                \item \textbf{Mutable types}:  These are objects and collections, whose contents can change without changing the reference.
                    \begin{itemize}
                        \item Object	
                        \item Array	
                        \item Function	
                        \item Date	
                        \item Map / Set
                    \end{itemize}
                \item \textbf{Pass by value and pass by reference}: JavaScript does not technically have pass-by-reference.
                    \begin{itemize}
                        \item Primitive values are passed by value
                        \item Objects are passed by value of their reference
                    \end{itemize}
                    All primitives are passed by value. 
                    \bigbreak \noindent 
                    Objects are somewhat passed by reference, technically by value of reference. The reference (memory address) is copied, not the object itself.
                    \bigbreak \noindent 
                    \begin{jscode}
                        function modify(obj) {
                            obj.x = 10;
                        }

                        const data = { x: 1 };
                        modify(data);

                        console.log(data.x); // 10
                    \end{jscode}
                    \begin{itemize}
                        \item data holds a reference to the object
                        \item That reference is copied into obj
                        \item Both point to the same object
                        \item Mutating the object affects both
                    \end{itemize}
                \item \textbf{Objects}: Key value pairs
                    \bigbreak \noindent 
                    \begin{jscode}
                        var obj = {x: 2, y: 4}; obj.x = 3; obj.y = 5;
                    \end{jscode}
                    \bigbreak \noindent 
                    Prototypes for instance functions. We can access properties via dot notation or [] notation. Objects may also contain functions
                    \bigbreak \noindent 
                    \begin{jscode}
                        var student = {firstName: "John",
                            lastName: "Smith",
                            fullName: function() { return this.firstName + " " + this.lastName; }};
                        student.fullName()
                    \end{jscode}
                    \bigbreak \noindent 
                    \textbf{Note:} Dot-notation only works with certain identifiers, bracket notation works with more identifiers, like if the key was a string.
                \item \textbf{JSON}: Data interchange format, subset of JS. Uses nested objects and arrays. Data only, no functions.
                \item \textbf{Functional programming in JS}
                \item \textbf{Unary plus operator}: The unary plus (+) operator precedes its operand and evaluates to its operand but attempts to convert it into a number, if it isn't already.
                \item \textbf{Map, filter, and reduce}: 
                    \begin{itemize}
                        \item \textbf{Map}: map transforms each element of an array using a callback function and returns a new array of the same length. It is a pure transformation; the original array is not modified.
                            \bigbreak \noindent 
                            \begin{jscode}
                            arr.map((element, index, array) => newElement) -> Array
                            \end{jscode}
                        \item \textbf{Filter}: filter selects a subset of elements based on a predicate function and returns a new array containing only those elements for which the predicate evaluates to true.
                            \bigbreak \noindent 
                            \begin{jscode}
                            arr.filter((element, index, array) => boolean) -> Array
                            \end{jscode}
                        \item \textbf{Reduce}: reduce aggregates an array into a single value by repeatedly combining elements using an accumulator function. It is the most general of the three operations.
                            \bigbreak \noindent 
                            \begin{jscode}
                                arr.reduce((accumulator, element, index, array) => newAccumulator, initialValue) -> any
                            \end{jscode}
                    \end{itemize}
                \item \textbf{forEach}: forEach executes a provided callback function once for each element of an array. It is intended for side effects, not for producing values.
                    \bigbreak \noindent 
                    \begin{jscode}
                    arr.forEach((element, index, array) => void) -> void
                    \end{jscode}
                \item \textbf{Object manipulation}
                    \begin{itemize}
                        \item \textbf{Deleting properties}: We use the delete operator
                            \bigbreak \noindent 
                            \begin{jscode}
                            delete person.age;
                            \end{jscode}
                    \end{itemize}
                \item \textbf{JS functions are objects}: We can assign properties to functions
                    \bigbreak \noindent 
                    \begin{jscode}
                    function f() {}

                    f.x = 10;
                    f.y = 15;
                    \end{jscode}

        \item \textbf{Creating html elements manually with JS (SVGs)}:
            \begin{itemize}
                \item \textbf{document.createElementNS}: We use create element to create new elements, to create a new svg element,
                    \bigbreak \noindent 
                    \begin{jscode}
                    const new_element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    \end{jscode}
                \item \textbf{setAttribute}: We can set attributes on our element with setAttribute
                    \bigbreak \noindent 
                    \begin{jscode}
                    new_element.setAttribute(name: string, value);
                    \end{jscode}
                \item \textbf{appendChild}: We use append child to append child to a root node in our document tree
                    \bigbreak \noindent 
                    \begin{jscode}
                        root_element.appendChild(new_element);
                    \end{jscode}
                \item \textbf{createTextNode(value)}: Creates a plain text node
                    \bigbreak \noindent 
                    \begin{jscode}
                    root_element.appendChild(document.createTextNode("Hello world"));
                    \end{jscode}
            \end{itemize}
        \item \textbf{General JS to create HTML dynamically}: 
            \begin{itemize}
                \item \textbf{document.createElement(tagName)}: Creates a new DOM element but does not place it in the document.
                    \bigbreak \noindent 
                    \begin{jscode}
                    const div = document.createElement("div");
                    \end{jscode}
                \item \textbf{document.createTextNode(text)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                        const text = document.createTextNode("Hello world");
                        div.appendChild(text);
                    \end{jscode}
                \item \textbf{element.textContent}: Assigns or retrieves text content (preferred in most cases).
                    \bigbreak \noindent 
                    \begin{jscode}
                    div.textContent = "Hello world";
                    \end{jscode}
                \item \textbf{div.setAttribute("class", "container")}:
                    \bigbreak \noindent 
                    \begin{jscode}
                    div.setAttribute("class", "container");
                    \end{jscode}
                \item \textbf{getAttribute(name)}:
                \item \textbf{removeAttribute(name)}:
                \item \textbf{hasAttribute(name)}: 
                \item \textbf{parent.appendChild(child)}: Appends as the last child.
                    \bigbreak \noindent 
                    \begin{jscode}
                    document.body.appendChild(div);
                    \end{jscode}
                \item \textbf{parent.insertBefore(newNode, referenceNode)}: Inserts at a specific position.
                    \bigbreak \noindent 
                    \begin{jscode}
                    parent.insertBefore(div, parent.firstChild);
                    \end{jscode}
                \item \textbf{element.append(...)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                    document.body.append(div);
                    \end{jscode}
                \item \textbf{element.prepend(...):}
                \item \textbf{element.before(...):}
                \item \textbf{element.after(...)}:
                \item \textbf{element.innerHTML}: Parses an HTML string and replaces the element’s contents.
                    \bigbreak \noindent 
                    \begin{jscode}
                        div.innerHTML = "<strong>Hello</strong>";
                    \end{jscode}
                \item \textbf{document.getElementById(id)}:
                \item \textbf{document.querySelector(cssSelector)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                        const container = document.querySelector(".container");
                        container.append(div);
                    \end{jscode}
                \item \textbf{document.querySelectorAll(cssSelector)}:
                \item \textbf{element.cloneNode(deep)}: Copies an element.
                    \bigbreak \noindent 
                    \begin{jscode}
                    const copy = div.cloneNode(true);
                    \end{jscode}
                \item \textbf{element.addEventListener(type, handler)}:
                    \bigbreak \noindent 
                    \begin{jscode}
                    button.addEventListener("click", handleClick);
                    \end{jscode}
            \end{itemize}
        \item \textbf{Direct property assignment (often cleaner and safer):}
            \bigbreak \noindent 
            \begin{jscode}
                div.id = "main";
                div.className = "container";
            \end{jscode}
        \item \textbf{Element properties}: 
            \begin{itemize}
                \item \textbf{id}: Unique element identifier
                \item \textbf{className}: Space-separated CSS classes
                \item \textbf{classList}: Token-based class API (add, remove, toggle)
                \item \textbf{tagName}: Uppercase tag name (read-only)
                \item \textbf{nodeName}: Same as tagName for elements
                \item \textbf{nodeType}: Numeric node type (1 = Element)
                \item \textbf{style}: Inline style object
                \item \textbf{hidden}: Shortcut for display: none
            \end{itemize}


    \end{itemize}

    \pagebreak 
    \unsect{D3}
    \begin{itemize}
        \item \textbf{Data-driven documents}: D3.js (Data-Driven Documents) is a JavaScript library for producing dynamic, interactive data visualizations in web browsers using standard web technologies — primarily HTML, SVG, and CSS. Unlike charting libraries that provide predefined plots, D3 is a low-level visualization toolkit that gives fine-grained control over how data maps to visual elements.
            \bigbreak \noindent 
            D3’s central abstraction is that data drives document structure. You associate data with elements on a page, and D3 computes what should be created, updated, or removed.
            \bigbreak \noindent 
            Conceptually,
            \begin{center}
                Data $\to$ Visual elements
            \end{center}
        \item \textbf{Key features}: 
            \begin{itemize}
                \item Supports data as a core piece of Web elements
                    \begin{itemize}
                        \item Loading data
                        \item Dealing with changing data (joins, enter/update/exit)
                        \item Correspondence between data and DOM elements               
                    \end{itemize}
                \item Selections (similar to CSS) that allow greater manipulation
                \item Method chaining
                \item Integrated layout algorithms
                \item Focus on interaction support
            \end{itemize}
        \item \textbf{Data Binding (Selections)}: D3 can bind arrays or objects directly to DOM elements.
            \bigbreak \noindent 
            \begin{jscode}
                d3.selectAll("p")
                .data([10, 20, 30])
                .text(d => d);
            \end{jscode}
            \bigbreak \noindent 
            This replaces each paragraph’s text with the corresponding data value.
        \item \textbf{Select and selectAll}:
            \begin{itemize}
                \item \textbf{d3.select(selector)}: Selects the first element that matches the specified selector string. If no elements match the selector, returns an empty selection. If multiple elements match the selector, only the first matching element (in document order) will be selected. 
                    \bigbreak \noindent 
                    If the selector is not a string, instead selects the specified node; this is useful if you already have a reference to a node
                \item \textbf{selection.select(selector)}: For each selected element, selects the first descendant element that matches the specified selector string
                    \bigbreak \noindent 
                    If the selector is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes),
                \item \textbf{d3.selectAll(selector)}: Selects all elements that match the specified selector string. The elements will be selected in document order (top-to-bottom). If no elements in the document match the selector, or if the selector is null or undefined, returns an empty selection.
                    \bigbreak \noindent 
                    If the selector is not a string, instead selects the specified array of nodes
                \item \textbf{selection.selectAll(selector)}: For each selected element, selects the descendant elements that match the specified selector string. The elements in the returned selection are grouped by their corresponding parent node in this selection.
            \end{itemize}
        \item \textbf{selection.selectAll with function example}
            \bigbreak \noindent 
            \begin{jscode}
                function run5b(svg) {
                    // arrow functions
                    svg.selectAll("rect")
                        .attr("x", 0)
                        .attr("y", (d,i) => i*90+50)
                        .attr("width", (d,i) => i*150+100)
                        .attr("height", 20)
                        .style("fill", "steelblue")  
                }
            \end{jscode}
        \item \textbf{Enter-update-exit pattern}: When data size changes, D3 determines
            \begin{itemize}
                \item \textbf{Enter:} New data $\to $ create elements
                \item \textbf{Update:} Existing data $\to $ modify elements
                \item \textbf{Exit:} Removed data $\to$ delete elements
            \end{itemize}
        \item \textbf{Changing attributes}: 
            \bigbreak \noindent 
            \begin{jscode}
            var r1 = svg.select("rect").attr("width", 100).attr("height", 100);
            \end{jscode}
        \item \textbf{Changing styles}: 
            \bigbreak \noindent 
            \begin{jscode}
            var r1 = svg.select("rect").style("fill", "blue"); 
            \end{jscode}
        \item \textbf{Binding data}: We use
            \bigbreak \noindent 
            \begin{jscode}
                selection.data(data: arr, key?: fn)
            \end{jscode}
            \bigbreak \noindent 
            Binds the specified array of data with the selected elements, returning a new selection that represents the update selection: the elements successfully bound to data. Also defines the enter and exit selections on the returned selection, which can be used to add or remove elements to correspond to the new data.
            \bigbreak \noindent 
            the key parameter in .data(data, key) specifies how data items are matched to existing DOM elements during a data join.
            \bigbreak \noindent 
            If we write
            \bigbreak \noindent 
            \begin{jscode}
            selection.data(data)
            \end{jscode}
            \bigbreak \noindent 
            D3 matches data to elements by index (position):
            \begin{itemize}
                \item First data item $\to$ first element
                \item Second $\to$ second
            \end{itemize}
            etc... With a key,
            \bigbreak \noindent 
            \begin{jscode}
            selection.data(data, key)
            \end{jscode}
            \bigbreak \noindent 
            D3 matches elements by identity, not position. The key function returns a unique identifier for each datum.
            \bigbreak \noindent 
            \begin{jscode}
            (d, i) => keyValue
            \end{jscode}
            \bigbreak \noindent 
            Suppose the data is
            \bigbreak \noindent 
            \begin{jscode}
            const data = [
                { id: 101, name: "Alice" },
                { id: 102, name: "Bob" }
            ];
            \end{jscode}
            \bigbreak \noindent 
            Then, the key could be 
            \bigbreak \noindent 
            \begin{jscode}
                svg.selectAll("circle")
                .data(data, d => d.id);
            \end{jscode}
            \bigbreak \noindent 
            D3 now tracks circles by id, not position.
        \item \textbf{The enter selection}: In D3, the enter selection represents data items that do not yet have corresponding DOM elements. It is the mechanism by which new visual elements are created when the dataset grows. 
            \bigbreak \noindent 
            After a data join,
            \bigbreak \noindent 
            \begin{jscode}
            const sel = selction.data(data);
            \end{jscode}
            \bigbreak \noindent 
            D3 partitions the result into three disjoint subsets
            \begin{itemize}
                \item Update — data matched to existing elements
                \item Enter — data with no element yet
                \item Exit — elements with no data anymore
            \end{itemize}
            \bigbreak \noindent 
            .enter() returns a special selection containing placeholder nodes — not actual DOM elements. Each placeholder corresponds to one new data item. You cannot style or position them until you append real elements.
            \bigbreak \noindent 
            \begin{jscode}
                selection.data(data)
                    .enter()
                    .append("circle");
            \end{jscode}
            \bigbreak \noindent 
            “For each new datum, create a new <circle> element.”
            \bigbreak \noindent 
            \begin{jscode}
            function run8(svg) {
                var selection = svg.selectAll("rect")
                .data([127, 61, 256, 71])

                selection
                    .attr("x", 0)
                    .attr("y", (d,i) => i*90+50)
                    .attr("width", d => d)
                    .attr("height", 20)
                    .style("fill", "steelblue")

                selection.enter().append("rect")
                    .attr("x", 10) // let's just put it somewhere
                    .attr("y", 10)
                    .attr("width", 30)
                    .attr("height", 30)
                    .style("fill", "green")
            }
            \end{jscode}
        \item \textbf{Appending}: 
            \bigbreak \noindent 
            \begin{jscode}
            selection.append(type)
            \end{jscode}
            \bigbreak \noindent 
            If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an enter selection. The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data
            \bigbreak \noindent 
            If the specified type is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with \textit{this} as the current DOM element (nodes[i]). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) 
        \item \textbf{Inserting}: 
            \bigbreak \noindent 
            \begin{jscode}
            selection.insert(type, before?)
            \end{jscode}
            \bigbreak \noindent 
            If the specified type is a string, inserts a new element of this type (tag name) before the first element matching the specified before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child. If before is not specified, it defaults to null.
        \item \textbf{Merge}: .merge() combines two selections into one — most commonly the enter selection and the update selection — so that you can apply the same operations to both newly created and already existing elements.
            \bigbreak \noindent 
            \begin{jscode}
                function run10(svg) {
                    var selection = svg.selectAll("rect")
                    .data([127, 61, 256, 71]);

                    selection.enter().append("rect")
                        .merge(selection)
                        .attr("x", 0)
                        .attr("y", (d,i) => i*90+50)
                        .attr("width", d => d)
                        .attr("height", 20)
                        .style("fill", "steelblue");
                }
            \end{jscode}
            \bigbreak \noindent 
            Here, the enter section is merged with the update section.
        \item \textbf{Join}: .join() is a high-level method that performs the complete data join lifecycle — handling enter, update, and exit selections in a single operation. It is the modern replacement for the classic pattern using .enter(), .merge(), and .exit().
            \bigbreak \noindent 
            Formally, .join() orchestrates:
            \begin{itemize}
                \item Creation of elements for new data (enter)
                \item Updating of existing elements (update)
                \item Removal of obsolete elements (exit)
            \end{itemize}
            \bigbreak \noindent 
            \begin{jscode}
                selection.data(data).join("tag")
            \end{jscode}
            \bigbreak \noindent 
            For example, 
            \bigbreak \noindent 
            \begin{jscode}
                svg.selectAll("circle")
                    .data(data)
                    .join("circle");
            \end{jscode}
            \bigbreak \noindent 
            For each data item, ensure there is exactly one <circle> element.
            \bigbreak \noindent 
            Internally:
            \begin{itemize}
                \item Enter $\to $ append <circle>
                \item Update $\to $ keep existing circles
                \item Exit $\to$ remove extra circles
            \end{itemize}
            After .join(), you typically chain attribute setters:
            \bigbreak \noindent 
            \begin{jscode}
                svg.selectAll("circle")
                    .data(data)
                    .join("circle")
                    .attr("r", d => d);
            \end{jscode}
            \bigbreak \noindent 
            The selector in selectAll() determines which existing elements participate in the join; the tag in .join() determines what new elements are created.
            \bigbreak \noindent 
            This affects both newly created and existing elements. This simplifies the classic no-join pattern
            \bigbreak \noindent 
            \begin{jscode}
                const update = svg.selectAll("circle") .data(data);

                update.enter()
                    .append("circle")
                    .merge(update)
                    .attr("r", d => d);

                update.exit().remove();
            \end{jscode}
            \bigbreak \noindent 
            For 
            \bigbreak \noindent 
            \begin{jscode}
                svg.selectAll("rect")
                    .data(data)
                    .join("circle");
            \end{jscode}
            \bigbreak \noindent 
            \begin{itemize}
                \item \textbf{Update selection}: Existing <rect> elements are matched to data
                    \bigbreak \noindent 
                    They remain <rect> elements (they are not converted)
                \item \textbf{Enter selection}: For new data items, D3 creates <circle> elements
                \item \textbf{Exit selection}: Extra <rect> elements (without data) are removed
            \end{itemize}
        \item \textbf{.join with function parameters}: .join also has two optional parameters \texttt{update} and \texttt{exit}, specifying functions to call on update and exit. Note that the enter parameter can also be a function, and as is called for enter.
            \bigbreak \noindent 
            \begin{jscode}
            svg.selectAll("rect")
            .data([127, 61, 256, 71])
            .join(enter => enter.append("rect")
                   .attr("x", 200)
                   .attr("y", 200)
                   .attr("width", 10)
                   .attr("height", 10)
                   .style("fill", "red")
                   .call(update_bars),
                 update => update.call(update_bars),
                 exit => exit.attr("opacity", 1)
                   .transition()
                   .duration(3000)
                   .attr("opacity", 0)
                   .remove());
            \end{jscode}
        \item \textbf{Remove}: 
            \bigbreak \noindent 
            \begin{jscode}
            selection.remove()
            \end{jscode}
            \bigbreak \noindent 
            Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the DOM. There is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.
        \item \textbf{Exit}: The .exit() selection represents DOM elements that no longer have corresponding data after a data join.
            \bigbreak \noindent 
            \begin{jscode}
                sel.exit()
            \end{jscode}
            \bigbreak \noindent 
            returns a selection of actual DOM nodes (unlike enter placeholders) that are now obsolete. These nodes still exist in the DOM until you remove them.
            \bigbreak \noindent 
            \begin{jscode}
            sel.exit().remove();
            \end{jscode}
            \bigbreak \noindent 
            Is most commonly used, removes all elements that no longer represent any data.
        \item \textbf{Transition}:
            \bigbreak \noindent 
            \begin{jscode}
                selection.transition(name?)
            \end{jscode}
            \bigbreak \noindent 
            Returns a new transition on the given selection with the specified name. If a name is not specified, null is used. The new transition is only exclusive with other transitions of the same name.
            \bigbreak \noindent 
            selection.transition() initiates an animated transition on the selected elements, allowing their attributes, styles, or properties to change smoothly over time rather than instantaneously.
            \bigbreak \noindent 
            \begin{jscode}
                d3.select("circle")
                    .transition()
                    .attr("r", 50);
            \end{jscode}
            \bigbreak \noindent 
            Calling .transition():
            \begin{enumerate}
                \item Captures current state of each element
                \item Schedules animation frames
                \item Interpolates values over time
                \item Applies intermediate values continuously
            \end{enumerate}
            If nothing is specified, 
            \begin{itemize}
                \item \textbf{Duration:} 250 ms (approximate default)
                \item \textbf{Delay:} 0
                \item \textbf{Easing:} cubic in-out
            \end{itemize}
            We have the functions
            \bigbreak \noindent 
            \begin{jscode}
            .duration(ms), .delay(ms), .ease(fn)
            \end{jscode}
            \bigbreak \noindent 
            .ease() takes an ease function, for example d3.easeSin().
        \item \textbf{What can be animated}: Transitions interpolate numeric or color values. Common targets are
            \begin{itemize}
                \item SVG attributes (cx, r, x, y, etc.)
                \item CSS styles (opacity, fill, etc.)
                \item Text content (with special handling)
                \item Transforms
            \end{itemize}
        \item \textbf{Chaining Transitions}: You can sequence animations
            \bigbreak \noindent 
            \begin{jscode}
                .transition()
                .duration(500)
                .attr("r", 20)
                .transition()
                .duration(500)
                .attr("r", 5);
            \end{jscode}
            \bigbreak \noindent 
            Second transition begins after the first completes.
            \bigbreak \noindent 
            \begin{jscode}
                function run15(svg) {
                    var selection = svg.selectAll("rect")
                        .data([127, 61,256,128])

                    selection.enter().append("rect")
                            .attr("x", 200)
                            .attr("y", 200)
                            .attr("width", 10)
                            .attr("height", 10)
                            .style("fill", "red")
                        .merge(selection)
                        .transition()
                        .duration(3000)
                            .attr("x", 0)
                            .attr("y", (d,i) => i*10+50)
                            .attr("width", d => d)
                            .attr("height", 8)
                            .style("fill", "steelblue")
                            .transition()
                            .duration(3000)
                                .style("fill", "green")
                                .attr("width", d => d*1.5)

                    selection.exit()
                        .attr("opacity", 1)
                        .transition()
                        .duration(3000)
                            .attr("opacity", 0)
                            .remove()
                }
            \end{jscode}
        \item \textbf{.call()}: .call() invokes a function on a selection (or transition) and passes that selection as the function’s argument.
            \bigbreak \noindent 
            \begin{jscode}
            selection.call(function, ...args?)
            \end{jscode}
            \bigbreak \noindent 
            \begin{jscode}
            selection.call(f);
            \end{jscode}
            \bigbreak \noindent 
            Is essentially the same as 
            \bigbreak \noindent 
            \begin{jscode}
            f(selection)
            \end{jscode}
            \bigbreak \noindent 
            but .call() returns the original selection, enabling chaining.
        \item \textbf{Data as the key}: Consider
            \bigbreak \noindent 
            \begin{jscode}
                .data(data, d => d); 
            \end{jscode}
            \bigbreak \noindent 
            So, the key is simply the datum value itself. The key function computes a unique key for each datum. It is appropriate when your data consists of primitive unique values, such as numbers or strings.
            \bigbreak \noindent 
            Consider the initial data
            \bigbreak \noindent 
            \begin{jscode}
                [1,2,3]
            \end{jscode}
            \bigbreak \noindent 
            Then, we update the data to 
            \bigbreak \noindent 
            \begin{jscode}
                [3,2,1]
            \end{jscode}
            \bigbreak \noindent 
            Without the key, D3 assumes
            \begin{itemize}
                \item Element 1 now represents 3
                \item Element 2 still represents 2
                \item Element 3 now represents 1
            \end{itemize}
            With $d \implies d$,  
            \begin{itemize}
                \item Element with key 3 already exists $\to$ move/update
                \item Element with key 2 $\to $ unchanged
                \item Element with key 1 $\to$ move/update
            \end{itemize}
        \item \textbf{Nested selections, grouping}: 
            \bigbreak \noindent 
            \begin{jscode}
                function run19(svg) {
                  var myData = [
                    [15, 20],
                    [40, 10],
                    [30, 27]
                  ]

                  // First selection (within svg)
                  var selA = svg.selectAll("g")
                    .data(myData)
                    .join("g")
                    // .attr("y", (d,i) => i*100 + 50)
                    .attr("transform", (d, i) => `translate(70,${i*100+50})`)
                    // backticks (``) denote template literal
                    // normal strings except that text inside ${...}
                    // is evaluated (can be js expression)!

                  // Second selection (within first selection)
                  var selB = selA.selectAll('circle')
                    .data(d => d)
                    .join("circle")
                    .attr("cx", (d, i) => i*80)
                    .attr("r", (d,i) => d)
                };
            \end{jscode}
        \item \textbf{Scaling}: In D3, scaling refers to mapping values from a data domain to a visual range — typically pixel positions, lengths, colors, or sizes. Raw data values usually do not correspond directly to screen coordinates.
            \bigbreak \noindent 
            Every D3 scale has two fundamental parts:
            \begin{enumerate}
                \item \textbf{Domain}:
                    \bigbreak \noindent 
                    \begin{jscode}
                        [min data, max data]
                    \end{jscode}
                \item \textbf{Range}
                    \bigbreak \noindent 
                    \begin{jscode}
                        [min pixel, max pixel]
                    \end{jscode}
            \end{enumerate}
            For example,
            \bigbreak \noindent 
            \begin{jscode}
                const x = d3.scaleLinear().domain([0,100]).range([0,500]);
            \end{jscode}
            \bigbreak \noindent 
            A scale is simply a function. Now, we can use it when defining $x,y$ attributes.
            \bigbreak \noindent 
            \begin{jscode}
            .attr("x", d => x(d));
            \end{jscode}
        \item \textbf{scaleLog and scaleBand}: A log scale maps data using a logarithmic function, instead of using a linear mapping
            \begin{align*}
                y = ax + b
            ,\end{align*}
            it uses a logarithmic one
            \begin{align*}
               y = a\log_{}{x} + b 
            .\end{align*}
            We use logarithmic scaling when data spans multiple orders of magnitude. A linear scale would compress small values and stretch large ones excessively.
            \bigbreak \noindent 
            \textbf{Note:} Be careful with the domain,
            \begin{align*}
                D(\log(x)) = (0, \infty)
            .\end{align*}
            We can also define the base of the logarithm
            \bigbreak \noindent 
            \begin{jscode}
            x.base(2);
            \end{jscode}
            \bigbreak \noindent 
            Log scales typically produce ticks at powers
            \bigbreak \noindent 
            d3.scaleBand() maps discrete categories to evenly spaced rectangular bands across a continuous range. It is the standard tool for bar charts. Categorical data has no numeric spacing.
            \bigbreak \noindent 
            \begin{jscode}
                const x = d3.scaleBand().domain(["A", "B", "C"]).range([0,300]);
            \end{jscode}
            \bigbreak \noindent 
            D3 divides the range into equal bands
            \begin{align*}
                A &\to 0-100 \\
                B &\to 100-200 \\
                C &\to 200-300
            .\end{align*}
            We get the bandwidth with \texttt{bandwidth()}
            \bigbreak \noindent 
            \begin{jscode}
            .attr("x", d=>x(d.category)).attr("width", x.bandwidth());
            \end{jscode}
            \bigbreak \noindent 
            We can add spacing between bars with 
            \bigbreak \noindent 
            \begin{jscode}
            x.padding(p)
            \end{jscode}
        \item \textbf{d3.max(), d3.min()}: Retrieves the max or min value from an iterablea. Unlike Math.max() and Math.min(), these methods ignores undefined values, which is useful for missing data.
        \item \textbf{d3.maxIndex(), d3.minIndex()}: Retrieves the index of the max or min value from an iterable.
        \item \textbf{Axes}:
            \begin{itemize}
                \item \textbf{axis(context)}: Render the axis to the given context, which may be either a selection of SVG containers (either SVG or G elements) or a corresponding transition.
                \item \textbf{d3.axisTop(scale)}: Constructs a new top-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn above the horizontal domain path.
                \item \textbf{d3.axisBottom(scale)}: Constructs a new bottom-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn below the horizontal domain path.
                \item \textbf{d3.axisLeft(scale)}: Constructs a new left-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the left of the vertical domain path.
                \item \textbf{d3.axisRight(scale)}: Constructs a new right-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the right of the vertical domain path.
                \item \textbf{axis.scale(scale?)}: If scale is specified, sets the scale and returns the axis. If scale is not specified, returns the current scale.
                \item \textbf{axis.ticks(args...)}: Sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator. The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted.
                    \bigbreak \noindent 
                    This method has no effect if the scale does not implement scale.ticks, as with band and point scales. To set the tick values explicitly, use axis.tickValues. To set the tick format explicitly, use axis.tickFormat.
                \item \textbf{axis.offset(offset?)}: If offset is specified, sets the offset to the specified value in pixels and returns the axis. If offset is not specified, returns the current offset which defaults to 0 on devices with a devicePixelRatio greater than 1, and 0.5px otherwise. This default offset ensures crisp edges on low-resolution devices.
                \item \textbf{axis.tickSize(size?)}: If size is specified, sets the inner and outer tick size to the specified value and returns the axis. If size is not specified, returns the current inner tick size, which defaults to 6.
                \item \textbf{exis.tickSizeInner(size?)}: 
                \item \textbf{axis.tickSizeOuter(size?)}:
                \item \textbf{axis.tickFormat(format?)}: If format is specified, sets the tick format function and returns the axis. If format is not specified, returns the current format function, which defaults to null. A null format indicates that the scale’s default formatter should be used, which is generated by calling scale.tickFormat. In this case, the arguments specified by axis.tickArguments are likewise passed to scale.tickFormat.
                    \bigbreak \noindent 
                    \begin{jscode}
                    axis.tickFormat(d3.format(",.0f"));
                    \end{jscode}
                    \bigbreak \noindent 
                    Formats integers with comma-grouping for thousands
                    \bigbreak \noindent 
                    More commonly, a format specifier is passed to axis.ticks
                    \bigbreak \noindent 
                    \begin{jscode}
                    axis.ticks(10, ",f")
                    \end{jscode}
                \item \textbf{axis.tickValues(values?)}: If a values iterable is specified, the specified values are used for ticks rather than using the scale’s automatic tick generator. If values is null, clears any previously-set explicit tick values and reverts back to the scale’s tick generator. If values is not specified, returns the current tick values, which defaults to null.
                \item \textbf{axis.tickPadding(padding?)}: If padding is specified, sets the padding to the specified value in pixels and returns the axis. If padding is not specified, returns the current padding which defaults to 3 pixels.
                \item \textbf{axis.tickArguments([args])}: If arguments is specified, sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator. The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted.
            \end{itemize}
        \item \textbf{The return value of axisTop() and others}: The return value is the generator function that builds the axis.
            \bigbreak \noindent 
            We can then call this generator passing in selectors so that an axis is built as a child of that selector.
        \item \textbf{Axis example}: 
            \bigbreak \noindent 
            \begin{jscode}
            // the scale function
            var xScale = d3.scaleLinear()
              .domain([0,d3.max(data)])
              .range([0,300]);

            var xAxis = d3.axisTop()
            xAxis.scale(xScale);
            svg.append("g").call(xAxis);
            \end{jscode}
            \bigbreak \noindent 
            Where 
            \bigbreak \noindent 
            \begin{jscode}
                svg.append("g").call(xAxis);
            \end{jscode}
            \bigbreak \noindent 
            means “Apply the axis generator to this <g> element, causing it to create ticks, labels, and lines inside it.”
        \item \textbf{Adding text}: 
            \bigbreak \noindent 
            \begin{jscode}
            selection.text(value?)
            \end{jscode}
            \bigbreak \noindent 
            If a value is specified, sets the text content to the specified value on all selected elements, replacing any existing child elements. If the value is a constant, then all elements are given the same text content; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s text content. A null value will clear the content.
            \bigbreak \noindent 
            If a value is not specified, returns the text content for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.
        \item \textbf{Inner html}: 
            \bigbreak \noindent 
            \begin{jscode}
            selection.html(value?)
            \end{jscode}
            \bigbreak \noindent 
            If a value is specified, sets the inner HTML to the specified value on all selected elements, replacing any existing child elements. If the value is a constant, then all elements are given the same inner HTML; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.
            \bigbreak \noindent 
            If a value is not specified, returns the inner HTML for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.










    \end{itemize}
    






















    
\end{document}
