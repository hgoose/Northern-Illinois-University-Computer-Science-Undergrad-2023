\contentsline {section}{\numberline {1}Theory of Computation}{3}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Natural Languages, Formal languages: Definitions and theorems}{3}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Regular languages}{6}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Finite Automata}{6}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Finite Automata: More examples}{13}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}Regular expressions}{14}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}nondeterministic Finite automata (NFA)}{24}{subsubsection.0.1.2.4}%
\contentsline {section}{\numberline {2}DSA}{38}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}C++ Stuff}{38}{subsection.0.2.1}%
\contentsline {subsubsection}{\numberline {2.1.1}Type declarations: Definitions and theorems}{38}{subsubsection.0.2.1.1}%
\contentsline {subsubsection}{\numberline {2.1.2}G++}{40}{subsubsection.0.2.1.2}%
\contentsline {subsubsection}{\numberline {2.1.3}STL Vectors}{42}{subsubsection.0.2.1.3}%
\contentsline {paragraph}{\numberline {2.1.3.1}Implementation}{42}{paragraph.0.2.1.3.1}%
\contentsline {paragraph}{\numberline {2.1.3.2}Performance in operations on the end}{42}{paragraph.0.2.1.3.2}%
\contentsline {paragraph}{\numberline {2.1.3.3}Size and capacity}{42}{paragraph.0.2.1.3.3}%
\contentsline {paragraph}{\numberline {2.1.3.4}Constructors}{43}{paragraph.0.2.1.3.4}%
\contentsline {paragraph}{\numberline {2.1.3.5}Note about at()}{43}{paragraph.0.2.1.3.5}%
\contentsline {paragraph}{\numberline {2.1.3.6}Iterator methods}{44}{paragraph.0.2.1.3.6}%
\contentsline {subsubsection}{\numberline {2.1.4}STL Deque}{45}{subsubsection.0.2.1.4}%
\contentsline {paragraph}{\numberline {2.1.4.1}Implementation}{45}{paragraph.0.2.1.4.1}%
\contentsline {paragraph}{\numberline {2.1.4.2}Abilities, performance, uses}{45}{paragraph.0.2.1.4.2}%
\contentsline {paragraph}{\numberline {2.1.4.3}When to use deques}{45}{paragraph.0.2.1.4.3}%
\contentsline {paragraph}{\numberline {2.1.4.4}Constructors}{46}{paragraph.0.2.1.4.4}%
\contentsline {subsubsection}{\numberline {2.1.5}STL Lists}{47}{subsubsection.0.2.1.5}%
\contentsline {paragraph}{\numberline {2.1.5.1}Implementation}{47}{paragraph.0.2.1.5.1}%
\contentsline {paragraph}{\numberline {2.1.5.2}Abilities}{47}{paragraph.0.2.1.5.2}%
\contentsline {paragraph}{\numberline {2.1.5.3}Differencs in the methods}{47}{paragraph.0.2.1.5.3}%
\contentsline {paragraph}{\numberline {2.1.5.4}Constructors}{48}{paragraph.0.2.1.5.4}%
\contentsline {paragraph}{\numberline {2.1.5.5}Element access}{48}{paragraph.0.2.1.5.5}%
\contentsline {paragraph}{\numberline {2.1.5.6}Iterator functions}{48}{paragraph.0.2.1.5.6}%
\contentsline {paragraph}{\numberline {2.1.5.7}Splice Functions and Functions to Change the Order of Elements}{49}{paragraph.0.2.1.5.7}%
\contentsline {subsubsection}{\numberline {2.1.6}STL Forward lists}{50}{subsubsection.0.2.1.6}%
\contentsline {paragraph}{\numberline {2.1.6.1}Implementation}{50}{paragraph.0.2.1.6.1}%
\contentsline {paragraph}{\numberline {2.1.6.2}Abilities, limitations}{50}{paragraph.0.2.1.6.2}%
\contentsline {paragraph}{\numberline {2.1.6.3}No size()?}{50}{paragraph.0.2.1.6.3}%
\contentsline {paragraph}{\numberline {2.1.6.4}Similarities to list}{51}{paragraph.0.2.1.6.4}%
\contentsline {paragraph}{\numberline {2.1.6.5}Constructors}{51}{paragraph.0.2.1.6.5}%
\contentsline {subsubsection}{\numberline {2.1.7}STL Sets and multisets}{53}{subsubsection.0.2.1.7}%
\contentsline {paragraph}{\numberline {2.1.7.1}Implementation}{53}{paragraph.0.2.1.7.1}%
\contentsline {paragraph}{\numberline {2.1.7.2}Strict weak ordering}{53}{paragraph.0.2.1.7.2}%
\contentsline {paragraph}{\numberline {2.1.7.3}Abilities}{54}{paragraph.0.2.1.7.3}%
\contentsline {paragraph}{\numberline {2.1.7.4}Changing elements directly, no direct element access}{54}{paragraph.0.2.1.7.4}%
\contentsline {paragraph}{\numberline {2.1.7.5}Constructors}{54}{paragraph.0.2.1.7.5}%
\contentsline {paragraph}{\numberline {2.1.7.6}Types}{55}{paragraph.0.2.1.7.6}%
\contentsline {subsubsection}{\numberline {2.1.8}STL Maps and multimaps}{56}{subsubsection.0.2.1.8}%
\contentsline {paragraph}{\numberline {2.1.8.1}Implementation}{56}{paragraph.0.2.1.8.1}%
\contentsline {paragraph}{\numberline {2.1.8.2}Template parameters}{56}{paragraph.0.2.1.8.2}%
\contentsline {paragraph}{\numberline {2.1.8.3}Abilities}{56}{paragraph.0.2.1.8.3}%
\contentsline {paragraph}{\numberline {2.1.8.4}Constructors and types}{57}{paragraph.0.2.1.8.4}%
\contentsline {paragraph}{\numberline {2.1.8.5}Using maps as associative arrays}{58}{paragraph.0.2.1.8.5}%
\contentsline {subsubsection}{\numberline {2.1.9}STL Unordered containers}{59}{subsubsection.0.2.1.9}%
\contentsline {subsubsection}{\numberline {2.1.10}STL Containers: Implementations}{60}{subsubsection.0.2.1.10}%
\contentsline {subsubsection}{\numberline {2.1.11}STL Containers: Iterator Functions}{61}{subsubsection.0.2.1.11}%
\contentsline {subsubsection}{\numberline {2.1.12}STL containers: Main concepts, differences, uses}{62}{subsubsection.0.2.1.12}%
\contentsline {subsubsection}{\numberline {2.1.13}STL Containers: Iterator invalidation}{64}{subsubsection.0.2.1.13}%
\contentsline {subsubsection}{\numberline {2.1.14}STL Containers: Reallocation}{65}{subsubsection.0.2.1.14}%
\contentsline {subsubsection}{\numberline {2.1.15}STL Containers: Element access}{66}{subsubsection.0.2.1.15}%
\contentsline {subsubsection}{\numberline {2.1.16}STL Containers: Uses and advantages}{67}{subsubsection.0.2.1.16}%
\contentsline {subsubsection}{\numberline {2.1.17}STL Iterators}{68}{subsubsection.0.2.1.17}%
\contentsline {section}{\numberline {3}Databases}{72}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Introduction to databases (db concepts)}{72}{subsection.0.3.1}%
\contentsline {subsubsection}{\numberline {3.1.1}Definitions and theorems}{72}{subsubsection.0.3.1.1}%
\contentsline {subsection}{\numberline {3.2}Conceptual Modeling and ER Diagrams}{78}{subsection.0.3.2}%
\contentsline {subsubsection}{\numberline {3.2.1}Definitions and theorems}{78}{subsubsection.0.3.2.1}%
\contentsline {subsection}{\numberline {3.3}The Relational Model}{87}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Relational Model Normalization}{89}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}ERD to Relations (Conceptual to logical)}{97}{subsection.0.3.5}%
