\contentsline {section}{\numberline {1}Theory of Computation}{4}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Natural Languages, Formal languages: Definitions and theorems}{4}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Regular languages}{7}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Finite Automata}{7}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Finite Automata: More examples}{14}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}nondeterministic Finite automata (NFA)}{15}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}Regular expressions}{26}{subsubsection.0.1.2.4}%
\contentsline {subsubsection}{\numberline {1.2.5}Properties of regular languages}{40}{subsubsection.0.1.2.5}%
\contentsline {section}{\numberline {2}DSA}{43}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}C++ Stuff}{43}{subsection.0.2.1}%
\contentsline {subsubsection}{\numberline {2.1.1}Type declarations: Definitions and theorems}{43}{subsubsection.0.2.1.1}%
\contentsline {subsubsection}{\numberline {2.1.2}G++}{45}{subsubsection.0.2.1.2}%
\contentsline {subsubsection}{\numberline {2.1.3}STL Vectors}{47}{subsubsection.0.2.1.3}%
\contentsline {paragraph}{\numberline {2.1.3.1}Implementation}{47}{paragraph.0.2.1.3.1}%
\contentsline {paragraph}{\numberline {2.1.3.2}Performance in operations on the end}{47}{paragraph.0.2.1.3.2}%
\contentsline {paragraph}{\numberline {2.1.3.3}Size and capacity}{47}{paragraph.0.2.1.3.3}%
\contentsline {paragraph}{\numberline {2.1.3.4}Constructors}{48}{paragraph.0.2.1.3.4}%
\contentsline {paragraph}{\numberline {2.1.3.5}Note about at()}{48}{paragraph.0.2.1.3.5}%
\contentsline {paragraph}{\numberline {2.1.3.6}Iterator methods}{49}{paragraph.0.2.1.3.6}%
\contentsline {subsubsection}{\numberline {2.1.4}STL Deque}{50}{subsubsection.0.2.1.4}%
\contentsline {paragraph}{\numberline {2.1.4.1}Implementation}{50}{paragraph.0.2.1.4.1}%
\contentsline {paragraph}{\numberline {2.1.4.2}Abilities, performance, uses}{50}{paragraph.0.2.1.4.2}%
\contentsline {paragraph}{\numberline {2.1.4.3}When to use deques}{50}{paragraph.0.2.1.4.3}%
\contentsline {paragraph}{\numberline {2.1.4.4}Constructors}{51}{paragraph.0.2.1.4.4}%
\contentsline {subsubsection}{\numberline {2.1.5}STL Lists}{52}{subsubsection.0.2.1.5}%
\contentsline {paragraph}{\numberline {2.1.5.1}Implementation}{52}{paragraph.0.2.1.5.1}%
\contentsline {paragraph}{\numberline {2.1.5.2}Abilities}{52}{paragraph.0.2.1.5.2}%
\contentsline {paragraph}{\numberline {2.1.5.3}Differencs in the methods}{52}{paragraph.0.2.1.5.3}%
\contentsline {paragraph}{\numberline {2.1.5.4}Constructors}{53}{paragraph.0.2.1.5.4}%
\contentsline {paragraph}{\numberline {2.1.5.5}Element access}{53}{paragraph.0.2.1.5.5}%
\contentsline {paragraph}{\numberline {2.1.5.6}Iterator functions}{53}{paragraph.0.2.1.5.6}%
\contentsline {paragraph}{\numberline {2.1.5.7}Splice Functions and Functions to Change the Order of Elements}{54}{paragraph.0.2.1.5.7}%
\contentsline {subsubsection}{\numberline {2.1.6}STL Forward lists}{55}{subsubsection.0.2.1.6}%
\contentsline {paragraph}{\numberline {2.1.6.1}Implementation}{55}{paragraph.0.2.1.6.1}%
\contentsline {paragraph}{\numberline {2.1.6.2}Abilities, limitations}{55}{paragraph.0.2.1.6.2}%
\contentsline {paragraph}{\numberline {2.1.6.3}No size()?}{55}{paragraph.0.2.1.6.3}%
\contentsline {paragraph}{\numberline {2.1.6.4}Similarities to list}{56}{paragraph.0.2.1.6.4}%
\contentsline {paragraph}{\numberline {2.1.6.5}Constructors}{56}{paragraph.0.2.1.6.5}%
\contentsline {subsubsection}{\numberline {2.1.7}STL Sets and multisets}{58}{subsubsection.0.2.1.7}%
\contentsline {paragraph}{\numberline {2.1.7.1}Implementation}{58}{paragraph.0.2.1.7.1}%
\contentsline {paragraph}{\numberline {2.1.7.2}Strict weak ordering}{58}{paragraph.0.2.1.7.2}%
\contentsline {paragraph}{\numberline {2.1.7.3}Abilities}{59}{paragraph.0.2.1.7.3}%
\contentsline {paragraph}{\numberline {2.1.7.4}Changing elements directly, no direct element access}{59}{paragraph.0.2.1.7.4}%
\contentsline {paragraph}{\numberline {2.1.7.5}Constructors}{59}{paragraph.0.2.1.7.5}%
\contentsline {paragraph}{\numberline {2.1.7.6}Types}{60}{paragraph.0.2.1.7.6}%
\contentsline {subsubsection}{\numberline {2.1.8}STL Maps and multimaps}{61}{subsubsection.0.2.1.8}%
\contentsline {paragraph}{\numberline {2.1.8.1}Implementation}{61}{paragraph.0.2.1.8.1}%
\contentsline {paragraph}{\numberline {2.1.8.2}Template parameters}{61}{paragraph.0.2.1.8.2}%
\contentsline {paragraph}{\numberline {2.1.8.3}Abilities}{61}{paragraph.0.2.1.8.3}%
\contentsline {paragraph}{\numberline {2.1.8.4}Constructors and types}{62}{paragraph.0.2.1.8.4}%
\contentsline {paragraph}{\numberline {2.1.8.5}Using maps as associative arrays}{63}{paragraph.0.2.1.8.5}%
\contentsline {subsubsection}{\numberline {2.1.9}STL Unordered containers}{64}{subsubsection.0.2.1.9}%
\contentsline {subsubsection}{\numberline {2.1.10}STL Containers: Implementations}{65}{subsubsection.0.2.1.10}%
\contentsline {subsubsection}{\numberline {2.1.11}STL Containers: Iterator Functions}{66}{subsubsection.0.2.1.11}%
\contentsline {subsubsection}{\numberline {2.1.12}STL containers: Main concepts, differences, uses}{67}{subsubsection.0.2.1.12}%
\contentsline {subsubsection}{\numberline {2.1.13}STL Containers: Iterator invalidation}{69}{subsubsection.0.2.1.13}%
\contentsline {subsubsection}{\numberline {2.1.14}STL Containers: Reallocation}{70}{subsubsection.0.2.1.14}%
\contentsline {subsubsection}{\numberline {2.1.15}STL Containers: Element access}{71}{subsubsection.0.2.1.15}%
\contentsline {subsubsection}{\numberline {2.1.16}STL Containers: Uses and advantages}{72}{subsubsection.0.2.1.16}%
\contentsline {subsubsection}{\numberline {2.1.17}STL Iterators}{73}{subsubsection.0.2.1.17}%
\contentsline {subsubsection}{\numberline {2.1.18}STL Function Objects}{77}{subsubsection.0.2.1.18}%
\contentsline {paragraph}{\numberline {2.1.18.1}Why?}{77}{paragraph.0.2.1.18.1}%
\contentsline {paragraph}{\numberline {2.1.18.2}Predefined function objects}{78}{paragraph.0.2.1.18.2}%
\contentsline {section}{\numberline {3}Databases}{79}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Introduction to databases (db concepts)}{79}{subsection.0.3.1}%
\contentsline {subsubsection}{\numberline {3.1.1}Definitions and theorems}{79}{subsubsection.0.3.1.1}%
\contentsline {subsection}{\numberline {3.2}Conceptual Modeling and ER Diagrams}{85}{subsection.0.3.2}%
\contentsline {subsubsection}{\numberline {3.2.1}Definitions and theorems}{85}{subsubsection.0.3.2.1}%
\contentsline {subsection}{\numberline {3.3}The Relational Model}{94}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Relational Model Normalization}{96}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}ERD to Relations (Conceptual to logical)}{104}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}MariaDB, SQL}{111}{subsection.0.3.6}%
