\contentsline {section}{\numberline {1}Theory of Computation}{3}{section.0.1}%
\contentsline {subsection}{\numberline {1.1}Natural Languages, Formal languages: Definitions and theorems}{3}{subsection.0.1.1}%
\contentsline {subsection}{\numberline {1.2}Regular languages}{6}{subsection.0.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}Finite Automata}{6}{subsubsection.0.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}Finite Automata: More examples}{13}{subsubsection.0.1.2.2}%
\contentsline {subsubsection}{\numberline {1.2.3}nondeterministic Finite automata (NFA)}{14}{subsubsection.0.1.2.3}%
\contentsline {subsubsection}{\numberline {1.2.4}Regular expressions}{25}{subsubsection.0.1.2.4}%
\contentsline {section}{\numberline {2}DSA}{39}{section.0.2}%
\contentsline {subsection}{\numberline {2.1}C++ Stuff}{39}{subsection.0.2.1}%
\contentsline {subsubsection}{\numberline {2.1.1}Type declarations: Definitions and theorems}{39}{subsubsection.0.2.1.1}%
\contentsline {subsubsection}{\numberline {2.1.2}G++}{41}{subsubsection.0.2.1.2}%
\contentsline {subsubsection}{\numberline {2.1.3}STL Vectors}{43}{subsubsection.0.2.1.3}%
\contentsline {paragraph}{\numberline {2.1.3.1}Implementation}{43}{paragraph.0.2.1.3.1}%
\contentsline {paragraph}{\numberline {2.1.3.2}Performance in operations on the end}{43}{paragraph.0.2.1.3.2}%
\contentsline {paragraph}{\numberline {2.1.3.3}Size and capacity}{43}{paragraph.0.2.1.3.3}%
\contentsline {paragraph}{\numberline {2.1.3.4}Constructors}{44}{paragraph.0.2.1.3.4}%
\contentsline {paragraph}{\numberline {2.1.3.5}Note about at()}{44}{paragraph.0.2.1.3.5}%
\contentsline {paragraph}{\numberline {2.1.3.6}Iterator methods}{45}{paragraph.0.2.1.3.6}%
\contentsline {subsubsection}{\numberline {2.1.4}STL Deque}{46}{subsubsection.0.2.1.4}%
\contentsline {paragraph}{\numberline {2.1.4.1}Implementation}{46}{paragraph.0.2.1.4.1}%
\contentsline {paragraph}{\numberline {2.1.4.2}Abilities, performance, uses}{46}{paragraph.0.2.1.4.2}%
\contentsline {paragraph}{\numberline {2.1.4.3}When to use deques}{46}{paragraph.0.2.1.4.3}%
\contentsline {paragraph}{\numberline {2.1.4.4}Constructors}{47}{paragraph.0.2.1.4.4}%
\contentsline {subsubsection}{\numberline {2.1.5}STL Lists}{48}{subsubsection.0.2.1.5}%
\contentsline {paragraph}{\numberline {2.1.5.1}Implementation}{48}{paragraph.0.2.1.5.1}%
\contentsline {paragraph}{\numberline {2.1.5.2}Abilities}{48}{paragraph.0.2.1.5.2}%
\contentsline {paragraph}{\numberline {2.1.5.3}Differencs in the methods}{48}{paragraph.0.2.1.5.3}%
\contentsline {paragraph}{\numberline {2.1.5.4}Constructors}{49}{paragraph.0.2.1.5.4}%
\contentsline {paragraph}{\numberline {2.1.5.5}Element access}{49}{paragraph.0.2.1.5.5}%
\contentsline {paragraph}{\numberline {2.1.5.6}Iterator functions}{49}{paragraph.0.2.1.5.6}%
\contentsline {paragraph}{\numberline {2.1.5.7}Splice Functions and Functions to Change the Order of Elements}{50}{paragraph.0.2.1.5.7}%
\contentsline {subsubsection}{\numberline {2.1.6}STL Forward lists}{51}{subsubsection.0.2.1.6}%
\contentsline {paragraph}{\numberline {2.1.6.1}Implementation}{51}{paragraph.0.2.1.6.1}%
\contentsline {paragraph}{\numberline {2.1.6.2}Abilities, limitations}{51}{paragraph.0.2.1.6.2}%
\contentsline {paragraph}{\numberline {2.1.6.3}No size()?}{51}{paragraph.0.2.1.6.3}%
\contentsline {paragraph}{\numberline {2.1.6.4}Similarities to list}{52}{paragraph.0.2.1.6.4}%
\contentsline {paragraph}{\numberline {2.1.6.5}Constructors}{52}{paragraph.0.2.1.6.5}%
\contentsline {subsubsection}{\numberline {2.1.7}STL Sets and multisets}{54}{subsubsection.0.2.1.7}%
\contentsline {paragraph}{\numberline {2.1.7.1}Implementation}{54}{paragraph.0.2.1.7.1}%
\contentsline {paragraph}{\numberline {2.1.7.2}Strict weak ordering}{54}{paragraph.0.2.1.7.2}%
\contentsline {paragraph}{\numberline {2.1.7.3}Abilities}{55}{paragraph.0.2.1.7.3}%
\contentsline {paragraph}{\numberline {2.1.7.4}Changing elements directly, no direct element access}{55}{paragraph.0.2.1.7.4}%
\contentsline {paragraph}{\numberline {2.1.7.5}Constructors}{55}{paragraph.0.2.1.7.5}%
\contentsline {paragraph}{\numberline {2.1.7.6}Types}{56}{paragraph.0.2.1.7.6}%
\contentsline {subsubsection}{\numberline {2.1.8}STL Maps and multimaps}{57}{subsubsection.0.2.1.8}%
\contentsline {paragraph}{\numberline {2.1.8.1}Implementation}{57}{paragraph.0.2.1.8.1}%
\contentsline {paragraph}{\numberline {2.1.8.2}Template parameters}{57}{paragraph.0.2.1.8.2}%
\contentsline {paragraph}{\numberline {2.1.8.3}Abilities}{57}{paragraph.0.2.1.8.3}%
\contentsline {paragraph}{\numberline {2.1.8.4}Constructors and types}{58}{paragraph.0.2.1.8.4}%
\contentsline {paragraph}{\numberline {2.1.8.5}Using maps as associative arrays}{59}{paragraph.0.2.1.8.5}%
\contentsline {subsubsection}{\numberline {2.1.9}STL Unordered containers}{60}{subsubsection.0.2.1.9}%
\contentsline {subsubsection}{\numberline {2.1.10}STL Containers: Implementations}{61}{subsubsection.0.2.1.10}%
\contentsline {subsubsection}{\numberline {2.1.11}STL Containers: Iterator Functions}{62}{subsubsection.0.2.1.11}%
\contentsline {subsubsection}{\numberline {2.1.12}STL containers: Main concepts, differences, uses}{63}{subsubsection.0.2.1.12}%
\contentsline {subsubsection}{\numberline {2.1.13}STL Containers: Iterator invalidation}{65}{subsubsection.0.2.1.13}%
\contentsline {subsubsection}{\numberline {2.1.14}STL Containers: Reallocation}{66}{subsubsection.0.2.1.14}%
\contentsline {subsubsection}{\numberline {2.1.15}STL Containers: Element access}{67}{subsubsection.0.2.1.15}%
\contentsline {subsubsection}{\numberline {2.1.16}STL Containers: Uses and advantages}{68}{subsubsection.0.2.1.16}%
\contentsline {subsubsection}{\numberline {2.1.17}STL Iterators}{69}{subsubsection.0.2.1.17}%
\contentsline {subsubsection}{\numberline {2.1.18}STL Function Objects}{73}{subsubsection.0.2.1.18}%
\contentsline {paragraph}{\numberline {2.1.18.1}Why?}{73}{paragraph.0.2.1.18.1}%
\contentsline {section}{\numberline {3}Databases}{75}{section.0.3}%
\contentsline {subsection}{\numberline {3.1}Introduction to databases (db concepts)}{75}{subsection.0.3.1}%
\contentsline {subsubsection}{\numberline {3.1.1}Definitions and theorems}{75}{subsubsection.0.3.1.1}%
\contentsline {subsection}{\numberline {3.2}Conceptual Modeling and ER Diagrams}{81}{subsection.0.3.2}%
\contentsline {subsubsection}{\numberline {3.2.1}Definitions and theorems}{81}{subsubsection.0.3.2.1}%
\contentsline {subsection}{\numberline {3.3}The Relational Model}{90}{subsection.0.3.3}%
\contentsline {subsection}{\numberline {3.4}Relational Model Normalization}{92}{subsection.0.3.4}%
\contentsline {subsection}{\numberline {3.5}ERD to Relations (Conceptual to logical)}{100}{subsection.0.3.5}%
\contentsline {subsection}{\numberline {3.6}MariaDB, SQL}{107}{subsection.0.3.6}%
