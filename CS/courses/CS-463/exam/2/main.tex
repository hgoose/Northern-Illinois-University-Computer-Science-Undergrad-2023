\documentclass{report}

\input{~/dev/latex/template/preamble.tex}
\input{~/dev/latex/template/macros.tex}

\title{\Huge{}}
\author{\huge{Nathan Warner}}
\date{\huge{}}
\fancyhf{}
\rhead{}
\fancyhead[R]{\itshape Warner} % Left header: Section name
\fancyhead[L]{\itshape\leftmark}  % Right header: Page number
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt} % Optional: Removes the header line
%\pagestyle{fancy}
%\fancyhf{}
%\lhead{Warner \thepage}
%\rhead{}
% \lhead{\leftmark}
%\cfoot{\thepage}
%\setborder
% \usepackage[default]{sourcecodepro}
% \usepackage[T1]{fontenc}

% Change the title
\hypersetup{
    pdftitle={Exam 1}
}

\begin{document}
    % \maketitle
        \begin{titlepage}
       \begin{center}
           \vspace*{1cm}
    
           \textbf{Exam 1}
    
           \vspace{0.5cm}
            
                
           \vspace{1.5cm}
    
           \textbf{Nathan Warner}
    
           \vfill
                
                
           \vspace{0.8cm}
         
           \includegraphics[width=0.4\textwidth]{~/niu/seal.png}
                
           Computer Science \\
           Northern Illinois University\\
           United States\\
           
                
       \end{center}
    \end{titlepage}
    \tableofcontents
    \unsect{Von Neumann model}
    \begin{itemize}
        \item \textbf{\textit{What is a stored-program computer? Why were they an improvement over plugboard machines?}}: A stored program computer is a computer that stores programs / instructions in memory, instead of using hardware / circuits to implement programs. By doing this, changing the program meant you didn't need to change the hardware. This meant more efficient computers, less time needed to change / write programs
            \bigbreak \noindent 
            A stored program computer has
            \begin{enumerate}
                \item CPU
                \item Main memory
                \item I/O
            \end{enumerate}
        \item \textbf{\textit{Who was John von Neumann? What is the relationship between stored-program computers and the von Neumann model? What is the relationship between the von Neumann model and the fetch-decode-execute cycle?}}: J.V.N was the inventor of the stored program computer (V.N model). The V.N model refers to stored program computers, computers that employ the fetch-decode-execute cycle
        \item \textbf{\textit{What is the von Neumann bottleneck? What is the relationship between the von Neumann bottleneck and the bus? How does having multiple processors help mitigate the von Neumann bottleneck?}}: The single data path between the CPU and main memory is the V.N bottleneck, the bus carries data from the CPU and main memory, i.e along the V.N bottleneck. Multiple processors helps mitigate the V.N bottleneck because work / memory requests are split amongst the processors. Adds parallelism, all the data is no longer waiting at a single processor.
    \end{itemize}

    \pagebreak 
    \unsect{Core architecture}
    \begin{itemize}
        \item \textit{What is the datapath? control unit? CPU? ALU? What is the relationship between them?}: \textbf{The datapath is one of the core parts of the CPU. The datapath consists of an ALU and registers that are connected by a data bus that is also connected to main memory}
            \bigbreak \noindent 
            \textbf{The control unit is the second core part of the CPU, the control unit provides signals that tell the CPU components what sequenced operations it should perform.}
            \bigbreak \noindent 
            \textbf{The CPU is the part of the computer that fetches, decodes, and executes program instructions, made up of control unit and datapath}
            \bigbreak \noindent 
            \textbf{The Arithmetic  Logic Unit (ALU) is a part of the CPU and carries out arithmetic and logical operations that are directed by the control unit.}
            \bigbreak \noindent 
            \textbf{The CPU executes instructions using the coordination between its control unit and datapath. The control unit tells the datapath what to do; the datapath (via the ALU and registers) performs the operations and moves data; together, they fetch, decode, and execute the program’s instructions.}
        \item \textit{What are the three types of lines on a bus? What does each of them do}:
            \begin{enumerate}
                \item \textbf{Data lines}: Conveys bits from one device to another.
                \item \textbf{Address lines}: Determines the source or destination of the data.
                \item \textbf{Control lines}: Determines the direction of data flow, and when each device can access the bus.
            \end{enumerate}
        \item \textit{How many address lines are required for a byte-addressable machine with $2^{n}$ bytes of memory?}: \textbf{Requires $8$ address lines}
        \item \textit{What is the difference between a point-to-point bus and a multipoint bus?}: \textbf{A point to point bus carries data from one device to another, only two devices share the bus.}:
            \bigbreak \noindent 
            \textbf{A multipoint bus} carries data to and from many devices, many devices share the bus.
        \item \textit{What is bus arbitration? Name several types of bus arbitration and the differences between them.}: \textbf{Bus arbitration refers to the protocols (algorithms) in place to resolve the conflicts that happen when multiple devices want to use the bus at the same time}
            \begin{enumerate}
                \item \textbf{Daisy-chain}: \textbf{Permissions are passed from highest priority device to lowest priority}
                \item \textbf{Centralized parallel}: \textbf{Each device is connected to an arbitration circuit}
                \item \textbf{Distributed using self-detection}: \textbf{Devices decide who gets the bus amongst themselves}
                \item \textbf{Distributed using collision-detection}: \textbf{Any device can try to use the bus, if collisions occur, they try again.}
            \end{enumerate}
    \end{itemize}


    \pagebreak 
    \unsect{MARIE architecture}
    \begin{itemize}
        \item \textit{How many bits are in a MARIE data word? What data format does MARIE use internally (decimal, unsigned binary, or 2’s complement)?}: \textbf{16-bits, 2's complement}
        \item \textit{How many data words does MARIE have? Is MARIE byte-addressable or word-addressable? How many bits are in a MARIE address, i.e., how many bits does an address need to have a unique address for every data word?}: \textbf{$\mathbf{2^{12} = 4096}$ data words, word-addressable, 12-bits, 12-bits}
        \item \textit{How many bits are in a MARIE instruction? Is MARIE a fixed word length or variable word length machine?}: \textbf{$\mathbf{16}$-bits}, fixed word length}
        \item \textit{What do the AC, MAR, MBR, PC and IR do in MARIE? How many bits does each have? Why does each register have the number of bits that it has? (Hint: What type of data or instruction goes in each register?)}:
            \begin{enumerate}
                \item \textbf{AC}: Accumulator, holds operands for arithmetic and results of arithmetic, 16-bits since it holds words (words are 16-bits)
                \item \textbf{MAR}: Holds an address, 12-bit because addresses are 12-bit
                \item \textbf{MBR}: Holds a word, 16-bit because words are 16-bit
                \item \textbf{PC}: Holds the address of the next instruction, 12-bit because addresses are 12-bit
                \item \textbf{IR}: Holds the current instruction, 16-bit because instructions are 16-bit
            \end{enumerate}
        \item \textit{What is the fetch-decode-execute cycle? What happens in each step? How is the fetch-decodeexecute cycle different depending on whether the instruction contains an address operand or not?}: \textbf{The fetch-decode-execute cycle is the steps a computer goes through when running a program.}
            \begin{enumerate}
                \item \textbf{Fetch:} Fetches instruction from memory and places into IR
                \item \textbf{Decode}: Instruction in the IR is decoded to determine what needs to be done next
                \item \textbf{Execute}: The instruction is executed
            \end{enumerate}
            \textbf{If the instruction requires an operand, an additional step is done between steps 2 and 3 (fetch-operand). The operand is fetched from memory and placed inside the MBR.}
        \item \textit{Which MARIE instructions need a fetch operand step? What is the maximum number of fetch operand steps a MARIE instruction can have? Why?}: \textbf{At most one fetch-operand step, since all instructions either have zero or one operands}.
        \item \textit{What is RTL? What is a microoperation? Which steps in the execution cycle (fetch, decode, fetch operand, execute) use the same RTL for every instruction? What does the RTL for fetch do? the RTL for fetch operand? the RTL for execute? Why does the decode step not need any RTL?}: \textbf{Each instruction is made up of a sequence of smaller  instructions called microoperations. The microoperations are specified using the register-transfer language (RTL). Fetch, decode, fetch operand use the same RTL for every instruction}
        \item \textit{How many bus addresses does MARIE have?}: \textbf{7}
        \item \textit{What are the parts of a MARIE instruction? How many bits does each part have? Why?}: The opcode (4 bits), MARIE has 12 instructions, need 4 bits = $2^{4} = 16$ possible opcodes. and the address operand (12-bits)
        \item \textit{Make sure you understand why the RTL for each instruction works. For example, why does the RTL for JUMP load the operand into the PC? Why does SKIPCOND not contain an address to skip to?}: \textbf{Only 12-bits for the operand. Since addreses are 12-bits, if we supplied an address to jump to , there would be no room for the condition. We use bits 10 and 11 for the condition}
\end{itemize}


\pagebreak 
\unsect{MARIE execution cycle}
\begin{itemize}
    \item \textbf{Because some lines of RTL for the load instruction (the first two) are already done during the fetch-decode-fetch operand steps, they are redundant} 
\end{itemize}

\pagebreak 
\unsect{Indirect addressing}
\begin{itemize}
    \item \textit{What is indirect addressing? Which MARIE instruction(s) use indirect addressing?}: \textbf{In indirect addressing, the address of the address of the operand is given in the instruction, ADDI and JUMPI use it}
    \item \textit{How do you call a subroutine in MARIE? How do you return from a subroutine? Why can’t MARIE handle recursive calls (instances where a function calls itself)?}: \textbf{Use the JNS (jump and store) instruction. To return, jump to the address stored in the address given to JNS in the subroutine call. Can't handle recursion because there is only room for one return address}, for recursion each call would need to store its return address.
    \item \textit{What is the difference between the DEC and HEX assembler directives? (Assembler directives are commands that do something inside the assembler but not in the executable program, so they do not create RTL. In this case the assembler directives assign memory.)}: \textbf{}
        \bigbreak \noindent 
        \textbf{The \texttt{DEC} and \texttt{HEX} directives both tell the assembler to reserve a memory location and store a constant value there. The difference is in the number system used to interpret that value. The \texttt{DEC} directive stores the value as a decimal (base 10) number, while the \texttt{HEX} directive stores the value as a hexadecimal (base 16) number. These directives do not generate executable instructions; they only define initial data values in memory.}

\end{itemize}

\pagebreak 
\unsect{Hardwired implementation}
\begin{itemize}
    \item \textit{What is hardwired control? What is microprogramming? What is the difference between them?}:  \textbf{In hardwired, circuits (digital logic components) are used to generate the control signals. In Microprogramming , execution of microcode instructions produces control signal changes.}
    \item \textit{What is a signal line? What is a datapath address? How many signal lines (input and output) does a machine need if there are $2^{n}$ addresses on the datapath? What is a timing signal? How many timing signals are needed to handle all the instructions, including the indirect addressing instructions and the other advanced ones in section 4e (i.e., all the instructions on the MARIE summary sheet? Why do some instructions need more timing signals than others? What does the counter reset signal do? When is it triggered? What would happen if we didn’t have a counter reset signal? Do these terms refer to a hardwired machine or a microprogrammed machine?}: \textbf{A signal line is a wire used to carry a control signal (bit). A datapath address is the bus address of a register or main memory, each register and main memory has a unique address along the datapath. If there are $2^{n}$ address along the datapath, we need $n$ signal lines for the input, and $n$ for the output. A timing signal is a control signal used to indicate the clock tick number, used to determine which line of RTL we need to execute. A MARIE instruction has at most 7 lines of RTL, so we have 7 timing signals. Some instructions require more timing signals because they require more lines of RTL. An instruction only needs enough timing signals for each line of RTL (one per line). The counter reset signal resets the binary counter that produces the timing signals (back to zero), it is triggered after the execute step of the instruction. If we did not have counter reset, the counter would not be reset for the next instruction, and incorrect timing signals would be produced. These concepts refer to a hardwired machine}
    \item \textit{What do the following symbols represent: P0-P5, T0-T7, A0-A3, Cr?}: address signals, timing signals, ALU signals, counter reset
\end{itemize}

\pagebreak 
\unsect{Microcode implementation}
\begin{itemize}
    \item \textit{What is firmware? How often are microcode instructions retrieved from the firmware? Why do MARIE microinstructions have space for two microoperations? What goes in the second one if it’s not used in a given microinstruction? What are the Jump and Dest fields and how are they used?}: \textbf{Firmware is the software stored in ROM that controls the hardware, one microcode instruction is retrieved during each clock cycle}
        \bigbreak \noindent 
        \textbf{Marie microinstructions have space for two microoperations, the first one is the opcode for the microinstruction, and the second is used to hold the opcode of the MARIE instruction, in some microinstructions we compare the microopcode to the MARIE opcode, so that we know which microoperation to go to to start executing the MARIE instruction. If the microinstruction is not a comparision, we put NOP as the second microoperation.
            The jump bit is either one or zero, if its set to one, we jump to the address in the destination field. The dest field is the address that we jump to if the jump bit is on. After the first four microinstructions (fetch and decode) are executed, we go through the jump table, and find the microinstruction that has the same opcode as the marie instruction. That instruction will have the jump bit set on, and the dest field has the address of the start of the execute step for that instruction.
        }
    \item \textit{Which steps of the fetch-decode-execute cycle are located before the jump table in MARIE’s microcode? Which lines of the microcode implement fetch? decode? fetch operand? execute? What does the jump table contain? What is at the addresses jumped to by the jump table? Why does the last line of each of the jumped-to sections have the jump flag set? Where does each of these lines jump to?}: \textbf{Fetch and decode are before the jump table, lines 1-3 implement fetch, line 4 implements decode. The lines of microcode that implement fetch-operand and execute are found at the jump address. The jump table contains microinstructions that compare the rightmost 4 bits of the IR (MARIE instruction opcode) to microopcodes, it also contains the jump dest address, which is the address of the start of the execute step for the instruction found in microOp2. The last line has the jump flag set, and jumps to address zero, which is the beginning of the microprogram (fetch-decode-...)}.
\end{itemize}

\pagebreak \bigbreak \noindent 
\unsect{Important information}
\begin{itemize}
    \item \textbf{V.N bottleneck}: Single datapath between CPU and memorn may 
    \item \textbf{CPU}: Fetches, decodes, and executes program instructions
    \item \textbf{Two principal parts of thheh CPU}
        \begin{enumerate}
            \item \textbf{Datapath}: Consists of ALU and storage units (registers), connected by a data bus that is also connected to memory.
            \item \textbf{Control unit}: Produces control signals that tell the CPU components which operations to perform
        \end{enumerate}
    \item \textbf{Bus}: Set of wires (lines) that convey signal bits across each line.
        \begin{itemize}
            \item \textbf{Point to point bus}: Only two devices are connected to the bus
            \item \textbf{Multipoint bus}: Many devices are connected to the bus
        \end{itemize}
    \item \textbf{MARIE bus}:
        MARIE uses a single shared 16-bit bus for both data and addresses (time-multiplexed).
        \bigbreak \noindent 
        That means:
        \begin{itemize}
            \item The same 16 wires carry either addresses or data at different times.
            \item Control signals decide what’s currently being sent.
    \end{itemize}
    \item \textbf{Send and receive data through the bus}: 
        When one component needs to send or receive data:
        \begin{itemize}
            \item The Control Unit activates that device’s bus address line.
            \item That component either places data on the bus (output) or reads from it (input).
        \end{itemize}
    \item \textbf{ISA}:  A computer’s instruction set architecture (ISA) specifies the format of its instructions and the primitive operations that the machine can perform.
        The ISA is an interface between a computer’s hardware and its software. Some ISAs include hundreds of different instructions for processing data and controlling program execution.
        \bigbreak \noindent 
        The MARIE ISA has only thirteen instructions
    \item \textbf{Control unit}: Ensures that each instruction is executed in sequence, making sure that data flows to the correct components as each instruction is executed.
        \begin{itemize}
            \item \textbf{Hardwired control unit}: Digit logic components are used to select the to and from components and ensure that data flows to them at the correct time
            \item \textbf{Microprogrammed control}: Machine contains a small program in ROM in a component called the microcontroller. The microprogram contains RTL for each instruction. To execute an instruction, the microcontroller interprets the corresponding piece of the microprogram
                \bigbreak \noindent 
                The microcontroller (microprogram control unit) is the hardware that fetches, decodes, and executes microinstructions... just like the CPU.
                \bigbreak \noindent 
                Microprogrammed machines have the same control lines,  the patterns for the control lines are stored as data in the control store.
        \end{itemize}
    \item \textbf{Microprogramming}: Execution of microcode instructions produces control signal changes. The microprogram converts each microcode instruction into control signals.
        \bigbreak \noindent 
        Microprogram stored in firmware. The piece of ROM that holds the microprogram is called the control store. One microinstruction retrieved during each clock cycle.
        \bigbreak \noindent 
        Doesn't remove the control unit, changes its implementation. Instead of AND/OR gates and flip-flops generating control signals, you have
        \begin{itemize}
            \item The microinstructions in the control store.
            \item Microsequencer (microcontroller / microprogram control unit) that fetches, decodes, and executes the microinstructions
        \end{itemize}
        \bigbreak \noindent 
        \textbf{Note:} A microprogrammed control unit still requires circuits.
        \begin{center}
            \begin{tabularx}{\textwidth}{@{}lXX@{}}
                \toprule
                \textbf{Aspect} &	\textbf{Hardwired Control}&	\textbf{Microprogrammed Control} \\
                \midrule
                Control logic	& Implemented entirely by fixed logic circuits	& Implemented mostly as data stored in the control store (ROM or PLA) \\[2ex]
                Still needs circuits?	 & Yes (for all control signals and timing)	& Yes (for the control store, microinstruction register, sequencing logic, etc.) \\
                \bottomrule
            \end{tabularx}
        \end{center}
        So the microprogrammed control unit is still a circuit, but one that reads control words from memory instead of generating them entirely through logic.
    \item \textbf{Generic microsequencer}:
        \begin{enumerate}
            \item IR $\to$ microinstruction address generator $\to$ control store $\to$ microinstruction buffer $\to$ microinstruction decoder $\to$ control signals
        \end{enumerate}
\end{itemize}



    
\end{document}
